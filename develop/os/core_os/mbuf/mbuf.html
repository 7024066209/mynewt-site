

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    

    
    <title>Mbufs &mdash; Apache Mynewt 1.3.0 documentation</title>
    

    
    
      <link rel="shortcut icon" href="../../../_static/mynewt-logo-only-newt32x32.png"/>
    

    

    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />

    
      <link rel="stylesheet" href="../../../_static/css/sphinx_theme.css" type="text/css" />
    
      <link rel="stylesheet" href="../../../_static/css/bootstrap-3.0.3.min.css" type="text/css" />
    
      <link rel="stylesheet" href="../../../_static/css/v2.css" type="text/css" />
    
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
    
      <link rel="stylesheet" href="../../../_static/css/restructuredtext.css" type="text/css" />
    

    

    <link rel="stylesheet" href="../../../_static/css/overrides.css" type="text/css" />
          <link rel="index" title="Index"
                href="../../../genindex.html"/>
          <link rel="search" title="Search" href="../../../search.html"/>
      <link rel="top" title="Apache Mynewt 1.3.0 documentation" href="../../../index.html"/>
          <link rel="up" title="Mynewt Core OS" href="../mynewt_os.html"/>
          <link rel="next" title="Msys" href="../msys/msys.html"/>
          <link rel="prev" title="Heap" href="../heap/heap.html"/> 

    
    <script src="../../../_static/js/modernizr.min.js"></script>

    
    <script>
    (function(i, s, o, g, r, a, m) {
	i["GoogleAnalyticsObject"] = r;
	(i[r] =
		i[r] ||
		function() {
			(i[r].q = i[r].q || []).push(arguments);
		}),
		(i[r].l = 1 * new Date());
	(a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
	a.async = 1;
	a.src = g;
	m.parentNode.insertBefore(a, m);
})(window, document, "script", "//www.google-analytics.com/analytics.js", "ga");

ga("create", "UA-72162311-1", "auto");
ga("send", "pageview");
</script>
    

  </head>

  <body class="not-front page-documentation" role="document" >
    <div id="wrapper">
      <div class="container">
    <div id="banner" class="row v2-main-banner">
        <a class="logo-cell" href="/">
            <img class="logo" src="../../../_static/img/logo.png">
        </a>
        <div class="tagline-cell">
            <h4 class="tagline">An OS to build, deploy and securely manage billions of devices</h4>
        </div>
        <div class="news-cell">
            <div class="well">
              <h4>Latest News:</h4> <a href="/download">Apache Mynewt 1.3.0</a> released (December 13, 2017)
            </div>
        </div>
    </div>
</div>
      
<header>
    <nav id="navbar" class="navbar navbar-inverse" role="navigation">
        <div class="container">
            <!-- Collapsed navigation -->
            <div class="navbar-header">
                <!-- Expander button -->
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>

            </div>

            <!-- Expanded navigation -->
            <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/"><i class="fa fa-home" style="font-size: larger;"></i></a>
                    </li>
                    <li class="important">
                        <a href="/get_started/quick_start.html">Quick Start</a>
                    </li>
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    <li>
                        <a href="/talks/">Talks</a>
                    </li>
                    <li class="active">
                        <a href="/documentation/">Documentation</a>
                    </li>
                    <li>
                        <a href="/download/">Download</a>
                    </li>
                    <li>
                        <a href="/community/">Community</a>
                    </li>
                    <li>
                        <a href="/events/">Events</a>
                    </li>
                </ul>

                <!-- Search, Navigation and Repo links -->
                <ul class="nav navbar-nav navbar-right">
                    
                </ul>
            </div>
        </div>
    </nav>
</header>
      <!-- STARTS MAIN CONTENT -->
      <div id="main-content">
        





<div id="breadcrumb">
  <div class="container">
    <a href="/documentation/">Docs</a> /
    
      <a href="../../os_user_guide.html">OS User Guide</a> /
    
      <a href="../mynewt_os.html">Mynewt Core OS</a> /
    
    Mbufs
    
  <div class="sourcelink">
    <a href="https://github.com/apache/mynewt-core/edit/master/docs/os/core_os/mbuf/mbuf.rst" class="icon icon-github"
           rel="nofollow"> Edit on GitHub</a>
</div>
  </div>
</div>
        <!-- STARTS CONTAINER -->
        <div class="container">
          <!-- STARTS .content -->
          <div id="content" class="row">
            
            <!-- STARTS .container-sidebar -->
<div class="container-sidebar col-xs-12 col-sm-3">
  <div id="docSidebar" class="sticky-container">
    <div role="search" class="sphinx-search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search documentation" class="search-documentation" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
    
<!-- Note: only works when deployed -->
<select class="form-control" onchange="if (this.value) window.location.href=this.value">
    <option
      value="/develop"
      selected
      >
      Version: develop (latest - mynewt-documentation)
    </option>
    <option
      value="/latest/os/introduction"
      >
      Version: master (latest - mynewt-site)
    </option>
    <option
      value="/v1_2_0/os/introduction"
      >
      Version: 1.2.0
    </option>
    <option
      value="/v1_1_0/os/introduction">
      Version: 1.1.0
    </option>
    <option
      value="/v1_0_0/os/introduction">
      Version: 1.0.0
    </option>
    <option
      value="/v0_9_0/os/introduction">
      Version: 0_9_0
    </option>
</select>
    <div class="region region-sidebar">
      <div class="docs-menu">
      
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/index.html">Setup &amp; Get Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts.html">Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/tutorials.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../os_user_guide.html">OS User Guide</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../mynewt_os.html">OS Core</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../context_switch/context_switch.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cputime/os_cputime.html">CPU Time</a></li>
<li class="toctree-l3"><a class="reference internal" href="../time/os_time.html">OS Time</a></li>
<li class="toctree-l3"><a class="reference internal" href="../task/task.html">Task</a></li>
<li class="toctree-l3"><a class="reference internal" href="../event_queue/event_queue.html">Event Queues</a></li>
<li class="toctree-l3"><a class="reference internal" href="../semaphore/semaphore.html">Semaphore</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mutex/mutex.html">Mutex</a></li>
<li class="toctree-l3"><a class="reference internal" href="../memory_pool/memory_pool.html">Memory Pools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../heap/heap.html">Heap</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Mbufs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../msys/msys.html">Msys</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mqueue/mqueue.html">Mqueue</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sanity/sanity.html">Sanity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../callout/callout.html">Callout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../API.html">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../porting/port_os.html">Porting Mynewt OS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules/console/console.html">Console</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules/sysinitconfig/sysinitconfig.html">System Configuration and Initialization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../network/ble/ble_intro.html">BLE User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../newt/index.html">Newt Tool Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../newtmgr/index.html">Newt Manager Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../misc/index.html">Appendix</a></li>
</ul>

        
      
      </div>
    </div>
  </div>
  <!-- ENDS STICKY CONTAINER -->
</div>
<!-- ENDS .container-sidebar -->

            <div class="col-xs-12 col-sm-9">
              <div class="alert alert-info" role="alert">
  <p>
    This is the development version of Apache Mynewt documentation. As such it may not be as complete as the latest
    stable version of the documentation found <a href="/latest/os/introduction/">here</a>.
  </p>
  <p>
    To improve this documentation please visit <a href="https://github.com/apache/mynewt-documentation">https://github.com/apache/mynewt-documentation</a>.
  </p>
</div>
              
              <div class="">
                <div class="rst-content">
                  <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
                   <div itemprop="articleBody">
                    
  <div class="section" id="mbufs">
<h1>Mbufs<a class="headerlink" href="#mbufs" title="Permalink to this headline">¶</a></h1>
<p>The mbuf (short for memory buffer) is a common concept in networking
stacks. The mbuf is used to hold packet data as it traverses the stack.
The mbuf also generally stores header information or other networking
stack information that is carried around with the packet. The mbuf and
its associated library of functions were developed to make common
networking stack operations (like stripping and adding protocol headers)
efficient and as copy-free as possible.</p>
<p>In its simplest form, an mbuf is a memory block with some space reserved
for internal information and a pointer which is used to “chain” memory
blocks together in order to create a “packet”. This is a very important
aspect of the mbuf: the ability to chain mbufs together to create larger
“packets” (chains of mbufs).</p>
<div class="section" id="why-use-mbufs">
<h2>Why use mbufs?<a class="headerlink" href="#why-use-mbufs" title="Permalink to this headline">¶</a></h2>
<p>The main reason is to conserve memory. Consider a networking protocol
that generally sends small packets but occasionally sends large ones.
The Bluetooth Low Energy (BLE) protocol is one such example. A flat
buffer would need to be sized so that the maximum packet size could be
contained by the buffer. With the mbuf, a number of mbufs can be chained
together so that the occasional large packet can be handled while
leaving more packet buffers available to the networking stack for
smaller packets.</p>
</div>
<div class="section" id="packet-header-mbuf">
<h2>Packet Header mbuf<a class="headerlink" href="#packet-header-mbuf" title="Permalink to this headline">¶</a></h2>
<p>Not all mbufs are created equal. The first mbuf in a chain of mbufs is a
special mbuf called a “packet header mbuf”. The reason that this mbuf is
special is that it contains the length of all the data contained by the
chain of mbufs (the packet length, in other words). The packet header
mbuf may also contain a user defined structure (called a “user header”)
so that networking protocol specific information can be conveyed to
various layers of the networking stack. Any mbufs that are part of the
packet (i.e. in the mbuf chain but not the first one) are “normal” (i.e.
non-packet header) mbufs. A normal mbuf does not have any packet header
or user packet header structures in them; they only contain the basic
mbuf header (<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">os_mbuf</span></code>). Figure 1 illustrates these two types
of mbufs. Note that the numbers/text in parentheses denote the size of
the structures/elements (in bytes) and that MBLEN is the memory block
length of the memory pool used by the mbuf pool.</p>
<div class="figure" id="id7">
<img alt="Packet header mbuf" src="os/core_os/mbuf/pics/mbuf_fig1.png" />
<p class="caption"><span class="caption-text">Packet header mbuf</span></p>
</div>
</div>
<div class="section" id="normal-mbuf">
<h2>Normal mbuf<a class="headerlink" href="#normal-mbuf" title="Permalink to this headline">¶</a></h2>
<p>Now let’s take a deeper dive into the mbuf structure. Figure 2
illustrates a normal mbuf and breaks out the various fields in the
<code class="docutils literal notranslate"><span class="pre">os_mbuf</span></code> structure.</p>
<ul class="simple">
<li>The <em>om_data</em> field is a pointer to where the data starts inside the
data buffer. Typically, mbufs that are allocated from the mbuf pool
(discussed later) have their om_data pointer set to the start of the
data buffer but there are cases where this may not be desirable
(added a protocol header to a packet, for example).</li>
<li>The <em>om_flags</em> field is a set of flags used internally by the mbuf
library. Currently, no flags have been defined.</li>
<li>The <em>om_pkthdr_len</em> field is the total length of all packet headers
in the mbuf. For normal mbufs this is set to 0 as there is no packet
or user packet headers. For packet header mbufs, this would be set to
the length of the packet header structure (16) plus the size of the
user packet header (if any). Note that it is this field which
differentiates packet header mbufs from normal mbufs (i.e. if
<em>om_pkthdr_len</em> is zero, this is a normal mbuf; otherwise it is a
packet header mbuf).</li>
<li>The <em>om_len</em> field contains the amount of user data in the data
buffer. When initially allocated, this field is 0 as there is no user
data in the mbuf.</li>
<li>The <em>omp_pool</em> field is a pointer to the pool from which this mbuf
has been allocated. This is used internally by the mbuf library.</li>
<li>The <em>omp_next</em> field is a linked list element which is used to chain
mbufs.</li>
</ul>
<p>Figure 2 also shows a normal mbuf with actual values in the <code class="docutils literal notranslate"><span class="pre">os_mbuf</span></code>
structure. This mbuf starts at address 0x1000 and is 256 bytes in total
length. In this example, the user has copied 33 bytes into the data
buffer starting at address 0x1010 (this is where om_data points). Note
that the packet header length in this mbuf is 0 as it is not a packet
header mbuf.</p>
<div class="figure" id="id8">
<img alt="OS mbuf structure" src="os/core_os/mbuf/pics/mbuf_fig2.png" />
<p class="caption"><span class="caption-text">OS mbuf structure</span></p>
</div>
<p>Figure 3 illustrates the packet header mbuf along with some chained
mbufs (i.e a “packet”). In this example, the user header structure is
defined to be 8 bytes. Note that in figure 3 we show a number of
different mbufs with varying <em>om_data</em> pointers and lengths since we
want to show various examples of valid mbufs. For all the mbufs (both
packet header and normal ones) the total length of the memory block is
128 bytes.</p>
<div class="figure" id="id9">
<img alt="Packet" src="os/core_os/mbuf/pics/mbuf_fig3.png" />
<p class="caption"><span class="caption-text">Packet</span></p>
</div>
</div>
<div class="section" id="mbuf-pools">
<h2>Mbuf pools<a class="headerlink" href="#mbuf-pools" title="Permalink to this headline">¶</a></h2>
<p>Mbufs are collected into “mbuf pools” much like memory blocks. The mbuf
pool itself contains a pointer to a memory pool. The memory blocks in
this memory pool are the actual mbufs; both normal and packet header
mbufs. Thus, the memory block (and corresponding memory pool) must be
sized correctly. In other words, the memory blocks which make up the
memory pool used by the mbuf pool must be at least: sizeof(struct
os_mbuf) + sizeof(struct os_mbuf_pkthdr) + sizeof(struct
user_defined_header) + desired minimum data buffer length. For
example, if the developer wants mbufs to contain at least 64 bytes of
user data and they have a user header of 12 bytes, the size of the
memory block would be (at least): 64 + 12 + 16 + 8, or 100 bytes. Yes,
this is a fair amount of overhead. However, the flexibility provided by
the mbuf library usually outweighs overhead concerns.</p>
</div>
<div class="section" id="create-mbuf-pool">
<h2>Create mbuf pool<a class="headerlink" href="#create-mbuf-pool" title="Permalink to this headline">¶</a></h2>
<p>Creating an mbuf pool is fairly simple: create a memory pool and then
create the mbuf pool using that memory pool. Once the developer has
determined the size of the user data needed per mbuf (this is based on
the application/networking stack and is outside the scope of this
discussion) and the size of the user header (if any), the memory blocks
can be sized. In the example shown below, the application requires 64
bytes of user data per mbuf and also allocates a user header (called
struct user_hdr). Note that we do not show the user header data
structure as there really is no need; all we need to do is to account
for it when creating the memory pool. In the example, we use the macro
<em>MBUF_PKTHDR_OVERHEAD</em> to denote the amount of packet header overhead
per mbuf and <em>MBUF_MEMBLOCK_OVERHEAD</em> to denote the total amount of
overhead required per memory block. The macro <em>MBUF_BUF_SIZE</em> is used
to denote the amount of payload that the application requires (aligned
on a 32-bit boundary in this case). All this leads to the total memory
block size required, denoted by the macro <em>MBUF_MEMBLOCK_OVERHEAD</em>.</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>#define MBUF_PKTHDR_OVERHEAD    sizeof(struct os_mbuf_pkthdr) + sizeof(struct user_hdr)
#define MBUF_MEMBLOCK_OVERHEAD  sizeof(struct os_mbuf) + MBUF_PKTHDR_OVERHEAD

#define MBUF_NUM_MBUFS      (32)
#define MBUF_PAYLOAD_SIZE   (64)
#define MBUF_BUF_SIZE       OS_ALIGN(MBUF_PAYLOAD_SIZE, 4)
#define MBUF_MEMBLOCK_SIZE  (MBUF_BUF_SIZE + MBUF_MEMBLOCK_OVERHEAD)
#define MBUF_MEMPOOL_SIZE   OS_MEMPOOL_SIZE(MBUF_NUM_MBUFS, MBUF_MEMBLOCK_SIZE)

struct os_mbuf_pool g_mbuf_pool;
struct os_mempool g_mbuf_mempool;
os_membuf_t g_mbuf_buffer[MBUF_MEMPOOL_SIZE];

void
create_mbuf_pool(void)
{
    int rc;

    rc = os_mempool_init(&amp;g_mbuf_mempool, MBUF_NUM_MBUFS,
                          MBUF_MEMBLOCK_SIZE, &amp;g_mbuf_buffer[0], &quot;mbuf_pool&quot;);
    assert(rc == 0);

    rc = os_mbuf_pool_init(&amp;g_mbuf_pool, &amp;g_mbuf_mempool, MBUF_MEMBLOCK_SIZE,
                           MBUF_NUM_MBUFS);
    assert(rc == 0);
}
</pre></div>
</div>
</div>
<div class="section" id="using-mbufs">
<h2>Using mbufs<a class="headerlink" href="#using-mbufs" title="Permalink to this headline">¶</a></h2>
<p>The following examples illustrate typical mbuf usage. There are two
basic mbuf allocation API: <code class="docutils literal notranslate"><span class="pre">os_mbuf_get()</span></code> and
<code class="docutils literal notranslate"><span class="pre">os_mbuf_get_pkthdr()</span></code>. The first API obtains a normal mbuf whereas
the latter obtains a packet header mbuf. Typically, application
developers use <code class="docutils literal notranslate"><span class="pre">os_mbuf_get_pkthdr()</span></code> and rarely, if ever, need to
call <code class="docutils literal notranslate"><span class="pre">os_mbuf_get()</span></code> as the rest of the mbuf API (e.g.
<code class="docutils literal notranslate"><span class="pre">os_mbuf_append()</span></code>, <code class="docutils literal notranslate"><span class="pre">os_mbuf_copyinto()</span></code>, etc.) typically deal with
allocating and chaining mbufs. It is recommended to use the provided API
to copy data into/out of mbuf chains and/or manipulate mbufs.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">example1</span></code>, the developer creates a packet and then sends the
packet to a networking interface. The code sample also provides an
example of copying data out of an mbuf as well as use of the “pullup”
api (another very common mbuf api).</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>void
mbuf_usage_example1(uint8_t *mydata, int mydata_length)
{
    int rc;
    struct os_mbuf *om;

    /* get a packet header mbuf */
    om = os_mbuf_get_pkthdr(&amp;g_mbuf_pool, sizeof(struct user_hdr));
    if (om) {
        /*
         * Copy user data into mbuf. NOTE: if mydata_length is greater than the
         * mbuf payload size (64 bytes using above example), mbufs are allocated
         * and chained together to accommodate the total packet length.
         */
        rc = os_mbuf_copyinto(om, 0, mydata, len);
        if (rc) {
            /* Error! Could not allocate enough mbufs for total packet length */
            return -1;
        }

        /* Send packet to networking interface */
        send_pkt(om);
    }
}
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">example2</span></code> we show use of the pullup api as this illustrates some
of the typical pitfalls developers encounter when using mbufs. The first
pitfall is one of alignment/padding. Depending on the processor and/or
compiler, the sizeof() a structure may vary. Thus, the size of
<em>my_protocol_header</em> may be different inside the packet data of the
mbuf than the size of the structure on the stack or as a global
variable, for instance. While some networking protcols may align
protocol information on convenient processor boundaries many others try
to conserve bytes “on the air” (i.e inside the packet data). Typical
methods used to deal with this are “packing” the structure (i.e. force
compiler to not pad) or creating protocol headers that do not require
padding. <code class="docutils literal notranslate"><span class="pre">example2</span></code> assumes that one of these methods was used when
defining the <em>my_protocol_header</em> structure.</p>
<p>Another common pitfall occurs around endianness. A network protocol may
be little endian or big endian; it all depends on the protocol
specification. Processors also have an endianness; this means that the
developer has to be careful that the processor endianness and the
protocol endianness are handled correctly. In <code class="docutils literal notranslate"><span class="pre">example2</span></code>, some common
networking functions are used: <code class="docutils literal notranslate"><span class="pre">ntohs()</span></code> and <code class="docutils literal notranslate"><span class="pre">ntohl()</span></code>. These are
shorthand for “network order to host order, short” and “network order to
host order, long”. Basically, these functions convert data of a certain
size (i.e. 16 bits, 32 bits, etc) to the endianness of the host. Network
byte order is big-endian (most significant byte first), so these
functions convert big-endian byte order to host order (thus, the
implementation of these functions is host dependent). Note that the BLE
networking stack “on the air” format is least signigicant byte first
(i.e. little endian), so a “bletoh” function would have to take little
endian format and convert to host format.</p>
<p>A long story short: the developer must take care when copying structure
data to/from mbufs and flat buffers!</p>
<p>A final note: these examples assume the same mbuf struture and
definitions used in the first example.</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>void
mbuf_usage_example2(struct mbuf *rxpkt)
{
    int rc;
    uint8_t packet_data[16];
    struct mbuf *om;
    struct my_protocol_header *phdr;

    /* Make sure that &quot;my_protocol_header&quot; bytes are contiguous in mbuf */
    om = os_mbuf_pullup(&amp;g_mbuf_pool, sizeof(struct my_protocol_header));
    if (!om) {
        /* Not able to pull up data into contiguous area */
        return -1;
    }

    /*
     * Get the protocol information from the packet. In this example we presume that we
     * are interested in protocol types that are equal to MY_PROTOCOL_TYPE, are not zero
     * length, and have had some time in flight.
     */
    phdr = OS_MBUF_DATA(om, struct my_protocol_header *);
    type = ntohs(phdr-&gt;prot_type);
    length = ntohs(phdr-&gt;prot_length);
    time_in_flight = ntohl(phdr-&gt;prot_tif);

    if ((type == MY_PROTOCOL_TYPE) &amp;&amp; (length &gt; 0) &amp;&amp; (time_in_flight &gt; 0)) {
        rc = os_mbuf_copydata(rxpkt, sizeof(struct my_protocol_header), 16, packet_data);
        if (!rc) {
            /* Success! Perform operations on packet data */
            &lt;... user code here ...&gt;
        }
    }

    /* Free passed in packet (mbuf chain) since we don&#39;t need it anymore */
    os_mbuf_free_chain(om);
}
</pre></div>
</div>
</div>
<div class="section" id="data-structures">
<h2>Data Structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>struct os_mbuf_pool {
    uint16_t omp_databuf_len;
    uint16_t omp_mbuf_count;
    struct os_mempool *omp_pool;
    STAILQ_ENTRY(os_mbuf_pool) omp_next;
};
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Element</strong></th>
<th class="head"><a href="#id1"><span class="problematic" id="id2">**</span></a>Description*
*</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>omp_databuf
_len</td>
<td>The length, in
bytes, of the
“data buffer”
of the mbuf.
The data
buffer of the
mbuf is
everything
except the
os_mbuf
structure
(which is
present in all
types of
mbufs)</td>
</tr>
<tr class="row-odd"><td>omp_mbuf_c
ount</td>
<td>Total number
of mbufs in
the pool when
allocated.
This is NOT
the number of
free mbufs in
the pool!</td>
</tr>
<tr class="row-even"><td>omp_pool</td>
<td>The memory
pool from
which the
mbufs are
allocated</td>
</tr>
<tr class="row-odd"><td>omp_next</td>
<td>This is a
linked list
pointer which
chains memory
pools. It is
used by the
system memory
pool library</td>
</tr>
</tbody>
</table>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>struct os_mbuf_pkthdr {
    uint16_t omp_len;
    uint16_t omp_flags;
    STAILQ_ENTRY(os_mbuf_pkthdr) omp_next;
};
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Element</strong></th>
<th class="head"><a href="#id3"><span class="problematic" id="id4">**</span></a>Description*
*</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>omp_len</td>
<td>Length, in
bytes, of the
“packet”. This
is the sum of
the user data
in all the
mbufs chained
to the packet
header mbuf
(including the
packet header
mbuf)</td>
</tr>
<tr class="row-odd"><td>omp_flags</td>
<td>Packet header
flags.</td>
</tr>
<tr class="row-even"><td>omp_next</td>
<td>Linked list
pointer to
chain
“packets”.
This can be
used to add
mbuf chains to
a queue or
linked list
and is there
for
convenience.</td>
</tr>
</tbody>
</table>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>struct os_mbuf {
    uint8_t *om_data;
    uint8_t om_flags;
    uint8_t om_pkthdr_len;
    uint16_t om_len;
    struct os_mbuf_pool *om_omp;
    SLIST_ENTRY(os_mbuf) om_next;
    uint8_t om_databuf[0];
};
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Element</strong></th>
<th class="head"><a href="#id5"><span class="problematic" id="id6">**</span></a>Description*
*</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>om_data</td>
<td>Pointer to
start of user
data in mbuf
data buffer</td>
</tr>
<tr class="row-odd"><td>om_flags</td>
<td>mbuf flags
field.
Currently all
flags unused.</td>
</tr>
<tr class="row-even"><td>om_pkthdr_
len</td>
<td>The total
length of all
packet headers
in the mbuf
(mbuf packet
header plus
user packet
header), in
bytes</td>
</tr>
<tr class="row-odd"><td>om_len</td>
<td>The length of
the user data
contained in
this mbuf, in
bytes</td>
</tr>
<tr class="row-even"><td>om_omp</td>
<td>Memory pool
pointer. This
is the mbuf
pool from
which this
mbuf was
allocated.</td>
</tr>
<tr class="row-odd"><td>om_next</td>
<td>Pointer to
next mbuf in
packet chain</td>
</tr>
<tr class="row-even"><td>om_databuf</td>
<td>mbuf data
buffer
(accessor to
start of mbuf
data buffer).
Note that the
mbuf data
buffer refers
to the start
of either the
user data in
normal mbufs
or the start
of the os mbuf
packet header
for packet
header mbufs</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">doxygengroup: Cannot find namespace “OSMbuf” in doxygen xml output for project “mynewt-core” from directory: mynewt-core-xml</p>
</div>
</div>
</div>


                   </div>
                  </div>
                  
    <div class="rst-footer-buttons row" role="navigation" aria-label="footer navigation">
      
        <a href="../msys/msys.html" class="btn btn-neutral float-right" title="Msys" accesskey="n">Next: Msys <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../heap/heap.html" class="btn btn-neutral" title="Heap" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous: Heap</a>
      
    </div>

                </div>
              </div>
            </div>
            <!-- ENDS CONTENT SECTION -->
          </div>
          <!-- ENDS .content -->
        </div>
      </div>
      <footer>
  <div class="container">
    <div class="row">
      <div class="col-xs-12">
          
              <p class="copyright">Apache Mynewt is available under Apache License, version 2.0.</p>
          
      </div>
      <div class="col-xs-12">
          <div class="logos">
              <img src="../../../_static/img/asf_logo_wide_small.png" alt="Apache" title="Apache">
              <small class="footnote">
                Apache Mynewt, Mynewt, Apache, the Apache feather logo, and the Apache Mynewt project logo are either
                registered trademarks or trademarks of the Apache Software Foundation in the United States and other countries.
              </small>
              <a href="https://join.slack.com/mynewt/shared_invite/MTkwMTg1ODM1NTg5LTE0OTYxNzQ4NzQtZTU1YmNhYjhkMg">
                <img src="../../../_static/img/add_to_slack.png" alt="Slack Icon" title="Join our Slack Community" />
              </a>
          </div>
      </div>
    </div>
  </div>
</footer>
    </div>
    <!-- ENDS #wrapper -->

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1.3.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/js/bootstrap-3.0.3.min.js"></script>
      <script type="text/javascript" src="../../../_static/js/affix.js"></script>
      <script type="text/javascript" src="../../../_static/js/main.js"></script>

   

  </body>
</html>