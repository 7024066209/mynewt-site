{
    "docs": [
        {
            "location": "/", 
            "text": "Apache Mynewt is a community-driven, permissively licensed open source initiative for constrained, embedded applications. The emergence of the Internet of Things is proving that \nanything that can be connected will be connected \n. Many of these connected devices\u2014wristbands and other wearables, light bulbs and locks\u2014must be operated for long periods of time, but are constrained in terms of power, memory, and storage. Apache Mynewt flexibly addresses these constraints while remaining hardware agnostic.", 
            "title": "Home"
        }, 
        {
            "location": "/documentation/", 
            "text": "Documentation Organization\n\n\nThe chapter organization is outlined below. Each chapter will include one or more tutorials for hands-on experience with the material in each chapter.", 
            "title": "Documentation"
        }, 
        {
            "location": "/documentation/#documentation-organization", 
            "text": "The chapter organization is outlined below. Each chapter will include one or more tutorials for hands-on experience with the material in each chapter.", 
            "title": "Documentation Organization"
        }, 
        {
            "location": "/download/", 
            "text": "For general information on using Git at Apache, go to https://git-wip-us.apache.org.\n\n\nIf you are not a committer, follow the proposed non-committer workflow to share your work. The direct link to the proposed workflow is https://git-wip-us.apache.org/docs/workflow.html.\n\n\nTo clone the Mynewt OS development repository:\n\n\nNon Committers\n\n\n    $ git clone http://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git\n\n\n\n\nCommitters\n\n\n    $ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git", 
            "title": "Download"
        }, 
        {
            "location": "/community/", 
            "text": "Community\n\n\nMailing Lists\n\n\nTo subscribe to a mailing list, you simply send an email to a special subscription address. For example, to subscribe to the dev list, send an email to \ndev-subscribe@mynewt.incubator.apache.org\n.\n\n\nThe following mailing lists can be used to get help with MyNewt.", 
            "title": "Community"
        }, 
        {
            "location": "/community/#community", 
            "text": "", 
            "title": "Community"
        }, 
        {
            "location": "/community/#mailing-lists", 
            "text": "To subscribe to a mailing list, you simply send an email to a special subscription address. For example, to subscribe to the dev list, send an email to  dev-subscribe@mynewt.incubator.apache.org .  The following mailing lists can be used to get help with MyNewt.", 
            "title": "Mailing Lists"
        }, 
        {
            "location": "/events/", 
            "text": "Events\n\n\nPlease take a look at our upcoming events! We hope to see you there.", 
            "title": "Events"
        }, 
        {
            "location": "/events/#events", 
            "text": "Please take a look at our upcoming events! We hope to see you there.", 
            "title": "Events"
        }, 
        {
            "location": "/get_started/newt_concepts/", 
            "text": "Newt Concepts\n\n\nThis page introduces the basic terms you will need to find your way around the Mynewt ecosystem.\n\n\nBasic components in the ecosystem\n\n\n\n\n\n\nNewtOS is an open-source RTOS (Real Time Operating System) that works on a variety of hardware. The goal is to develop a pre-emptive, multitasking OS that is highly modular, making it possible to mix and match components to enable desired features and capabilities on multiple hardware architectures. Examples of components being worked on are the Core RTOS, a flash file system, utility functions, a variety of board support packages, packages of microcontrollers etc.\n\n\n\n\n\n\nNetwork protocol stacks such as Bluetooth Low Energy, and more\n\n\n\n\n\n\nNewt Tool helps you mix the specific packages for the combination of hardware and low-level embedded architecture features of the user's choice and generate the corresponding run-time image based on the NewtOS. It provides the infrastructure to manage and build for different CPU architectures, memory units, board support packages etc., allowing a user to formulate the contents according to the low-level features needed by his or her project.\n\n\n\n\n\n\nTerminology\n\n\nA Mynewt user starts with a project in mind that defines the application or utility that he or she wants to implement on an embedded device. Making an LED blink on an electronics prototyping board is a common starter project. Enabling a BLE (Bluetooth Low Energy) peripheral mode on a development board is a more complex project. Specifying a project requires naming it, at the very least, and then adding the desired properties or attributes. In order to actualize a project, it needs to be applied to a target which is essentially a combination of some specified hardware and the execution environment. \n\n\nIn the mynewt lifecycle, a project grows in a nest. A nest may house multiple projects. The nest is, therefore, a repository where various component packages for one or more projects reside. Each package is an egg (naturally!). However, in the world of Mynewt an egg may consist of other eggs! For example, the starter project Blinky is an egg consisting of several constituent eggs that enable core features. The egg form is suitable for elemental units of code as it explicitly exposes characteristics such as dependencies, versions, capabilities, requirements etc., thus making assembling appropriate components for a project and building an image for it easy to follow, modular, and robust.\n\n\nA nest can be given any name. For example, you will see a nest named \"tadpole\" in Mynewt (\nhttps://git-wip-us.apache.org/repos/asf?p=incubator-mynewt-tadpole.git\n). It contains all the core libraries of the operating system for the native platform which currently supports compilation on Mac OS X. The core libraries are contained in the form of eggs where an egg is a basic unit of implementation of any aspect of the RTOS. The eggs are distributed in the following directory structure inside the nest:\n\n\n\n\nlibs: contains the two eggs \nos\n and \ntestutil\n\n\nhw: contains three eggs - (i) \nhal\n which has the abstraction layer (HAL) API definitions that all BSP and MCU implementations must support, (ii) \n/mcu/native\n which in an MCU implementation for the native platform (a simulator, in this case), and (iii) \nbsp/native\n which is a BSP implementation for the native platform \n\n\ncompiler: contains the \nsim\n egg which bundles the compiler specifications for the native platform.\n\n\n\n\nLet's explore this sample nest a bit further. The \nlibs/os\n egg contains code for scheduler, process/thread/memory management, semaphores etc. It is the core RTOS which ports to all supported chip platforms.The \nlibs/testutil\n egg contains code for testing packages on hardware or simulated environment. The \nhw/hal\n egg contains header files that provide abstraction for physical hardware components such as GPIO (general purpose input/output), network adapters, timers, and UARTs. This \nhw/hal\n egg is an MCU peripheral abstraction designed to make it easy to port to different MCUs (microcontrollers). The \nhw/mcu/native\n egg contains code for microcontroller operations on the native platform. The \nhw/bsp/native\n egg contains the board support package for the native platform. And finally, the sixth egg \nsim\n contains the compiler specifications such as path and flags. Currently the compilation is supported on Mac OS X.\n\n\nYou can see another nest in the mynewt ecosystem called the \"larva\". It was spawned from the skeletal \"tadpole\" nest using the newt tool. Spawning is easy - \n$ newt create nest \nyour_nest_name\n. \"larva\" is the developer's test repository containing all sorts of eggs being written and incubated, including ones to enhance the core operating system which should eventually make their way into the \"tadpole\" nest. There is a \nhatch_tadpole\n script to update the \"tadpole\" nest when the core OS related eggs in \"larva\" are ready.\n\n\nThere is a third nest named \"newt\" that contains all the eggs needed to support the build and release process of mynewt software. In the future, there will also be pre-built nests for certain common hardware devices to enable a user to quickly get started with a project.\n\n\nA Mynewt contributor\n\n\nA contributor can choose to work on any area(s) of the Mynewt endeavor that appeals to him or her. Hence, you can work on one or more eggs or an entire nest. You can create your own nest (master) or create a branch in an existing nest. For now, Runtime contributors will review any new areas of support that you may wish to introduce e.g. a new board support package (BSP) or a new network protocol. \n\n\nA contributer role necessarily implies he or she is a Mynewt user (see below) of some or all of the products developed.\n\n\nA Mynewt user\n\n\nAn application developer is interested only in using software available in this ecosystem to build a top level build artifact. He or she may either:\n\n\n\n\nUse a pre-built nest, or\n\n\nSpawn a new nest using the newt tool for a target where a target is a custom combination of supported hardware components\n\n\n\n\nIn either case, the user would use the newt tool to create and set the target in the chosen nest. The newt tool would then be used to build out the target profile which would determine which eggs to choose. Finally, the user would use the newt tool to generate a run-time image that can be run on the device.", 
            "title": "Newt Concepts"
        }, 
        {
            "location": "/get_started/newt_concepts/#newt-concepts", 
            "text": "This page introduces the basic terms you will need to find your way around the Mynewt ecosystem.  Basic components in the ecosystem    NewtOS is an open-source RTOS (Real Time Operating System) that works on a variety of hardware. The goal is to develop a pre-emptive, multitasking OS that is highly modular, making it possible to mix and match components to enable desired features and capabilities on multiple hardware architectures. Examples of components being worked on are the Core RTOS, a flash file system, utility functions, a variety of board support packages, packages of microcontrollers etc.    Network protocol stacks such as Bluetooth Low Energy, and more    Newt Tool helps you mix the specific packages for the combination of hardware and low-level embedded architecture features of the user's choice and generate the corresponding run-time image based on the NewtOS. It provides the infrastructure to manage and build for different CPU architectures, memory units, board support packages etc., allowing a user to formulate the contents according to the low-level features needed by his or her project.    Terminology  A Mynewt user starts with a project in mind that defines the application or utility that he or she wants to implement on an embedded device. Making an LED blink on an electronics prototyping board is a common starter project. Enabling a BLE (Bluetooth Low Energy) peripheral mode on a development board is a more complex project. Specifying a project requires naming it, at the very least, and then adding the desired properties or attributes. In order to actualize a project, it needs to be applied to a target which is essentially a combination of some specified hardware and the execution environment.   In the mynewt lifecycle, a project grows in a nest. A nest may house multiple projects. The nest is, therefore, a repository where various component packages for one or more projects reside. Each package is an egg (naturally!). However, in the world of Mynewt an egg may consist of other eggs! For example, the starter project Blinky is an egg consisting of several constituent eggs that enable core features. The egg form is suitable for elemental units of code as it explicitly exposes characteristics such as dependencies, versions, capabilities, requirements etc., thus making assembling appropriate components for a project and building an image for it easy to follow, modular, and robust.  A nest can be given any name. For example, you will see a nest named \"tadpole\" in Mynewt ( https://git-wip-us.apache.org/repos/asf?p=incubator-mynewt-tadpole.git ). It contains all the core libraries of the operating system for the native platform which currently supports compilation on Mac OS X. The core libraries are contained in the form of eggs where an egg is a basic unit of implementation of any aspect of the RTOS. The eggs are distributed in the following directory structure inside the nest:   libs: contains the two eggs  os  and  testutil  hw: contains three eggs - (i)  hal  which has the abstraction layer (HAL) API definitions that all BSP and MCU implementations must support, (ii)  /mcu/native  which in an MCU implementation for the native platform (a simulator, in this case), and (iii)  bsp/native  which is a BSP implementation for the native platform   compiler: contains the  sim  egg which bundles the compiler specifications for the native platform.   Let's explore this sample nest a bit further. The  libs/os  egg contains code for scheduler, process/thread/memory management, semaphores etc. It is the core RTOS which ports to all supported chip platforms.The  libs/testutil  egg contains code for testing packages on hardware or simulated environment. The  hw/hal  egg contains header files that provide abstraction for physical hardware components such as GPIO (general purpose input/output), network adapters, timers, and UARTs. This  hw/hal  egg is an MCU peripheral abstraction designed to make it easy to port to different MCUs (microcontrollers). The  hw/mcu/native  egg contains code for microcontroller operations on the native platform. The  hw/bsp/native  egg contains the board support package for the native platform. And finally, the sixth egg  sim  contains the compiler specifications such as path and flags. Currently the compilation is supported on Mac OS X.  You can see another nest in the mynewt ecosystem called the \"larva\". It was spawned from the skeletal \"tadpole\" nest using the newt tool. Spawning is easy -  $ newt create nest  your_nest_name . \"larva\" is the developer's test repository containing all sorts of eggs being written and incubated, including ones to enhance the core operating system which should eventually make their way into the \"tadpole\" nest. There is a  hatch_tadpole  script to update the \"tadpole\" nest when the core OS related eggs in \"larva\" are ready.  There is a third nest named \"newt\" that contains all the eggs needed to support the build and release process of mynewt software. In the future, there will also be pre-built nests for certain common hardware devices to enable a user to quickly get started with a project.  A Mynewt contributor  A contributor can choose to work on any area(s) of the Mynewt endeavor that appeals to him or her. Hence, you can work on one or more eggs or an entire nest. You can create your own nest (master) or create a branch in an existing nest. For now, Runtime contributors will review any new areas of support that you may wish to introduce e.g. a new board support package (BSP) or a new network protocol.   A contributer role necessarily implies he or she is a Mynewt user (see below) of some or all of the products developed.  A Mynewt user  An application developer is interested only in using software available in this ecosystem to build a top level build artifact. He or she may either:   Use a pre-built nest, or  Spawn a new nest using the newt tool for a target where a target is a custom combination of supported hardware components   In either case, the user would use the newt tool to create and set the target in the chosen nest. The newt tool would then be used to build out the target profile which would determine which eggs to choose. Finally, the user would use the newt tool to generate a run-time image that can be run on the device.", 
            "title": "Newt Concepts"
        }, 
        {
            "location": "/get_started/project1/", 
            "text": "Blinky, the First Project\n\n\nObjective\n\n\nWe will show you how you can use eggs from a nest on Mynewt to make an LED on a target board blink. We will call it \n Project Blinky\n. The goals of this tutorial are threefold:\n\n\n\n\nFirst, you will learn how to set up your environment to be ready to use Mynewt OS and newt tool. \n\n\nSecond, we will walk you through a download of eggs for building and testing \non a simulated target\n.\n\n\nThird, you will download eggs and use tools to create a runtime image for a board to make its LED blink. You have two choices here - you can \ndownload an image to SRAM\n or you can \ndownload it to flash\n.\n\n\n\n\n Time Requirement\n: Allow yourself a couple of hours for this project if you are relatively new to embedded systems and playing with development boards. Those jumpers can be pesky!\n\n\nWhat you need\n\n\n\n\nSTM32-E407 development board from Olimex. You can order it from \nhttp://www.mouser.com\n, \nhttp://www.digikey.com\n, and other places.\n\n\nARM-USB-TINY-H connector with JTAG interface for debugging ARM microcontrollers (comes with the ribbon cable to hook up to the board)\n\n\nUSB A-B type cable to connect the debugger to your personal computer\n\n\nPersonal Computer\n\n\n\n\nThe instructions assume the user is using a Bourne-compatible shell (e.g. bash or zsh) on your computer. The given instructions have been tested with the following releases of operating systems:\n\n\n\n\nMac: OS X Yosemite Version 10.10.5\n\n\nLinux: Ubuntu 14.10 (Utopic Unicorn)\n\n\nWindows: Windows 10\n\n\n\n\nAccess to the Apache repo\n\n\n\n\n\n\nGet an account on Apache. You do not need a committer account to view the website or clone the repository but you need it to push changes to it.\n\n\n\n\n\n\nThe latest codebase for the Mynewt OS is on the master branch at https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git\n\n\n\n\n\n\nThe latest codebase for the Newt tool is on the master branch at https://git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git\n\n\n\n\n\n\nThe following shows how to clone a Mynewt OS code repository:\n\n\n\n\nNon Committers\n\n\n\n\n        $ git clone http://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git\n\n\n\n\n\n\nCommitters\n\n\n\n\n        $ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git\n\n\n\n\nGetting your Mac Ready\n\n\nInstalling Homebrew to ease installs on OS X\n\n\n\n\nDo you have Homebrew? If not, open a terminal on your Mac and paste the following at a Terminal prompt. It will ask you for your sudo password.\n\n\n\n\n        $ ruby -e \n$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\n\n\n\n\n\nAlternatively, you can just extract (or \ngit clone\n) Homebrew and install it to \n/usr/local\n.\n\n\nInstalling Go\n\n\n\n\n\n\nThe directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:\n\n\n\n\n\n\nsrc contains Go source files organized into packages (one package per directory),\n\n\n\n\n\n\npkg contains package objects, and\n\n\n\n\n\n\nbin contains executable commands.\n\n\n\n\n\n\nThe GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory where you will soon clone the newt tool repository.\n\n\n\n\n\n\n        $ cd $HOME\n        $ mkdir -p dev/go  \n        $ cd dev/go\n        $ export GOPATH=`pwd`\n\n\n\n\nNote that you need to add export statements to ~/.bash_profile to export variables permanently. Don't forget to source the file for the change to go into effect.\n\n\n        $ vi ~/.bash_profile\n        $ source ~/.bash_profile\n\n\n\n\n\n\nNext you will use Homebrew to install Go. The summary message at the end of the installation should indicate that it is installed in the /usr/local/Cellar/go/ directory. You will use the Go command 'install' to compile and install packages (called eggs in the Mynewt world) and dependencies. \n\n\n\n\n        $ brew install go\n        ==\n \n        ...\n        ... \n        ==\n *Summary*\n        \ud83c\udf7a  /usr/local/Cellar/go/1.5.1: 5330 files, 273M\n\n\n\n\nAlternatively, you can download the Go package directly from (https://golang.org/dl/) instead of brewing it. Install it in /usr/local directory.\n\n\nCreating local repository\n\n\n\n\nYou are ready to download the newt tool repository. You will use Go to copy the directory (currently the asf incubator directory). Be patient as it may take a minute or two. Check the directories installed.\n\n\n\n\n        $ go get git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt\n        $ ls\n         bin    pkg    src\n        $ ls src\n        git-wip-us.apache.org   github.com      gopkg.in\n\n\n\n\n\n\nCheck that newt.go is in place.\n\n\n\n\n        $ ls $GOPATH/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt  \n        Godeps          README.md       coding_style.txt    newt.go\n        LICENSE         cli             design.txt\n\n\n\n\nBuilding the Newt tool\n\n\n\n\nYou will use Go to run the newt.go program to build the newt tool. The command used is \ngo install\n which compiles and writes the resulting executable to an output file named \nnewt\n. It installs the results along with its dependencies in $GOPATH/bin.\n\n\n\n\n        $ cd $GOPATH/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt\n        $ go install\n        $ ls \n$GOPATH\n/bin/\n        godep       incubator-mynewt-newt.git     newt\n\n\n\n\n\n\nTry running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.\n\n\n\n\nNote: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to store the command in a variable in your .bash_profile. So type in \nexport newt=\"go run $GOPATH/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt/newt/go\"\n in your .bash_profile and execute it by calling \n$newt\n at the prompt instead of \nnewt\n. Here, you use \ngo run\n which runs the compiled binary directly without producing an executable. Don't forget to reload the updated bash profile by typing \nsource ~/.bash_profile\n at the prompt! \n\n\n        $ newt version\n        Newt version:  1.0\n        $ newt -h\n        Newt allows you to create your own embedded project based on the Mynewt\n        operating system. Newt provides both build and package management in a\n        single tool, which allows you to compose an embedded workspace, and set\n        of projects, and then build the necessary artifacts from those projects.\n        For more information on the Mynewt operating system, please visit\n        https://www.github.com/mynewt/documentation.\n\n        Please use the newt help command, and specify the name of the command\n        you want help for, for help on how to use a specific command\n\n        Usage:\n         newt [flags]\n         newt [command]\n\n        Examples:\n         newt\n         newt help [\ncommand-name\n]\n           For help on \ncommand-name\n.  If not specified, print this message.\n\n\n        Available Commands:\n         version     Display the Newt version number.\n         target      Set and view target information\n         egg         Commands to list and inspect eggs on a nest\n         nest        Commands to manage nests \n clutches (remote egg repositories)\n         help        Help about any command\n\n        Flags:\n         -h, --help=false: help for newt\n         -l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n         -q, --quiet=false: Be quiet; only display error output.\n         -s, --silent=false: Be silent; don't output anything.\n         -v, --verbose=false: Enable verbose output when executing commands.\n\n\n        Use \nnewt help [command]\n for more information about a command.\n\n\n\n\n\n\nWithout creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool. \n\n\n\n\nGetting the debugger ready\n\n\n\n\nBefore you start building nests and hatching eggs, you need to do one final step in the environment preparation - install gcc / libc that can produce 32-bit executables. So, first install gcc. You will see the brew steps and a final summary confirming install.\n\n\n\n\n        $ brew install gcc\n        ...\n        ...\n        ==\n Summary\n        \ud83c\udf7a  /usr/local/Cellar/gcc/5.2.0: 1353 files, 248M\n\n\n\n\n\n\nARM maintains a pre-built GNU toolchain with a GCC source branch targeted at Embedded ARM Processors namely Cortex-R/Cortex-M processor families. Install the PX4 Toolchain and check the version installed. Make sure that the symbolic link installed by Homebrew points to the correct version of the debugger. If not, you can either change the symbolic link using the \"ln -f -s\" command or just go ahead and try with the version it points to!\n\n\n\n\n        $ brew tap PX4/homebrew-px4\n        $ brew update\n        $ brew install gcc-arm-none-eabi-49\n        $ arm-none-eabi-gcc --version  \n        arm-none-eabi-gcc (GNU Tools for ARM Embedded Processors) 4.9.3 20150529 (release) [ARM/embedded-4_9-branch revision 224288]\n        Copyright (C) 2014 Free Software Foundation, Inc.\n        This is free software; see the source for copying conditions.  There is NO\n        warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n        $ ls -al /usr/local/bin/arm-none-eabi-gdb\n        lrwxr-xr-x  1 aditihilbert  admin  69 Sep 22 17:16 /usr/local/bin/arm-none-eabi-gdb -\n /usr/local/Cellar/gcc-arm-none-eabi-49/20150609/bin/arm-none-eabi-gdb\n\n\n\n\nNote: If no version is specified, brew will install the latest version available. MynewtOS will eventually work with multiple versions available including the latest releases. However, at present we have tested only with this version and recommend it for getting started. \n\n\n\n\nYou have to install OpenOCD (Open On-Chip Debugger) which is an open-source software that will allow you to interface with the JTAG debug connector/adaptor for the Olimex board. It lets you program, debug, and test embedded target devices which, in this case, is the Olimex board. Use brew to install it. Brew adds a simlink /usr/local/bin/openocd to the openocd directory in the Cellar. For more on OpenOCD go to \nhttp://openocd.org\n.\n\n\n\n\n        $ brew install open-ocd\n        $ which openocd\n        /usr/local/bin/openocd\n        $ ls -l $(which openocd)\n        lrwxr-xr-x  1 \nuser\n  admin  36 Sep 17 16:22 /usr/local/bin/openocd -\n ../Cellar/open-ocd/0.9.0/bin/openocd\n\n\n\n\n\n\nProceed to the \nBuilding test code on simulator\n section.\n\n\n\n\nGetting your Ubuntu machine Ready\n\n\nInstalling some prerequisites\n\n\n\n\nInstall git, libcurl, and the Go language if you do not have them already.\n\n\n\n\n        $ sudo apt-get install git \n        $ sudo apt-get install libcurl4-gnutls-dev \n        $ sudo apt-get install golang \n\n\n\n\nCreating local repository\n\n\n\n\n\n\nThe directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:\n\n\n\n\n\n\nsrc contains Go source files organized into packages (one package per directory),\n\n\n\n\n\n\npkg contains package objects, and\n\n\n\n\n\n\nbin contains executable commands.\n\n\n\n\n\n\n\n\n\n\nThe GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory where you will soon clone the newt tool repository.\n\n\n        $ cd $HOME\n        $ mkdir -p dev/go  \n        $ cd dev/go\n        $ export GOPATH=$PWD\n\n\n\n\nNote that you need to add export statements to ~/.bashrc (or equivalent) to export variables permanently.\n\n\n\n\nYou are ready to download the newt tool repository. You will use Go to copy the directory (currently the asf incubator directory). Be patient as it may take a minute or two. Check the directories installed.\n\n\n\n\n        $ go get git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt\n        $ ls\n         bin    pkg    src\n        $ ls src\n        git-wip-us.apache.org   github.com      gopkg.in\n\n\n\n\n\n\nCheck that newt is in place.\n\n\n\n\n        $ ls $GOPATH/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt \n        Godeps          README.md       coding_style.txt    newt.go\n        LICENSE         cli             design.txt\n\n\n\n\nBuilding the newt tool\n\n\n\n\nYou will use Go to run the newt.go program to build the newt tool. The command used is  \ngo install\n which compiles and writes the resulting executable to an output file named \nnewt\n. It installs the results along with its dependencies in $GOPATH/bin.\n\n\n\n\n        $ cd $GOPATH/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt\n        $ go install\n        $ ls \n$GOPATH\n/bin/\n        godep       incubator-mynewt-newt.git     newt\n\n\n\n\n\n\nTry running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.\n\n\n\n\nNote: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to store the command in a variable in your .bash_profile. So type in \nexport newt=\"go run $GOPATH/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt/newt/go\"\n in your ~/.bashrc (or equivalent) and execute it by calling \n$newt\n at the prompt instead of \nnewt\n. Here, you use \ngo run\n which runs the compiled binary directly without producing an executable.   \n\n\n        $ newt version\n        Newt version:  1.0\n        $ newt -h\n        Newt allows you to create your own embedded project based on the Mynewt\n        operating system. Newt provides both build and package management in a\n        single tool, which allows you to compose an embedded workspace, and set\n        of projects, and then build the necessary artifacts from those projects.\n        For more information on the Mynewt operating system, please visit\n        https://www.github.com/mynewt/documentation.\n\n        Please use the newt help command, and specify the name of the command\n        you want help for, for help on how to use a specific command\n\n        Usage:\n         newt [flags]\n         newt [command]\n\n        Examples:\n         newt\n         newt help [\ncommand-name\n]\n           For help on \ncommand-name\n.  If not specified, print this message.\n\n\n        Available Commands:\n         version     Display the Newt version number.\n         target      Set and view target information\n         egg         Commands to list and inspect eggs on a nest\n         nest        Commands to manage nests \n clutches (remote egg repositories)\n         help        Help about any command\n\n        Flags:\n         -h, --help=false: help for newt\n         -l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n         -q, --quiet=false: Be quiet; only display error output.\n         -s, --silent=false: Be silent; don't output anything.\n         -v, --verbose=false: Enable verbose output when executing commands.\n\n\n        Use \nnewt help [command]\n for more information about a command.\n\n\n\n\n\n\nWithout creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool. \n\n\n\n\nGetting the debugger ready\n\n\n\n\nBefore you start building nests and hatching eggs, you need to do one final step in the environment preparation - install gcc / libc that can produce 32-bit executables. You can install these as follows: \n\n\n\n\n        $ sudo apt-get install gcc-multilib libc6-i386\n\n\n\n\n\n\nFor the LED project on the Olimex hardware, you have to install gcc for AM 4.9.3.  This package can be installed with apt-get as documented below. The steps are explained in depth at \nhttps://launchpad.net/~terry.guo/+archive/ubuntu/gcc-arm-embedded\n.\n\n\n\n\n        $ sudo apt-get remove binutils-arm-none-eabi gcc-arm-none-eabi \n        $ sudo add-apt-repository ppa:terry.guo/gcc-arm-embedded \n        $ sudo apt-get update \n        $ sudo apt-get install gcc-arm-none-eabi\n\n\n\n\n\n\n\n\nAnd finally, you have to install OpenOCD (Open On-Chip Debugger) which is an open-source software that will allow you to interface with the JTAG debug connector/adaptor for the Olimex board. It lets you program, debug, and test embedded target devices which, in this case, is the Olimex board. You have to acquire OpenOCD 0.8.0. \n\n\nIf you are running Ubuntu 15.x, then you are in luck and you can simply run: \n\n\n\n\n\n\n        $ sudo apt-get install openocd \n\n\n\n\nOther versions of Ubuntu may not have the correct version of openocd available.  In this case, you should download the openocd 0.8.0 package from \nhttps://launchpad.net/ubuntu/vivid/+source/openocd\n. The direct link to the amd64 build is \nhttp://launchpadlibrarian.net/188260097/openocd_0.8.0-4_amd64.deb\n. \n\n\n\n\nProceed to the \nBuilding test code on simulator\n section.\n\n\n\n\nGetting your Windows machine ready for simulated target\n\n\nThe \nnewt\n tool is the build software used to build Mynewt OS images or executables for any embedded hardware device/board, including the one for the current tutorial (STM32-E407 development board from Olimex). You can run the \nnewt\n tool natively on a computer running any of the three Operating System machines - OSX, Linux, or Windows.\n\n\nHowever, Mynewt OS images for a simulated target are built on the Windows machine by using Linux versions of the build software (newt)in a virtual machine on your Windows box. The Linux VM is set up by installing the Docker Toolbox. Your Windows machine will communicate with the Linux VM via transient ssh connections. You will then download a Docker image (\nnewtvm.exe\n)that allows you to run the newt commands in the Linux Docker instance. The Docker image contains:\n\n\n\n\nThe newt command-line tool\n\n\nGo\n\n\nA multilib-capable native gcc / glibc\n\n\nAn arm-none-eabi gcc\n\n\nNative gdb\n\n\n\n\nThe sequence of events when using the Docker image is as follows:\n\n\n\n\nA new docker environment is created in the Linux VM.\n\n\nThe specified command with the newtvm prefix (\nnewtvm newt\n command) is sent to the docker environment via ssh.\n\n\nThe Linux command runs.\n\n\nThe output from the command is sent back to Windows via ssh.\n\n\nThe output is displayed in the Windows command prompt.\n\n\n\n\nInstall Linux virtual machine\n\n\n\n\n\n\nDownload the Docker Toolbox for Windows (version 1.9.0c or later) from \nhttps://www.docker.com/docker-toolbox\n. The Docker toolbox creates a consistently reproducible and self-contained environment in Linux.\n\n\n\n\n\n\nRun the Docker Toolbox installer.  All the default settings are OK.\n\n\n\n\n\n\nYou may need to add \"C:\\Program Files\\Git\\usr\\bin\" to your PATH\nenvironment variable.  To add to the PATH environment variable, right-click on the Start button in the bottom left corner. Choose System -\n Advanced system settings -\n Environment Variables. Click on the PATH variable under \"System variables\" and click Edit to check and add it if it is not already there. \n\n\n\n\n\n\nInstall newtvm tool\n\n\n\n\nFrom your base user (home) directory, pull or clone the latest code from the newt repository into the \nnewt\n directory. It includes the executable \nnewtvm.exe\n for the newtvm tool in the \nnewtvm\n directory.\n\n\n\n\n      C:\\Users\\admin\n git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-newt newt\n\n\n\n\nThe newtvm tool is what allows you to run programs in the Linux docker\ninstance.  \n\n\n\n\nRun the Docker Quickstart Terminal application inside the Docker folder under Programs. You can find it by clicking Start button -\n All apps. By default, the Docker Toolbox installer creates a shortcut to this program on your desktop.  Wait until you see an ASCII art whale displayed in the terminal window and the Docker prompt given.  \n\n\n\n\n                          ##         .\n                    ## ## ##        ==\n                 ## ## ## ## ##    ===\n             /\n\\___/ ===\n        ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~\n           \\______ o           __/\n             \\    \\         __/\n              \\____\\_______/\n\n         docker is configured to use the default machine with IP 192.168.99.100\n         For help getting started, check out the docs at https://docs.docker.com\n\n         admin@dev1 MINGW64 ~ (master)\n         $\n\n\n\n\nThe first time you run this, it may take several minutes to complete. You will need to run the Docker Quickstart Terminal once each time you\nrestart your computer.\n\n\n\n\nOpen a command prompt (e.g., Windows-R, \"cmd\", enter). You execute the newt tool commands as though you were running newt in Linux, but you prefix each command with \"newtvm\".  For example:\n\n\n\n\n        C:\\Users\\admin\\newt\\newtvm\n newtvm newt help\n\n\n\n\nThe newtvm tool will take a long time to run the first time you execute\nit.  The delay is due to the fact that the tool must download the mynewt\ndocker instance.\n\n\n\n\nYou are now ready to proceed to \nbuilding the image for the simulated target\n.\n\n\n\n\nGetting your Windows machine ready for hardware target\n\n\nWhen you want to produce images for actual hardware board on your Windows machine, go through the following setup procedure and then proceed to the \nblinky project on the Olimex board\n with this method.\n\n\nInstalling some prerequisites\n\n\n\n\n\n\nYou have to install the following if you do not have them already.  The steps below indicate specific folders where each of these programs should be installed. You can choose different locations, but the remainder of this\ntutorial for a Windows machine assumes the specified folders.    \n\n\n\n\nwin-builds-i686\n\n\nwin-builds-x86_64\n\n\nMSYS\n\n\ngcc for ARM\n\n\nopenocd\n\n\nzadig\n\n\ngit\n\n\n\n\ngo\n\n\n\n\nwin-builds (mingw64) 1.5 for i686\n\n\n\n\nDownload from \nhttp://win-builds.org/doku.php/download_and_installation_from_windows\n. Install at: \"C:\\win-builds-i686\".\n\n\nBe sure to click the i686 option (not x86_64). The defaults for all other options are OK. The installer will want to download a bunch of additional packages. They are not all necessary, but it is simplest to just accept the defaults.\n\n\n\n\nwin-builds (mingw64) 1.5 for x86_64\n\n\n\n\nDownload from \nhttp://win-builds.org/doku.php/download_and_installation_from_windows\n. Install at \"C:\\win-builds-x86_64\"\n\n\nRun the installer a second time, but this time click the x86_64 option, NOT i686.  The defaults for all other options are OK.\n\n\n\n\nMSYS\n\n\n\n\nStart your download from \nhttp://sourceforge.net/projects/mingw-w64/files/External%20binary%20packages%20%28Win64%20hosted%29/MSYS%20%2832-bit%29/MSYS-20111123.zip\n\n\nUnzip to \"C:\\msys\"\n\n\n\n\ngcc for ARM, 4.9.3\n\n\n\n\nDownload the Windows installer from \nhttps://launchpad.net/gcc-arm-embedded/+download\n and install at \"C:\\Program Files (x86)\\GNU Tools ARM Embedded\\4.9 2015q3\".\n\n\n\n\nOpenOCD 0.8.0 \n\n\n\n\nDownload OpenOCD 0.8.0 from \nhttp://www.freddiechopin.info/en/download/category/4-openocd\n. Unzip to \"C:\\openocd\".\n\n\n\n\nZadig 2.1.2\n\n\n\n\nDownload it from \nhttp://zadig.akeo.ie\n and install it at \"C:\\zadig\".\n\n\n\n\nGit\n\n\n\n\nClick on \nhttps://git-scm.com/download/win\n to start the download. Install at \"C:\\Program Files (x86)\\Git\". Specify the \"Use Git from the Windows Command Prompt\" option.  The defaults for all other options are OK.\n\n\n\n\nGo\n\n\n\n\nDownload the release for Microsoft Windows from \nhttps://golang.org/dl/\n and install it \"C:\\Go\".\n\n\n\n\n\n\n\n\n\n\nCreating local repository\n\n\n\n\n\n\nThe directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:\n\n\n\n\n\n\nsrc contains Go source files organized into packages (one package per directory),\n\n\n\n\n\n\npkg contains package objects, and\n\n\n\n\n\n\nbin contains executable commands.\n\n\n\n\n\n\nThe GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory and then proceed to create the directory for cloning the newt tool repository.\n\n\n\n\n\n\n        $ cd c:\\\n        $ mkdir dev\\go\n        $ cd dev\\go\n\n\n\n\n\n\nSet the following user environment variables using the steps outlined here.\n\n\n\n\n    * GOPATH: C:\\dev\\go\n    * PATH: C:\\Program Files (x86)\\GNU Tools ARM Embedded\\4.9 2015q3\\bin;%GOPATH%\\bin;C:\\win-builds-x86_64\\bin;C:\\win-builds-i686\\bin;C:\\msys\\bin\n\n\n\n\nSteps:\n\n\n\n\nRight-click the start button\n\n\nClick \"Control panel\"\n\n\nClick \"System and Security\"\n\n\nClick \"System\"\n\n\nClick \"Advanced system settings\" in the left panel\n\n\nClick the \"Envoronment Variables...\" button\n\n\nThere will be two sets of environment variables: user variables\n      in the upper half of the screen, and system variables in the lower\n      half.  Configuring the user variables is recommended and tested \n      (though system variables will work as well).\n\n\n\n\n\n\nNext, install godep. Note that the following command produces no output.\n\n\n\n\n        $ go get github.com/tools/godep \n\n\n\n\n\n\nSet up the repository for the package building tool \"newt\" on your local machine. First create the appropriate directory for it and then clone the newt tool repository from the online apache repository (or its github.com mirror) into this newly created directory. Check the contents of the directory.\n\n\n\n\n        $ go get git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt\n        $ dir \n         bin    pkg    src\n        $ dir src\n        git-wip-us.apache.org   github.com      gopkg.in\n        $ dir\n        newt\n        $ cd newt\n        $ dir\n        Godeps                  README.md               coding_style.txt        newt.go\n        LICENSE                 cli                     design.txt\n\n\n\n\n\n\nCheck that newt is in place.\n\n\n\n\n        $ dir $GOPATH\\src\\git-wip-us.apache.org\\repos\\asf\\incubator-mynewt-newt.git\\newt \n        Godeps          README.md       coding_style.txt    newt.go\n        LICENSE         cli             design.txt\n\n\n\n\nBuilding the newt tool\n\n\n\n\nYou will use Go to run the newt.go program to build the newt tool. The command used is  \ngo install\n which compiles and writes the resulting executable to an output file named \nnewt\n. It installs the results along with its dependencies in $GOPATH/bin.\n\n\n\n\n        $ go install\n        $ ls \n$GOPATH\n/bin/\n        godep       incubator-mynewt-newt.git     newt\n\n\n\n\n\n\nTry running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.\n\n\n\n\nNote: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to define the newt environment variable that allows you to execute the command via \n%newt%\n. Use \nset newt=go run %GOPATH%\\src\\github.com\\mynewt\\newt\\newt.go\n or set it from the GUI. Here, you use \ngo run\n which runs the compiled binary directly without producing an executable.\n\n\n        $ newt version\n        Newt version:  1.0\n        $ newt -h\n        Newt allows you to create your own embedded project based on the Mynewt\n        operating system. Newt provides both build and package management in a\n        single tool, which allows you to compose an embedded workspace, and set\n        of projects, and then build the necessary artifacts from those projects.\n        For more information on the Mynewt operating system, please visit\n        https://www.github.com/mynewt/documentation.\n\n        Please use the newt help command, and specify the name of the command\n        you want help for, for help on how to use a specific command\n\n        Usage:\n         newt [flags]\n         newt [command]\n\n        Examples:\n         newt\n         newt help [\ncommand-name\n]\n           For help on \ncommand-name\n.  If not specified, print this message.\n\n\n        Available Commands:\n         version     Display the Newt version number.\n         target      Set and view target information\n         egg         Commands to list and inspect eggs on a nest\n         nest        Commands to manage nests \n clutches (remote egg repositories)\n         help        Help about any command\n\n        Flags:\n         -h, --help=false: help for newt\n         -l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n         -q, --quiet=false: Be quiet; only display error output.\n         -s, --silent=false: Be silent; don't output anything.\n         -v, --verbose=false: Enable verbose output when executing commands.\n\n\n        Use \nnewt help [command]\n for more information about a command.\n\n\n\n\n\n\nWithout creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool. \n\n\n\n\nGetting the debugger ready\n\n\n\n\nUse Zadig to configure the USB driver for your Olimex debugger.  If your debugger is already set up, you can skip this step.\n\n\n\n\n\n\nPlug in your Olimex debugger.\n\n\nStart Zadig.\n\n\nCheck the Options -\n List All Devices checkbox.    \n\n\nSelect \"Olimex OpenOCD JTAG ARM-USB-TINY-H\" in the dropdown menu.\n\n\nSelect the \"WinUSB\" driver.\n\n\nClick the \"Install Driver\" button.\n\n\n\n\n\n\nProceed to the section on how to \nmake an LED blink\n section.\n\n\n\n\nBuilding test code on simulator\n\n\nNote: On a Windows computer, the simulator can be run only in a Linux virtual environment. Make sure you have installed the Docker instance as outlined in \nan earlier section\n. Consequently, all \nnewt\n commands must be prefaced with \nnewtvm\n.\n\n\n\n\n\n\nFirst, you have to create a repository for the project i.e. build your first nest! Go to ~/dev (or your base user directory on a Windows machine)and clone the larva repository from the apache git repository into a local directory named \nlarva\n.\n\n\nSubstitute DOS commands for Unix commands as necessary in the following steps if your machine is running Windows. The newt tool commands do not change.\n\n\n\n\n\n\n        $ cd ~/dev \n        $ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git larva\n        $ ls\n        go  larva\n        $ cd larva\n        $ ls\n        LICENSE     clutch.yml  hw      nest.yml      project\n        README.md   compiler    libs        net       scripts\n\n\n\n\nOn Windows, open a command prompt (e.g., Windows-R, \"cmd\", enter) and work from your home directory:\n\n\n        C:\\Users\\admin\n git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git larva\n        C:\\Users\\admin\n cd larva\n        C:\\Users\\admin\\larva\n dir\n        Volume in drive C is Windows\n        Volume Serial Number is 4CBB-0920\n\n        Directory of C:\\Users\\admin\\larva\n\n        \nDIR\n          .\n        \nDIR\n          ..\n                    76 .gitignore\n                     0 .gitmodules\n                       .nest\n                 6,133 clutch.yml\n        \nDIR\n          compiler\n        \nDIR\n          hw\n        \nDIR\n          libs\n                11,560 LICENSE\n                    20 nest.yml\n        \nDIR\n          net\n        \nDIR\n          project\n                 2,263 README.md\n        \nDIR\n          scripts\n        6 File(s)         20,052 bytes\n        9 Dir(s)  90,723,442,688 bytes free\n\n\n\n\n2.  You will now create a new target using the newt tool. You can either use the compiled binary \nnewt\n or run the newt.go program using \n$newt\n (assuming you have stored the command in a variable in your .bash_profile or .bashrc). When you do a \nnewt target show\n or \n$newt target show\n it should list all the projects you have created so far. \n\n\n        $ newt target create sim_test\n        Creating target sim_test\n        Target sim_test sucessfully created!\n        $ newt target show\n        sim_test\n            name: sim_test\n            arch: sim\n\n\n\n\nRemember, on a Windows machine you will have to preface \nnewt\n with \nnewtvm\n!\n\n\n        C:\\Users\\admin\\larva\nnewtvm newt target create sim_test\n\n\n\n\n3. Now continue to populate and build out the sim project.\n\n\n        $ newt target set sim_test project=test\n        Target sim_test successfully set project to test\n        $ newt target set sim_test compiler_def=debug\n        Target sim_test successfully set compiler_def to debug\n        $ newt target set sim_test bsp=hw/bsp/native\n        Target sim_test successfully set bsp to hw/bsp/native\n        $ newt target set sim_test compiler=sim\n        Target sim_test successfully set compiler to sim\n        $ newt target show sim_test\n        sim_test\n            arch: sim\n            project: test\n            compiler_def: debug\n            bsp: hw/bsp/native\n            compiler: sim\n            name: sim_test\n\n\n\n\nAgain remember to preface \nnewt\n with \nnewtvm\non a Windows machine as shown below. Continue to fill out all the project attributes.\n\n\n        C:\\Users\\admin\\larva\nnewtvm newt target set sim_test project=test\n        Target sim_test successfully set project to test\n\n\n\n\n4. Configure newt to use the gnu build tools native to OS X or linux. In order for sim to work properly, it needs to be using 32-bit gcc (gcc-5). Replace \n~/dev/larva/compiler/sim/compiler.yml with the compiler/sim/osx-compiler.yml or linux-compiler.yml file, depending on the system. On a Windows machine follow the instruction for the Linux machine as you are running commands in a Linux VM.\n\n\nFor a Mac OS X environment:\n\n\n        $ cp compiler/sim/osx-compiler.yml compiler/sim/compiler.yml \n\n\n\n\nFor a Linux machine:\n\n\n        $ cp compiler/sim/linux-compiler.yml compiler/sim/compiler.yml\n\n\n\n\n5. Next, create (hatch!) the eggs for this project using the newt tool - basically, build the packages for it. You can specify the VERBOSE option if you want to see the gory details. Always remember to preface \nnewt\n with \nnewtvm\non a Windows machine.\n\n\n        $ newt target build sim_test\n        Successfully run!\n\n\n\n\nYou can specify the VERBOSE option if you want to see the gory details.\n\n\n        $newt -l VERBOSE target build sim_test\n        2015/09/29 09:46:12 [INFO] Building project test\n        2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//bootutil...\n        2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//cmsis-core...\n        2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//ffs..\n        ...\n        Successfully run!\n\n\n\n\n6. Try running the test suite executable inside this project and enjoy your first successful hatch.\n\n\n        $ newt ./project/test/bin/sim_test/test.elf\n        [pass] os_mempool_test_suite/os_mempool_test_case\n        [pass] os_mutex_test_suite/os_mutex_test_basic\n        [pass] os_mutex_test_suite/os_mutex_test_case_1\n        [pass] os_mutex_test_suite/os_mutex_test_case_2\n        [pass] os_sem_test_suite/os_sem_test_basic\n        [pass] os_sem_test_suite/os_sem_test_case_1\n        [pass] os_sem_test_suite/os_sem_test_case_2\n        [pass] os_sem_test_suite/os_sem_test_case_3\n        [pass] os_sem_test_suite/os_sem_test_case_4\n        [pass] os_mbuf_test_suite/os_mbuf_test_case_1\n        [pass] os_mbuf_test_suite/os_mbuf_test_case_2\n        [pass] os_mbuf_test_suite/os_mbuf_test_case_3\n        [pass] gen_1_1/ffs_test_unlink\n        [pass] gen_1_1/ffs_test_rename\n        [pass] gen_1_1/ffs_test_truncate\n        [pass] gen_1_1/ffs_test_append\n        [pass] gen_1_1/ffs_test_read\n        [pass] gen_1_1/ffs_test_overwrite_one\n        [pass] gen_1_1/ffs_test_overwrite_two\n        [pass] gen_1_1/ffs_test_overwrite_three\n        ...\n        ...\n        [pass] boot_test_main/boot_test_vb_ns_11\n\n\n\n\nUsing SRAM to make LED blink\n\n\nYou are here because you want to build an image to be run from internal SRAM on the Olimex board.\n\n\nPreparing the Software\n\n\n\n\n\n\nMake sure the PATH environment variable includes the $HOME/dev/go/bin directory (or C:\\%GOPATH%\\bin on Windows machine). \n\n\nSubstitute DOS commands for Unix commands as necessary in the following steps if your machine is running Windows (e.g. \ncd dev\\go\n instead of \ncd dev/go\n). The newt tool commands do not change.\n\n\n\n\n\n\nIf you have cloned the larva repository for the simulator test in the previous section you can skip this step. Otherwise, you have to create a repository for the project i.e. build your first nest! Go to ~/dev and clone the larva repository from the apache git repository into a local directory named \nlarva\n.\n\n\nSubstitute DOS commands for Unix commands as necessary in the following steps if your machine is running Windows. The newt tool commands do not change.\n\n\n\n\n\n\n        $ cd ~/dev \n        $ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git larva\n        $ ls\n        go  larva\n        $ cd larva\n        $ ls\n        LICENSE     clutch.yml  hw      nest.yml      project\n        README.md   compiler    libs        net       scripts\n\n\n\n\n\n\n\n\nYou first have to create a repository for the project. Go to the ~dev/larva directory and build out a second project inside larva. The project name is \"blinky\", in keeping with the objective. Starting with the target name, you have to specify the different aspects of the project to pull the appropriate eggs and build the right package for the board. In this case that means setting the architecture (arch), compiler, board support package (bsp), project, and compiler mode.\n\n\nRemember to prefix each command with \"newtvm\" if you are executing the newt command in a Linux virtual machine on your Windows box!\n\n\n\n\n\n\n        $ newt target create blinky\n        Creating target blinky\n        Target blinky sucessfully created!\n        $ newt target set blinky arch=cortex_m4\n        Target blinky successfully set arch to arm\n        $ newt target set blinky compiler=arm-none-eabi-m4\n        Target blinky successfully set compiler to arm-none-eabi-m4\n        $ newt target set blinky project=blinky\n        Target blinky successfully set project to blinky\n        $ newt target set blinky compiler_def=debug\n        Target blinky successfully set compiler_def to debug\n        $ newt target set blinky bsp=hw/bsp/olimex_stm32-e407_devboard\n        Target blinky successfully set bsp to hw/bsp/olimex_stm32-e407_devboard\n        $ newt target show blinky\n        blinky\n            compiler: arm-none-eabi-m4\n            project: blinky\n            compiler_def: debug\n            bsp: hw/bsp/olimex_stm32-e407_devboard\n            name: blinky\n            arch: cortex_m4\n\n\n\n\n\n\n\n\nNow you have to build the image. The linker script within the \nhw/bsp/olimex_stm32-e407_devboard\n egg builds an image for flash memory by default. Since you want an image for the SRAM, you need to switch that script with \nrun_from_sram.ld\n in order to get the egg to produce an image for SRAM. \n We are working on making it easier to specify where the executable will be run from for a particular project and automatically choose the correct linker scripts and generate the appropriate image. It will be specified as a project identity e.g. bootloader, RAM, flash (default) and the target will build accordingly. \n. \n\n\nOnce the target is built, you can find the executable \"blinky.elf\" in the project directory at ~/dev/larva/project/blinky/bin/blinky. It's a good idea to take a little time to understand the directory structure.\n\n\n\n\n\n\n        $ cd ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n        $ diff olimex_stm32-e407_devboard.ld run_from_sram.ld\n        $ cp run_from_sram.ld olimex_stm32-e407_devboard.ld\n        $ cd ~/dev/larva/project/blinky/bin/blinky\n        $ newt target build blinky\n        Building target blinky (project = blinky)\n        Compiling case.c\n        Compiling suite.c\n        ...\n        Successfully run!\n        $ ls\n        LICENSE     clutch.yml  hw      nest.yml    project\n        README.md   compiler    libs        net     scripts\n        $ cd project\n        $ ls\n        bin2img     bletest     blinky      boot        ffs2native  test\n        $ cd blinky\n        $ ls\n        bin     blinky.yml  egg.yml     src\n        $ cd bin\n        $ ls\n        blinky\n        $ cd blinky\n        $ ls\n        blinky.elf  blinky.elf.bin  blinky.elf.cmd  blinky.elf.lst  blinky.elf.map\n\n\n\n\n\n\n\n\nCheck that you have all the scripts needed to get OpenOCD up and talking with the project's specific hardware. Depending on your system (Ubuntu, Windows) you may already have the scripts in your \n/usr/share/openocd/scripts/\n directory as they may have been part of the openocd download. If yes, you are all set and can proceed to preparing the hardware.\n\n\nOtherwise check the \n~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n directory for a file named \nf407.cfg\n. That is the config we will use to talk to this specific hardware using OpenOCD. You are all set if you see it.\n\n\n\n\n\n\n        $ ls ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n        bin                 olimex_stm32-e407_devboard_debug.sh\n        boot-olimex_stm32-e407_devboard.ld  olimex_stm32-e407_devboard_download.sh\n        egg.yml                 run_from_flash.ld\n        f407.cfg                run_from_loader.ld\n        include                 run_from_sram.ld\n        olimex_stm32-e407_devboard.ld       src\n\n\n\n\nPreparing the hardware to boot from embedded SRAM\n\n\n\n\n\n\nLocate the boot jumpers on the board.\n\n\n\n\n\n\n\n\n\nB1_1/B1_0 and B0_1/B0_0 are PTH jumpers which can be moved relatively easy. Note that the markings on the board may not always be accurate. Always refer to the manual for the correct positioning of jumpers in case of doubt. The two jumpers must always be moved together \u2013 they are responsible for the boot mode if bootloader is present. The board can search for bootloader on three places \u2013 User Flash Memory, System Memory or the Embedded SRAM. We will configure it to boot from SRAM by jumpering B0_1 and B1_1.\n\n\n\n\n\n\nConnect USB-OTG#2 in the picture above to a USB port on your computer (or a powered USB hub to make sure there is enough power available to the board). \n\n\n\n\n\n\nThe red PWR LED should be lit. \n\n\n\n\n\n\nConnect the JTAG connector to the SWD/JTAG interface on the board. The other end of the cable should be connected to the USB port or hub of your computer.\n\n\n\n\n\n\nLet's Go!\n\n\n\n\nMake sure you are in the blinky project directory with the blinky.elf executable. Run the debug command in the newt tool. You should see some status messages are shown below. There is an inbuilt \n-c \"reset halt\"\n flag that tells it to halt after opening the session.\n\n\n\n\n        $ cd dev/larva/project/blinky/bin/blinky\n        $ newt target debug blinky\n        Debugging with /Users/aditihilbert/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_debug.sh blinky\n        Debugging /Users/aditihilbert/dev/larva/project/blinky/bin/blinky/blinky.elf\n        GNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\n        Copyright (C) 2014 Free Software Foundation, Inc.\n        License GPLv3+: GNU GPL version 3 or later \nhttp://gnu.org/licenses/gpl.html\n\n        This is free software: you are free to change and redistribute it.\n        There is NO WARRANTY, to the extent permitted by law.  Type \nshow copying\n\n        and \nshow warranty\n for details.\n        This GDB was configured as \n--host=x86_64-apple-darwin10 --target=arm-none-eabi\n.\n        Type \nshow configuration\n for configuration details.\n        For bug reporting instructions, please see:\n        \nhttp://www.gnu.org/software/gdb/bugs/\n.\n        Find the GDB manual and other documentation resources online at:\n        \nhttp://www.gnu.org/software/gdb/documentation/\n.\n        For help, type \nhelp\n.\n        Type \napropos word\n to search for commands related to \nword\n...\n        Reading symbols from /Users/aditihilbert/dev/larva/project/blinky/bin/        blinky/blinky.elf...done.\n        Open On-Chip Debugger 0.8.0 (2015-09-22-18:21)\n        Licensed under GNU GPL v2\n        For bug reports, read\n            http://openocd.sourceforge.net/doc/doxygen/bugs.html\n        Info : only one transport option; autoselect 'jtag'\n        adapter speed: 1000 kHz\n        adapter_nsrst_delay: 100\n        jtag_ntrst_delay: 100\n        Warn : target name is deprecated use: 'cortex_m'\n        DEPRECATED! use 'cortex_m' not 'cortex_m3'\n        cortex_m reset_config sysresetreq\n        Info : clock speed 1000 kHz\n        Info : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\n        Info : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\n        Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints\n        Info : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\n        Info : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\n        target state: halted\n        target halted due to debug-request, current mode: Thread \n        xPSR: 0x01000000 pc: 0x20000250 msp: 0x10010000\n        Info : accepting 'gdb' connection from 3333\n        Info : device id = 0x10036413\n        Info : flash size = 1024kbytes\n        Reset_Handler () at startup_STM32F40x.s:199\n        199     ldr    r1, =__etext\n\n\n\n\nCheck the value of the msp (main service pointer) register. If it is not 0x10010000 as indicated above, you will have to manually set it after you open the gdp tool and load the image on it. \n\n\n        (gdb) set $msp=0x10010000\n\n\n\n\nNow load the image and type \"c\" or \"continue\" from the GNU debugger. \n\n\n        (gdb) load ~/dev/larva/project/blinky/bin/blinky/blinky.elf\n        Loading section .text, size 0x4294 lma 0x20000000\n        Loading section .ARM.extab, size 0x24 lma 0x20004294\n        Loading section .ARM.exidx, size 0xd8 lma 0x200042b8\n        Loading section .data, size 0x874 lma 0x20004390\n        Start address 0x20000250, load size 19460\n        Transfer rate: 81 KB/sec, 2432 bytes/write.\n        (gdb) c\n        Continuing.\n\n\n\n\n\n\nVoil\u00e0! The board's LED should be blinking at 1 Hz.\n\n\n\n\nUsing flash to make LED blink\n\n\nYou are here because you want to build an image to be run from flash memory on the Olimex board.\n\n\n\n\nConfigure the board to boot from flash by moving the two jumpers together to B0_0 and B1_0. Refer to the pictures of the board under the section titled \n\"Preparing the hardware to boot from embedded SRAM\"\n.\n\n\n\n\nYou will have to reset the board once the image is uploaded to it.\n\n\n\n\nIf you skipped the first option for the project \n(downloading an image to SRAM)\n, then skip this step. Otherwise, continue with this step. \n\n\n\n\nBy default, the linker script (\nolimex_stm32-e407_devboard.ld\n) is configured to run from bootloader and flash. However, if you first ran the image from SRAM you had changed \nolimex_stm32-e407_devboard.ld\n to match \nrun_from_sram.ld\n. You will therefore return to defaults with \nolimex_stm32-e407_devboard.ld\n linker script matching the contents of 'run_from_loader.ld'. Return to the project directory.\n\n\n        $ cd ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n        $ diff olimex_stm32-e407_devboard.ld run_from_sram.ld\n        $ diff olimex_stm32-e407_devboard.ld run_from_loader.ld\n        $ cp run_from_loader.ld olimex_stm32-e407_devboard.ld\n        $ cd ~/dev/larva/project/blinky/bin/blinky\n\n\n\n\n\n\nIn order to run the image from flash, you need to build the bootloader as well. The bootloader does the initial bring up of the Olimex board and then transfers control to the image stored at a location in flash known to it. The bootloader in turn requires the bin2image tool to check the image header for version information, CRC checks etc. So, we will need to build these two additional targets (bootloader and bin2img).\n\n\n\n\nLet's first create bin2img:\n\n\n        $ newt target create bin2img\n        Creating target bin2img\n        Target bin2img successfully created!\n        $ newt target set bin2img arch=sim\n        Target bin2img successfully set arch to sim\n        $ newt target set bin2img compiler=sim\n        Target bin2img successfully set compiler to sim\n        $ newt target set bin2img project=bin2img\n        Target bin2img successfully set project to bin2img\n        $ newt target set bin2img compiler_def=debug\n        Target bin2img successfully set compiler_def to debug\n        $ newt target set bin2img bsp=hw/bsp/native\n        Target bin2img successfully set bsp to hw/bsp/native\n        $ newt target show bin2img\n        bin2img\n            arch: sim\n            compiler: sim\n            project: bin2img\n            compiler_def: debug\n            bsp: hw/bsp/native\n            name: bin2img\n\n\n\n\nAnd then let's create boot_olimex:\n\n\n        $ newt target create boot_olimex\n        Creating target boot_olimex\n        Target boot_olimex successfully created!\n        $ newt target set boot_olimex arch=cortex_m4\n        Target boot_olimex successfully set arch to cortex_m4\n        $ newt target set boot_olimex compiler=arm-none-eabi-m4\n        Target boot_olimex successfully set compiler to arm-none-eabi-m4\n        $ newt target set boot_olimex project=boot\n        Target boot_olimex successfully set project to boot\n        $ newt target set boot_olimex compiler_def=optimized\n        Target boot_olimex successfully set compiler_def to optimized\n        $ newt target set boot_olimex bsp=hw/bsp/olimex_stm32-e407_devboard\n        Target boot_olimex successfully set bsp to hw/bsp/olimex_stm32-e407_devboard\n        $ newt target show boot_olimex\n        boot_olimex\n            project: boot\n            compiler_def: optimized\n            bsp: hw/bsp/olimex_stm32-e407_devboard\n            name: boot_olimex\n            arch: cortex_m4\n            compiler: arm-none-eabi-m4\n\n\n\n\n\n\nLet's build all the three targets now.\n\n\n\n\n        $ newt target build bin2img\n        Building target bin2img (project = bin2img)\n        Building project bin2img\n        Successfully run!\n        $ newt target build boot_olimex\n        Building target boot_olimex (project = boot)\n        Building project boot\n        Successfully run!\n        $ newt target build blinky\n        Building target blinky (project = blinky)\n        Building project blinky\n        Successfully run!\n\n\n\n\n\n\nGo to the project directory and download the bootloader and the image to flash ... in a flash! \n\n\n\n\n        $ cd ~/dev/larva/project/blinky/bin/blinky\n        $ newt target download boot_olimex\n        Downloading with ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_download.sh\n        $ newt target download blinky\n        Downloading with ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_download.sh\n\n\n\n\n\n\n\n\nThe LED should be blinking!\n\n\n\n\n\n\nBut wait...let's double check that it is indeed booting from flash and making the LED blink from the image in flash. Pull the USB cable off the Olimex JTAG adaptor. The debug connection to the JTAG port is now severed. Next power off the Olimex board by pulling out the USB cable from the board. Wait for a couple of seconds and plug the USB cable back to the board. \n\n\n\n\n\n\nThe LED light will start blinking again. Success!\n\n\nNote #1: If you want to download the image to flash and a gdb session opened up, use \nnewt target debug blinky\n instead of \nnewt target download blinky\n.\n\n\n        $ newt target debug blinky\n        Debugging with ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_debug.sh blinky\n        Debugging ~/dev/larva/project/blinky/bin/blinky/blinky.elf\n        GNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\n        Copyright (C) 2014 Free Software Foundation, Inc.\n        License GPLv3+: GNU GPL version 3 or later \nhttp://gnu.org/licenses/gpl.html\n\n        This is free software: you are free to change and redistribute it.\n        There is NO WARRANTY, to the extent permitted by law.  Type \nshow copying\n\n        and \nshow warranty\n for details.\n        This GDB was configured as \n--host=x86_64-apple-darwin10 --target=arm-none-eabi\n.\n        Type \nshow configuration\n for configuration details.\n        For bug reporting instructions, please see:\n        \nhttp://www.gnu.org/software/gdb/bugs/\n.\n        Find the GDB manual and other documentation resources online at:\n        \nhttp://www.gnu.org/software/gdb/documentation/\n.\n        For help, type \nhelp\n.\n        Type \napropos word\n to search for commands related to \nword\n...\n        Reading symbols from /Users/aditihilbert/dev/larva/project/blinky/bin/blinky/blinky.elf...done.\n        Open On-Chip Debugger 0.8.0 (2015-09-22-18:21)\n        Licensed under GNU GPL v2\n        For bug reports, read\n            http://openocd.sourceforge.net/doc/doxygen/bugs.html\n        Info : only one transport option; autoselect 'jtag'\n        adapter speed: 1000 kHz\n        adapter_nsrst_delay: 100\n        jtag_ntrst_delay: 100\n        Warn : target name is deprecated use: 'cortex_m'\n        DEPRECATED! use 'cortex_m' not 'cortex_m3'\n        cortex_m reset_config sysresetreq\n        Info : clock speed 1000 kHz\n        Info : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\n        Info : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\n        Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints\n        Info : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\n        Info : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\n        target state: halted\n        target halted due to debug-request, current mode: Thread \n        xPSR: 0x01000000 pc: 0x08000250 msp: 0x10010000\n        Info : accepting 'gdb' connection from 3333\n        Info : device id = 0x10036413\n        Info : flash size = 1024kbytes\n        Reset_Handler () at startup_STM32F40x.s:199\n        199     ldr    r1, =__etext\n        (gdb)\n\n\n\n\nNote #2: If you want to erase the flash and load the image again you may use the following commands from within gdb. \nflash erase_sector 0 0 x\n tells it to erase sectors 0 through x. When you ask it to display (in hex notation) the contents of the sector starting at location 'lma' you should therefore see all f's. The memory location 0x8000000 is the start or origin of the flash memory contents and is specified in the olimex_stm32-e407_devboard.ld linker script. The flash memory locations is specific to the processor.\n\n\n        (gdb) monitor flash erase_sector 0 0 4\n        erased sectors 0 through 4 on flash bank 0 in 2.296712s\n        (gdb) monitor mdw 0x08000000 16\n        0x08000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \n        (0x08000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \n        (0x08000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \n        (0x08000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff         \n        (gdb) monitor flash info 0", 
            "title": "Blinky, The First Project"
        }, 
        {
            "location": "/get_started/project1/#blinky-the-first-project", 
            "text": "Objective  We will show you how you can use eggs from a nest on Mynewt to make an LED on a target board blink. We will call it   Project Blinky . The goals of this tutorial are threefold:   First, you will learn how to set up your environment to be ready to use Mynewt OS and newt tool.   Second, we will walk you through a download of eggs for building and testing  on a simulated target .  Third, you will download eggs and use tools to create a runtime image for a board to make its LED blink. You have two choices here - you can  download an image to SRAM  or you can  download it to flash .    Time Requirement : Allow yourself a couple of hours for this project if you are relatively new to embedded systems and playing with development boards. Those jumpers can be pesky!  What you need   STM32-E407 development board from Olimex. You can order it from  http://www.mouser.com ,  http://www.digikey.com , and other places.  ARM-USB-TINY-H connector with JTAG interface for debugging ARM microcontrollers (comes with the ribbon cable to hook up to the board)  USB A-B type cable to connect the debugger to your personal computer  Personal Computer   The instructions assume the user is using a Bourne-compatible shell (e.g. bash or zsh) on your computer. The given instructions have been tested with the following releases of operating systems:   Mac: OS X Yosemite Version 10.10.5  Linux: Ubuntu 14.10 (Utopic Unicorn)  Windows: Windows 10   Access to the Apache repo    Get an account on Apache. You do not need a committer account to view the website or clone the repository but you need it to push changes to it.    The latest codebase for the Mynewt OS is on the master branch at https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git    The latest codebase for the Newt tool is on the master branch at https://git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git    The following shows how to clone a Mynewt OS code repository:   Non Committers           $ git clone http://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git   Committers           $ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git  Getting your Mac Ready  Installing Homebrew to ease installs on OS X   Do you have Homebrew? If not, open a terminal on your Mac and paste the following at a Terminal prompt. It will ask you for your sudo password.           $ ruby -e  $(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)   Alternatively, you can just extract (or  git clone ) Homebrew and install it to  /usr/local .  Installing Go    The directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:    src contains Go source files organized into packages (one package per directory),    pkg contains package objects, and    bin contains executable commands.    The GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory where you will soon clone the newt tool repository.            $ cd $HOME\n        $ mkdir -p dev/go  \n        $ cd dev/go\n        $ export GOPATH=`pwd`  Note that you need to add export statements to ~/.bash_profile to export variables permanently. Don't forget to source the file for the change to go into effect.          $ vi ~/.bash_profile\n        $ source ~/.bash_profile   Next you will use Homebrew to install Go. The summary message at the end of the installation should indicate that it is installed in the /usr/local/Cellar/go/ directory. You will use the Go command 'install' to compile and install packages (called eggs in the Mynewt world) and dependencies.            $ brew install go\n        ==  \n        ...\n        ... \n        ==  *Summary*\n        \ud83c\udf7a  /usr/local/Cellar/go/1.5.1: 5330 files, 273M  Alternatively, you can download the Go package directly from (https://golang.org/dl/) instead of brewing it. Install it in /usr/local directory.  Creating local repository   You are ready to download the newt tool repository. You will use Go to copy the directory (currently the asf incubator directory). Be patient as it may take a minute or two. Check the directories installed.           $ go get git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt\n        $ ls\n         bin    pkg    src\n        $ ls src\n        git-wip-us.apache.org   github.com      gopkg.in   Check that newt.go is in place.           $ ls $GOPATH/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt  \n        Godeps          README.md       coding_style.txt    newt.go\n        LICENSE         cli             design.txt  Building the Newt tool   You will use Go to run the newt.go program to build the newt tool. The command used is  go install  which compiles and writes the resulting executable to an output file named  newt . It installs the results along with its dependencies in $GOPATH/bin.           $ cd $GOPATH/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt\n        $ go install\n        $ ls  $GOPATH /bin/\n        godep       incubator-mynewt-newt.git     newt   Try running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.   Note: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to store the command in a variable in your .bash_profile. So type in  export newt=\"go run $GOPATH/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt/newt/go\"  in your .bash_profile and execute it by calling  $newt  at the prompt instead of  newt . Here, you use  go run  which runs the compiled binary directly without producing an executable. Don't forget to reload the updated bash profile by typing  source ~/.bash_profile  at the prompt!           $ newt version\n        Newt version:  1.0\n        $ newt -h\n        Newt allows you to create your own embedded project based on the Mynewt\n        operating system. Newt provides both build and package management in a\n        single tool, which allows you to compose an embedded workspace, and set\n        of projects, and then build the necessary artifacts from those projects.\n        For more information on the Mynewt operating system, please visit\n        https://www.github.com/mynewt/documentation.\n\n        Please use the newt help command, and specify the name of the command\n        you want help for, for help on how to use a specific command\n\n        Usage:\n         newt [flags]\n         newt [command]\n\n        Examples:\n         newt\n         newt help [ command-name ]\n           For help on  command-name .  If not specified, print this message.\n\n\n        Available Commands:\n         version     Display the Newt version number.\n         target      Set and view target information\n         egg         Commands to list and inspect eggs on a nest\n         nest        Commands to manage nests   clutches (remote egg repositories)\n         help        Help about any command\n\n        Flags:\n         -h, --help=false: help for newt\n         -l, --loglevel= WARN : Log level, defaults to WARN.\n         -q, --quiet=false: Be quiet; only display error output.\n         -s, --silent=false: Be silent; don't output anything.\n         -v, --verbose=false: Enable verbose output when executing commands.\n\n\n        Use  newt help [command]  for more information about a command.   Without creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool.    Getting the debugger ready   Before you start building nests and hatching eggs, you need to do one final step in the environment preparation - install gcc / libc that can produce 32-bit executables. So, first install gcc. You will see the brew steps and a final summary confirming install.           $ brew install gcc\n        ...\n        ...\n        ==  Summary\n        \ud83c\udf7a  /usr/local/Cellar/gcc/5.2.0: 1353 files, 248M   ARM maintains a pre-built GNU toolchain with a GCC source branch targeted at Embedded ARM Processors namely Cortex-R/Cortex-M processor families. Install the PX4 Toolchain and check the version installed. Make sure that the symbolic link installed by Homebrew points to the correct version of the debugger. If not, you can either change the symbolic link using the \"ln -f -s\" command or just go ahead and try with the version it points to!           $ brew tap PX4/homebrew-px4\n        $ brew update\n        $ brew install gcc-arm-none-eabi-49\n        $ arm-none-eabi-gcc --version  \n        arm-none-eabi-gcc (GNU Tools for ARM Embedded Processors) 4.9.3 20150529 (release) [ARM/embedded-4_9-branch revision 224288]\n        Copyright (C) 2014 Free Software Foundation, Inc.\n        This is free software; see the source for copying conditions.  There is NO\n        warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n        $ ls -al /usr/local/bin/arm-none-eabi-gdb\n        lrwxr-xr-x  1 aditihilbert  admin  69 Sep 22 17:16 /usr/local/bin/arm-none-eabi-gdb -  /usr/local/Cellar/gcc-arm-none-eabi-49/20150609/bin/arm-none-eabi-gdb  Note: If no version is specified, brew will install the latest version available. MynewtOS will eventually work with multiple versions available including the latest releases. However, at present we have tested only with this version and recommend it for getting started.    You have to install OpenOCD (Open On-Chip Debugger) which is an open-source software that will allow you to interface with the JTAG debug connector/adaptor for the Olimex board. It lets you program, debug, and test embedded target devices which, in this case, is the Olimex board. Use brew to install it. Brew adds a simlink /usr/local/bin/openocd to the openocd directory in the Cellar. For more on OpenOCD go to  http://openocd.org .           $ brew install open-ocd\n        $ which openocd\n        /usr/local/bin/openocd\n        $ ls -l $(which openocd)\n        lrwxr-xr-x  1  user   admin  36 Sep 17 16:22 /usr/local/bin/openocd -  ../Cellar/open-ocd/0.9.0/bin/openocd   Proceed to the  Building test code on simulator  section.   Getting your Ubuntu machine Ready  Installing some prerequisites   Install git, libcurl, and the Go language if you do not have them already.           $ sudo apt-get install git \n        $ sudo apt-get install libcurl4-gnutls-dev \n        $ sudo apt-get install golang   Creating local repository    The directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:    src contains Go source files organized into packages (one package per directory),    pkg contains package objects, and    bin contains executable commands.      The GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory where you will soon clone the newt tool repository.          $ cd $HOME\n        $ mkdir -p dev/go  \n        $ cd dev/go\n        $ export GOPATH=$PWD  Note that you need to add export statements to ~/.bashrc (or equivalent) to export variables permanently.   You are ready to download the newt tool repository. You will use Go to copy the directory (currently the asf incubator directory). Be patient as it may take a minute or two. Check the directories installed.           $ go get git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt\n        $ ls\n         bin    pkg    src\n        $ ls src\n        git-wip-us.apache.org   github.com      gopkg.in   Check that newt is in place.           $ ls $GOPATH/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt \n        Godeps          README.md       coding_style.txt    newt.go\n        LICENSE         cli             design.txt  Building the newt tool   You will use Go to run the newt.go program to build the newt tool. The command used is   go install  which compiles and writes the resulting executable to an output file named  newt . It installs the results along with its dependencies in $GOPATH/bin.           $ cd $GOPATH/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt\n        $ go install\n        $ ls  $GOPATH /bin/\n        godep       incubator-mynewt-newt.git     newt   Try running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.   Note: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to store the command in a variable in your .bash_profile. So type in  export newt=\"go run $GOPATH/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt/newt/go\"  in your ~/.bashrc (or equivalent) and execute it by calling  $newt  at the prompt instead of  newt . Here, you use  go run  which runs the compiled binary directly without producing an executable.             $ newt version\n        Newt version:  1.0\n        $ newt -h\n        Newt allows you to create your own embedded project based on the Mynewt\n        operating system. Newt provides both build and package management in a\n        single tool, which allows you to compose an embedded workspace, and set\n        of projects, and then build the necessary artifacts from those projects.\n        For more information on the Mynewt operating system, please visit\n        https://www.github.com/mynewt/documentation.\n\n        Please use the newt help command, and specify the name of the command\n        you want help for, for help on how to use a specific command\n\n        Usage:\n         newt [flags]\n         newt [command]\n\n        Examples:\n         newt\n         newt help [ command-name ]\n           For help on  command-name .  If not specified, print this message.\n\n\n        Available Commands:\n         version     Display the Newt version number.\n         target      Set and view target information\n         egg         Commands to list and inspect eggs on a nest\n         nest        Commands to manage nests   clutches (remote egg repositories)\n         help        Help about any command\n\n        Flags:\n         -h, --help=false: help for newt\n         -l, --loglevel= WARN : Log level, defaults to WARN.\n         -q, --quiet=false: Be quiet; only display error output.\n         -s, --silent=false: Be silent; don't output anything.\n         -v, --verbose=false: Enable verbose output when executing commands.\n\n\n        Use  newt help [command]  for more information about a command.   Without creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool.    Getting the debugger ready   Before you start building nests and hatching eggs, you need to do one final step in the environment preparation - install gcc / libc that can produce 32-bit executables. You can install these as follows:            $ sudo apt-get install gcc-multilib libc6-i386   For the LED project on the Olimex hardware, you have to install gcc for AM 4.9.3.  This package can be installed with apt-get as documented below. The steps are explained in depth at  https://launchpad.net/~terry.guo/+archive/ubuntu/gcc-arm-embedded .           $ sudo apt-get remove binutils-arm-none-eabi gcc-arm-none-eabi \n        $ sudo add-apt-repository ppa:terry.guo/gcc-arm-embedded \n        $ sudo apt-get update \n        $ sudo apt-get install gcc-arm-none-eabi    And finally, you have to install OpenOCD (Open On-Chip Debugger) which is an open-source software that will allow you to interface with the JTAG debug connector/adaptor for the Olimex board. It lets you program, debug, and test embedded target devices which, in this case, is the Olimex board. You have to acquire OpenOCD 0.8.0.   If you are running Ubuntu 15.x, then you are in luck and you can simply run:             $ sudo apt-get install openocd   Other versions of Ubuntu may not have the correct version of openocd available.  In this case, you should download the openocd 0.8.0 package from  https://launchpad.net/ubuntu/vivid/+source/openocd . The direct link to the amd64 build is  http://launchpadlibrarian.net/188260097/openocd_0.8.0-4_amd64.deb .    Proceed to the  Building test code on simulator  section.   Getting your Windows machine ready for simulated target  The  newt  tool is the build software used to build Mynewt OS images or executables for any embedded hardware device/board, including the one for the current tutorial (STM32-E407 development board from Olimex). You can run the  newt  tool natively on a computer running any of the three Operating System machines - OSX, Linux, or Windows.  However, Mynewt OS images for a simulated target are built on the Windows machine by using Linux versions of the build software (newt)in a virtual machine on your Windows box. The Linux VM is set up by installing the Docker Toolbox. Your Windows machine will communicate with the Linux VM via transient ssh connections. You will then download a Docker image ( newtvm.exe )that allows you to run the newt commands in the Linux Docker instance. The Docker image contains:   The newt command-line tool  Go  A multilib-capable native gcc / glibc  An arm-none-eabi gcc  Native gdb   The sequence of events when using the Docker image is as follows:   A new docker environment is created in the Linux VM.  The specified command with the newtvm prefix ( newtvm newt  command) is sent to the docker environment via ssh.  The Linux command runs.  The output from the command is sent back to Windows via ssh.  The output is displayed in the Windows command prompt.   Install Linux virtual machine    Download the Docker Toolbox for Windows (version 1.9.0c or later) from  https://www.docker.com/docker-toolbox . The Docker toolbox creates a consistently reproducible and self-contained environment in Linux.    Run the Docker Toolbox installer.  All the default settings are OK.    You may need to add \"C:\\Program Files\\Git\\usr\\bin\" to your PATH\nenvironment variable.  To add to the PATH environment variable, right-click on the Start button in the bottom left corner. Choose System -  Advanced system settings -  Environment Variables. Click on the PATH variable under \"System variables\" and click Edit to check and add it if it is not already there.     Install newtvm tool   From your base user (home) directory, pull or clone the latest code from the newt repository into the  newt  directory. It includes the executable  newtvm.exe  for the newtvm tool in the  newtvm  directory.         C:\\Users\\admin  git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-newt newt  The newtvm tool is what allows you to run programs in the Linux docker\ninstance.     Run the Docker Quickstart Terminal application inside the Docker folder under Programs. You can find it by clicking Start button -  All apps. By default, the Docker Toolbox installer creates a shortcut to this program on your desktop.  Wait until you see an ASCII art whale displayed in the terminal window and the Docker prompt given.                               ##         .\n                    ## ## ##        ==\n                 ## ## ## ## ##    ===\n             / \\___/ ===\n        ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~\n           \\______ o           __/\n             \\    \\         __/\n              \\____\\_______/\n\n         docker is configured to use the default machine with IP 192.168.99.100\n         For help getting started, check out the docs at https://docs.docker.com\n\n         admin@dev1 MINGW64 ~ (master)\n         $  The first time you run this, it may take several minutes to complete. You will need to run the Docker Quickstart Terminal once each time you\nrestart your computer.   Open a command prompt (e.g., Windows-R, \"cmd\", enter). You execute the newt tool commands as though you were running newt in Linux, but you prefix each command with \"newtvm\".  For example:           C:\\Users\\admin\\newt\\newtvm  newtvm newt help  The newtvm tool will take a long time to run the first time you execute\nit.  The delay is due to the fact that the tool must download the mynewt\ndocker instance.   You are now ready to proceed to  building the image for the simulated target .   Getting your Windows machine ready for hardware target  When you want to produce images for actual hardware board on your Windows machine, go through the following setup procedure and then proceed to the  blinky project on the Olimex board  with this method.  Installing some prerequisites    You have to install the following if you do not have them already.  The steps below indicate specific folders where each of these programs should be installed. You can choose different locations, but the remainder of this\ntutorial for a Windows machine assumes the specified folders.       win-builds-i686  win-builds-x86_64  MSYS  gcc for ARM  openocd  zadig  git   go   win-builds (mingw64) 1.5 for i686   Download from  http://win-builds.org/doku.php/download_and_installation_from_windows . Install at: \"C:\\win-builds-i686\".  Be sure to click the i686 option (not x86_64). The defaults for all other options are OK. The installer will want to download a bunch of additional packages. They are not all necessary, but it is simplest to just accept the defaults.   win-builds (mingw64) 1.5 for x86_64   Download from  http://win-builds.org/doku.php/download_and_installation_from_windows . Install at \"C:\\win-builds-x86_64\"  Run the installer a second time, but this time click the x86_64 option, NOT i686.  The defaults for all other options are OK.   MSYS   Start your download from  http://sourceforge.net/projects/mingw-w64/files/External%20binary%20packages%20%28Win64%20hosted%29/MSYS%20%2832-bit%29/MSYS-20111123.zip  Unzip to \"C:\\msys\"   gcc for ARM, 4.9.3   Download the Windows installer from  https://launchpad.net/gcc-arm-embedded/+download  and install at \"C:\\Program Files (x86)\\GNU Tools ARM Embedded\\4.9 2015q3\".   OpenOCD 0.8.0    Download OpenOCD 0.8.0 from  http://www.freddiechopin.info/en/download/category/4-openocd . Unzip to \"C:\\openocd\".   Zadig 2.1.2   Download it from  http://zadig.akeo.ie  and install it at \"C:\\zadig\".   Git   Click on  https://git-scm.com/download/win  to start the download. Install at \"C:\\Program Files (x86)\\Git\". Specify the \"Use Git from the Windows Command Prompt\" option.  The defaults for all other options are OK.   Go   Download the release for Microsoft Windows from  https://golang.org/dl/  and install it \"C:\\Go\".      Creating local repository    The directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:    src contains Go source files organized into packages (one package per directory),    pkg contains package objects, and    bin contains executable commands.    The GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory and then proceed to create the directory for cloning the newt tool repository.            $ cd c:\\\n        $ mkdir dev\\go\n        $ cd dev\\go   Set the following user environment variables using the steps outlined here.       * GOPATH: C:\\dev\\go\n    * PATH: C:\\Program Files (x86)\\GNU Tools ARM Embedded\\4.9 2015q3\\bin;%GOPATH%\\bin;C:\\win-builds-x86_64\\bin;C:\\win-builds-i686\\bin;C:\\msys\\bin  Steps:   Right-click the start button  Click \"Control panel\"  Click \"System and Security\"  Click \"System\"  Click \"Advanced system settings\" in the left panel  Click the \"Envoronment Variables...\" button  There will be two sets of environment variables: user variables\n      in the upper half of the screen, and system variables in the lower\n      half.  Configuring the user variables is recommended and tested \n      (though system variables will work as well).    Next, install godep. Note that the following command produces no output.           $ go get github.com/tools/godep    Set up the repository for the package building tool \"newt\" on your local machine. First create the appropriate directory for it and then clone the newt tool repository from the online apache repository (or its github.com mirror) into this newly created directory. Check the contents of the directory.           $ go get git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt\n        $ dir \n         bin    pkg    src\n        $ dir src\n        git-wip-us.apache.org   github.com      gopkg.in\n        $ dir\n        newt\n        $ cd newt\n        $ dir\n        Godeps                  README.md               coding_style.txt        newt.go\n        LICENSE                 cli                     design.txt   Check that newt is in place.           $ dir $GOPATH\\src\\git-wip-us.apache.org\\repos\\asf\\incubator-mynewt-newt.git\\newt \n        Godeps          README.md       coding_style.txt    newt.go\n        LICENSE         cli             design.txt  Building the newt tool   You will use Go to run the newt.go program to build the newt tool. The command used is   go install  which compiles and writes the resulting executable to an output file named  newt . It installs the results along with its dependencies in $GOPATH/bin.           $ go install\n        $ ls  $GOPATH /bin/\n        godep       incubator-mynewt-newt.git     newt   Try running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.   Note: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to define the newt environment variable that allows you to execute the command via  %newt% . Use  set newt=go run %GOPATH%\\src\\github.com\\mynewt\\newt\\newt.go  or set it from the GUI. Here, you use  go run  which runs the compiled binary directly without producing an executable.          $ newt version\n        Newt version:  1.0\n        $ newt -h\n        Newt allows you to create your own embedded project based on the Mynewt\n        operating system. Newt provides both build and package management in a\n        single tool, which allows you to compose an embedded workspace, and set\n        of projects, and then build the necessary artifacts from those projects.\n        For more information on the Mynewt operating system, please visit\n        https://www.github.com/mynewt/documentation.\n\n        Please use the newt help command, and specify the name of the command\n        you want help for, for help on how to use a specific command\n\n        Usage:\n         newt [flags]\n         newt [command]\n\n        Examples:\n         newt\n         newt help [ command-name ]\n           For help on  command-name .  If not specified, print this message.\n\n\n        Available Commands:\n         version     Display the Newt version number.\n         target      Set and view target information\n         egg         Commands to list and inspect eggs on a nest\n         nest        Commands to manage nests   clutches (remote egg repositories)\n         help        Help about any command\n\n        Flags:\n         -h, --help=false: help for newt\n         -l, --loglevel= WARN : Log level, defaults to WARN.\n         -q, --quiet=false: Be quiet; only display error output.\n         -s, --silent=false: Be silent; don't output anything.\n         -v, --verbose=false: Enable verbose output when executing commands.\n\n\n        Use  newt help [command]  for more information about a command.   Without creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool.    Getting the debugger ready   Use Zadig to configure the USB driver for your Olimex debugger.  If your debugger is already set up, you can skip this step.    Plug in your Olimex debugger.  Start Zadig.  Check the Options -  List All Devices checkbox.      Select \"Olimex OpenOCD JTAG ARM-USB-TINY-H\" in the dropdown menu.  Select the \"WinUSB\" driver.  Click the \"Install Driver\" button.    Proceed to the section on how to  make an LED blink  section.   Building test code on simulator  Note: On a Windows computer, the simulator can be run only in a Linux virtual environment. Make sure you have installed the Docker instance as outlined in  an earlier section . Consequently, all  newt  commands must be prefaced with  newtvm .    First, you have to create a repository for the project i.e. build your first nest! Go to ~/dev (or your base user directory on a Windows machine)and clone the larva repository from the apache git repository into a local directory named  larva .  Substitute DOS commands for Unix commands as necessary in the following steps if your machine is running Windows. The newt tool commands do not change.            $ cd ~/dev \n        $ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git larva\n        $ ls\n        go  larva\n        $ cd larva\n        $ ls\n        LICENSE     clutch.yml  hw      nest.yml      project\n        README.md   compiler    libs        net       scripts  On Windows, open a command prompt (e.g., Windows-R, \"cmd\", enter) and work from your home directory:          C:\\Users\\admin  git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git larva\n        C:\\Users\\admin  cd larva\n        C:\\Users\\admin\\larva  dir\n        Volume in drive C is Windows\n        Volume Serial Number is 4CBB-0920\n\n        Directory of C:\\Users\\admin\\larva\n\n         DIR           .\n         DIR           ..\n                    76 .gitignore\n                     0 .gitmodules\n                       .nest\n                 6,133 clutch.yml\n         DIR           compiler\n         DIR           hw\n         DIR           libs\n                11,560 LICENSE\n                    20 nest.yml\n         DIR           net\n         DIR           project\n                 2,263 README.md\n         DIR           scripts\n        6 File(s)         20,052 bytes\n        9 Dir(s)  90,723,442,688 bytes free  2.  You will now create a new target using the newt tool. You can either use the compiled binary  newt  or run the newt.go program using  $newt  (assuming you have stored the command in a variable in your .bash_profile or .bashrc). When you do a  newt target show  or  $newt target show  it should list all the projects you have created so far.           $ newt target create sim_test\n        Creating target sim_test\n        Target sim_test sucessfully created!\n        $ newt target show\n        sim_test\n            name: sim_test\n            arch: sim  Remember, on a Windows machine you will have to preface  newt  with  newtvm !          C:\\Users\\admin\\larva newtvm newt target create sim_test  3. Now continue to populate and build out the sim project.          $ newt target set sim_test project=test\n        Target sim_test successfully set project to test\n        $ newt target set sim_test compiler_def=debug\n        Target sim_test successfully set compiler_def to debug\n        $ newt target set sim_test bsp=hw/bsp/native\n        Target sim_test successfully set bsp to hw/bsp/native\n        $ newt target set sim_test compiler=sim\n        Target sim_test successfully set compiler to sim\n        $ newt target show sim_test\n        sim_test\n            arch: sim\n            project: test\n            compiler_def: debug\n            bsp: hw/bsp/native\n            compiler: sim\n            name: sim_test  Again remember to preface  newt  with  newtvm on a Windows machine as shown below. Continue to fill out all the project attributes.          C:\\Users\\admin\\larva newtvm newt target set sim_test project=test\n        Target sim_test successfully set project to test  4. Configure newt to use the gnu build tools native to OS X or linux. In order for sim to work properly, it needs to be using 32-bit gcc (gcc-5). Replace \n~/dev/larva/compiler/sim/compiler.yml with the compiler/sim/osx-compiler.yml or linux-compiler.yml file, depending on the system. On a Windows machine follow the instruction for the Linux machine as you are running commands in a Linux VM.  For a Mac OS X environment:          $ cp compiler/sim/osx-compiler.yml compiler/sim/compiler.yml   For a Linux machine:          $ cp compiler/sim/linux-compiler.yml compiler/sim/compiler.yml  5. Next, create (hatch!) the eggs for this project using the newt tool - basically, build the packages for it. You can specify the VERBOSE option if you want to see the gory details. Always remember to preface  newt  with  newtvm on a Windows machine.          $ newt target build sim_test\n        Successfully run!  You can specify the VERBOSE option if you want to see the gory details.          $newt -l VERBOSE target build sim_test\n        2015/09/29 09:46:12 [INFO] Building project test\n        2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//bootutil...\n        2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//cmsis-core...\n        2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//ffs..\n        ...\n        Successfully run!  6. Try running the test suite executable inside this project and enjoy your first successful hatch.          $ newt ./project/test/bin/sim_test/test.elf\n        [pass] os_mempool_test_suite/os_mempool_test_case\n        [pass] os_mutex_test_suite/os_mutex_test_basic\n        [pass] os_mutex_test_suite/os_mutex_test_case_1\n        [pass] os_mutex_test_suite/os_mutex_test_case_2\n        [pass] os_sem_test_suite/os_sem_test_basic\n        [pass] os_sem_test_suite/os_sem_test_case_1\n        [pass] os_sem_test_suite/os_sem_test_case_2\n        [pass] os_sem_test_suite/os_sem_test_case_3\n        [pass] os_sem_test_suite/os_sem_test_case_4\n        [pass] os_mbuf_test_suite/os_mbuf_test_case_1\n        [pass] os_mbuf_test_suite/os_mbuf_test_case_2\n        [pass] os_mbuf_test_suite/os_mbuf_test_case_3\n        [pass] gen_1_1/ffs_test_unlink\n        [pass] gen_1_1/ffs_test_rename\n        [pass] gen_1_1/ffs_test_truncate\n        [pass] gen_1_1/ffs_test_append\n        [pass] gen_1_1/ffs_test_read\n        [pass] gen_1_1/ffs_test_overwrite_one\n        [pass] gen_1_1/ffs_test_overwrite_two\n        [pass] gen_1_1/ffs_test_overwrite_three\n        ...\n        ...\n        [pass] boot_test_main/boot_test_vb_ns_11  Using SRAM to make LED blink  You are here because you want to build an image to be run from internal SRAM on the Olimex board.  Preparing the Software    Make sure the PATH environment variable includes the $HOME/dev/go/bin directory (or C:\\%GOPATH%\\bin on Windows machine).   Substitute DOS commands for Unix commands as necessary in the following steps if your machine is running Windows (e.g.  cd dev\\go  instead of  cd dev/go ). The newt tool commands do not change.    If you have cloned the larva repository for the simulator test in the previous section you can skip this step. Otherwise, you have to create a repository for the project i.e. build your first nest! Go to ~/dev and clone the larva repository from the apache git repository into a local directory named  larva .  Substitute DOS commands for Unix commands as necessary in the following steps if your machine is running Windows. The newt tool commands do not change.            $ cd ~/dev \n        $ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git larva\n        $ ls\n        go  larva\n        $ cd larva\n        $ ls\n        LICENSE     clutch.yml  hw      nest.yml      project\n        README.md   compiler    libs        net       scripts    You first have to create a repository for the project. Go to the ~dev/larva directory and build out a second project inside larva. The project name is \"blinky\", in keeping with the objective. Starting with the target name, you have to specify the different aspects of the project to pull the appropriate eggs and build the right package for the board. In this case that means setting the architecture (arch), compiler, board support package (bsp), project, and compiler mode.  Remember to prefix each command with \"newtvm\" if you are executing the newt command in a Linux virtual machine on your Windows box!            $ newt target create blinky\n        Creating target blinky\n        Target blinky sucessfully created!\n        $ newt target set blinky arch=cortex_m4\n        Target blinky successfully set arch to arm\n        $ newt target set blinky compiler=arm-none-eabi-m4\n        Target blinky successfully set compiler to arm-none-eabi-m4\n        $ newt target set blinky project=blinky\n        Target blinky successfully set project to blinky\n        $ newt target set blinky compiler_def=debug\n        Target blinky successfully set compiler_def to debug\n        $ newt target set blinky bsp=hw/bsp/olimex_stm32-e407_devboard\n        Target blinky successfully set bsp to hw/bsp/olimex_stm32-e407_devboard\n        $ newt target show blinky\n        blinky\n            compiler: arm-none-eabi-m4\n            project: blinky\n            compiler_def: debug\n            bsp: hw/bsp/olimex_stm32-e407_devboard\n            name: blinky\n            arch: cortex_m4    Now you have to build the image. The linker script within the  hw/bsp/olimex_stm32-e407_devboard  egg builds an image for flash memory by default. Since you want an image for the SRAM, you need to switch that script with  run_from_sram.ld  in order to get the egg to produce an image for SRAM.   We are working on making it easier to specify where the executable will be run from for a particular project and automatically choose the correct linker scripts and generate the appropriate image. It will be specified as a project identity e.g. bootloader, RAM, flash (default) and the target will build accordingly.  .   Once the target is built, you can find the executable \"blinky.elf\" in the project directory at ~/dev/larva/project/blinky/bin/blinky. It's a good idea to take a little time to understand the directory structure.            $ cd ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n        $ diff olimex_stm32-e407_devboard.ld run_from_sram.ld\n        $ cp run_from_sram.ld olimex_stm32-e407_devboard.ld\n        $ cd ~/dev/larva/project/blinky/bin/blinky\n        $ newt target build blinky\n        Building target blinky (project = blinky)\n        Compiling case.c\n        Compiling suite.c\n        ...\n        Successfully run!\n        $ ls\n        LICENSE     clutch.yml  hw      nest.yml    project\n        README.md   compiler    libs        net     scripts\n        $ cd project\n        $ ls\n        bin2img     bletest     blinky      boot        ffs2native  test\n        $ cd blinky\n        $ ls\n        bin     blinky.yml  egg.yml     src\n        $ cd bin\n        $ ls\n        blinky\n        $ cd blinky\n        $ ls\n        blinky.elf  blinky.elf.bin  blinky.elf.cmd  blinky.elf.lst  blinky.elf.map    Check that you have all the scripts needed to get OpenOCD up and talking with the project's specific hardware. Depending on your system (Ubuntu, Windows) you may already have the scripts in your  /usr/share/openocd/scripts/  directory as they may have been part of the openocd download. If yes, you are all set and can proceed to preparing the hardware.  Otherwise check the  ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard  directory for a file named  f407.cfg . That is the config we will use to talk to this specific hardware using OpenOCD. You are all set if you see it.            $ ls ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n        bin                 olimex_stm32-e407_devboard_debug.sh\n        boot-olimex_stm32-e407_devboard.ld  olimex_stm32-e407_devboard_download.sh\n        egg.yml                 run_from_flash.ld\n        f407.cfg                run_from_loader.ld\n        include                 run_from_sram.ld\n        olimex_stm32-e407_devboard.ld       src  Preparing the hardware to boot from embedded SRAM    Locate the boot jumpers on the board.     B1_1/B1_0 and B0_1/B0_0 are PTH jumpers which can be moved relatively easy. Note that the markings on the board may not always be accurate. Always refer to the manual for the correct positioning of jumpers in case of doubt. The two jumpers must always be moved together \u2013 they are responsible for the boot mode if bootloader is present. The board can search for bootloader on three places \u2013 User Flash Memory, System Memory or the Embedded SRAM. We will configure it to boot from SRAM by jumpering B0_1 and B1_1.    Connect USB-OTG#2 in the picture above to a USB port on your computer (or a powered USB hub to make sure there is enough power available to the board).     The red PWR LED should be lit.     Connect the JTAG connector to the SWD/JTAG interface on the board. The other end of the cable should be connected to the USB port or hub of your computer.    Let's Go!   Make sure you are in the blinky project directory with the blinky.elf executable. Run the debug command in the newt tool. You should see some status messages are shown below. There is an inbuilt  -c \"reset halt\"  flag that tells it to halt after opening the session.           $ cd dev/larva/project/blinky/bin/blinky\n        $ newt target debug blinky\n        Debugging with /Users/aditihilbert/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_debug.sh blinky\n        Debugging /Users/aditihilbert/dev/larva/project/blinky/bin/blinky/blinky.elf\n        GNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\n        Copyright (C) 2014 Free Software Foundation, Inc.\n        License GPLv3+: GNU GPL version 3 or later  http://gnu.org/licenses/gpl.html \n        This is free software: you are free to change and redistribute it.\n        There is NO WARRANTY, to the extent permitted by law.  Type  show copying \n        and  show warranty  for details.\n        This GDB was configured as  --host=x86_64-apple-darwin10 --target=arm-none-eabi .\n        Type  show configuration  for configuration details.\n        For bug reporting instructions, please see:\n         http://www.gnu.org/software/gdb/bugs/ .\n        Find the GDB manual and other documentation resources online at:\n         http://www.gnu.org/software/gdb/documentation/ .\n        For help, type  help .\n        Type  apropos word  to search for commands related to  word ...\n        Reading symbols from /Users/aditihilbert/dev/larva/project/blinky/bin/        blinky/blinky.elf...done.\n        Open On-Chip Debugger 0.8.0 (2015-09-22-18:21)\n        Licensed under GNU GPL v2\n        For bug reports, read\n            http://openocd.sourceforge.net/doc/doxygen/bugs.html\n        Info : only one transport option; autoselect 'jtag'\n        adapter speed: 1000 kHz\n        adapter_nsrst_delay: 100\n        jtag_ntrst_delay: 100\n        Warn : target name is deprecated use: 'cortex_m'\n        DEPRECATED! use 'cortex_m' not 'cortex_m3'\n        cortex_m reset_config sysresetreq\n        Info : clock speed 1000 kHz\n        Info : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\n        Info : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\n        Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints\n        Info : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\n        Info : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\n        target state: halted\n        target halted due to debug-request, current mode: Thread \n        xPSR: 0x01000000 pc: 0x20000250 msp: 0x10010000\n        Info : accepting 'gdb' connection from 3333\n        Info : device id = 0x10036413\n        Info : flash size = 1024kbytes\n        Reset_Handler () at startup_STM32F40x.s:199\n        199     ldr    r1, =__etext  Check the value of the msp (main service pointer) register. If it is not 0x10010000 as indicated above, you will have to manually set it after you open the gdp tool and load the image on it.           (gdb) set $msp=0x10010000  Now load the image and type \"c\" or \"continue\" from the GNU debugger.           (gdb) load ~/dev/larva/project/blinky/bin/blinky/blinky.elf\n        Loading section .text, size 0x4294 lma 0x20000000\n        Loading section .ARM.extab, size 0x24 lma 0x20004294\n        Loading section .ARM.exidx, size 0xd8 lma 0x200042b8\n        Loading section .data, size 0x874 lma 0x20004390\n        Start address 0x20000250, load size 19460\n        Transfer rate: 81 KB/sec, 2432 bytes/write.\n        (gdb) c\n        Continuing.   Voil\u00e0! The board's LED should be blinking at 1 Hz.   Using flash to make LED blink  You are here because you want to build an image to be run from flash memory on the Olimex board.   Configure the board to boot from flash by moving the two jumpers together to B0_0 and B1_0. Refer to the pictures of the board under the section titled  \"Preparing the hardware to boot from embedded SRAM\" .   You will have to reset the board once the image is uploaded to it.   If you skipped the first option for the project  (downloading an image to SRAM) , then skip this step. Otherwise, continue with this step.    By default, the linker script ( olimex_stm32-e407_devboard.ld ) is configured to run from bootloader and flash. However, if you first ran the image from SRAM you had changed  olimex_stm32-e407_devboard.ld  to match  run_from_sram.ld . You will therefore return to defaults with  olimex_stm32-e407_devboard.ld  linker script matching the contents of 'run_from_loader.ld'. Return to the project directory.          $ cd ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n        $ diff olimex_stm32-e407_devboard.ld run_from_sram.ld\n        $ diff olimex_stm32-e407_devboard.ld run_from_loader.ld\n        $ cp run_from_loader.ld olimex_stm32-e407_devboard.ld\n        $ cd ~/dev/larva/project/blinky/bin/blinky   In order to run the image from flash, you need to build the bootloader as well. The bootloader does the initial bring up of the Olimex board and then transfers control to the image stored at a location in flash known to it. The bootloader in turn requires the bin2image tool to check the image header for version information, CRC checks etc. So, we will need to build these two additional targets (bootloader and bin2img).   Let's first create bin2img:          $ newt target create bin2img\n        Creating target bin2img\n        Target bin2img successfully created!\n        $ newt target set bin2img arch=sim\n        Target bin2img successfully set arch to sim\n        $ newt target set bin2img compiler=sim\n        Target bin2img successfully set compiler to sim\n        $ newt target set bin2img project=bin2img\n        Target bin2img successfully set project to bin2img\n        $ newt target set bin2img compiler_def=debug\n        Target bin2img successfully set compiler_def to debug\n        $ newt target set bin2img bsp=hw/bsp/native\n        Target bin2img successfully set bsp to hw/bsp/native\n        $ newt target show bin2img\n        bin2img\n            arch: sim\n            compiler: sim\n            project: bin2img\n            compiler_def: debug\n            bsp: hw/bsp/native\n            name: bin2img  And then let's create boot_olimex:          $ newt target create boot_olimex\n        Creating target boot_olimex\n        Target boot_olimex successfully created!\n        $ newt target set boot_olimex arch=cortex_m4\n        Target boot_olimex successfully set arch to cortex_m4\n        $ newt target set boot_olimex compiler=arm-none-eabi-m4\n        Target boot_olimex successfully set compiler to arm-none-eabi-m4\n        $ newt target set boot_olimex project=boot\n        Target boot_olimex successfully set project to boot\n        $ newt target set boot_olimex compiler_def=optimized\n        Target boot_olimex successfully set compiler_def to optimized\n        $ newt target set boot_olimex bsp=hw/bsp/olimex_stm32-e407_devboard\n        Target boot_olimex successfully set bsp to hw/bsp/olimex_stm32-e407_devboard\n        $ newt target show boot_olimex\n        boot_olimex\n            project: boot\n            compiler_def: optimized\n            bsp: hw/bsp/olimex_stm32-e407_devboard\n            name: boot_olimex\n            arch: cortex_m4\n            compiler: arm-none-eabi-m4   Let's build all the three targets now.           $ newt target build bin2img\n        Building target bin2img (project = bin2img)\n        Building project bin2img\n        Successfully run!\n        $ newt target build boot_olimex\n        Building target boot_olimex (project = boot)\n        Building project boot\n        Successfully run!\n        $ newt target build blinky\n        Building target blinky (project = blinky)\n        Building project blinky\n        Successfully run!   Go to the project directory and download the bootloader and the image to flash ... in a flash!            $ cd ~/dev/larva/project/blinky/bin/blinky\n        $ newt target download boot_olimex\n        Downloading with ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_download.sh\n        $ newt target download blinky\n        Downloading with ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_download.sh    The LED should be blinking!    But wait...let's double check that it is indeed booting from flash and making the LED blink from the image in flash. Pull the USB cable off the Olimex JTAG adaptor. The debug connection to the JTAG port is now severed. Next power off the Olimex board by pulling out the USB cable from the board. Wait for a couple of seconds and plug the USB cable back to the board.     The LED light will start blinking again. Success!  Note #1: If you want to download the image to flash and a gdb session opened up, use  newt target debug blinky  instead of  newt target download blinky .          $ newt target debug blinky\n        Debugging with ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_debug.sh blinky\n        Debugging ~/dev/larva/project/blinky/bin/blinky/blinky.elf\n        GNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\n        Copyright (C) 2014 Free Software Foundation, Inc.\n        License GPLv3+: GNU GPL version 3 or later  http://gnu.org/licenses/gpl.html \n        This is free software: you are free to change and redistribute it.\n        There is NO WARRANTY, to the extent permitted by law.  Type  show copying \n        and  show warranty  for details.\n        This GDB was configured as  --host=x86_64-apple-darwin10 --target=arm-none-eabi .\n        Type  show configuration  for configuration details.\n        For bug reporting instructions, please see:\n         http://www.gnu.org/software/gdb/bugs/ .\n        Find the GDB manual and other documentation resources online at:\n         http://www.gnu.org/software/gdb/documentation/ .\n        For help, type  help .\n        Type  apropos word  to search for commands related to  word ...\n        Reading symbols from /Users/aditihilbert/dev/larva/project/blinky/bin/blinky/blinky.elf...done.\n        Open On-Chip Debugger 0.8.0 (2015-09-22-18:21)\n        Licensed under GNU GPL v2\n        For bug reports, read\n            http://openocd.sourceforge.net/doc/doxygen/bugs.html\n        Info : only one transport option; autoselect 'jtag'\n        adapter speed: 1000 kHz\n        adapter_nsrst_delay: 100\n        jtag_ntrst_delay: 100\n        Warn : target name is deprecated use: 'cortex_m'\n        DEPRECATED! use 'cortex_m' not 'cortex_m3'\n        cortex_m reset_config sysresetreq\n        Info : clock speed 1000 kHz\n        Info : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\n        Info : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\n        Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints\n        Info : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\n        Info : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\n        target state: halted\n        target halted due to debug-request, current mode: Thread \n        xPSR: 0x01000000 pc: 0x08000250 msp: 0x10010000\n        Info : accepting 'gdb' connection from 3333\n        Info : device id = 0x10036413\n        Info : flash size = 1024kbytes\n        Reset_Handler () at startup_STM32F40x.s:199\n        199     ldr    r1, =__etext\n        (gdb)  Note #2: If you want to erase the flash and load the image again you may use the following commands from within gdb.  flash erase_sector 0 0 x  tells it to erase sectors 0 through x. When you ask it to display (in hex notation) the contents of the sector starting at location 'lma' you should therefore see all f's. The memory location 0x8000000 is the start or origin of the flash memory contents and is specified in the olimex_stm32-e407_devboard.ld linker script. The flash memory locations is specific to the processor.          (gdb) monitor flash erase_sector 0 0 4\n        erased sectors 0 through 4 on flash bank 0 in 2.296712s\n        (gdb) monitor mdw 0x08000000 16\n        0x08000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \n        (0x08000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \n        (0x08000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \n        (0x08000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff         \n        (gdb) monitor flash info 0", 
            "title": "Blinky, the First Project"
        }, 
        {
            "location": "/get_started/how_to_edit_docs/", 
            "text": "How to Edit Docs\n\n\nObjective\n\n\nWe will go through the process of downloading existing doccumentation and adding some content to a test document.\n\n\nMarkdown, MkDocs, Mou\n\n\nThe Mynewt documentation you see on the Apache incubator website is a bunch of HTML files generated using MkDocs which is a simple static site generation tool geared towards building project documentation. You can read about it at \nhttp://www.mkdocs.org\n. Documentation source files are written in Markdown, and configured with a single YAML configuration file. Markdown is a lightweight markup language with plain text formatting syntax designed so that it can be converted to HTML and many other formats using a tool (which in our case is MkDocs).\n\n\nYou do not need to install MkDocs unless you want to actually render your documentation in HTML in order to preview it before pushing your content to the remote repository. Typically, using a Markdown editor such as \nMou\n is enough to check how it will look after the document has gone through MkDocs. Go ahead and download \nMou\n. If you are on a Windows machine, download the \neditor of your choice\n.\n\n\nCurrently someone in the project is designated to use MkDocs to generate the HTML pages periodically after changes have been reviewed and accepted into the master branch.\n\n\nAccess to the Apache repo\n\n\nGet an account on Apache. You do not need a committer account to view the website or clone the repository but you need it to push changes to it.\n\n\nIf you are not a committer, you may follow the proposed non-committer workflow to share your work. The direct link to the proposed workflow is \nhttps://git-wip-us.apache.org/docs/workflow.html\n. You will find the steps described in more detail later in this tutorial.\n\n\nMaking a local copy\n\n\n\n\nCopy the document source files into a local directory and look at the contents of the copied directory to get an idea of the directory structure. Use http instead of https if you are a non-committer.\n\n\n\n\n        $ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git\n        Cloning into 'incubator-mynewt-site'...\n        remote: Counting objects: 330, done.\n        remote: Compressing objects: 100% (263/263), done.\n        remote: Total 330 (delta 120), reused 0 (delta 0)\n        Receiving objects: 100% (330/330), 4.34 MiB | 830.00 KiB/s, done.\n        Resolving deltas: 100% (120/120), done.\n        Checking connectivity... done.\n        $ ls\n        incubator-mynewt-site\n        $ ls incubator-mynewt-site/\n        docs        images      mkdocs.yml\n\n\n\n\n\n\nCreate a new branch to work on your documentation and move to that branch.\n\n\n\n\n        $ git checkout -b \nyour-branch-name\n\n\n\n\n\nFile to be edited\n\n\nThe file you will edit is \ntry_markdown.md\n.\n\n\nEditing an existing page\n\n\n\n\n\n\nOpen the application Mou.\n\n\n\n\n\n\nOpen the file incubator-mynewt-site/docs/get_started/try_markdown.md in Mou.\n\n\n\n\n\n\nEdit the last item on the list.\n\n\n\n\n\n\nSave and quit the application.\n\n\n\n\n\n\nYou may want to review the documentation organization back in \nHome\n to remind you how to locate files easily. The corresponding directory tree structure is shown below.\n\n\n      .\n      \u251c\u2500\u2500 docs\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 get_started \n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 how_to_edit_docs.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 newt_concepts.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pics\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 bottomview.png\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 topview.png\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 project1.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 try_markdown.md\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 get_acclimated\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 project2.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 project3.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ... (more to be added)\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 vocabulary.md\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 newt\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 newt_ops.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 newt_tool_reference.md\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 os\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 context_switch.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 event_queue.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 heap.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 mbufs.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 memory_pool.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 mutex.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 mynewt_os.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 port_os.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 sanity.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 semaphore.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 task.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 time.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ... (more to be added)\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 modules\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 bootloader.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 console.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 filesystem.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 shell.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 testutil.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ... (more to be added)\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 packaging\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 dist.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ... (more to be added)\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 extra.css\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 images\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 egg-logo.png\n      \u2502\u00a0\u00a0 \u2514\u2500\u2500 index.md\n      \u251c\u2500\u2500 images\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 asf_logo_wide.gif\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 content-bg.png\n      \u2502\u00a0\u00a0 \u2514\u2500\u2500 egg-logo.png\n      \u251c\u2500\u2500 mkdocs.yml\n\n\n\n\nAdding a new page\n\n\nIf you create a new file somewhere in the \ndocs\n subdirectory to add a new page, you have to add a line in the \nmkdocs.yml\n file at the correct level. For example, if you add a new module named \"Ethernet\" by creating a new file named \nethernet.md\n in the \nmodules\n subdirectory, you have to insert the following line under \nModules:\n in the \nmkdocs.yml\n file.\n\n\n        - 'Ethernet': 'modules/ethernet.md'\n\n\n\n\nPushing changes to remote as a committer\n\n\nIf you are not a committer yet, skip this section and proceed to the \nnext section\n.\n\n\n\n\nCheck whether your remote git repository is set up. If you see the remote location as shown below you can skip the next step.\n\n\n\n\n        $ git remote -v\n        origin  https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git (fetch)\n        origin  https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git (push)\n\n\n\n\n\n\nIf, however, you do not see your remote repository, then set it up as follows.\n\n\n\n\n        $ git remote add origin https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git \n\n\n\n\n\n\nFirst check the git status. It will show you that the \ntry_markdown.md\n document has been modified. So you will stage a commit, and then commit the change. Finally, you will push the changes to the remote repository. \n\n\n\n\nDuring staging below using \ngit add\n, we use the \n-A\n option indicating you want to stage all your modifications. Instead, you can choose to specify only the files that you want to. The commit message (specified after \n-m\n) should summarize what your changes are about.\n\n\n        $ git status\n        $ git add -A \n        $ git commit -m \nMy first doc change as a trial run\n\n        $ git push -u origin \nyour-branch-name\n\n\n\n\n\n\n\n\n\nYou can see the changed Markdown file if you traverse the tree on the git repository \n https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git\n.\n\n\n\n\n\n\nA commit notification automatically goes out to the commits@mynewt.incubator.apache.org mailing list. The \"upstream\" manager pulls the notified changes, reviews it, and merges it to the master branch if all is well. Otherwise you get an email for further changes.\n\n\n\n\n\n\nSharing changes as a non-committer\n\n\nWe suggest you follow the proposed non-committer workflow at Apache to share your work. The direct link to the proposed workflow is \nhttps://git-wip-us.apache.org/docs/workflow.html\n. \n\n\n\n\nAssuming you have made changes to the example file, you will first commit your changes.\n\n\n\n\n        $ git add -A \n        $ git commit -m \nMy first doc change as a trial run\n\n\n\n\n\n\n\nOnce you're ready to share your changes with the rest of the project team, you can use the git format-patch command to produce a patch file (or a nice set of patches in the future):\n\n\n\n\n        $ git format-patch origin/trunk\n\n\n\n\n\n\nEmail the patch file to dev@mynewt.incubator.apache.org. Later on you may attach multiple files in your email to the mailing list as part of an existing thread or a new one. Remember to summarize the issue you have tackled and your work if the commit message is not detailed enough. \n\n\n\n\nIf there is a JIRA ticket associated with your work you should post your patch files to the ticket.\n\n\nConversion to HTML\n\n\nThe conversion of the Markdown files to HTML for the website happens manually and statically using MkDocs. You cannot see automatic and immediate rendering in HTML upon making a change in the Markdown file. You can choose to stop here and proceed to changing other Markdown files in your branch.\n\n\nLocal preview of HTML files\n\n\nHowever, you have the option to download MkDocs and do a local conversion yourself to preview the pages using the built-in devserver that comes with MkDocs. But first you will have to install MkDocs for that. In order to install MkDocs you'll need Python installed on your system, as well as the Python package manager, pip. You can check if you have them already (usually you will).\n\n\n        $ python --version\n        Python 2.7.2\n        $ pip --version\n        pip 1.5.2\n        $ pip install mkdocs\n\n\n\n\nYou will then run the built-in webserver from the root of the documentation directory using the command \nmkdocs serve\n. The root directory for documentation is \nincubator-mynewt-site\n or the directory with the \nmkdocs.yml\n file.\n\n\n        $ ls\n        docs        images      mkdocs.yml\n        $ mkdocs serve\n\n\n\n\nThen go to \nhttp://127.0.0.1:8000\n to preview your pages and see how they will look on the website! Remember that the Myself website itself will not be updated.\n\n\nFor more information on MkDocs go to \nhttp://www.mkdocs.org\n.", 
            "title": "How to edit docs"
        }, 
        {
            "location": "/get_started/how_to_edit_docs/#how-to-edit-docs", 
            "text": "Objective  We will go through the process of downloading existing doccumentation and adding some content to a test document.  Markdown, MkDocs, Mou  The Mynewt documentation you see on the Apache incubator website is a bunch of HTML files generated using MkDocs which is a simple static site generation tool geared towards building project documentation. You can read about it at  http://www.mkdocs.org . Documentation source files are written in Markdown, and configured with a single YAML configuration file. Markdown is a lightweight markup language with plain text formatting syntax designed so that it can be converted to HTML and many other formats using a tool (which in our case is MkDocs).  You do not need to install MkDocs unless you want to actually render your documentation in HTML in order to preview it before pushing your content to the remote repository. Typically, using a Markdown editor such as  Mou  is enough to check how it will look after the document has gone through MkDocs. Go ahead and download  Mou . If you are on a Windows machine, download the  editor of your choice .  Currently someone in the project is designated to use MkDocs to generate the HTML pages periodically after changes have been reviewed and accepted into the master branch.  Access to the Apache repo  Get an account on Apache. You do not need a committer account to view the website or clone the repository but you need it to push changes to it.  If you are not a committer, you may follow the proposed non-committer workflow to share your work. The direct link to the proposed workflow is  https://git-wip-us.apache.org/docs/workflow.html . You will find the steps described in more detail later in this tutorial.  Making a local copy   Copy the document source files into a local directory and look at the contents of the copied directory to get an idea of the directory structure. Use http instead of https if you are a non-committer.           $ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git\n        Cloning into 'incubator-mynewt-site'...\n        remote: Counting objects: 330, done.\n        remote: Compressing objects: 100% (263/263), done.\n        remote: Total 330 (delta 120), reused 0 (delta 0)\n        Receiving objects: 100% (330/330), 4.34 MiB | 830.00 KiB/s, done.\n        Resolving deltas: 100% (120/120), done.\n        Checking connectivity... done.\n        $ ls\n        incubator-mynewt-site\n        $ ls incubator-mynewt-site/\n        docs        images      mkdocs.yml   Create a new branch to work on your documentation and move to that branch.           $ git checkout -b  your-branch-name   File to be edited  The file you will edit is  try_markdown.md .  Editing an existing page    Open the application Mou.    Open the file incubator-mynewt-site/docs/get_started/try_markdown.md in Mou.    Edit the last item on the list.    Save and quit the application.    You may want to review the documentation organization back in  Home  to remind you how to locate files easily. The corresponding directory tree structure is shown below.        .\n      \u251c\u2500\u2500 docs\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 get_started \n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 how_to_edit_docs.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 newt_concepts.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pics\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 bottomview.png\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 topview.png\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 project1.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 try_markdown.md\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 get_acclimated\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 project2.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 project3.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ... (more to be added)\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 vocabulary.md\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 newt\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 newt_ops.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 newt_tool_reference.md\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 os\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 context_switch.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 event_queue.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 heap.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 mbufs.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 memory_pool.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 mutex.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 mynewt_os.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 port_os.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 sanity.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 semaphore.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 task.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 time.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ... (more to be added)\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 modules\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 bootloader.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 console.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 filesystem.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 shell.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 testutil.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ... (more to be added)\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 packaging\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 dist.md\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ... (more to be added)\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 extra.css\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 images\n      \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 egg-logo.png\n      \u2502\u00a0\u00a0 \u2514\u2500\u2500 index.md\n      \u251c\u2500\u2500 images\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 asf_logo_wide.gif\n      \u2502\u00a0\u00a0 \u251c\u2500\u2500 content-bg.png\n      \u2502\u00a0\u00a0 \u2514\u2500\u2500 egg-logo.png\n      \u251c\u2500\u2500 mkdocs.yml  Adding a new page  If you create a new file somewhere in the  docs  subdirectory to add a new page, you have to add a line in the  mkdocs.yml  file at the correct level. For example, if you add a new module named \"Ethernet\" by creating a new file named  ethernet.md  in the  modules  subdirectory, you have to insert the following line under  Modules:  in the  mkdocs.yml  file.          - 'Ethernet': 'modules/ethernet.md'  Pushing changes to remote as a committer  If you are not a committer yet, skip this section and proceed to the  next section .   Check whether your remote git repository is set up. If you see the remote location as shown below you can skip the next step.           $ git remote -v\n        origin  https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git (fetch)\n        origin  https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git (push)   If, however, you do not see your remote repository, then set it up as follows.           $ git remote add origin https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git    First check the git status. It will show you that the  try_markdown.md  document has been modified. So you will stage a commit, and then commit the change. Finally, you will push the changes to the remote repository.    During staging below using  git add , we use the  -A  option indicating you want to stage all your modifications. Instead, you can choose to specify only the files that you want to. The commit message (specified after  -m ) should summarize what your changes are about.          $ git status\n        $ git add -A \n        $ git commit -m  My first doc change as a trial run \n        $ git push -u origin  your-branch-name     You can see the changed Markdown file if you traverse the tree on the git repository   https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git .    A commit notification automatically goes out to the commits@mynewt.incubator.apache.org mailing list. The \"upstream\" manager pulls the notified changes, reviews it, and merges it to the master branch if all is well. Otherwise you get an email for further changes.    Sharing changes as a non-committer  We suggest you follow the proposed non-committer workflow at Apache to share your work. The direct link to the proposed workflow is  https://git-wip-us.apache.org/docs/workflow.html .    Assuming you have made changes to the example file, you will first commit your changes.           $ git add -A \n        $ git commit -m  My first doc change as a trial run    Once you're ready to share your changes with the rest of the project team, you can use the git format-patch command to produce a patch file (or a nice set of patches in the future):           $ git format-patch origin/trunk   Email the patch file to dev@mynewt.incubator.apache.org. Later on you may attach multiple files in your email to the mailing list as part of an existing thread or a new one. Remember to summarize the issue you have tackled and your work if the commit message is not detailed enough.    If there is a JIRA ticket associated with your work you should post your patch files to the ticket.  Conversion to HTML  The conversion of the Markdown files to HTML for the website happens manually and statically using MkDocs. You cannot see automatic and immediate rendering in HTML upon making a change in the Markdown file. You can choose to stop here and proceed to changing other Markdown files in your branch.  Local preview of HTML files  However, you have the option to download MkDocs and do a local conversion yourself to preview the pages using the built-in devserver that comes with MkDocs. But first you will have to install MkDocs for that. In order to install MkDocs you'll need Python installed on your system, as well as the Python package manager, pip. You can check if you have them already (usually you will).          $ python --version\n        Python 2.7.2\n        $ pip --version\n        pip 1.5.2\n        $ pip install mkdocs  You will then run the built-in webserver from the root of the documentation directory using the command  mkdocs serve . The root directory for documentation is  incubator-mynewt-site  or the directory with the  mkdocs.yml  file.          $ ls\n        docs        images      mkdocs.yml\n        $ mkdocs serve  Then go to  http://127.0.0.1:8000  to preview your pages and see how they will look on the website! Remember that the Myself website itself will not be updated.  For more information on MkDocs go to  http://www.mkdocs.org .", 
            "title": "How to Edit Docs"
        }, 
        {
            "location": "/get_started/try_markdown/", 
            "text": "Try Markdown\n\n\nHeading3\n\n\nHeading4\n\n\n\n\nList\n\n\n\n\n\n\nStart with one # for the largest heading (Heading1). The next smaller heading (Heading2) starts with ##. You can go all the way up to Heading 6 (######).\n\n\n\n\n\n\nHeading4 (####) and Heading5 (#####) has been styled to show up underlined. Yes, it can be changed. If you are curious, you can look at the extra.css file in your repo branch.\n\n\n\n\n\n\nIt's \nvery\n easy to do \nbold\n and \nitalics\n.\n\n\n\n\n\n\nSee how this list has been made using *\n\n\n\n\n\n\nClick on \"Help\" in Mou and then on \"Markdown Syntax Reference\".\n\n\n\n\n\n\n Substitute a sentence of your own here \n\n\n\n\n\n\n Guinea Pig!!! \n\n\n\n\n\n\n\n\n\n\n Note! \n\n\n\n\nYou will not be able to see the change immediately by refreshing your browser right after editign the Markdown file. You can only push the change to the Apache repository. So continue with the steps in \nhow_to_edit_docs.md\n.\n\n\nYou can see the change on the website if/when a doc builder on the project team merges your changes to the master branch and generates the pages for the website.\n\n\nYou do have the option to download MkDocs and preview the change by hosting the pages locally using its built-in web server. The steps are described in \nhow_to_edit_docs.md\n.", 
            "title": "Sample doc to edit"
        }, 
        {
            "location": "/get_started/try_markdown/#try-markdown", 
            "text": "Heading3  Heading4   List    Start with one # for the largest heading (Heading1). The next smaller heading (Heading2) starts with ##. You can go all the way up to Heading 6 (######).    Heading4 (####) and Heading5 (#####) has been styled to show up underlined. Yes, it can be changed. If you are curious, you can look at the extra.css file in your repo branch.    It's  very  easy to do  bold  and  italics .    See how this list has been made using *    Click on \"Help\" in Mou and then on \"Markdown Syntax Reference\".     Substitute a sentence of your own here      Guinea Pig!!!        Note!    You will not be able to see the change immediately by refreshing your browser right after editign the Markdown file. You can only push the change to the Apache repository. So continue with the steps in  how_to_edit_docs.md .  You can see the change on the website if/when a doc builder on the project team merges your changes to the master branch and generates the pages for the website.  You do have the option to download MkDocs and preview the change by hosting the pages locally using its built-in web server. The steps are described in  how_to_edit_docs.md .", 
            "title": "Try Markdown"
        }, 
        {
            "location": "/get_acclimated/vocabulary/", 
            "text": "Understanding Newt Terms\n\n\nNest\n\n\nThe nest is the base directory of your embedded software. It is meant to be the workspace containing a logical collection of the source code for one or more of your projects. A nest can contain multiple projects, and reflect multiple end products. \n\n\nAs the base repository of your source code, the nest has a master branch and several other branches off it. You may choose any branch to nest on. Each project in your nest will typically consist of several \neggs\n. A project could be an egg itself as well. In addition to eggs, a local nest will contain additional items such as \ntarget\n or build definitions, clutch description files, scripts etc.\n\n\nFor example, a walk through the \"larva\" nest at \nhttps://github.com/mynewt/larva.git\n shows the following structure. The nest.yml file in the larva directory indicates that it is a nest. An egg will have the egg.yml file in it as shown below. By this nomenclature, each board support package for a particular chip is an egg, the API for the hardware abstraction layer is an egg, and so on. \n\n\nlarva\n  |- nest.yml \n  |- compiler\n        |- arm-none-eabi-m4\n        |- sim\n  |- hw (hardware)\n        |- bsp (board support package)\n                |- nrf52pdk (Nordic nRF52 series chip)\n                        |- egg.yml\n                        |- ...\n                |- olimex_stm32-e407_devboard (used in Project Blinky)\n                        |- egg.yml\n                        |- ...\n                |- stm32f3discovery (another board with stm32f3 mcu)\n                        |- egg.yml\n                        |- ...\n                |- yet another board\n                        |- egg.yml\n                        |- ...\n        |- hal (hardware abstraction layer APIs)\n                |- egg.yml\n                |- include\n                        |- hal_cputime.h\n                        |- hal_flash.h\n                        |- hal_gpio.h\n                        |- ... (header files for other peripherals)\n        |- mcu (microcontroller)\n                |- stm (STMicro family)\n                    |- stm32f3xx (STM32f3 series, 32-bit ARM Cortex-M4  core)\n                        |- egg.yml\n                        |- src\n                            |- hal_gpio.c (specific to the STM32f3 mcu)\n                            |- hal_cputime.c\n                            |- ... (code for other peripherals)\n                |- nordic (Nordic Semiconductor family)\n                    |- nrf52xxx (nRF52 Series SoC, Cortex-M4F core)\n                        |- egg.yml\n                        |- src\n                            |- hal_gpio.c (specific to the nRF52 mcu )\n                            |- hal_cputime.c\n                            |- ... (code for other peripherals)\n                |- yet another family of mcu\n                    |- ...\n  |- libs\n        |- bootutil (hw architecture independent boot loader library)\n                |- egg.yml\n                |- src\n                    |- loader.c\n                    |- ... (related source code files)\n        |- nffs (hw architecture independent Newtron Flash File System)\n                |- egg.yml\n                |- src\n                    |- nffs.c\n                    |- ... (related source code files)\n        |- another library \n                |- egg.yml\n                |- src\n                    |- ... (related source code files)\n  |- project\n  |- scripts\n\n\n\n\n\n\nThe newt tool offers the \nnest\n command to create and manage nests. In general, commands represent actions and flags are modifiers for those actions. A command can have children commands and optionally run an action. A full description of the \nnest\n command can be found in the newt tool reference in Chapter 3.\n\n\n    newt nest [flags]\n    newt nest [child-commands] \n\n\n\n\nA complete list of all the nest commands can be found in the newt tool reference in \nNewt Tool\n.\n\n\nProject\n\n\nProjects represent the individual build configurations of your embedded system and essentially defines your application. The project files are what dictate the resulting binary that is generated. \n\n\nLayout-wise, a project is a directory inside a nest and contains eggs required for a certain application. For example, the \nblinky\n egg sits in \nproject/blinky\n directory of the \nlarva\n nest. This egg is used in the blinky project (application) outlined in \nGet Started\n. \nNote: This Will Change\n\n\nA project has the following concepts or properties associated with it. You can find them in the \nproject-name\n.yml\n file in the project directory. For example, the \nproject/blinky\n directory has the \nblinky.yml\n file indicating some or all of the properties below. Only the name of a project is required for the project to exist, however additional properties may need to be specified for the eggs in it to compile properly and produce an executable. \n\n\n\n\nProject name\n\n\nBase path of the project (nest/project/project-name by default)\n\n\nEggs belonging to the project\n\n\nCapabilities\n that are required for the project or target \n\n\nIdentity\n to classify the type of project or target\n\n\nCompiler flags to call out any specific compiler requirement\n\n\n\n\nA project could itself be an egg if it is a distributable package for a specific application. \n\n\nThe newt tool offers various commands that you can use with a project. For example, if your project is an egg, you can use the following command to install a project from a nest.\n\n\n    newt egg install [flags] \nproject egg name\n\n\n\n\n\nEgg\n\n\nAn egg is a distributable package of libraries. Just as an egg in nature has various parts each of which serves a certain purpose, the Mynewt egg consists of software parcels or modules that have different functions. However, unlike the egg in nature these software modules can exist by itself and may be distributed; therefore, they too are essentially eggs. Once this concept is grasped it is easy to see how an egg may consist of other eggs.\n\n\nThe two main directories in an egg are \n/include\n and \n/src\n.\n\n\nThe newt tool offers several egg commands to list, inspect, install, and do other operations on eggs. For example, the following command\n\n\n    newt egg list \n\n\n\n\noutputs all the eggs in the current nest where each egg has details on its version, path, and dependencies. A sample output for an egg is given below.\n\n\n    Egg libs/os, version 0.1.0\n    path: /Users/aditihilbert/dev/test_project/libs/os\n    deps: libs/testutil@none#stable \n\n\n\n\nA complete list of all the egg commands can be found in the newt tool reference in \nNewt Tool\n.\n\n\nClutch\n\n\nA clutch is a snapshot of all eggs in a remote nest at any point in time. On any given github branch, a nest with a clutch of eggs will contain a \nclutch.yml\n file that specifies the version number, dependencies, and hash value for each constituent egg as well as the name of the entire clutch and the github url for it. [Note: Currently ]\n\n\nYou may download multiple clutches into your local nest as long as the names of the clutches are different. This allows you to mix and match various features and functionality coming from different clutches of eggs. You can see all the clutches in the \n.nest/clutches\n directory in your nest.\n\n\nThe newt tool offers clutch management commands within the \nnewt nest\n command. For example, the following command creates a new clutch using all the eggs in the current directory. It requires that a clutch name be specified and the url for the location of that clutch in the online repository. These two inputs go into the \nclutch.yml\n file in the nest.\n\n\n    newt nest generate-clutch \nname\n \nurl\n\n\n\n\n\nNote that a clutch merely defines the eggs belonging together and requires the eggs to be installed (hatched) for the source code to be populated in the project. \n\n\nEggshell\n\n\nThe term eggshell is used to refer to the eggs of a clutch in a remote repository. They are not useful on your local machine until you actually install them. So they are mere shells of themselves while sitting on the online repository. When you enter the following command outputs the total number of shells in each remote clutch.\n\n\n    newt nest list-clutches\n\n\n\n\nSo, if you had two clutches installed, the output could be:\n\n\n    Remote clutch larva (eggshells: 19)\n    Remote clutch ble_test (eggshells: 15)\n\n\n\n\nTarget\n\n\nA target is the hardware build or its software equivalent (e.g. test, simulator) set for a project. It tells the newt tool how to build the source code within a given nest. Once a new target is created, its architecture and other details needs to be defined. An example of a defined target named \"blink_f3disc\" is given below.\n\n\n    blink_f3disc\n             compiler_def: debug\n             compiler: arm-none-eabi-m4\n             name: blink_f3disc\n             arch: cortex_m4\n             project: blinky\n             bsp: hw/bsp/stm32f3discovery\n\n\n\n\nThe newt tool offers commands to create, set up and manipulate targets. For example, the create command below creates an empty target named \nmy_target1\n and the set command sets one detail of its definition, namely the architecture.\n\n\n    newt target create my_target1\n    newt target set my_target1 arch=cortex_m4\n\n\n\n\nCapability\n\n\nCapability is functionality that is exposed by an egg. A capability is tracked by its name and version. An egg may require capabilities exposed by another egg, thus establishing a dependency tracked through the egg.yml files. \n\n\nThe newt tool can ascertain a map of all the egg capabilities and use it to check dependencies and make sure all the necessary eggs are in a project for a particular target.\n\n\nIdentity\n\n\nIdentity is a property of a target or project in the newt world. A target may inherit it from a project or vice versa. It may be used to determine what eggs to include or how an egg code should behave in a build or which linkerscripts to use. For example, the identity of a lock is different from the identity of a wearable monitor. Even if they were to be built on the same hardware target, different features and behavior are required. Their different identities result in differing sets of eggs in the projects and/or the same egg behaving differently depending on the identity.", 
            "title": "Understanding Newt Terms"
        }, 
        {
            "location": "/get_acclimated/vocabulary/#understanding-newt-terms", 
            "text": "Nest  The nest is the base directory of your embedded software. It is meant to be the workspace containing a logical collection of the source code for one or more of your projects. A nest can contain multiple projects, and reflect multiple end products.   As the base repository of your source code, the nest has a master branch and several other branches off it. You may choose any branch to nest on. Each project in your nest will typically consist of several  eggs . A project could be an egg itself as well. In addition to eggs, a local nest will contain additional items such as  target  or build definitions, clutch description files, scripts etc.  For example, a walk through the \"larva\" nest at  https://github.com/mynewt/larva.git  shows the following structure. The nest.yml file in the larva directory indicates that it is a nest. An egg will have the egg.yml file in it as shown below. By this nomenclature, each board support package for a particular chip is an egg, the API for the hardware abstraction layer is an egg, and so on.   larva\n  |- nest.yml \n  |- compiler\n        |- arm-none-eabi-m4\n        |- sim\n  |- hw (hardware)\n        |- bsp (board support package)\n                |- nrf52pdk (Nordic nRF52 series chip)\n                        |- egg.yml\n                        |- ...\n                |- olimex_stm32-e407_devboard (used in Project Blinky)\n                        |- egg.yml\n                        |- ...\n                |- stm32f3discovery (another board with stm32f3 mcu)\n                        |- egg.yml\n                        |- ...\n                |- yet another board\n                        |- egg.yml\n                        |- ...\n        |- hal (hardware abstraction layer APIs)\n                |- egg.yml\n                |- include\n                        |- hal_cputime.h\n                        |- hal_flash.h\n                        |- hal_gpio.h\n                        |- ... (header files for other peripherals)\n        |- mcu (microcontroller)\n                |- stm (STMicro family)\n                    |- stm32f3xx (STM32f3 series, 32-bit ARM Cortex-M4  core)\n                        |- egg.yml\n                        |- src\n                            |- hal_gpio.c (specific to the STM32f3 mcu)\n                            |- hal_cputime.c\n                            |- ... (code for other peripherals)\n                |- nordic (Nordic Semiconductor family)\n                    |- nrf52xxx (nRF52 Series SoC, Cortex-M4F core)\n                        |- egg.yml\n                        |- src\n                            |- hal_gpio.c (specific to the nRF52 mcu )\n                            |- hal_cputime.c\n                            |- ... (code for other peripherals)\n                |- yet another family of mcu\n                    |- ...\n  |- libs\n        |- bootutil (hw architecture independent boot loader library)\n                |- egg.yml\n                |- src\n                    |- loader.c\n                    |- ... (related source code files)\n        |- nffs (hw architecture independent Newtron Flash File System)\n                |- egg.yml\n                |- src\n                    |- nffs.c\n                    |- ... (related source code files)\n        |- another library \n                |- egg.yml\n                |- src\n                    |- ... (related source code files)\n  |- project\n  |- scripts  The newt tool offers the  nest  command to create and manage nests. In general, commands represent actions and flags are modifiers for those actions. A command can have children commands and optionally run an action. A full description of the  nest  command can be found in the newt tool reference in Chapter 3.      newt nest [flags]\n    newt nest [child-commands]   A complete list of all the nest commands can be found in the newt tool reference in  Newt Tool .  Project  Projects represent the individual build configurations of your embedded system and essentially defines your application. The project files are what dictate the resulting binary that is generated.   Layout-wise, a project is a directory inside a nest and contains eggs required for a certain application. For example, the  blinky  egg sits in  project/blinky  directory of the  larva  nest. This egg is used in the blinky project (application) outlined in  Get Started .  Note: This Will Change  A project has the following concepts or properties associated with it. You can find them in the  project-name .yml  file in the project directory. For example, the  project/blinky  directory has the  blinky.yml  file indicating some or all of the properties below. Only the name of a project is required for the project to exist, however additional properties may need to be specified for the eggs in it to compile properly and produce an executable.    Project name  Base path of the project (nest/project/project-name by default)  Eggs belonging to the project  Capabilities  that are required for the project or target   Identity  to classify the type of project or target  Compiler flags to call out any specific compiler requirement   A project could itself be an egg if it is a distributable package for a specific application.   The newt tool offers various commands that you can use with a project. For example, if your project is an egg, you can use the following command to install a project from a nest.      newt egg install [flags]  project egg name   Egg  An egg is a distributable package of libraries. Just as an egg in nature has various parts each of which serves a certain purpose, the Mynewt egg consists of software parcels or modules that have different functions. However, unlike the egg in nature these software modules can exist by itself and may be distributed; therefore, they too are essentially eggs. Once this concept is grasped it is easy to see how an egg may consist of other eggs.  The two main directories in an egg are  /include  and  /src .  The newt tool offers several egg commands to list, inspect, install, and do other operations on eggs. For example, the following command      newt egg list   outputs all the eggs in the current nest where each egg has details on its version, path, and dependencies. A sample output for an egg is given below.      Egg libs/os, version 0.1.0\n    path: /Users/aditihilbert/dev/test_project/libs/os\n    deps: libs/testutil@none#stable   A complete list of all the egg commands can be found in the newt tool reference in  Newt Tool .  Clutch  A clutch is a snapshot of all eggs in a remote nest at any point in time. On any given github branch, a nest with a clutch of eggs will contain a  clutch.yml  file that specifies the version number, dependencies, and hash value for each constituent egg as well as the name of the entire clutch and the github url for it. [Note: Currently ]  You may download multiple clutches into your local nest as long as the names of the clutches are different. This allows you to mix and match various features and functionality coming from different clutches of eggs. You can see all the clutches in the  .nest/clutches  directory in your nest.  The newt tool offers clutch management commands within the  newt nest  command. For example, the following command creates a new clutch using all the eggs in the current directory. It requires that a clutch name be specified and the url for the location of that clutch in the online repository. These two inputs go into the  clutch.yml  file in the nest.      newt nest generate-clutch  name   url   Note that a clutch merely defines the eggs belonging together and requires the eggs to be installed (hatched) for the source code to be populated in the project.   Eggshell  The term eggshell is used to refer to the eggs of a clutch in a remote repository. They are not useful on your local machine until you actually install them. So they are mere shells of themselves while sitting on the online repository. When you enter the following command outputs the total number of shells in each remote clutch.      newt nest list-clutches  So, if you had two clutches installed, the output could be:      Remote clutch larva (eggshells: 19)\n    Remote clutch ble_test (eggshells: 15)  Target  A target is the hardware build or its software equivalent (e.g. test, simulator) set for a project. It tells the newt tool how to build the source code within a given nest. Once a new target is created, its architecture and other details needs to be defined. An example of a defined target named \"blink_f3disc\" is given below.      blink_f3disc\n             compiler_def: debug\n             compiler: arm-none-eabi-m4\n             name: blink_f3disc\n             arch: cortex_m4\n             project: blinky\n             bsp: hw/bsp/stm32f3discovery  The newt tool offers commands to create, set up and manipulate targets. For example, the create command below creates an empty target named  my_target1  and the set command sets one detail of its definition, namely the architecture.      newt target create my_target1\n    newt target set my_target1 arch=cortex_m4  Capability  Capability is functionality that is exposed by an egg. A capability is tracked by its name and version. An egg may require capabilities exposed by another egg, thus establishing a dependency tracked through the egg.yml files.   The newt tool can ascertain a map of all the egg capabilities and use it to check dependencies and make sure all the necessary eggs are in a project for a particular target.  Identity  Identity is a property of a target or project in the newt world. A target may inherit it from a project or vice versa. It may be used to determine what eggs to include or how an egg code should behave in a build or which linkerscripts to use. For example, the identity of a lock is different from the identity of a wearable monitor. Even if they were to be built on the same hardware target, different features and behavior are required. Their different identities result in differing sets of eggs in the projects and/or the same egg behaving differently depending on the identity.", 
            "title": "Understanding Newt Terms"
        }, 
        {
            "location": "/get_acclimated/project2/", 
            "text": "Project 2 - Blinky on additional boards\n\n\nObjective\n\n\nThe goal of this tutorial is to download a generic firmware skeleton (\"bootstrap image\") that applies to any hardware and then throw in additional applicable eggs to generate a build for a specific board. In the process you will be exposed to more Mynewt terms and Newt tool commands.\n\n\nThe following target hardware chips are covered:\n\n\n\n\nSTM32F303VC MCU\n from STMicroelectronics\n\n\nnRF52 Series\n from Nordic Semiconductors \n\n\n\n\nSTM32F303VC MCU\n\n\nHardware needed\n\n\n\n\nDiscovery kit with STM32F303VC MCU\n\n\nLaptop running Mac OS\n\n\n\n\nStep by Step Instructions to build image\n\n\n\n\nThe first step is to download the generic skeleton of the project. The eggs constituting the skeleton are not hardware architecture specific. The skeleton is maintained as a nest in a separate repository on Apache. You know it is a nest because there is a nest.yml file. \n\n\n\n\n        [user:~/dev]$ newt nest create test_project\n        Downloading nest skeleton from https://git-wip-us.apache.org/repos/asf/incubator-mynewt-tadpole.git... ok!\n        Nest test_project successfully created in ~/dev/go/test_project\n\n        [user:~/dev]$ cd test_project/\n        [user:~/dev/test_project]$ ls\n        README.md   compiler    hw      libs    nest.yml\n\n\n\n\n\n\nNext, the clutch of eggs named larva is added from the nest (also named larva) from another repository on Apache. This step simply downloads the clutch description file and does not actually install the eggs that constitute the clutch. The clutch description file (\nclutch.yml\n) will be used to check dependencies during the egg install to ensure completeness. It serves as a reference for all the eggs in the clutch that one can choose from and install.\n\n\n\n\n        [user:~/dev/test_project]$ newt nest add-clutch larva https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git\n        Downloading clutch.yml from https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git/master... ok!\n        Verifying clutch.yml format...\n        ok!\n        Clutch larva successfully installed to Nest.\n\n\n\n\n\n\nThe next step is to install relevant eggs from the larva nest on github. The instructions assume that you know what application or project you are interested in (the blinky application, in this case), what hardware you are using (STM32F3DISCOVERY board, in this case) and hence, what board support package you need. \n\n\n\n\n\n        [user:~/dev/test_project]$ newt egg install project/blinky          \n        Downloading larva from https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva/master... ok!\n        Installing project/blinky\n        Installing libs/console/full\n        Installing libs/shell\n        Installation was a success!\n\n        [user:~/dev/test_project]$ newt egg install hw/bsp/stm32f3discovery\n        Downloading larva from https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva/master... ok!\n        Installing hw/bsp/stm32f3discovery\n        Installing hw/mcu/stm/stm32f3xx\n        Installing libs/cmsis-core\n        Installing compiler/arm-none-eabi-m4\n        Installation was a success!\n\n\n\n\n\n\nIt's time to create a target for the project and define the target attributes. \n\n\n\n\n        [user:~/dev/test_project]$ newt target create blink_f3disc\n        Creating target blink_f3disc\n        Target blink_f3disc successfully created!\n\n        [user:~/dev/test_project]$ newt target set blink_f3disc project=blinky\n        Target blink_f3disc successfully set project to blinky\n\n        [user:~/dev/test_project]$ newt target set blink_f3disc bsp=hw/bsp/stm32f3discovery\n        Target blink_f3disc successfully set bsp to hw/bsp/stm32f3discovery\n\n        [user:~/dev/test_project]$ newt target set blink_f3disc compiler_def=debug\n        Target blink_f3disc successfully set compiler_def to debug\n\n        [user:~/dev/test_project]$ newt target set blink_f3disc compiler=arm-none-eabi-m4\n        Target blink_f3disc successfully set compiler to arm-none-eabi-m4\n\n        [user:~/dev/test_project]$ newt target set blink_f3disc arch=cortex_m4\n        Target blink_f3disc successfully set arch to cortex_m4\n\n        [user:~/dev/test_project]$ newt target show blink_f3disc\n        blink_f3disc\n            arch: cortex_m4\n            project: blinky\n            bsp: hw/bsp/stm32f3discovery\n            compiler_def: debug\n            compiler: arm-none-eabi-m4\n            name: blink_f3disc\n\n\n\n\n\n\n\n\nNext, you get to build the target and generate an executable that can then be uploaded to the board. The STM32F3DISCOVERY board includes an ST-LINK/V2 embedded debug tool interface that will be used to program/debug the board. To program the MCU on the board, simply plug in the two jumpers on CN4, as shown in the picture in red. If you want to learn more about the board you will find the User Manual at \nhttp://www.st.com/st-web-ui/static/active/jp/resource/technical/document/user_manual/DM00063382.pdf\n\n\n\n\n\n\n\n\n\n\n\n\n        [user:~/dev/test_project]$ newt target build blink_f3disc\n        Building target blink_f3disc (project = blinky)\n        Compiling case.c\n        Compiling suite.c\n        Compiling testutil.c\n        Compiling testutil_arch_arm.c\n        Archiving libtestutil.a\n        Compiling os.c\n        Compiling os_callout.c\n        Compiling os_eventq.c\n        Compiling os_heap.c\n        Compiling os_mbuf.c\n        Compiling os_mempool.c\n        Compiling os_mutex.c\n        Compiling os_sanity.c\n        Compiling os_sched.c\n        Compiling os_sem.c\n        Compiling os_task.c\n        Compiling os_time.c\n        Compiling os_arch_arm.c\n        Assembling HAL_CM4.s\n        Assembling SVC_Table.s\n        Archiving libos.a\n        Compiling hal_gpio.c\n        Compiling stm32f3xx_hal_gpio.c\n        Archiving libstm32f3xx.a\n        Compiling cmsis_nvic.c\n        Compiling libc_stubs.c\n        Compiling os_bsp.c\n        Compiling sbrk.c\n        Compiling system_stm32f3xx.c\n        Assembling startup_stm32f303xc.s\n        Archiving libstm32f3discovery.a\n        Compiling main.c\n        Building project blinky\n        Linking blinky.elf\n        Successfully run!\n\n\n\n\n\n\nFinally, you have to download the image on to the board. You will see a blue light start to blink.\n\n\n\n\n        [user:~/dev/test_project]$ newt target download blink_f3disc\n        Downloading with /Users/user/dev/test_project/hw/bsp/stm32f3discovery/stm32f3discovery_download.sh\n\n\n\n\nnRF52 Series\n\n\nHardware needed\n\n\n\n\nnRF52 Development Kit\n\n\nLaptop running Mac OS\n\n\n\n\nStep by Step Instructions to build image\n\n\n\n\nThe first step is to download the generic skeleton of the project. The eggs installed are not hardware architecture specific.\n\n\n\n\n        []user@~/dev]$ newt nest create nordic_blinky\n        Downloading nest skeleton from https://www.github.com/mynewt/tadpole... ok!\n        Nest nordic_blinky successfully created in ~dev/nordic_blinky\n\n        user@~/dev$ cd nordic_blinky/\n\n\n\n\n\n\nThen, the clutch of eggs named larva is added from the nest (also named larva) on the github. This step simply downloads the clutch description file and does not actually install the eggs that constitute the clutch. The clutch description file (\nclutch.yml\n) will be used to check dependencies during the egg install to ensure completeness. It serves as a reference for all the eggs in the clutch that one can choose from and install.\n\n\n\n\n        []user@~/dev/nordic_blinky]$ newt nest add-clutch larva https://github.com/mynewt/larva\n        Downloading clutch.yml from https://github.com/mynewt/larva/master... ok!\n        Verifying clutch.yml format...ok!\n        Clutch larva successfully installed to Nest.\n\n\n\n\n\n\nThe next step is to install relevant eggs from the larva nest on github. The instructions assume that you know what application or project you are interested in (the blinky application, in this case), what hardware you are using (STM32F3DISCOVERY board, in this case) and hence, what board support package you need. \n\n\n\n\n        [user@~/dev/nordic_blinky]$ newt egg install project/blinky \n        Downloading larva from https://github.com/mynewt/larva//master... ok!\n        Installing project/blinky\n        Installation was a success!\n\n\n        [user@~/dev/nordic_blinky]$ newt egg install hw/bsp/nrf52pdk\n        Downloading larva from https://github.com/mynewt/larva//master... ok!\n        Installing hw/bsp/nrf52pdk\n        Installing hw/mcu/nordic/nrf52xxx\n        Installing libs/cmsis-core\n        Installing compiler/arm-none-eabi-m4\n        Installation was a success!\n\n\n\n\n\n\nIt's time to create a target for the project and define the target attributes. \n\n\n\n\n        [user@~/dev/nordic_blinky]$ newt target create blink_nordic\n        Creating target blink_nordic\n        Target blink_nordic successfully created!\n        [user@~/dev/nordic_blinky]$ newt target set blink_nordic project=blinky\n        Target blink_nordic successfully set project to blinky\n        [user@~/dev/nordic_blinky]$ newt target set blink_nordic bsp=hw/bsp/nrf52pdk\n        Target blink_nordic successfully set bsp to hw/bsp/nrf52pdk\n        [user@~/dev/nordic_blinky]$ newt target set blink_nordic compiler_def=debug\n        Target blink_nordic successfully set compiler_def to debug\n        [user@~/dev/nordic_blinky]$ newt target set blink_nordic compiler=arm-none-eabi-m4\n        Target blink_nordic successfully set compiler to arm-none-eabi-m4\n        [user@~/dev/nordic_blinky]$ newt target set blink_nordic arch=cortex_m4\n        Target blink_nordic successfully set arch to cortex_m4\n        [user@~/dev/nordic_blinky]$ newt target show\n        blink_nordic\n            compiler: arm-none-eabi-m4\n            name: blink_nordic\n            arch: cortex_m4\n            project: blinky\n            bsp: hw/bsp/nrf52pdk\n            compiler_def: debug\n\n\n\n\n\n\nFinally, you get to build the target and generate an executable that can now be uploaded to the board via the on-board SEGGER J-Link debugger. \n\n\n\n\n        [user@~/dev/nordic_blinky]$ newt target build blink_nordic\n        Building target blink_nordic (project = blinky)\n        Compiling case.c\n        Compiling suite.c\n        Compiling testutil.c\n        Compiling testutil_arch_arm.c\n        Archiving libtestutil.a\n        Compiling os.c\n        Compiling os_callout.c\n        Compiling os_eventq.c\n        Compiling os_heap.c\n        Compiling os_mbuf.c\n        Compiling os_mempool.c\n        Compiling os_mutex.c\n        Compiling os_sanity.c\n        Compiling os_sched.c\n        Compiling os_sem.c\n        Compiling os_task.c\n        Compiling os_time.c\n        Compiling os_arch_arm.c\n        Assembling HAL_CM4.s\n        Assembling SVC_Table.s\n        Archiving libos.a\n        Compiling hal_cputime.c\n        Compiling hal_gpio.c\n        Compiling hal_uart.c\n        Archiving libnrf52xxx.a\n        Compiling cmsis_nvic.c\n        Compiling hal_bsp.c\n        Compiling libc_stubs.c\n        Compiling os_bsp.c\n        Compiling sbrk.c\n        Compiling system_nrf52.c\n        Assembling gcc_startup_nrf52.s\n        Archiving libnrf52pdk.a\n        Compiling main.c\n        Building project blinky\n        Linking blinky.elf\n        Successfully run!\n\n\n\n\n\n\n\n\nIn order to be able to communicate with the SEGGER J-Link debugger on the dev board, you have to download and install the J-Link GDB Server software on to your laptop. You may download the \"Software and documentation pack for Mac OS X\" from \nhttps://www.segger.com/jlink-software.html\n. The command line version of the server is used in the steps below. \n\n\n\n\n\n\nOpen a new terminal and start a J-Link session.\n\n\n\n\n\n\n        [user@~/dev/nordic_blinky/project/blinky/bin]$ which JLinkGDBServer\n        /usr/local/bin/JLinkGDBServer\n        [user@~/dev/nordic_blinky/project/blinky/bin]$ JLinkGDBServer -if SWD\n        SEGGER J-Link GDB Server V5.02f Command Line Version\n\n        JLinkARM.dll V5.02f (DLL compiled Oct  2 2015 20:55:03)\n\n        -----GDB Server start settings-----\n        GDBInit file:                  none\n        GDB Server Listening port:     2331\n        SWO raw output listening port: 2332\n        Terminal I/O port:             2333\n        Accept remote connection:      yes\n        Generate logfile:              off\n        Verify download:               off\n        Init regs on start:            off\n        Silent mode:                   off\n        Single run mode:               off\n        Target connection timeout:     0 ms\n        ------J-Link related settings------\n        J-Link Host interface:         USB\n        J-Link script:                 none\n        J-Link settings file:          none\n        ------Target related settings------\n        Target device:                 unspecified\n        Target interface:              SWD\n        Target interface speed:        1000kHz\n        Target endian:                 little\n\n        Connecting to J-Link...\n        J-Link is connected.\n        Firmware: J-Link OB-SAM3U128-V2-NordicSemi compiled Aug 28 2015 19:26:24\n        Hardware: V1.00\n        S/N: 682371959\n        Checking target voltage...\n        Target voltage: 3.30 V\n        Listening on TCP/IP port 2331\n        Connecting to target...Connected to target\n        Waiting for GDB connection...Connected to 127.0.0.1\n\n\n\n\n\n\nYou need a configuration file for the GDB session to be opened correctly and the image (\"blinky.elf\") you built for this target downloaded to flash. A sample config script is given below. Alternatively, you could choose to type each command at the gdb prompt.\n\n\n\n\n         [user@~/dev/nordic_blinky/project/blinky/bin/blink_nordic]$ cat jlink-gdb.cfg \n         echo ***Setting up the environment for debugging gdb.***\\n\n         set complaints 1\n         set prompt (gdb) \n         set endian little\n         echo \\n*** Set target charset ASCII\\n\n         set target-charset ASCII\n         echo \\n*** Connecting over port #2331 ***\\n\n         target remote localhost:2331\n         echo \\n*** Enable flash write and set device to nrf52 ***\\n\n         monitor flash download=1\n         monitor flash device=nRF52\n         echo \\n*** loading blinky.elf ***\\n\n         load ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf \n         symbol-file ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf\n         echo \\n*** Resetting target ***\\n\n         monitor reset\n         echo \\n*** Halting target ***\\n\n         monitor halt\n\n\n\n\n\n\nStart the gdb session and monitor that it loads the image, resets the target, and halts for a command to continue. \n\n\n\n\n        [user@~/dev/nordic_blinky/project/blinky/bin/blink_nordic]$ arm-none-eabi-gdb -x ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/jlink-gdb.cfg\n\n        GNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\n        Copyright (C) 2014 Free Software Foundation, Inc.\n        License GPLv3+: GNU GPL version 3 or later \nhttp://gnu.org/licenses/gpl.html\n\n        This is free software: you are free to change and redistribute it.\n        There is NO WARRANTY, to the extent permitted by law.  Type \nshow copying\n\n        and \nshow warranty\n for details.\n        This GDB was configured as \n--host=x86_64-apple-darwin10 --target=arm-none-eabi\n.\n        Type \nshow configuration\n for configuration details.\n        For bug reporting instructions, please see:\n        \nhttp://www.gnu.org/software/gdb/bugs/\n.\n        Find the GDB manual and other documentation resources online at:\n        \nhttp://www.gnu.org/software/gdb/documentation/\n.\n        For help, type \nhelp\n.\n        Type \napropos word\n to search for commands related to \nword\n.\n\n        ***Setting up the environment for debugging gdb.***\n        The target is assumed to be little endian\n\n        *** Set target charset ASCII\n\n        *** Connecting over port #2331 ***\n        0x00003c34 in ?? ()\n\n        *** Enable flash write and set device to nrf52 ***\n        Flash download enabled\n        Selecting device: nRF52\n\n        *** loading blinky.elf ***\n        Loading section .text, size 0x5c84 lma 0x0\n        Loading section .ARM.extab, size 0x24 lma 0x5c84\n        Loading section .ARM.exidx, size 0xd8 lma 0x5ca8\n        Loading section .data, size 0x8f8 lma 0x5d80\n        Start address 0x48c, load size 26232\n        Transfer rate: 12808 KB/sec, 2914 bytes/write.\n        During symbol reading, unexpected overlap between:\n         (A) section `.text' from `~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf' [0x0, 0x5c84)\n         (B) section `*COM*' from `~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf' [0x0, 0x0).\n        Will ignore section B.\n\n        *** Resetting target ***\n        Resetting target\n\n        *** Halting target ***\n\n\n\n\n\n\nType 'c' to continue. The LED on the board will start to blink. You will also see some activity in the terminal showing the open J-Link GDB server connection. The LED will continue to blink after you quit out of that connection.\n\n\n\n\n        (gdb) c\n        Continuing.", 
            "title": "Project 2"
        }, 
        {
            "location": "/get_acclimated/project2/#project-2-blinky-on-additional-boards", 
            "text": "Objective  The goal of this tutorial is to download a generic firmware skeleton (\"bootstrap image\") that applies to any hardware and then throw in additional applicable eggs to generate a build for a specific board. In the process you will be exposed to more Mynewt terms and Newt tool commands.  The following target hardware chips are covered:   STM32F303VC MCU  from STMicroelectronics  nRF52 Series  from Nordic Semiconductors    STM32F303VC MCU  Hardware needed   Discovery kit with STM32F303VC MCU  Laptop running Mac OS   Step by Step Instructions to build image   The first step is to download the generic skeleton of the project. The eggs constituting the skeleton are not hardware architecture specific. The skeleton is maintained as a nest in a separate repository on Apache. You know it is a nest because there is a nest.yml file.            [user:~/dev]$ newt nest create test_project\n        Downloading nest skeleton from https://git-wip-us.apache.org/repos/asf/incubator-mynewt-tadpole.git... ok!\n        Nest test_project successfully created in ~/dev/go/test_project\n\n        [user:~/dev]$ cd test_project/\n        [user:~/dev/test_project]$ ls\n        README.md   compiler    hw      libs    nest.yml   Next, the clutch of eggs named larva is added from the nest (also named larva) from another repository on Apache. This step simply downloads the clutch description file and does not actually install the eggs that constitute the clutch. The clutch description file ( clutch.yml ) will be used to check dependencies during the egg install to ensure completeness. It serves as a reference for all the eggs in the clutch that one can choose from and install.           [user:~/dev/test_project]$ newt nest add-clutch larva https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git\n        Downloading clutch.yml from https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git/master... ok!\n        Verifying clutch.yml format...\n        ok!\n        Clutch larva successfully installed to Nest.   The next step is to install relevant eggs from the larva nest on github. The instructions assume that you know what application or project you are interested in (the blinky application, in this case), what hardware you are using (STM32F3DISCOVERY board, in this case) and hence, what board support package you need.    \n        [user:~/dev/test_project]$ newt egg install project/blinky          \n        Downloading larva from https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva/master... ok!\n        Installing project/blinky\n        Installing libs/console/full\n        Installing libs/shell\n        Installation was a success!\n\n        [user:~/dev/test_project]$ newt egg install hw/bsp/stm32f3discovery\n        Downloading larva from https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva/master... ok!\n        Installing hw/bsp/stm32f3discovery\n        Installing hw/mcu/stm/stm32f3xx\n        Installing libs/cmsis-core\n        Installing compiler/arm-none-eabi-m4\n        Installation was a success!   It's time to create a target for the project and define the target attributes.            [user:~/dev/test_project]$ newt target create blink_f3disc\n        Creating target blink_f3disc\n        Target blink_f3disc successfully created!\n\n        [user:~/dev/test_project]$ newt target set blink_f3disc project=blinky\n        Target blink_f3disc successfully set project to blinky\n\n        [user:~/dev/test_project]$ newt target set blink_f3disc bsp=hw/bsp/stm32f3discovery\n        Target blink_f3disc successfully set bsp to hw/bsp/stm32f3discovery\n\n        [user:~/dev/test_project]$ newt target set blink_f3disc compiler_def=debug\n        Target blink_f3disc successfully set compiler_def to debug\n\n        [user:~/dev/test_project]$ newt target set blink_f3disc compiler=arm-none-eabi-m4\n        Target blink_f3disc successfully set compiler to arm-none-eabi-m4\n\n        [user:~/dev/test_project]$ newt target set blink_f3disc arch=cortex_m4\n        Target blink_f3disc successfully set arch to cortex_m4\n\n        [user:~/dev/test_project]$ newt target show blink_f3disc\n        blink_f3disc\n            arch: cortex_m4\n            project: blinky\n            bsp: hw/bsp/stm32f3discovery\n            compiler_def: debug\n            compiler: arm-none-eabi-m4\n            name: blink_f3disc    Next, you get to build the target and generate an executable that can then be uploaded to the board. The STM32F3DISCOVERY board includes an ST-LINK/V2 embedded debug tool interface that will be used to program/debug the board. To program the MCU on the board, simply plug in the two jumpers on CN4, as shown in the picture in red. If you want to learn more about the board you will find the User Manual at  http://www.st.com/st-web-ui/static/active/jp/resource/technical/document/user_manual/DM00063382.pdf               [user:~/dev/test_project]$ newt target build blink_f3disc\n        Building target blink_f3disc (project = blinky)\n        Compiling case.c\n        Compiling suite.c\n        Compiling testutil.c\n        Compiling testutil_arch_arm.c\n        Archiving libtestutil.a\n        Compiling os.c\n        Compiling os_callout.c\n        Compiling os_eventq.c\n        Compiling os_heap.c\n        Compiling os_mbuf.c\n        Compiling os_mempool.c\n        Compiling os_mutex.c\n        Compiling os_sanity.c\n        Compiling os_sched.c\n        Compiling os_sem.c\n        Compiling os_task.c\n        Compiling os_time.c\n        Compiling os_arch_arm.c\n        Assembling HAL_CM4.s\n        Assembling SVC_Table.s\n        Archiving libos.a\n        Compiling hal_gpio.c\n        Compiling stm32f3xx_hal_gpio.c\n        Archiving libstm32f3xx.a\n        Compiling cmsis_nvic.c\n        Compiling libc_stubs.c\n        Compiling os_bsp.c\n        Compiling sbrk.c\n        Compiling system_stm32f3xx.c\n        Assembling startup_stm32f303xc.s\n        Archiving libstm32f3discovery.a\n        Compiling main.c\n        Building project blinky\n        Linking blinky.elf\n        Successfully run!   Finally, you have to download the image on to the board. You will see a blue light start to blink.           [user:~/dev/test_project]$ newt target download blink_f3disc\n        Downloading with /Users/user/dev/test_project/hw/bsp/stm32f3discovery/stm32f3discovery_download.sh  nRF52 Series  Hardware needed   nRF52 Development Kit  Laptop running Mac OS   Step by Step Instructions to build image   The first step is to download the generic skeleton of the project. The eggs installed are not hardware architecture specific.           []user@~/dev]$ newt nest create nordic_blinky\n        Downloading nest skeleton from https://www.github.com/mynewt/tadpole... ok!\n        Nest nordic_blinky successfully created in ~dev/nordic_blinky\n\n        user@~/dev$ cd nordic_blinky/   Then, the clutch of eggs named larva is added from the nest (also named larva) on the github. This step simply downloads the clutch description file and does not actually install the eggs that constitute the clutch. The clutch description file ( clutch.yml ) will be used to check dependencies during the egg install to ensure completeness. It serves as a reference for all the eggs in the clutch that one can choose from and install.           []user@~/dev/nordic_blinky]$ newt nest add-clutch larva https://github.com/mynewt/larva\n        Downloading clutch.yml from https://github.com/mynewt/larva/master... ok!\n        Verifying clutch.yml format...ok!\n        Clutch larva successfully installed to Nest.   The next step is to install relevant eggs from the larva nest on github. The instructions assume that you know what application or project you are interested in (the blinky application, in this case), what hardware you are using (STM32F3DISCOVERY board, in this case) and hence, what board support package you need.            [user@~/dev/nordic_blinky]$ newt egg install project/blinky \n        Downloading larva from https://github.com/mynewt/larva//master... ok!\n        Installing project/blinky\n        Installation was a success!\n\n\n        [user@~/dev/nordic_blinky]$ newt egg install hw/bsp/nrf52pdk\n        Downloading larva from https://github.com/mynewt/larva//master... ok!\n        Installing hw/bsp/nrf52pdk\n        Installing hw/mcu/nordic/nrf52xxx\n        Installing libs/cmsis-core\n        Installing compiler/arm-none-eabi-m4\n        Installation was a success!   It's time to create a target for the project and define the target attributes.            [user@~/dev/nordic_blinky]$ newt target create blink_nordic\n        Creating target blink_nordic\n        Target blink_nordic successfully created!\n        [user@~/dev/nordic_blinky]$ newt target set blink_nordic project=blinky\n        Target blink_nordic successfully set project to blinky\n        [user@~/dev/nordic_blinky]$ newt target set blink_nordic bsp=hw/bsp/nrf52pdk\n        Target blink_nordic successfully set bsp to hw/bsp/nrf52pdk\n        [user@~/dev/nordic_blinky]$ newt target set blink_nordic compiler_def=debug\n        Target blink_nordic successfully set compiler_def to debug\n        [user@~/dev/nordic_blinky]$ newt target set blink_nordic compiler=arm-none-eabi-m4\n        Target blink_nordic successfully set compiler to arm-none-eabi-m4\n        [user@~/dev/nordic_blinky]$ newt target set blink_nordic arch=cortex_m4\n        Target blink_nordic successfully set arch to cortex_m4\n        [user@~/dev/nordic_blinky]$ newt target show\n        blink_nordic\n            compiler: arm-none-eabi-m4\n            name: blink_nordic\n            arch: cortex_m4\n            project: blinky\n            bsp: hw/bsp/nrf52pdk\n            compiler_def: debug   Finally, you get to build the target and generate an executable that can now be uploaded to the board via the on-board SEGGER J-Link debugger.            [user@~/dev/nordic_blinky]$ newt target build blink_nordic\n        Building target blink_nordic (project = blinky)\n        Compiling case.c\n        Compiling suite.c\n        Compiling testutil.c\n        Compiling testutil_arch_arm.c\n        Archiving libtestutil.a\n        Compiling os.c\n        Compiling os_callout.c\n        Compiling os_eventq.c\n        Compiling os_heap.c\n        Compiling os_mbuf.c\n        Compiling os_mempool.c\n        Compiling os_mutex.c\n        Compiling os_sanity.c\n        Compiling os_sched.c\n        Compiling os_sem.c\n        Compiling os_task.c\n        Compiling os_time.c\n        Compiling os_arch_arm.c\n        Assembling HAL_CM4.s\n        Assembling SVC_Table.s\n        Archiving libos.a\n        Compiling hal_cputime.c\n        Compiling hal_gpio.c\n        Compiling hal_uart.c\n        Archiving libnrf52xxx.a\n        Compiling cmsis_nvic.c\n        Compiling hal_bsp.c\n        Compiling libc_stubs.c\n        Compiling os_bsp.c\n        Compiling sbrk.c\n        Compiling system_nrf52.c\n        Assembling gcc_startup_nrf52.s\n        Archiving libnrf52pdk.a\n        Compiling main.c\n        Building project blinky\n        Linking blinky.elf\n        Successfully run!    In order to be able to communicate with the SEGGER J-Link debugger on the dev board, you have to download and install the J-Link GDB Server software on to your laptop. You may download the \"Software and documentation pack for Mac OS X\" from  https://www.segger.com/jlink-software.html . The command line version of the server is used in the steps below.     Open a new terminal and start a J-Link session.            [user@~/dev/nordic_blinky/project/blinky/bin]$ which JLinkGDBServer\n        /usr/local/bin/JLinkGDBServer\n        [user@~/dev/nordic_blinky/project/blinky/bin]$ JLinkGDBServer -if SWD\n        SEGGER J-Link GDB Server V5.02f Command Line Version\n\n        JLinkARM.dll V5.02f (DLL compiled Oct  2 2015 20:55:03)\n\n        -----GDB Server start settings-----\n        GDBInit file:                  none\n        GDB Server Listening port:     2331\n        SWO raw output listening port: 2332\n        Terminal I/O port:             2333\n        Accept remote connection:      yes\n        Generate logfile:              off\n        Verify download:               off\n        Init regs on start:            off\n        Silent mode:                   off\n        Single run mode:               off\n        Target connection timeout:     0 ms\n        ------J-Link related settings------\n        J-Link Host interface:         USB\n        J-Link script:                 none\n        J-Link settings file:          none\n        ------Target related settings------\n        Target device:                 unspecified\n        Target interface:              SWD\n        Target interface speed:        1000kHz\n        Target endian:                 little\n\n        Connecting to J-Link...\n        J-Link is connected.\n        Firmware: J-Link OB-SAM3U128-V2-NordicSemi compiled Aug 28 2015 19:26:24\n        Hardware: V1.00\n        S/N: 682371959\n        Checking target voltage...\n        Target voltage: 3.30 V\n        Listening on TCP/IP port 2331\n        Connecting to target...Connected to target\n        Waiting for GDB connection...Connected to 127.0.0.1   You need a configuration file for the GDB session to be opened correctly and the image (\"blinky.elf\") you built for this target downloaded to flash. A sample config script is given below. Alternatively, you could choose to type each command at the gdb prompt.            [user@~/dev/nordic_blinky/project/blinky/bin/blink_nordic]$ cat jlink-gdb.cfg \n         echo ***Setting up the environment for debugging gdb.***\\n\n         set complaints 1\n         set prompt (gdb) \n         set endian little\n         echo \\n*** Set target charset ASCII\\n\n         set target-charset ASCII\n         echo \\n*** Connecting over port #2331 ***\\n\n         target remote localhost:2331\n         echo \\n*** Enable flash write and set device to nrf52 ***\\n\n         monitor flash download=1\n         monitor flash device=nRF52\n         echo \\n*** loading blinky.elf ***\\n\n         load ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf \n         symbol-file ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf\n         echo \\n*** Resetting target ***\\n\n         monitor reset\n         echo \\n*** Halting target ***\\n\n         monitor halt   Start the gdb session and monitor that it loads the image, resets the target, and halts for a command to continue.            [user@~/dev/nordic_blinky/project/blinky/bin/blink_nordic]$ arm-none-eabi-gdb -x ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/jlink-gdb.cfg\n\n        GNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\n        Copyright (C) 2014 Free Software Foundation, Inc.\n        License GPLv3+: GNU GPL version 3 or later  http://gnu.org/licenses/gpl.html \n        This is free software: you are free to change and redistribute it.\n        There is NO WARRANTY, to the extent permitted by law.  Type  show copying \n        and  show warranty  for details.\n        This GDB was configured as  --host=x86_64-apple-darwin10 --target=arm-none-eabi .\n        Type  show configuration  for configuration details.\n        For bug reporting instructions, please see:\n         http://www.gnu.org/software/gdb/bugs/ .\n        Find the GDB manual and other documentation resources online at:\n         http://www.gnu.org/software/gdb/documentation/ .\n        For help, type  help .\n        Type  apropos word  to search for commands related to  word .\n\n        ***Setting up the environment for debugging gdb.***\n        The target is assumed to be little endian\n\n        *** Set target charset ASCII\n\n        *** Connecting over port #2331 ***\n        0x00003c34 in ?? ()\n\n        *** Enable flash write and set device to nrf52 ***\n        Flash download enabled\n        Selecting device: nRF52\n\n        *** loading blinky.elf ***\n        Loading section .text, size 0x5c84 lma 0x0\n        Loading section .ARM.extab, size 0x24 lma 0x5c84\n        Loading section .ARM.exidx, size 0xd8 lma 0x5ca8\n        Loading section .data, size 0x8f8 lma 0x5d80\n        Start address 0x48c, load size 26232\n        Transfer rate: 12808 KB/sec, 2914 bytes/write.\n        During symbol reading, unexpected overlap between:\n         (A) section `.text' from `~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf' [0x0, 0x5c84)\n         (B) section `*COM*' from `~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf' [0x0, 0x0).\n        Will ignore section B.\n\n        *** Resetting target ***\n        Resetting target\n\n        *** Halting target ***   Type 'c' to continue. The LED on the board will start to blink. You will also see some activity in the terminal showing the open J-Link GDB server connection. The LED will continue to blink after you quit out of that connection.           (gdb) c\n        Continuing.", 
            "title": "Project 2 - Blinky on additional boards"
        }, 
        {
            "location": "/get_acclimated/project3/", 
            "text": "How to Test an Egg", 
            "title": "Project 3"
        }, 
        {
            "location": "/get_acclimated/project3/#how-to-test-an-egg", 
            "text": "", 
            "title": "How to Test an Egg"
        }, 
        {
            "location": "/newt/newt_ops/", 
            "text": "Command Structure\n\n\nIn the newt tool, commands represent actions and flags are modifiers for those actions. A command can have children commands which are also simply referred to as commands. One or more arguments may need to be provided to a command to execute it correctly. \n\n\nIn the example below, the \nnewt\n command has the child command \ntarget set\n. The first argument 'my_target1' is the name of the target whose attributes are being set. The second argument 'arch=cortex_m4' specifies the value to set the attribute (variable) 'arch' to, which in this case is 'cortex_m4'. \n\n\n    newt target set my_target1 arch=cortex_m4\n\n\n\n\nGlobal flags work on all newt commands in the same way. An example is the flag \n-v, --verbose\n to ask for a verbose output while executing a command. The help flag \n-h\n or  \n--help\n is available on all commands but provides command specific output, of course. These flags may be specified in either a long or a short form. \n\n\nA command may additionally take flags specific to it. For example, the \n-b\n flag may be used with \nnewt egg install\n to tell it which branch to install the egg from. \n\n\n    newt egg install -b \nbranchname\n \neggname\n\n\n\n\n\nIn addition to the newt tool \nreference\n in this documentation set, command-line help is available for each command (and child command). Simply use the flag \n-h\n or \n--help\n as shown below:\n\n\n    $ newt target export --help\n    Export build targets from the current nest, and print them to \n    standard output. If the -a (or -export-all) option is specified, \n    then all targets will be exported. Otherwise, \ntarget-name\n \n    must be specified, and only that target will be exported.\n\n    Usage: \n      newt target export [flags]\n\n    Examples:\n      newt target export [-a -export-all] [\ntarget-name\n]\n      newt target export -a \n my_exports.txt\n      newt target export my_target \n my_target_export.txt\n\n    Flags:\n      -a, --export-all=false: If present, export all targets\n      -h, --help=false: help for export\n\n    Global Flags:\n      -l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n      -q, --quiet=false: Be quiet; only display error output.\n      -s, --silent=false: Be silent; don't output anything.\n      -v, --verbose=false: Enable verbose output when executing commands.", 
            "title": "Command structure"
        }, 
        {
            "location": "/newt/newt_ops/#command-structure", 
            "text": "In the newt tool, commands represent actions and flags are modifiers for those actions. A command can have children commands which are also simply referred to as commands. One or more arguments may need to be provided to a command to execute it correctly.   In the example below, the  newt  command has the child command  target set . The first argument 'my_target1' is the name of the target whose attributes are being set. The second argument 'arch=cortex_m4' specifies the value to set the attribute (variable) 'arch' to, which in this case is 'cortex_m4'.       newt target set my_target1 arch=cortex_m4  Global flags work on all newt commands in the same way. An example is the flag  -v, --verbose  to ask for a verbose output while executing a command. The help flag  -h  or   --help  is available on all commands but provides command specific output, of course. These flags may be specified in either a long or a short form.   A command may additionally take flags specific to it. For example, the  -b  flag may be used with  newt egg install  to tell it which branch to install the egg from.       newt egg install -b  branchname   eggname   In addition to the newt tool  reference  in this documentation set, command-line help is available for each command (and child command). Simply use the flag  -h  or  --help  as shown below:      $ newt target export --help\n    Export build targets from the current nest, and print them to \n    standard output. If the -a (or -export-all) option is specified, \n    then all targets will be exported. Otherwise,  target-name  \n    must be specified, and only that target will be exported.\n\n    Usage: \n      newt target export [flags]\n\n    Examples:\n      newt target export [-a -export-all] [ target-name ]\n      newt target export -a   my_exports.txt\n      newt target export my_target   my_target_export.txt\n\n    Flags:\n      -a, --export-all=false: If present, export all targets\n      -h, --help=false: help for export\n\n    Global Flags:\n      -l, --loglevel= WARN : Log level, defaults to WARN.\n      -q, --quiet=false: Be quiet; only display error output.\n      -s, --silent=false: Be silent; don't output anything.\n      -v, --verbose=false: Enable verbose output when executing commands.", 
            "title": "Command Structure"
        }, 
        {
            "location": "/newt/newt_tool_reference/", 
            "text": "Command List\n\n\nAvailable high-level commands\n\n\nversion     Display the Newt version number\nhelp        Help about any command\nnest        Commands to manage nests \n clutches (remote egg repositories)\negg         Commands to list and inspect eggs on a nest\ntarget      Set and view target information\n\n\n\n\nversion\n\n\nUsage:\n\n\n    newt version [flags]\n\n\n\n\nFlags:\n\n\n    -h, --help=false: help for version\n\n\n\n\nGlobal Flags:\n\n\n    -h, --help=false: help for newt\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nversion\n\n\nnewt version\n\n\nDisplays the version of newt tool installed\n\n\n\n\n\n\n\n\nhelp\n\n\nUsage:\n\n\n    newt help [input1]\n\n\n\n\nFlags:\n\n\n\n-h, --help=false: help for newt\n-l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nhelp\n\n\nnewt help target\n\n\nDisplays the help text for the newt command 'target'\n\n\n\n\n\n\nhelp\n\n\nnewt help\n\n\nDisplays the help text for newt tool\n\n\n\n\n\n\n\n\nnest\n\n\nUsage:\n\n\n    newt nest [command][flags] input1 input2...\n\n\n\n\nAvailable commands: \n\n\n    create          Create a new nest\n    generate-clutch Generate a clutch file from the eggs in the current directory\n    add-clutch      Add a remote clutch, and put it in the current nest\n    list-clutches   List the clutches installed in the current nest\n    show-clutch     Show an individual clutch in the current nest\n\n\n\n\nFlags:\n\n\n    -h, --help=false: help for nest\n\n\n\n\nGlobal Flags:\n\n\n    -h, --help=false: help for newt\n    -l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n    -q, --quiet=false: Be quiet; only display error output.\n    -s, --silent=false: Be silent; don't output anything.\n    -v, --verbose=false: Enable verbose output when executing commands.\n\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSub-command\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\ncreate\n\n\nDownloads the skeleton of a nest on your local machine from the optional \ninput2\nnest url, if specified, and creates a new nest directory by the name of \ninput1\n If \ninput2\nis not specified, then a default skeleton from the \ntadpole\nnest on Mynewt is downloaded. The command lays out a generic directory structure for the nest you are going to build under it and includes some default eggs in it.\n\n\n\n\n\n\ngenerate-clutch\n\n\nTakes a snapshot of the eggs in the current local directory and combines them into a clutch by the name of \ninput1\nand with the url of \ninput2\nand generates a standard output of the clutch details that can be redirected to a \n.yml\nclutch file. Typically the clutch file name is chosen to match the clutch name which means the standard output should be directed to a clutch file named \ninput1.yml\n\n\n\n\n\n\nadd-clutch\n\n\nDownloads the clutch of the name \ninput1\nfrom the master branch of the github repository \ninput2\ninto the current nest. A file named \ninput1.yml\nfile is added in the \n.nest/clutches\nsubdirectory inside the current local nest. The \n.nest/\ndirectory structure is created automatically if it does not exist.\n\n\n\n\n\n\nlist-clutches\n\n\nLists all the clutches present in the current nest, including clutches that may have been added from other nests on github. The output shows all the remote clutch names and the total eggshells in each of the clutches.\n\n\n\n\n\n\nshow-clutch\n\n\nShows information about the clutch that has the name given in the \ninput1\nargument. Output includes the clutch name, url, and all the constituent eggs with their version numbers.\n\n\n\n\n\n\n\n\nCommand-specific flags\n\n\n\n\n\n\n\n\nSub-command\n\n\nAvailable flags\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nadd-clutch\n\n\n-b, --branch=\"\n\"\n\n\nFetches the clutch file with name \ninput1\nfrom the specified branch at \ninput1\nurl of the github repository. All subsequent egg installations will be done from that branch.\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\ncreate\n\n\nnewt nest create test_project\n\n\nCreates a new nest named \"test_project \" using the default skeleton0\n\n\n\n\n\n\ncreate\n\n\nnewt nest create mynest \n\n\nCreates a new nest named \"mynest\" using the skeleton at the \n specified\n\n\n\n\n\n\ngenerate-clutch\n\n\nnewt nest generate-clutch myclutch https://www.github.com/mynewt/larva \n myclutch.yml\n\n\nTakes a snapshot of the eggs in the current nest to form a clutch named myclutch with the url https://www.github.com/mynewt/larva. The output is written to a file named \nmyclutch.yml\nand describes the properties and contents of the clutch (name, url, eggs).\n\n\n\n\n\n\nadd-clutch\n\n\nnewt nest add-clutch larva https://www.github.com/mynewt/larva\n\n\nAdds the remote clutch named larva at www.github.com/mynewt/larva to the local nest.\n\n\n\n\n\n\nlist-clutches\n\n\nnewt nest list-clutches\n\n\nShows all the remote clutch description files that been downloaded into the current nest\n\n\n\n\n\n\nshow-clutch\n\n\nnewt nest show-clutch larva\n\n\nOutputs the details of the clutch named larva such as the github url where the remote sits, the constituent eggs and their versions\n\n\n\n\n\n\n\n\negg\n\n\nUsage:\n\n\n    newt egg [command][flag] input1 input2\n\n\n\n\nAvailable Commands: \n\n\n    list        List eggs in the current nest\n    checkdeps   Check egg dependencies\n    hunt        Search for egg from clutches\n    show        Show the contents of an egg.\n    install     Install an egg\n    remove      Remove an egg\n\n\n\n\nFlags:\n\n\n    -h, --help=false: help for egg\n\nGlobal Flags:\n\n    -l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n    -q, --quiet=false: Be quiet; only display error output.\n    -s, --silent=false: Be silent; don't output anything.\n    -v, --verbose=false: Enable verbose output when executing commands.\n\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSub-command\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nlist\n\n\nList all the eggs in the current nest. The output shows the name, version, path, and any additional attributes of each egg in the nest such as dependencies, capabilities, and linker scripts. The newt command gets the attributes of each egg from the corresponsing egg.yml description file.\n\n\n\n\n\n\ncheckdeps\n\n\nResolve all dependencies in the local nest. This command goes through all eggs currently installed, checks their dependencies, and prints any unresolved dependencies between eggs.\n\n\n\n\n\n\nhunt\n\n\nHunts for an egg, specified by \ninput1\n The local nest, along with all remote nests (clutches) are searched. All matched eggs are shown along with the clutch informaton. Installed eggs are called out as such. The command can be invoked from anywhere in the nest.\n\n\n\n\n\n\nshow\n\n\nShow the contents of the egg named \ninput2\nfound in the clutch named \ninput1\n The clutch name is optional; if only the egg name is given as the argument it is resolved using all the clutches installed in the current nest. If the egg is present in multiple clutches it will list all of them along with the clutch information for each.\n\n\n\n\n\n\ninstall\n\n\nInstall the egg specified by \ninput2\nfrom the clutch named \ninput1\n The command downloads the egg from the github repository using the URL in the clutch description file (typically donwloaded as 'input1@\n.yml' in .nest/clutches). It also downloads all the dependencies (constituent eggs) as decribed in the egg's description file ('egg.yml') and installs all of them. The clutch name is optional. If only the egg name is given as the argument, the command looks for the egg name in all the clutches in the local nest and installs accordingly. An egg is installed by this command only if it has not already been installed.\n\n\n\n\n\n\nremove\n\n\nRemove an egg named \ninput2\nfrom clutch \ninput1\n if clutch is specified. Otherwise only one input required - that of the name of the egg to be removed from the local nest.\n\n\n\n\n\n\n\n\nCommand-specific flags\n\n\n\n\n\n\n\n\nSub-command\n\n\nAvailable flags\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\ninstall\n\n\n-b, --branch=\"\n\"\n\n\nInstalls the eggs from the branch name or tag of the clutch specified\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nlist\n\n\nnewt egg list\n\n\nCList all of the eggs in the current nest and the details of the eggs.\n\n\n\n\n\n\ncheckdeps\n\n\nnewt egg checkdeps\n\n\nChecks all the dependencies between eggs in the nest. Lists any unresolved dependencies.\n\n\n\n\n\n\nhunt\n\n\nnewt egg hunt blinky\n\n\nHunts for the egg named 'blinky'. The command can be invoked from anywhere in the nest. Results show if the egg is installed and which clutch, if any, has the egg.\n\n\n\n\n\n\nshow\n\n\nnewt egg show larva libs/os\n\n\nShow the contents of the egg named 'libs/os' in the clutch named larva. The contents are essentially derived from the egg's 'egg.yml' file.\n\n\n\n\n\n\ninstall\n\n\nnewt egg install hw/bsp/stm32f3discovery\n\n\nDownloads and installs the egg named \"stm32f3discovery\" (specified with its full path name inside the remote nest) along with all its dependencies from the remote nest on github. Since no clutch is specified, the URL for the remote nest in the clutch description file found in the local nest (in .nest/clutches for the project) is used.\n\n\n\n\n\n\nremove\n\n\nnewt egg remove larva blinky\n\n\nRemoves the egg named blinky only from the clutch named larva\n\n\n\n\n\n\nremove\n\n\nnewt egg remove blinky\n\n\nRemoves the egg named blinky from the local nest\n\n\n\n\n\n\n\n\ntarget\n\n\nUsage:\n\n\nUsage: \n\n\n    newt target [command] input1 [flag1] [flag2]\n\n\n\n\nAvailable Commands: \n\n\n    set         Set target configuration variable\n    unset       Unset target configuration variable\n    delete      Delete target\n    create      Create a target\n    show        View target configuration variables\n    build       Build target\n    test        Test target\n    export      Export target\n    import      Import target\n    download    Download image to target\n    debug       Download image to target and start an openocd/gdb session\n\n\n\n\nFlags:\n\n\n    -h, --help=false: help for target\n\n\n\n\nGlobal Flags:\n\n\n    -l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n    -q, --quiet=false: Be quiet; only display error output.\n    -s, --silent=false: Be silent; don't output anything.\n    -v, --verbose=false: Enable verbose output when executing commands.\n\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSub-command\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nset\n\n\nSet attributes of the target. Currently the list of possible attributes are:\narch, compiler, compiler_def, project, bsp, egg, identities, capabilities, dependencies, cflags, lflags\n Typically only the first 5 need to be set for a hardware target. For a simulated target, e.g. for software testing purposes, \narch=sim\n \ncompiler=sim\n and \negg=\negg name to be tested\n You cannot set both the project and egg for a target.\n\n\n\n\n\n\nunset\n\n\nUnset attributes of the target in its configuration.\n\n\n\n\n\n\ndelete\n\n\nDeletes only the description for the target. Does not delete the target directory with associated binaries. If you want to clean out the binaries, list files, and executables use\nnewt target build \ntarget-name\n clean\nbefore\n deleting the target!\n\n\n\n\n\n\ncreate\n\n\nCreates a target description or build definition by the name \ninput1\n By default it assigns the sim (simulator) architecture to it which allows you to build new projects and software on your native OS and try it out.\n\n\n\n\n\n\nshow\n\n\nDisplay the configuration defined for the target named \ninput1\n If no \ninput1\nis specified then show the details for all the targets in the nest.\n\n\n\n\n\n\nbuild\n\n\nBuild the source code into an image that can be loaded on the hardware associated with the target named \ninput1\nto do the application enabled by the 'project' associated with that target (via the target definition). It creates 'bin/' and 'bin/\n/' subdirectories inside the base directory for the project, compiles and generates binaries and executables, and places them in 'bin/\n/.\n\n\n\n\n\n\ntest\n\n\nTest an egg on the target named \ninput1\n The egg is either supplied as an argument to the command line invocation of \nnewt target test\nor added as part of the target definition. If only the target is specified as \ninput1\n then the egg in the target's definition is automatically chosen to be tested. You currently cannot test an entire project on a hardware target. The test command is envisioned for use if one or two eggs gets updated and each needs to be tested against a target. Alternatively, a script may be written for a series of tests on several eggs.\n\n\n\n\n\n\nexport\n\n\nExports the configurations of the specified target \ninput1\n If -a or -export-all flag is used, then all targets are exported and printed out to standard out. You may redirect the output to a file.\n\n\n\n\n\n\nimport\n\n\nImport one or more target configuration from standard input or a file. Each target starts with \n@target=\ntarget-name\nfollowed by the attributes. The list of targets should end with \n@endtargets\n\n\n\n\n\n\nsize\n\n\nOutputs the RAM and flash consumption by the components of the specified target \ninput1\n\n\n\n\n\n\ndownload\n\n\nDownloads the binary executable \ntarget-name\n.elf.bin\nto the board.\n\n\n\n\n\n\ndebug\n\n\nDownloads the binary executable \ntarget-name\n.elf.bin\nto the board and starts up the openocd/gdb combination session. gdb takes over the terminal.\n\n\n\n\n\n\n\n\nCommand-specific flags\n\n\n\n\n\n\n\n\nSub-command\n\n\nAvailable flags\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nbuild\n\n\nclean\n\n\nAll the binaries and object files for the specified target will be removed. The subdirectory named after the specified target within that project is removed.\n\n\n\n\n\n\nbuild clean\n\n\nall\n\n\nAll the binaries and object files for all targets are removed, and subdirectories of all targets for the project are removed. However, the entire repository is not emptied since any eggs or projects that the specified target doesn't reference are not touched.\n\n\n\n\n\n\nexport\n\n\n-a, -export-all\n\n\nExport all targets. \ninput1\nis not necessary when this flag is used.\n\n\n\n\n\n\nimport\n\n\n-a, -import-all\n\n\nImport all targets typed into standard input or redirected from a file.\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nset\n\n\nnewt target set myblinky compiler=arm-none-eabi-m4\n\n\nSet the compiler for the 'myblinky' target to the gcc compiler for embedded ARM chips.\n\n\n\n\n\n\nunset\n\n\nnewt target unset myblinky compiler\n\n\nRemove the setting for the compiler for the 'myblinky' target.\n\n\n\n\n\n\ndelete\n\n\nnewt target delete myblinky\n\n\nDelete the target description for the target named 'myblinky'. Note that it does not remove any binaries or clean out the directory for this target.\n\n\n\n\n\n\ncreate\n\n\nnewt target create blink_f3disc\n\n\nCreate a new target description by the name 'blink_f3disc'. The architecture is 'sim' by default and can be changed using subcommand 'set' above.\n\n\n\n\n\n\nshow\n\n\nnewt target show myblinky\n\n\nShow the target attributes set for 'myblinky'\n\n\n\n\n\n\nbuild\n\n\nnewt target build blink_f3disc\n\n\nCompile the source code for the target named blink_f3disc and generate binaries that can be loaded into the target hardware.\n\n\n\n\n\n\ntest\n\n\nnewt target test test_target egg=libs/os\n\n\nTests the egg named 'libs/os' against the target named 'test_target'\n\n\n\n\n\n\nexport\n\n\nnewt target export -a \n my_exports.txt\n\n\nExport all build targets from the current nest, and redirect output to a file named 'my_exports.txt'.\n\n\n\n\n\n\nexport\n\n\nnewt target export -export-all\n\n\nExport all build targets from the current nest, and print them to standard output on the screen.\n\n\n\n\n\n\nexport\n\n\nnewt target export my_target\n\n\nExport only target named 'my_target' and print it to standard output on the screen.\n\n\n\n\n\n\nimport\n\n\nnewt target import ex_tgt_1 \n exported_targets.txt\n\n\nImports the target configuration for 'ex_tgt_1' in 'exported_targets.txt'.\n\n\n\n\n\n\nimport\n\n\nnewt target import -a \n in_targets.txt\n\n\nImports all the targets specified in the file named \nin_targets.txt\n A sample file is shown after this table.\n\n\n\n\n\n\nsize\n\n\nnewt target size blink_nordic\n\n\nInspects and lists the RAM and Flash memory use by each component (object files and libraries) of the target.\n\n\n\n\n\n\ndownload\n\n\nnewt target -v -lVERBOSE download blinky\n\n\nDownloads \nblinky.elf.bin\nto the hardware in verbose mode with logging turned on at VERBOSE level.\n\n\n\n\n\n\ndebug\n\n\nnewt target debug blinky\n\n\nDownloads \nblinky.elf.bin\nto the hardware, opens up a gdb session with \nblinky.elf\nin the terminal, and halts for further input in gdb.\n\n\n\n\n\n\n\n\nExample content for \nin_targets.txt\n file used for importing targets \ntest3\n and \ntest4\n.  \n\n\n\n\n@target=test3\n\nproject=blinked\n\narch=sim\n\ncompiler_def=debug\n\ncompiler=arm-none-eabi-m4\n\n@target=test4\n\nproject=super_blinky\n\narch=sim\n\ncompiler_def=debug\n\ncompiler=arm-none-eabi-m4\n\n@endtargets", 
            "title": "Command list"
        }, 
        {
            "location": "/newt/newt_tool_reference/#command-list", 
            "text": "Available high-level commands  version     Display the Newt version number\nhelp        Help about any command\nnest        Commands to manage nests   clutches (remote egg repositories)\negg         Commands to list and inspect eggs on a nest\ntarget      Set and view target information  version  Usage:      newt version [flags]  Flags:      -h, --help=false: help for version  Global Flags:      -h, --help=false: help for newt  Examples     Sub-command  Usage  Explanation      version  newt version  Displays the version of newt tool installed     help  Usage:      newt help [input1]  Flags:  \n-h, --help=false: help for newt\n-l, --loglevel= WARN : Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.  Examples     Sub-command  Usage  Explanation      help  newt help target  Displays the help text for the newt command 'target'    help  newt help  Displays the help text for newt tool     nest  Usage:      newt nest [command][flags] input1 input2...  Available commands:       create          Create a new nest\n    generate-clutch Generate a clutch file from the eggs in the current directory\n    add-clutch      Add a remote clutch, and put it in the current nest\n    list-clutches   List the clutches installed in the current nest\n    show-clutch     Show an individual clutch in the current nest  Flags:      -h, --help=false: help for nest  Global Flags:      -h, --help=false: help for newt\n    -l, --loglevel= WARN : Log level, defaults to WARN.\n    -q, --quiet=false: Be quiet; only display error output.\n    -s, --silent=false: Be silent; don't output anything.\n    -v, --verbose=false: Enable verbose output when executing commands.  Description     Sub-command  Explanation      create  Downloads the skeleton of a nest on your local machine from the optional  input2 nest url, if specified, and creates a new nest directory by the name of  input1  If  input2 is not specified, then a default skeleton from the  tadpole nest on Mynewt is downloaded. The command lays out a generic directory structure for the nest you are going to build under it and includes some default eggs in it.    generate-clutch  Takes a snapshot of the eggs in the current local directory and combines them into a clutch by the name of  input1 and with the url of  input2 and generates a standard output of the clutch details that can be redirected to a  .yml clutch file. Typically the clutch file name is chosen to match the clutch name which means the standard output should be directed to a clutch file named  input1.yml    add-clutch  Downloads the clutch of the name  input1 from the master branch of the github repository  input2 into the current nest. A file named  input1.yml file is added in the  .nest/clutches subdirectory inside the current local nest. The  .nest/ directory structure is created automatically if it does not exist.    list-clutches  Lists all the clutches present in the current nest, including clutches that may have been added from other nests on github. The output shows all the remote clutch names and the total eggshells in each of the clutches.    show-clutch  Shows information about the clutch that has the name given in the  input1 argument. Output includes the clutch name, url, and all the constituent eggs with their version numbers.     Command-specific flags     Sub-command  Available flags  Explanation      add-clutch  -b, --branch=\" \"  Fetches the clutch file with name  input1 from the specified branch at  input1 url of the github repository. All subsequent egg installations will be done from that branch.     Examples     Sub-command  Usage  Explanation      create  newt nest create test_project  Creates a new nest named \"test_project \" using the default skeleton0    create  newt nest create mynest   Creates a new nest named \"mynest\" using the skeleton at the   specified    generate-clutch  newt nest generate-clutch myclutch https://www.github.com/mynewt/larva   myclutch.yml  Takes a snapshot of the eggs in the current nest to form a clutch named myclutch with the url https://www.github.com/mynewt/larva. The output is written to a file named  myclutch.yml and describes the properties and contents of the clutch (name, url, eggs).    add-clutch  newt nest add-clutch larva https://www.github.com/mynewt/larva  Adds the remote clutch named larva at www.github.com/mynewt/larva to the local nest.    list-clutches  newt nest list-clutches  Shows all the remote clutch description files that been downloaded into the current nest    show-clutch  newt nest show-clutch larva  Outputs the details of the clutch named larva such as the github url where the remote sits, the constituent eggs and their versions     egg  Usage:      newt egg [command][flag] input1 input2  Available Commands:       list        List eggs in the current nest\n    checkdeps   Check egg dependencies\n    hunt        Search for egg from clutches\n    show        Show the contents of an egg.\n    install     Install an egg\n    remove      Remove an egg  Flags:      -h, --help=false: help for egg\n\nGlobal Flags:\n\n    -l, --loglevel= WARN : Log level, defaults to WARN.\n    -q, --quiet=false: Be quiet; only display error output.\n    -s, --silent=false: Be silent; don't output anything.\n    -v, --verbose=false: Enable verbose output when executing commands.  Description     Sub-command  Explanation      list  List all the eggs in the current nest. The output shows the name, version, path, and any additional attributes of each egg in the nest such as dependencies, capabilities, and linker scripts. The newt command gets the attributes of each egg from the corresponsing egg.yml description file.    checkdeps  Resolve all dependencies in the local nest. This command goes through all eggs currently installed, checks their dependencies, and prints any unresolved dependencies between eggs.    hunt  Hunts for an egg, specified by  input1  The local nest, along with all remote nests (clutches) are searched. All matched eggs are shown along with the clutch informaton. Installed eggs are called out as such. The command can be invoked from anywhere in the nest.    show  Show the contents of the egg named  input2 found in the clutch named  input1  The clutch name is optional; if only the egg name is given as the argument it is resolved using all the clutches installed in the current nest. If the egg is present in multiple clutches it will list all of them along with the clutch information for each.    install  Install the egg specified by  input2 from the clutch named  input1  The command downloads the egg from the github repository using the URL in the clutch description file (typically donwloaded as 'input1@ .yml' in .nest/clutches). It also downloads all the dependencies (constituent eggs) as decribed in the egg's description file ('egg.yml') and installs all of them. The clutch name is optional. If only the egg name is given as the argument, the command looks for the egg name in all the clutches in the local nest and installs accordingly. An egg is installed by this command only if it has not already been installed.    remove  Remove an egg named  input2 from clutch  input1  if clutch is specified. Otherwise only one input required - that of the name of the egg to be removed from the local nest.     Command-specific flags     Sub-command  Available flags  Explanation      install  -b, --branch=\" \"  Installs the eggs from the branch name or tag of the clutch specified     Examples     Sub-command  Usage  Explanation      list  newt egg list  CList all of the eggs in the current nest and the details of the eggs.    checkdeps  newt egg checkdeps  Checks all the dependencies between eggs in the nest. Lists any unresolved dependencies.    hunt  newt egg hunt blinky  Hunts for the egg named 'blinky'. The command can be invoked from anywhere in the nest. Results show if the egg is installed and which clutch, if any, has the egg.    show  newt egg show larva libs/os  Show the contents of the egg named 'libs/os' in the clutch named larva. The contents are essentially derived from the egg's 'egg.yml' file.    install  newt egg install hw/bsp/stm32f3discovery  Downloads and installs the egg named \"stm32f3discovery\" (specified with its full path name inside the remote nest) along with all its dependencies from the remote nest on github. Since no clutch is specified, the URL for the remote nest in the clutch description file found in the local nest (in .nest/clutches for the project) is used.    remove  newt egg remove larva blinky  Removes the egg named blinky only from the clutch named larva    remove  newt egg remove blinky  Removes the egg named blinky from the local nest     target  Usage:  Usage:       newt target [command] input1 [flag1] [flag2]  Available Commands:       set         Set target configuration variable\n    unset       Unset target configuration variable\n    delete      Delete target\n    create      Create a target\n    show        View target configuration variables\n    build       Build target\n    test        Test target\n    export      Export target\n    import      Import target\n    download    Download image to target\n    debug       Download image to target and start an openocd/gdb session  Flags:      -h, --help=false: help for target  Global Flags:      -l, --loglevel= WARN : Log level, defaults to WARN.\n    -q, --quiet=false: Be quiet; only display error output.\n    -s, --silent=false: Be silent; don't output anything.\n    -v, --verbose=false: Enable verbose output when executing commands.  Description     Sub-command  Explanation      set  Set attributes of the target. Currently the list of possible attributes are: arch, compiler, compiler_def, project, bsp, egg, identities, capabilities, dependencies, cflags, lflags  Typically only the first 5 need to be set for a hardware target. For a simulated target, e.g. for software testing purposes,  arch=sim   compiler=sim  and  egg= egg name to be tested  You cannot set both the project and egg for a target.    unset  Unset attributes of the target in its configuration.    delete  Deletes only the description for the target. Does not delete the target directory with associated binaries. If you want to clean out the binaries, list files, and executables use newt target build  target-name  clean before  deleting the target!    create  Creates a target description or build definition by the name  input1  By default it assigns the sim (simulator) architecture to it which allows you to build new projects and software on your native OS and try it out.    show  Display the configuration defined for the target named  input1  If no  input1 is specified then show the details for all the targets in the nest.    build  Build the source code into an image that can be loaded on the hardware associated with the target named  input1 to do the application enabled by the 'project' associated with that target (via the target definition). It creates 'bin/' and 'bin/ /' subdirectories inside the base directory for the project, compiles and generates binaries and executables, and places them in 'bin/ /.    test  Test an egg on the target named  input1  The egg is either supplied as an argument to the command line invocation of  newt target test or added as part of the target definition. If only the target is specified as  input1  then the egg in the target's definition is automatically chosen to be tested. You currently cannot test an entire project on a hardware target. The test command is envisioned for use if one or two eggs gets updated and each needs to be tested against a target. Alternatively, a script may be written for a series of tests on several eggs.    export  Exports the configurations of the specified target  input1  If -a or -export-all flag is used, then all targets are exported and printed out to standard out. You may redirect the output to a file.    import  Import one or more target configuration from standard input or a file. Each target starts with  @target= target-name followed by the attributes. The list of targets should end with  @endtargets    size  Outputs the RAM and flash consumption by the components of the specified target  input1    download  Downloads the binary executable  target-name .elf.bin to the board.    debug  Downloads the binary executable  target-name .elf.bin to the board and starts up the openocd/gdb combination session. gdb takes over the terminal.     Command-specific flags     Sub-command  Available flags  Explanation      build  clean  All the binaries and object files for the specified target will be removed. The subdirectory named after the specified target within that project is removed.    build clean  all  All the binaries and object files for all targets are removed, and subdirectories of all targets for the project are removed. However, the entire repository is not emptied since any eggs or projects that the specified target doesn't reference are not touched.    export  -a, -export-all  Export all targets.  input1 is not necessary when this flag is used.    import  -a, -import-all  Import all targets typed into standard input or redirected from a file.     Examples     Sub-command  Usage  Explanation      set  newt target set myblinky compiler=arm-none-eabi-m4  Set the compiler for the 'myblinky' target to the gcc compiler for embedded ARM chips.    unset  newt target unset myblinky compiler  Remove the setting for the compiler for the 'myblinky' target.    delete  newt target delete myblinky  Delete the target description for the target named 'myblinky'. Note that it does not remove any binaries or clean out the directory for this target.    create  newt target create blink_f3disc  Create a new target description by the name 'blink_f3disc'. The architecture is 'sim' by default and can be changed using subcommand 'set' above.    show  newt target show myblinky  Show the target attributes set for 'myblinky'    build  newt target build blink_f3disc  Compile the source code for the target named blink_f3disc and generate binaries that can be loaded into the target hardware.    test  newt target test test_target egg=libs/os  Tests the egg named 'libs/os' against the target named 'test_target'    export  newt target export -a   my_exports.txt  Export all build targets from the current nest, and redirect output to a file named 'my_exports.txt'.    export  newt target export -export-all  Export all build targets from the current nest, and print them to standard output on the screen.    export  newt target export my_target  Export only target named 'my_target' and print it to standard output on the screen.    import  newt target import ex_tgt_1   exported_targets.txt  Imports the target configuration for 'ex_tgt_1' in 'exported_targets.txt'.    import  newt target import -a   in_targets.txt  Imports all the targets specified in the file named  in_targets.txt  A sample file is shown after this table.    size  newt target size blink_nordic  Inspects and lists the RAM and Flash memory use by each component (object files and libraries) of the target.    download  newt target -v -lVERBOSE download blinky  Downloads  blinky.elf.bin to the hardware in verbose mode with logging turned on at VERBOSE level.    debug  newt target debug blinky  Downloads  blinky.elf.bin to the hardware, opens up a gdb session with  blinky.elf in the terminal, and halts for further input in gdb.     Example content for  in_targets.txt  file used for importing targets  test3  and  test4 .     @target=test3 \nproject=blinked \narch=sim \ncompiler_def=debug \ncompiler=arm-none-eabi-m4 \n@target=test4 \nproject=super_blinky \narch=sim \ncompiler_def=debug \ncompiler=arm-none-eabi-m4 \n@endtargets", 
            "title": "Command List"
        }, 
        {
            "location": "/os/mynewt_os/", 
            "text": "Mynewt OS\n\n\nInsert introduction here  \n\n\nReal-Time Kernel \n\n\nDescription\n\n\nReal-Time OS \n\n\nDescription\n\n\nInsert topic of your choice\n\n\nDescription\n\n\nFeatures\n\n\n\n\n\n\nScheduler/context switching\n\n\nTime\n\n\nTasks\n\n\nEvent queues/callouts\n\n\nSemaphores\n\n\nMutexes\n\n\nMemory pools\n\n\nHeap\n\n\nMbufs\n\n\nSanity\n\n\nPorting OS to other platforms\n\n\n\n\nOS Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_idle_task\n\n\nos_started\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\n os_idle_task\n\n\n    void\n    os_idle_task(void *arg)\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n os_started\n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here", 
            "title": "Overview"
        }, 
        {
            "location": "/os/mynewt_os/#mynewt-os", 
            "text": "Insert introduction here", 
            "title": "Mynewt OS"
        }, 
        {
            "location": "/os/mynewt_os/#real-time-kernel", 
            "text": "Description", 
            "title": "Real-Time Kernel "
        }, 
        {
            "location": "/os/mynewt_os/#real-time-os", 
            "text": "Description", 
            "title": "Real-Time OS "
        }, 
        {
            "location": "/os/mynewt_os/#insert-topic-of-your-choice", 
            "text": "Description", 
            "title": "Insert topic of your choice"
        }, 
        {
            "location": "/os/mynewt_os/#features", 
            "text": "Scheduler/context switching  Time  Tasks  Event queues/callouts  Semaphores  Mutexes  Memory pools  Heap  Mbufs  Sanity  Porting OS to other platforms", 
            "title": "Features"
        }, 
        {
            "location": "/os/mynewt_os/#os-functions", 
            "text": "The functions available in this OS feature are:   os_idle_task  os_started  add the rest", 
            "title": "OS Functions"
        }, 
        {
            "location": "/os/mynewt_os/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/os/mynewt_os/#os_idle_task", 
            "text": "void\n    os_idle_task(void *arg)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " os_idle_task"
        }, 
        {
            "location": "/os/mynewt_os/#os_started", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " os_started"
        }, 
        {
            "location": "/os/mynewt_os/#next_one", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " next_one "
        }, 
        {
            "location": "/os/context_switch/", 
            "text": "Scheduler/Context Switching\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe scheduler here\n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in the scheduler are:\n\n\n\n\nos_sched_insert\n\n\nos_sched_walk\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\n os_sched_insert\n\n\n    os_error_t\n    os_sched_insert(struct os_task *t)\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n os_sched_walk\n\n\nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n next_one \n\n\nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here", 
            "title": "Scheduler/Context Switching"
        }, 
        {
            "location": "/os/context_switch/#schedulercontext-switching", 
            "text": "Insert synopsis here", 
            "title": "Scheduler/Context Switching"
        }, 
        {
            "location": "/os/context_switch/#description", 
            "text": "Describe scheduler here", 
            "title": "Description"
        }, 
        {
            "location": "/os/context_switch/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/context_switch/#list-of-functions", 
            "text": "The functions available in the scheduler are:   os_sched_insert  os_sched_walk  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/context_switch/#function-reference", 
            "text": "os_sched_insert      os_error_t\n    os_sched_insert(struct os_task *t)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here     os_sched_walk  Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here     next_one   Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": "Function Reference"
        }, 
        {
            "location": "/os/time/", 
            "text": "Time\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe OS feature here \n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_time_get\n\n\nos_time_tick\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\n os_time_get \n\n\n    os_time_t  \n    os_time_get(void) \n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n os_time_tick \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here", 
            "title": "Time"
        }, 
        {
            "location": "/os/time/#time", 
            "text": "Insert synopsis here", 
            "title": "Time"
        }, 
        {
            "location": "/os/time/#description", 
            "text": "Describe OS feature here", 
            "title": "Description"
        }, 
        {
            "location": "/os/time/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/time/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_time_get  os_time_tick  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/time/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/os/time/#os_time_get", 
            "text": "os_time_t  \n    os_time_get(void)    Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " os_time_get "
        }, 
        {
            "location": "/os/time/#os_time_tick", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": " os_time_tick "
        }, 
        {
            "location": "/os/time/#next_one", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": " next_one "
        }, 
        {
            "location": "/os/task/", 
            "text": "Tasks\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe OS feature here \n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\n_clear_stack\n\n\nos_task_next_id\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\n _clear_stack \n\n\nstatic void\n    _clear_stack(os_stack_t *stack_bottom, int size) \n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n os_task_next_id \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here", 
            "title": "Tasks"
        }, 
        {
            "location": "/os/task/#tasks", 
            "text": "Insert synopsis here", 
            "title": "Tasks"
        }, 
        {
            "location": "/os/task/#description", 
            "text": "Describe OS feature here", 
            "title": "Description"
        }, 
        {
            "location": "/os/task/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/task/#list-of-functions", 
            "text": "The functions available in this OS feature are:   _clear_stack  os_task_next_id  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/task/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/os/task/#_clear_stack", 
            "text": "static void\n    _clear_stack(os_stack_t *stack_bottom, int size)    Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " _clear_stack "
        }, 
        {
            "location": "/os/task/#os_task_next_id", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " os_task_next_id "
        }, 
        {
            "location": "/os/task/#next_one", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " next_one "
        }, 
        {
            "location": "/os/event_queue/", 
            "text": "Event Queues\n\n\nEvent queue is a way of serializing events arring to a task. This makes it easy to queue processing to happen inside task's context. This would be done either from an interrupt handler, or from another task.\n\n\nEvents arrive in a form of a data structure \nstruct os_event\n.\n\n\nDescription\n\n\nEvents are in form of a data structure \nstruct os_event\n, and they are queued to data structure \nstruct os_eventq\n.\n\n\nQueue must be initialized before trying to add events to it. This is done using \nos_eventq_init()\n.\n\n\nCommon way of using event queues is to have a task loop while calling \nos_eventq_get()\n, waiting for work to do.\nOther tasks (or interrupts) then call \nos_eventq_put()\n to wake it up. Once event has been queued task waiting on that queue is woken up, and will get a pointer to queued event structure.\nProcessing task would then act according to event type.\n\n\nWhen \nos_event\n is queued, it should not be freed until processing task is done with it.\n\n\nIt is assumed that there is only one task consuming events from an event queue. Only one task should be sleeping on a particular \nos_eventq\n at a time.\n\n\nNote that os_callout subsystem assumes that event queue is used as the wakeup mechanism.\n\n\nData structures\n\n\nstruct os_event {\n    uint8_t ev_queued;\n    uint8_t ev_type;\n    void *ev_arg;\n    STAILQ_ENTRY(os_event) ev_next;\n};\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nev_queued\n\n\nInternal field, which tells whether event is linked into an \nos_eventq\n already\n\n\n\n\n\n\nev_type\n\n\nType of an event. This should be unique, as it should be used by processing task to figure out what the event means\n\n\n\n\n\n\nev_arg\n\n\nCan be used further as input to task processing this event\n\n\n\n\n\n\nev_next\n\n\nLinkage attaching this event to an event queue\n\n\n\n\n\n\n\n\nstruct os_eventq {\n    struct os_task *evq_task;\n    STAILQ_HEAD(, os_event) evq_list;\n};\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nevq_task\n\n\nPointer to task if there is task sleeping on \nos_eventq_get()\n\n\n\n\n\n\nevq_list\n\n\nQueue head for list of events in this queue\n\n\n\n\n\n\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_eventq_init\n\n\nos_eventq_put\n\n\nos_eventq_put2\n\n\nos_eventq_get\n\n\nos_eventq_remove\n\n\n\n\nFunction Reference\n\n\n\n\n os_eventq_init\n\n\n   void\n    os_eventq_init(struct os_eventq *evq)\n\n\n\n\nInitializes \nstruct os_eventq\n, making it ready for use.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nevq\n\n\nPointer to event queue getting initialized\n\n\n\n\n\n\n\n\nReturned values\n\n\nNone\n\n\nNotes\n\n\nUsually done at subsystem init time; before OS has been started, and before interrupts generating events have been enabled.\n\n\nExample\n\n\n\nThis initializes event queue used by newtmgr task.\n\n\nstruct os_eventq g_nmgr_evq;\n\nint\nnmgr_task_init(uint8_t prio, os_stack_t *stack_ptr, uint16_t stack_len)\n{\n    /* variable declarations here */\n\n    os_eventq_init(\ng_nmgr_evq);\n\n    /* initialization continues here */\n}\n\n\n\n\n\n\n os_eventq_put\n\n\nvoid\nos_eventq_put(struct os_eventq *evq, struct os_event *ev)\n\n\n\n\nQueues an event to tail of the event queue.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nevq\n\n\nQueue where event is being placed\n\n\n\n\n\n\nev\n\n\nEvent which is being queued\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nFunctionality is of \nos_eventq_put2()\n, but this is to be called from a task context only.\n\n\nExample\n\n\n\nThis is used to pass info about an event to a task handling it.\n\n\n    /* Get an event structure off the queue */\n    ev = (struct os_event *)os_memblock_get(\ng_hci_os_event_pool);\n    if (!ev) {\n        err = os_memblock_put(\ng_hci_cmd_pool, hci_ev);\n        assert(err == OS_OK);\n        return -1;\n    }\n\n    /* Fill out the event and post to Link Layer */\n    ev-\nev_queued = 0;\n    ev-\nev_type = BLE_HOST_HCI_EVENT_CTLR_EVENT;\n    ev-\nev_arg = hci_ev;\n    os_eventq_put(\nble_hs_evq, ev);\n\n\n\n\n\n\n\n os_eventq_put2\n\n\nvoid\nos_eventq_put2(struct os_eventq *evq, struct os_event *ev, int isr)\n\n\n\n\nQueues an event to tail of the event queue.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nevq\n\n\nQueue where event is being placed\n\n\n\n\n\n\nev\n\n\nEvent which is being queued\n\n\n\n\n\n\nisr\n\n\nTells whether call is being made from within interrupt handler or not\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nIf the event has already been queued, nothing happens. Including event's relative position within the queue itself.\n\n\nThis can be called either from interrupt handler (in which case \nisr\n should be set to 1), or from another task context (in which case *isr should be set as 0).\n\n\nExample\n\n\nThis wakes up the task waiting on task1_evq, which processes console input (console input comes from UART, and is passed in in interrupt context).\n\n\nstatic void\nmy_cons_input(int full_line)\n{\n    os_eventq_put2(\ntask1_evq, \ncons_ev, 1);\n}\n\n\n\n\n\n\n os_eventq_get\n\n\nvoid\nos_eventq_get(struct os_eventq *evq)\n\n\n\n\nFetches the first event from a queue. Task will sleep until something gets queued.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nevq\n\n\nQueue to wait on\n\n\n\n\n\n\n\n\nReturned values\n\n\nWill return with a pointer to first \nstruct event\n which is in the queue.\n\n\nNotes\n\n\nExample\n\n\nMain loop of an example task.\n\n\n    while (1) {\n        ev = os_eventq_get(\ntask1_evq);\n        assert(ev);\n        if (ev-\nev_type == CONS_EV_TYPE) {\n            /* XXX do stuff */\n        }\n    }\n\n\n\n\n\n\n\n os_eventq_remove\n\n\nvoid\nos_eventq_remove(struct os_eventq *evq, struct os_event *ev)\n\n\n\n\nRemoves an event which has been placed in a queue.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nevq\n\n\nQueue where event is being removed from\n\n\n\n\n\n\nev\n\n\nEvent which is being removed\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nExample\n\n\n\nThis is from os_callout_stop(). User wants to stop a callout from getting passed to a task. If the event has already been queued, then remove it before it is seen.\n\n\n    if (c-\nc_evq) {\n        os_eventq_remove(c-\nc_evq, \nc-\nc_ev);\n    }", 
            "title": "Event Queues"
        }, 
        {
            "location": "/os/event_queue/#event-queues", 
            "text": "Event queue is a way of serializing events arring to a task. This makes it easy to queue processing to happen inside task's context. This would be done either from an interrupt handler, or from another task.  Events arrive in a form of a data structure  struct os_event .", 
            "title": "Event Queues"
        }, 
        {
            "location": "/os/event_queue/#description", 
            "text": "Events are in form of a data structure  struct os_event , and they are queued to data structure  struct os_eventq .  Queue must be initialized before trying to add events to it. This is done using  os_eventq_init() .  Common way of using event queues is to have a task loop while calling  os_eventq_get() , waiting for work to do.\nOther tasks (or interrupts) then call  os_eventq_put()  to wake it up. Once event has been queued task waiting on that queue is woken up, and will get a pointer to queued event structure.\nProcessing task would then act according to event type.  When  os_event  is queued, it should not be freed until processing task is done with it.  It is assumed that there is only one task consuming events from an event queue. Only one task should be sleeping on a particular  os_eventq  at a time.  Note that os_callout subsystem assumes that event queue is used as the wakeup mechanism.", 
            "title": "Description"
        }, 
        {
            "location": "/os/event_queue/#data-structures", 
            "text": "struct os_event {\n    uint8_t ev_queued;\n    uint8_t ev_type;\n    void *ev_arg;\n    STAILQ_ENTRY(os_event) ev_next;\n};     Element  Description      ev_queued  Internal field, which tells whether event is linked into an  os_eventq  already    ev_type  Type of an event. This should be unique, as it should be used by processing task to figure out what the event means    ev_arg  Can be used further as input to task processing this event    ev_next  Linkage attaching this event to an event queue     struct os_eventq {\n    struct os_task *evq_task;\n    STAILQ_HEAD(, os_event) evq_list;\n};     Element  Description      evq_task  Pointer to task if there is task sleeping on  os_eventq_get()    evq_list  Queue head for list of events in this queue", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/event_queue/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_eventq_init  os_eventq_put  os_eventq_put2  os_eventq_get  os_eventq_remove", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/event_queue/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/os/event_queue/#os_eventq_init", 
            "text": "void\n    os_eventq_init(struct os_eventq *evq)  Initializes  struct os_eventq , making it ready for use.  Arguments     Arguments  Description      evq  Pointer to event queue getting initialized     Returned values  None  Notes  Usually done at subsystem init time; before OS has been started, and before interrupts generating events have been enabled.  Example  \nThis initializes event queue used by newtmgr task.  struct os_eventq g_nmgr_evq;\n\nint\nnmgr_task_init(uint8_t prio, os_stack_t *stack_ptr, uint16_t stack_len)\n{\n    /* variable declarations here */\n\n    os_eventq_init( g_nmgr_evq);\n\n    /* initialization continues here */\n}", 
            "title": " os_eventq_init"
        }, 
        {
            "location": "/os/event_queue/#os_eventq_put", 
            "text": "void\nos_eventq_put(struct os_eventq *evq, struct os_event *ev)  Queues an event to tail of the event queue.  Arguments     Arguments  Description      evq  Queue where event is being placed    ev  Event which is being queued     Returned values  N/A  Notes  Functionality is of  os_eventq_put2() , but this is to be called from a task context only.  Example  \nThis is used to pass info about an event to a task handling it.      /* Get an event structure off the queue */\n    ev = (struct os_event *)os_memblock_get( g_hci_os_event_pool);\n    if (!ev) {\n        err = os_memblock_put( g_hci_cmd_pool, hci_ev);\n        assert(err == OS_OK);\n        return -1;\n    }\n\n    /* Fill out the event and post to Link Layer */\n    ev- ev_queued = 0;\n    ev- ev_type = BLE_HOST_HCI_EVENT_CTLR_EVENT;\n    ev- ev_arg = hci_ev;\n    os_eventq_put( ble_hs_evq, ev);", 
            "title": " os_eventq_put"
        }, 
        {
            "location": "/os/event_queue/#os_eventq_put2", 
            "text": "void\nos_eventq_put2(struct os_eventq *evq, struct os_event *ev, int isr)  Queues an event to tail of the event queue.  Arguments     Arguments  Description      evq  Queue where event is being placed    ev  Event which is being queued    isr  Tells whether call is being made from within interrupt handler or not     Returned values  N/A  Notes  If the event has already been queued, nothing happens. Including event's relative position within the queue itself.  This can be called either from interrupt handler (in which case  isr  should be set to 1), or from another task context (in which case *isr should be set as 0).  Example  This wakes up the task waiting on task1_evq, which processes console input (console input comes from UART, and is passed in in interrupt context).  static void\nmy_cons_input(int full_line)\n{\n    os_eventq_put2( task1_evq,  cons_ev, 1);\n}", 
            "title": " os_eventq_put2"
        }, 
        {
            "location": "/os/event_queue/#os_eventq_get", 
            "text": "void\nos_eventq_get(struct os_eventq *evq)  Fetches the first event from a queue. Task will sleep until something gets queued.  Arguments     Arguments  Description      evq  Queue to wait on     Returned values  Will return with a pointer to first  struct event  which is in the queue.  Notes  Example  Main loop of an example task.      while (1) {\n        ev = os_eventq_get( task1_evq);\n        assert(ev);\n        if (ev- ev_type == CONS_EV_TYPE) {\n            /* XXX do stuff */\n        }\n    }", 
            "title": " os_eventq_get"
        }, 
        {
            "location": "/os/event_queue/#os_eventq_remove", 
            "text": "void\nos_eventq_remove(struct os_eventq *evq, struct os_event *ev)  Removes an event which has been placed in a queue.  Arguments     Arguments  Description      evq  Queue where event is being removed from    ev  Event which is being removed     Returned values  N/A  Notes  Example  \nThis is from os_callout_stop(). User wants to stop a callout from getting passed to a task. If the event has already been queued, then remove it before it is seen.      if (c- c_evq) {\n        os_eventq_remove(c- c_evq,  c- c_ev);\n    }", 
            "title": " os_eventq_remove"
        }, 
        {
            "location": "/os/semaphore/", 
            "text": "Semaphore\n\n\nA semaphore is a structure used for gaining exclusive access (much like a mutex), synchronizing task operations and/or use in a \"producer/consumer\" roles. Semaphores like the ones used by the myNewt OS are called \"counting\" semaphores as they are allowed to have more than one token (explained below).\n\n\nDescription\n\n\nA semaphore is a fairly simple construct consisting of a queue for waiting tasks and the number of tokens currently owned by the semaphore. A semaphore can be obtained as long as there are tokens in the semaphore. Any task can add tokens to the semaphore and any task can request the semaphore, thereby removing tokens. When creating the semaphore, the initial number of tokens can be set as well.\n\n\nWhen used for exclusive access to a shared resource the semaphore only needs a single token. In this case, a single task \"creates\" the semaphore by calling \nos_sem_init\n with a value of one (1) for the token. When a task desires exclusive access to the shared resource it requests the semaphore by calling \nos_sem_pend\n. If there is a token the requesting task will acquire the semaphore and continue operation. If no tokens are available the task will be put to sleep until there is a token. A common \"problem\" with using a semaphore for exclusive access is called \npriority inversion\n. Consider the following scenario: a high and low priority task both share a resource which is locked using a semaphore. If the low priority task obtains the semaphore and then the high priority task requests the semaphore, the high priority task is now blocked until the low priority task releases the semaphore. Now suppose that there are tasks between the low priority task and the high priority task that want to run. These tasks will preempt the low priority task which owns the semaphore. Thus, the high priority task is blocked waiting for the low priority task to finish using the semaphore but the low priority task cannot run since other tasks are running. Thus, the high priority tasks is \"inverted\" in priority; in effect running at a much lower priority as normally it would preempt the other (lower priority) tasks. If this is an issue a mutex should be used instead of a semaphore.\n\n\nSemaphores can also be used for task synchronization. A simple example of this would be the following. A task creates a semaphore and initializes it with no tokens. The task then waits on the semaphore, and since there are no tokens, the task is put to sleep. When other tasks want to wake up the sleeping task they simply add a token by calling \nos_sem_release\n. This will cause the sleeping task to wake up (instantly if no other higher priority tasks want to run).\n\n\nThe other common use of a counting semaphore is in what is commonly called a \"producer/consumer\" relationship. The producer adds tokens (by calling \nos_sem_release\n) and the consumer consumes them by calling \nos_sem_pend\n. In this relationship, the producer has work for the consumer to do. Each token added to the semaphore will cause the consumer to do whatever work is required. A simple example could be the following: every time a button is pressed there is some work to do (ring a bell). Each button press causes the producer to add a token. Each token consumed rings the bell. There will exactly the same number of bell rings as there are button presses. In other words, each call to \nos_sem_pend\n subtracts exactly one token and each call to \nos_sem_release\n adds exactly one token.\n\n\nData structures\n\n\nstruct os_sem\n{\n    SLIST_HEAD(, os_task) sem_head;     /* chain of waiting tasks */\n    uint16_t    _pad;\n    uint16_t    sem_tokens;             /* # of tokens */\n};\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsem_head\n\n\nQueue head for list of tasks waiting on semaphore\n\n\n\n\n\n\n_pad\n\n\nPadding for alignment\n\n\n\n\n\n\nsem_tokens\n\n\nCurrent number of tokens\n\n\n\n\n\n\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_sem_init\n\n\nos_sem_release\n\n\nos_sem_pend\n\n\nos_sem_delete\n\n\n\n\nFunction Reference\n\n\n\n\n os_sem_init\n\n\nos_error_t os_sem_init(struct os_sem *sem, uint16_t tokens)    \n\n\n\n\nInitialize a semaphore with a given number of tokens. Should be called before the semaphore is used.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*sem\n\n\nPointer to semaphore\n\n\n\n\n\n\ntokens\n\n\nInitial number of tokens allocated to semaphore\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_INVALID_PARM: returned when *sem is NULL on entry.\n\n\nOS_OK: semaphore initialized successfully.\n\n\nNotes\n\n\n\n\nExample\n\n\nThe following example shows how to initialize a semaphore used for exclusive access.\n\n\nstruct os_mutex g_os_sem;\nos_error_t err;\n\nerr = os_sem_init(\ng_os_sem, 1);\nassert(err == OS_OK);\n\n\n\n\n\n\n os_sem_release \n\n\nos_error_t os_sem_release(struct os_sem *sem)\n\n\n\n\nRelease a semaphore that you are holding. This adds a token to the semaphore.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*sem\n\n\nPointer to semaphore\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_NOT_STARTED: Called before os has been started.\n\n\nOS_INVALID_PARM: returned when *sem is NULL on entry.\n\n\nOS_OK: semaphore released successfully.\n\n\nNotes\n\n\nExample\n\n\nstruct os_sem g_os_sem;\nos_error_t err;\n\nerr = os_sem_pend(\ng_os_sem, OS_TIMEOUT_NEVER);\nassert(err == OS_OK);\n\n/* Perform operations requiring semaphore lock */\n\nerr = os_sem_release(\ng_os_sem);\nassert(err == OS_OK);\n\n\n\n\n\n\n os_sem_pend \n\n\nos_error_t os_sem_pend(struct os_sem *sem, uint32_t timeout)\n\n\n\n\nWait for a semaphore for a given amount of time.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*sem\n\n\nPointer to semaphore\n\n\n\n\n\n\ntimeout\n\n\nAmount of time, in os ticks, to wait for semaphore. A value of 0 means no wait. A value of 0xFFFFFFFF means wait forever.\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_INVALID_PARM: returned when *sem is NULL on entry.\n\n\nOS_OK: semaphore acquired successfully.\n\n\nOS_TIMEOUT: the semaphore was not available within the timeout specified.\n\n\nOS_NOT_STARTED: Attempt to release a semaphore before os started.\n\n\nNotes\n\n\nIf a timeout of 0 is used and the function returns OS_TIMEOUT, the semaphore was not available and was not acquired. No release of the semaphore should occur and the calling task does not own the semaphore.\n\n\nExample\n\n\nstruct os_sem g_os_sem;\nos_error_t err;\n\nerr = os_sem_pend(\ng_os_sem, OS_TIMEOUT_NEVER);\nassert(err == OS_OK);\n\n/* Perform operations requiring semaphore lock */\n\nerr = os_sem_release(\ng_os_sem);\nassert(err == OS_OK);\n\n\n\n\n\n\n\n os_sem_delete \n\n\nos_error_t os_sem_delete(struct os_sem *sem)\n\n\n\n\nDelete a semaphore\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*sem\n\n\nPointer to semaphore\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_INVALID_PARM: returned when *sem is NULL on entry.\n\n\nOS_OK: semaphore deleted successfully.\n\n\nOS_NOT_STARTED: Attempt to release a semaphore before os started.\n\n\nNotes\n\n\nCare must be taken when deleting a semaphore as deleting a semaphore used by other tasks could causes unexpected/unwanted behavior.\n\n\nExample\n\n\nstruct os_sem g_os_sem;\nos_error_t err;\n\nerr = os_sem_delete(\ng_os_sem);\nassert(err == OS_OK);", 
            "title": "Semaphores"
        }, 
        {
            "location": "/os/semaphore/#semaphore", 
            "text": "A semaphore is a structure used for gaining exclusive access (much like a mutex), synchronizing task operations and/or use in a \"producer/consumer\" roles. Semaphores like the ones used by the myNewt OS are called \"counting\" semaphores as they are allowed to have more than one token (explained below).", 
            "title": "Semaphore"
        }, 
        {
            "location": "/os/semaphore/#description", 
            "text": "A semaphore is a fairly simple construct consisting of a queue for waiting tasks and the number of tokens currently owned by the semaphore. A semaphore can be obtained as long as there are tokens in the semaphore. Any task can add tokens to the semaphore and any task can request the semaphore, thereby removing tokens. When creating the semaphore, the initial number of tokens can be set as well.  When used for exclusive access to a shared resource the semaphore only needs a single token. In this case, a single task \"creates\" the semaphore by calling  os_sem_init  with a value of one (1) for the token. When a task desires exclusive access to the shared resource it requests the semaphore by calling  os_sem_pend . If there is a token the requesting task will acquire the semaphore and continue operation. If no tokens are available the task will be put to sleep until there is a token. A common \"problem\" with using a semaphore for exclusive access is called  priority inversion . Consider the following scenario: a high and low priority task both share a resource which is locked using a semaphore. If the low priority task obtains the semaphore and then the high priority task requests the semaphore, the high priority task is now blocked until the low priority task releases the semaphore. Now suppose that there are tasks between the low priority task and the high priority task that want to run. These tasks will preempt the low priority task which owns the semaphore. Thus, the high priority task is blocked waiting for the low priority task to finish using the semaphore but the low priority task cannot run since other tasks are running. Thus, the high priority tasks is \"inverted\" in priority; in effect running at a much lower priority as normally it would preempt the other (lower priority) tasks. If this is an issue a mutex should be used instead of a semaphore.  Semaphores can also be used for task synchronization. A simple example of this would be the following. A task creates a semaphore and initializes it with no tokens. The task then waits on the semaphore, and since there are no tokens, the task is put to sleep. When other tasks want to wake up the sleeping task they simply add a token by calling  os_sem_release . This will cause the sleeping task to wake up (instantly if no other higher priority tasks want to run).  The other common use of a counting semaphore is in what is commonly called a \"producer/consumer\" relationship. The producer adds tokens (by calling  os_sem_release ) and the consumer consumes them by calling  os_sem_pend . In this relationship, the producer has work for the consumer to do. Each token added to the semaphore will cause the consumer to do whatever work is required. A simple example could be the following: every time a button is pressed there is some work to do (ring a bell). Each button press causes the producer to add a token. Each token consumed rings the bell. There will exactly the same number of bell rings as there are button presses. In other words, each call to  os_sem_pend  subtracts exactly one token and each call to  os_sem_release  adds exactly one token.", 
            "title": "Description"
        }, 
        {
            "location": "/os/semaphore/#data-structures", 
            "text": "struct os_sem\n{\n    SLIST_HEAD(, os_task) sem_head;     /* chain of waiting tasks */\n    uint16_t    _pad;\n    uint16_t    sem_tokens;             /* # of tokens */\n};     Element  Description      sem_head  Queue head for list of tasks waiting on semaphore    _pad  Padding for alignment    sem_tokens  Current number of tokens", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/semaphore/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_sem_init  os_sem_release  os_sem_pend  os_sem_delete", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/semaphore/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/os/semaphore/#os_sem_init", 
            "text": "os_error_t os_sem_init(struct os_sem *sem, uint16_t tokens)      Initialize a semaphore with a given number of tokens. Should be called before the semaphore is used.  Arguments     Arguments  Description      *sem  Pointer to semaphore    tokens  Initial number of tokens allocated to semaphore     Returned values  OS_INVALID_PARM: returned when *sem is NULL on entry.  OS_OK: semaphore initialized successfully.  Notes   Example  The following example shows how to initialize a semaphore used for exclusive access.  struct os_mutex g_os_sem;\nos_error_t err;\n\nerr = os_sem_init( g_os_sem, 1);\nassert(err == OS_OK);", 
            "title": " os_sem_init"
        }, 
        {
            "location": "/os/semaphore/#os_sem_release", 
            "text": "os_error_t os_sem_release(struct os_sem *sem)  Release a semaphore that you are holding. This adds a token to the semaphore.  Arguments     Arguments  Description      *sem  Pointer to semaphore     Returned values  OS_NOT_STARTED: Called before os has been started.  OS_INVALID_PARM: returned when *sem is NULL on entry.  OS_OK: semaphore released successfully.  Notes  Example  struct os_sem g_os_sem;\nos_error_t err;\n\nerr = os_sem_pend( g_os_sem, OS_TIMEOUT_NEVER);\nassert(err == OS_OK);\n\n/* Perform operations requiring semaphore lock */\n\nerr = os_sem_release( g_os_sem);\nassert(err == OS_OK);", 
            "title": " os_sem_release "
        }, 
        {
            "location": "/os/semaphore/#os_sem_pend", 
            "text": "os_error_t os_sem_pend(struct os_sem *sem, uint32_t timeout)  Wait for a semaphore for a given amount of time.  Arguments     Arguments  Description      *sem  Pointer to semaphore    timeout  Amount of time, in os ticks, to wait for semaphore. A value of 0 means no wait. A value of 0xFFFFFFFF means wait forever.     Returned values  OS_INVALID_PARM: returned when *sem is NULL on entry.  OS_OK: semaphore acquired successfully.  OS_TIMEOUT: the semaphore was not available within the timeout specified.  OS_NOT_STARTED: Attempt to release a semaphore before os started.  Notes  If a timeout of 0 is used and the function returns OS_TIMEOUT, the semaphore was not available and was not acquired. No release of the semaphore should occur and the calling task does not own the semaphore.  Example  struct os_sem g_os_sem;\nos_error_t err;\n\nerr = os_sem_pend( g_os_sem, OS_TIMEOUT_NEVER);\nassert(err == OS_OK);\n\n/* Perform operations requiring semaphore lock */\n\nerr = os_sem_release( g_os_sem);\nassert(err == OS_OK);", 
            "title": " os_sem_pend "
        }, 
        {
            "location": "/os/semaphore/#os_sem_delete", 
            "text": "os_error_t os_sem_delete(struct os_sem *sem)  Delete a semaphore  Arguments     Arguments  Description      *sem  Pointer to semaphore     Returned values  OS_INVALID_PARM: returned when *sem is NULL on entry.  OS_OK: semaphore deleted successfully.  OS_NOT_STARTED: Attempt to release a semaphore before os started.  Notes  Care must be taken when deleting a semaphore as deleting a semaphore used by other tasks could causes unexpected/unwanted behavior.  Example  struct os_sem g_os_sem;\nos_error_t err;\n\nerr = os_sem_delete( g_os_sem);\nassert(err == OS_OK);", 
            "title": " os_sem_delete "
        }, 
        {
            "location": "/os/mutex/", 
            "text": "Mutex\n\n\nMutex is short for \"mutual exclusion\"; a mutex provides mutually exclusive access to a shared resource. A mutex provides \npriority inheritance\n in order to prevent \npriority inversion\n. Priority inversion occurs when a higher priority task is waiting on a resource owned by a lower priority task. Using a mutex, the lower priority task will inherit the highest priority of any task waiting on the mutex. \n\n\nDescription\n\n\nThe first order of business when using a mutex is to declare the mutex globally. The mutex needs to be initialized before it is used (see the examples). It is generally a good idea to initialize the mutex before tasks start running in order to avoid a task possibly using the mutex before it is initialized.\n\n\nWhen a task wants exclusive access to a shared resource it needs to obtain the mutex by calling \nos_mutex_pend\n. If the mutex is currently owned by a different task (a lower priority task), the requesting task will be put to sleep and the owners priority will be elevated to the priority of the requesting task. Note that multiple tasks can request ownership and the current owner is elevated to the highest priority of any task waitin on the mutex. When the task is done using the shared resource, it needs to release the mutex by called \nos_mutex_release\n. There needs to be one release per call to pend. Note that nested calls to \nos_mutex_pend\n are allowed but there needs to be one release per pend.\n\n\nThe following example will illustrate how priority inheritance works. In this example, the task number is the same as its priority. Remember that the lower the number, the higher the priority (i.e. priority 0 is higher priority than priority 1). Suppose that task 5 gets ownership of a mutex but is preempted by task 4. Task 4 attempts to gain ownership of the mutex but cannot as it is owned by task 5. Task 4 is put to sleep and task 5 is temporarily raised to priority 4. Before task 5 can release the mutex, task 3 runs and attempts to acquire the mutex. At this point, both task 3 and task 4 are waiting on the mutex (sleeping). Task 5 now runs at priority 3 (the highest priority of all the tasks waiting on the mutex). When task 5 finally releases the mutex it will be preempted as two higher priority tasks are waiting for it. \n\n\nNote that when multiple tasks are waiting on a mutex owned by another task, once the mutex is released the highest priority task waiting on the mutex is run. \n\n\nData structures\n\n\nstruct os_mutex\n{\n    SLIST_HEAD(, os_task) mu_head;\n    uint8_t     _pad;\n    uint8_t     mu_prio;\n    uint16_t    mu_level;\n    struct os_task *mu_owner;\n};\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmu_head\n\n\nQueue head for list of tasks waiting on mutex\n\n\n\n\n\n\n_pad\n\n\nPadding\n\n\n\n\n\n\nmu_prio\n\n\nDefault priority of owner of mutex. Used to reset priority of task when mutex released\n\n\n\n\n\n\nmu_level\n\n\nCall nesting level (for nested calls)\n\n\n\n\n\n\nmu_owner\n\n\nPointer to task structure which owns mutex\n\n\n\n\n\n\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_mutex_init\n\n\nos_mutex_release\n\n\nos_mutex_pend\n\n\nos_mutex_delete\n\n\n\n\nFunction Reference\n\n\n\n\nos_mutex_init\n\n\nos_error_t os_mutex_init(struct os_mutex *mu)\n\n\n\n\nInitialize the mutex. Must be called before the mutex can be used.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*mu\n\n\nPointer to mutex\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_INVALID_PARM: returned when *mu is NULL on entry.\n\n\nOS_OK: mutex initialized successfully.\n\n\nNotes\n\n\n\n\nExample\n\n\nstruct os_mutex g_mutex1;\nos_error_t err;\n\nerr = os_mutex_init(\ng_mutex1);\nassert(err == OS_OK);\n\n\n\n\n\n\nos_mutex_release\n\n\nos_error_t os_mutex_release(struct os_mutex *mu)\n\n\n\n\nRelease ownership of a mutex\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*mu\n\n\nPointer to mutex\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_INVALID_PARM: returned when *mu is NULL on entry.\n\n\nOS_OK: mutex initialized successfully.\n\n\nOS_BAD_MUTEX: The mutex was not owned by the task attempting to release it.\n\n\nOS_NOT_STARTED: Attempt to release a mutex before the os has been started.\n\n\nExample\n\n\nstruct os_mutex g_mutex1;\nos_error_t err;\n\nerr = os_mutex_pend(\ng_mutex1, 0);\nassert(err == OS_OK);\n\n/* Perform operations requiring exclusive access */\n\nerr = os_mutex_release(\ng_mutex1);\nassert(err == OS_OK);\n\n\n\n\n\n\nos_mutex_pend \n\n\nos_error_t os_mutex_pend(struct os_mutex *mu, uint32_t timeout) \n\n\n\n\nAcquire ownership of a mutex.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*mu\n\n\nPointer to mutex\n\n\n\n\n\n\ntimeout\n\n\nTimeout, in os ticks. A value of 0 means no timeout. A value of 0xFFFFFFFF means to wait forever.\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_INVALID_PARM: returned when *mu is NULL on entry.\n\n\nOS_OK: mutex was successfully acquired.\n\n\nOS_TIMEOUT: the mutex was not available within the timeout specified.\n\n\nOS_NOT_STARTED: Attempt to release a mutex before the os has been started.\n\n\nNotes\n\n\nIf the mutex is owned by another task and the timeout is 0 the function returns immediately with the error code OS_TIMEOUT. The calling task \ndoes not\n own the mutex when this occurs.\n\n\nExample\n\n\nstruct os_mutex g_mutex1;\nos_error_t err;\n\nerr = os_mutex_pend(\ng_mutex1, 0);\nassert(err == OS_OK);\n\n/* Perform operations requiring exclusive access */\n\nerr = os_mutex_release(\ng_mutex1);\nassert(err == OS_OK);\n\n\n\n\n\n\nos_mutex_delete \n\n\nos_error_t os_mutex_pend(struct os_mutex *mu)\n\n\n\n\nDelete a mutex\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*mu\n\n\nPointer to mutex\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_INVALID_PARM: returned when *mu is NULL on entry.\n\n\nOS_OK: mutex initialized successfully.\n\n\nOS_NOT_STARTED: Attempt to release a mutex before the os has been started.\n\n\nExample\n\n\nstruct os_mutex g_mutex1;\nos_error_t err;\n\nerr = os_mutex_delete(\ng_mutex1);\nassert(err == OS_OK);", 
            "title": "Mutexes"
        }, 
        {
            "location": "/os/mutex/#mutex", 
            "text": "Mutex is short for \"mutual exclusion\"; a mutex provides mutually exclusive access to a shared resource. A mutex provides  priority inheritance  in order to prevent  priority inversion . Priority inversion occurs when a higher priority task is waiting on a resource owned by a lower priority task. Using a mutex, the lower priority task will inherit the highest priority of any task waiting on the mutex.", 
            "title": "Mutex"
        }, 
        {
            "location": "/os/mutex/#description", 
            "text": "The first order of business when using a mutex is to declare the mutex globally. The mutex needs to be initialized before it is used (see the examples). It is generally a good idea to initialize the mutex before tasks start running in order to avoid a task possibly using the mutex before it is initialized.  When a task wants exclusive access to a shared resource it needs to obtain the mutex by calling  os_mutex_pend . If the mutex is currently owned by a different task (a lower priority task), the requesting task will be put to sleep and the owners priority will be elevated to the priority of the requesting task. Note that multiple tasks can request ownership and the current owner is elevated to the highest priority of any task waitin on the mutex. When the task is done using the shared resource, it needs to release the mutex by called  os_mutex_release . There needs to be one release per call to pend. Note that nested calls to  os_mutex_pend  are allowed but there needs to be one release per pend.  The following example will illustrate how priority inheritance works. In this example, the task number is the same as its priority. Remember that the lower the number, the higher the priority (i.e. priority 0 is higher priority than priority 1). Suppose that task 5 gets ownership of a mutex but is preempted by task 4. Task 4 attempts to gain ownership of the mutex but cannot as it is owned by task 5. Task 4 is put to sleep and task 5 is temporarily raised to priority 4. Before task 5 can release the mutex, task 3 runs and attempts to acquire the mutex. At this point, both task 3 and task 4 are waiting on the mutex (sleeping). Task 5 now runs at priority 3 (the highest priority of all the tasks waiting on the mutex). When task 5 finally releases the mutex it will be preempted as two higher priority tasks are waiting for it.   Note that when multiple tasks are waiting on a mutex owned by another task, once the mutex is released the highest priority task waiting on the mutex is run.", 
            "title": "Description"
        }, 
        {
            "location": "/os/mutex/#data-structures", 
            "text": "struct os_mutex\n{\n    SLIST_HEAD(, os_task) mu_head;\n    uint8_t     _pad;\n    uint8_t     mu_prio;\n    uint16_t    mu_level;\n    struct os_task *mu_owner;\n};     Element  Description      mu_head  Queue head for list of tasks waiting on mutex    _pad  Padding    mu_prio  Default priority of owner of mutex. Used to reset priority of task when mutex released    mu_level  Call nesting level (for nested calls)    mu_owner  Pointer to task structure which owns mutex", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/mutex/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_mutex_init  os_mutex_release  os_mutex_pend  os_mutex_delete", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/mutex/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/os/mutex/#os_mutex_init", 
            "text": "os_error_t os_mutex_init(struct os_mutex *mu)  Initialize the mutex. Must be called before the mutex can be used.  Arguments     Arguments  Description      *mu  Pointer to mutex     Returned values  OS_INVALID_PARM: returned when *mu is NULL on entry.  OS_OK: mutex initialized successfully.  Notes   Example  struct os_mutex g_mutex1;\nos_error_t err;\n\nerr = os_mutex_init( g_mutex1);\nassert(err == OS_OK);", 
            "title": "os_mutex_init"
        }, 
        {
            "location": "/os/mutex/#os_mutex_release", 
            "text": "os_error_t os_mutex_release(struct os_mutex *mu)  Release ownership of a mutex  Arguments     Arguments  Description      *mu  Pointer to mutex     Returned values  OS_INVALID_PARM: returned when *mu is NULL on entry.  OS_OK: mutex initialized successfully.  OS_BAD_MUTEX: The mutex was not owned by the task attempting to release it.  OS_NOT_STARTED: Attempt to release a mutex before the os has been started.  Example  struct os_mutex g_mutex1;\nos_error_t err;\n\nerr = os_mutex_pend( g_mutex1, 0);\nassert(err == OS_OK);\n\n/* Perform operations requiring exclusive access */\n\nerr = os_mutex_release( g_mutex1);\nassert(err == OS_OK);", 
            "title": "os_mutex_release"
        }, 
        {
            "location": "/os/mutex/#os_mutex_pend", 
            "text": "os_error_t os_mutex_pend(struct os_mutex *mu, uint32_t timeout)   Acquire ownership of a mutex.  Arguments     Arguments  Description      *mu  Pointer to mutex    timeout  Timeout, in os ticks. A value of 0 means no timeout. A value of 0xFFFFFFFF means to wait forever.     Returned values  OS_INVALID_PARM: returned when *mu is NULL on entry.  OS_OK: mutex was successfully acquired.  OS_TIMEOUT: the mutex was not available within the timeout specified.  OS_NOT_STARTED: Attempt to release a mutex before the os has been started.  Notes  If the mutex is owned by another task and the timeout is 0 the function returns immediately with the error code OS_TIMEOUT. The calling task  does not  own the mutex when this occurs.  Example  struct os_mutex g_mutex1;\nos_error_t err;\n\nerr = os_mutex_pend( g_mutex1, 0);\nassert(err == OS_OK);\n\n/* Perform operations requiring exclusive access */\n\nerr = os_mutex_release( g_mutex1);\nassert(err == OS_OK);", 
            "title": "os_mutex_pend "
        }, 
        {
            "location": "/os/mutex/#os_mutex_delete", 
            "text": "os_error_t os_mutex_pend(struct os_mutex *mu)  Delete a mutex  Arguments     Arguments  Description      *mu  Pointer to mutex     Returned values  OS_INVALID_PARM: returned when *mu is NULL on entry.  OS_OK: mutex initialized successfully.  OS_NOT_STARTED: Attempt to release a mutex before the os has been started.  Example  struct os_mutex g_mutex1;\nos_error_t err;\n\nerr = os_mutex_delete( g_mutex1);\nassert(err == OS_OK);", 
            "title": "os_mutex_delete "
        }, 
        {
            "location": "/os/memory_pool/", 
            "text": "Memory Pools\n\n\nMemory can be pre-allocated to a pool of fixed size elements.\n\n\nDescription\n\n\nSometimes it's useful to have several memory blocks of same size preallocated for specific use. E.g. you want to limit the amount of memory used for it, or you want to make sure that there is memory available when you ask for it.\n\n\nThis can be done using a memory pool. You allocate memory either statically or from heap, and then designate that memory to be used as storage for fixed size elements.\n\n\nPool will be initialized by calling \nos_mempool_init()\n. Element can be allocated from it with \nos_mempool_get()\n, and released back with \nos_mempool_put()\n.\n\n\nData structures\n\n\nstruct os_mempool {\n    int mp_block_size;\n    int mp_num_blocks;\n    int mp_num_free;\n    SLIST_HEAD(,os_memblock);\n    char *name;\n};\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmp_block_size\n\n\nSize of the memory blocks, in bytes\n\n\n\n\n\n\nmp_num_blocks\n\n\nNumber of memory blocks in the pool\n\n\n\n\n\n\nmp_num_free\n\n\nNumber of free blocks left\n\n\n\n\n\n\nname\n\n\nName for the memory block\n\n\n\n\n\n\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_mempool_init\n\n\nos_memblock_get\n\n\nos_memblock_put\n\n\nOS_MEMPOOL_BYTES\n\n\n\n\nFunction Reference\n\n\n\n\n os_mempool_init\n\n\nos_error_t os_mempool_init(struct os_mempool *mp, int blocks, int block_size, void *membuf, char *name)\n\n\n\n\nInitializes the memory pool. Memory pointed by \nmembuf\n is taken and \nblocks\n number of elements of size \nblock_size\n are added to the pool. \nname\n is optional, and names the memory pool.\n\n\nIt is assumed that the amount of memory pointed by \nmembuf\n has at least \nOS_MEMPOOL_BYTES(blocks, block_size)\n number of bytes.\n\n\nname\n is not copied, so caller should make sure that the memory does not get reused.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmp\n\n\nMemory pool being initialized\n\n\n\n\n\n\nblocks\n\n\nNumber of elements in the pool\n\n\n\n\n\n\nblock_size\n\n\nSize of an individual element in pool\n\n\n\n\n\n\nmembuf\n\n\nBacking store for the memory pool elements\n\n\n\n\n\n\nname\n\n\nName of the memory pool\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_OK: operation was successful.\nOS_INVALID_PARAM: invalid parameters. Block count or block size was negative, or membuf or mp was NULL.\nOS_MEM_NOT_ALIGNED: membuf has to be aligned to 4 byte boundary.\n\n\nNotes\n\n\nNote that os_mempool_init() does not allocate backing storage. \nmembuf\n has to be allocated by the caller.\n\n\nIt's recommended that you use \nOS_MEMPOOL_BYTES()\n to figure out how much memory to allocate for the pool.\n\n\nExample\n\n\n\n\n    rc = os_mempool_init(\nnffs_file_pool, nffs_config.nc_num_files,\n                         sizeof (struct nffs_file), nffs_file_mem,\n                         \nnffs_file_pool\n);\n    if (rc != 0) {\n        return FS_EOS;\n    }\n\n\n\n\n\n\n\n os_memblock_get\n\n\nvoid *os_memblock_get(struct os_mempool *mp)\n\n\n\n\nAllocate an element from the memory pool. If succesful, you'll get a pointer to allocated element. If there are no elements available, you'll get NULL as response.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmp\n\n\nPool where element is getting allocated from\n\n\n\n\n\n\n\n\nReturned values\n\n\nNULL: no elements available.\n\n: pointer to allocated element.\n\n\nNotes\n\n\nExample\n\n\n\n\n    struct nffs_file *file;\n\n    file = os_memblock_get(\nnffs_file_pool);\n    if (file != NULL) {\n        memset(file, 0, sizeof *file);\n    }\n\n\n\n\n\n\n\nos_memblock_put\n\n\nos_error_t os_memblock_put(struct os_mempool *mp, void *block_addr)\n\n\n\n\nReleases previously allocated element back to the pool.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmp\n\n\nPointer to memory pool where element is put\n\n\n\n\n\n\nblock_addr\n\n\nPointer to element getting freed\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_OK: operation was a success:\nOS_INVALID_PARAM: If either mp or block_addr were NULL.\n\n\nNotes\n\n\nExample\n\n\n\n\n    if (file != NULL) {\n        rc = os_memblock_put(\nnffs_file_pool, file);\n        if (rc != 0) {\n            return FS_EOS;\n        }\n    }\n\n\n\n\n\n\nOS_MEMPOOL_BYTES\n\n\nOS_MEMPOOL_BYTES(n,blksize)\n\n\n\n\nCalculates how many bytes of memory is used by \nn\n number of elements, when individual element size is \nblksize\n bytes.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nNumber of elements\n\n\n\n\n\n\nblksize\n\n\nSize of an element is number of bytes\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nExample\n\n\nHere we allocate memory to be used as a pool.\n\n\nvoid *nffs_file_mem;\n\nnffs_file_mem = malloc(\n        OS_MEMPOOL_BYTES(nffs_config.nc_num_files, sizeof (struct nffs_file)));\n    if (nffs_file_mem == NULL) {\n        return FS_ENOMEM;\n    }", 
            "title": "Memory Pools"
        }, 
        {
            "location": "/os/memory_pool/#memory-pools", 
            "text": "Memory can be pre-allocated to a pool of fixed size elements.", 
            "title": "Memory Pools"
        }, 
        {
            "location": "/os/memory_pool/#description", 
            "text": "Sometimes it's useful to have several memory blocks of same size preallocated for specific use. E.g. you want to limit the amount of memory used for it, or you want to make sure that there is memory available when you ask for it.  This can be done using a memory pool. You allocate memory either statically or from heap, and then designate that memory to be used as storage for fixed size elements.  Pool will be initialized by calling  os_mempool_init() . Element can be allocated from it with  os_mempool_get() , and released back with  os_mempool_put() .", 
            "title": "Description"
        }, 
        {
            "location": "/os/memory_pool/#data-structures", 
            "text": "struct os_mempool {\n    int mp_block_size;\n    int mp_num_blocks;\n    int mp_num_free;\n    SLIST_HEAD(,os_memblock);\n    char *name;\n};     Element  Description      mp_block_size  Size of the memory blocks, in bytes    mp_num_blocks  Number of memory blocks in the pool    mp_num_free  Number of free blocks left    name  Name for the memory block", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/memory_pool/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_mempool_init  os_memblock_get  os_memblock_put  OS_MEMPOOL_BYTES", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/memory_pool/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/os/memory_pool/#os_mempool_init", 
            "text": "os_error_t os_mempool_init(struct os_mempool *mp, int blocks, int block_size, void *membuf, char *name)  Initializes the memory pool. Memory pointed by  membuf  is taken and  blocks  number of elements of size  block_size  are added to the pool.  name  is optional, and names the memory pool.  It is assumed that the amount of memory pointed by  membuf  has at least  OS_MEMPOOL_BYTES(blocks, block_size)  number of bytes.  name  is not copied, so caller should make sure that the memory does not get reused.  Arguments     Arguments  Description      mp  Memory pool being initialized    blocks  Number of elements in the pool    block_size  Size of an individual element in pool    membuf  Backing store for the memory pool elements    name  Name of the memory pool     Returned values  OS_OK: operation was successful.\nOS_INVALID_PARAM: invalid parameters. Block count or block size was negative, or membuf or mp was NULL.\nOS_MEM_NOT_ALIGNED: membuf has to be aligned to 4 byte boundary.  Notes  Note that os_mempool_init() does not allocate backing storage.  membuf  has to be allocated by the caller.  It's recommended that you use  OS_MEMPOOL_BYTES()  to figure out how much memory to allocate for the pool.  Example       rc = os_mempool_init( nffs_file_pool, nffs_config.nc_num_files,\n                         sizeof (struct nffs_file), nffs_file_mem,\n                          nffs_file_pool );\n    if (rc != 0) {\n        return FS_EOS;\n    }", 
            "title": " os_mempool_init"
        }, 
        {
            "location": "/os/memory_pool/#os_memblock_get", 
            "text": "void *os_memblock_get(struct os_mempool *mp)  Allocate an element from the memory pool. If succesful, you'll get a pointer to allocated element. If there are no elements available, you'll get NULL as response.  Arguments     Arguments  Description      mp  Pool where element is getting allocated from     Returned values  NULL: no elements available. : pointer to allocated element.  Notes  Example       struct nffs_file *file;\n\n    file = os_memblock_get( nffs_file_pool);\n    if (file != NULL) {\n        memset(file, 0, sizeof *file);\n    }", 
            "title": " os_memblock_get"
        }, 
        {
            "location": "/os/memory_pool/#os_memblock_put", 
            "text": "os_error_t os_memblock_put(struct os_mempool *mp, void *block_addr)  Releases previously allocated element back to the pool.  Arguments     Arguments  Description      mp  Pointer to memory pool where element is put    block_addr  Pointer to element getting freed     Returned values  OS_OK: operation was a success:\nOS_INVALID_PARAM: If either mp or block_addr were NULL.  Notes  Example       if (file != NULL) {\n        rc = os_memblock_put( nffs_file_pool, file);\n        if (rc != 0) {\n            return FS_EOS;\n        }\n    }", 
            "title": "os_memblock_put"
        }, 
        {
            "location": "/os/memory_pool/#os_mempool_bytes", 
            "text": "OS_MEMPOOL_BYTES(n,blksize)  Calculates how many bytes of memory is used by  n  number of elements, when individual element size is  blksize  bytes.  Arguments     Arguments  Description      n  Number of elements    blksize  Size of an element is number of bytes     Returned values  List any values returned.\nError codes?  Notes  Example  Here we allocate memory to be used as a pool.  void *nffs_file_mem;\n\nnffs_file_mem = malloc(\n        OS_MEMPOOL_BYTES(nffs_config.nc_num_files, sizeof (struct nffs_file)));\n    if (nffs_file_mem == NULL) {\n        return FS_ENOMEM;\n    }", 
            "title": "OS_MEMPOOL_BYTES"
        }, 
        {
            "location": "/os/heap/", 
            "text": "Heap\n\n\nAPI for doing dynamic memory allocation.\n\n\nDescription\n\n\nThis provides malloc()/free() functionality with locking.  The shared resource heap needs to be protected from concurrent access when OS has been started. \nos_malloc()\n function grabs a mutex before calling \nmalloc()\n.\n\n\nData structures\n\n\nN/A\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_malloc\n\n\nos_free\n\n\nos_realloc\n\n\n\n\nFunction Reference\n\n\n\n\n os_malloc\n\n\nvoid *os_malloc(size_t size)\n\n\n\n\nAllocates \nsize\n number of bytes from heap and returns a pointer to it.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsize\n\n\nNumber of bytes to allocate\n\n\n\n\n\n\n\n\nReturned values\n\n\n: pointer to memory allocated from heap.\nNULL: not enough memory available.\n\n\nNotes\n\n\nos_malloc()\n calls \nmalloc()\n, which is provided by C-library. The heap must be set up during platform initialization.\nDepending on which C-library you use, you might have to do the heap setup differently. Most often \nmalloc()\n implementation will maintain a list of allocated and then freed memory blocks. If user asks for memory which cannot be satisfied from free list, they'll call platform's \nsbrk()\n, which then tries to grow the heap.\n\n\nExample\n\n\n\n\n    info = (struct os_task_info *) os_malloc(\n            sizeof(struct os_task_info) * tcount);\n    if (!info) {\n        rc = -1;\n        goto err;\n    }\n\n\n\n\n\n\nos_free\n\n\nvoid os_free(void *mem)\n\n\n\n\nFrees previously allocated memory back to the heap.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmem\n\n\nPointer to memory being released\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nCalls C-library \nfree()\n behind the covers.\n\n\nExample\n\n\n\n\n   os_free(info);\n\n\n\n\n\n\nos_realloc\n\n\nvoid *os_realloc(void *ptr, size_t size)\n\n\n\n\nTries to resize previously allocated memory block, and returns pointer to resized memory.\nptr can be NULL, in which case the call is similar to calling \nos_malloc()\n.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nptr\n\n\nPointer to previously allocated memory\n\n\n\n\n\n\nsize\n\n\nNew size to adjust the memory block to\n\n\n\n\n\n\n\n\nReturned values\n\n\nNULL: size adjustment was not successful. \n\nptr: pointer to new start of memory block\n\n\nNotes\n\n\nExample\n\n\n\n\nInsert the code snippet here", 
            "title": "Heap"
        }, 
        {
            "location": "/os/heap/#heap", 
            "text": "API for doing dynamic memory allocation.", 
            "title": "Heap"
        }, 
        {
            "location": "/os/heap/#description", 
            "text": "This provides malloc()/free() functionality with locking.  The shared resource heap needs to be protected from concurrent access when OS has been started.  os_malloc()  function grabs a mutex before calling  malloc() .", 
            "title": "Description"
        }, 
        {
            "location": "/os/heap/#data-structures", 
            "text": "N/A", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/heap/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_malloc  os_free  os_realloc", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/heap/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/os/heap/#os_malloc", 
            "text": "void *os_malloc(size_t size)  Allocates  size  number of bytes from heap and returns a pointer to it.  Arguments     Arguments  Description      size  Number of bytes to allocate     Returned values  : pointer to memory allocated from heap.\nNULL: not enough memory available.  Notes  os_malloc()  calls  malloc() , which is provided by C-library. The heap must be set up during platform initialization.\nDepending on which C-library you use, you might have to do the heap setup differently. Most often  malloc()  implementation will maintain a list of allocated and then freed memory blocks. If user asks for memory which cannot be satisfied from free list, they'll call platform's  sbrk() , which then tries to grow the heap.  Example       info = (struct os_task_info *) os_malloc(\n            sizeof(struct os_task_info) * tcount);\n    if (!info) {\n        rc = -1;\n        goto err;\n    }", 
            "title": " os_malloc"
        }, 
        {
            "location": "/os/heap/#os_free", 
            "text": "void os_free(void *mem)  Frees previously allocated memory back to the heap.  Arguments     Arguments  Description      mem  Pointer to memory being released     Returned values  N/A  Notes  Calls C-library  free()  behind the covers.  Example      os_free(info);", 
            "title": "os_free"
        }, 
        {
            "location": "/os/heap/#os_realloc", 
            "text": "void *os_realloc(void *ptr, size_t size)  Tries to resize previously allocated memory block, and returns pointer to resized memory.\nptr can be NULL, in which case the call is similar to calling  os_malloc() .  Arguments     Arguments  Description      ptr  Pointer to previously allocated memory    size  New size to adjust the memory block to     Returned values  NULL: size adjustment was not successful.  \nptr: pointer to new start of memory block  Notes  Example   Insert the code snippet here", 
            "title": "os_realloc"
        }, 
        {
            "location": "/os/mbufs/", 
            "text": "Mbufs\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe OS feature here \n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_mbuf_pool_init\n\n\nos_mbuf_get\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\n os_mbuf_pool_init\n\n\n    int \n    os_mbuf_pool_init(struct os_mbuf_pool *omp, struct os_mempool *mp, \n        uint16_t hdr_len, uint16_t buf_len, uint16_t nbufs)\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n os_mbuf_get\n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here", 
            "title": "Mbufs"
        }, 
        {
            "location": "/os/mbufs/#mbufs", 
            "text": "Insert synopsis here", 
            "title": "Mbufs"
        }, 
        {
            "location": "/os/mbufs/#description", 
            "text": "Describe OS feature here", 
            "title": "Description"
        }, 
        {
            "location": "/os/mbufs/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/mbufs/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_mbuf_pool_init  os_mbuf_get  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/mbufs/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/os/mbufs/#os_mbuf_pool_init", 
            "text": "int \n    os_mbuf_pool_init(struct os_mbuf_pool *omp, struct os_mempool *mp, \n        uint16_t hdr_len, uint16_t buf_len, uint16_t nbufs)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " os_mbuf_pool_init"
        }, 
        {
            "location": "/os/mbufs/#os_mbuf_get", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " os_mbuf_get"
        }, 
        {
            "location": "/os/mbufs/#next_one", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " next_one "
        }, 
        {
            "location": "/os/sanity/", 
            "text": "Sanity\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe OS feature here \n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_sanity_check_init\n\n\nos_sanity_check_list_lock\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\n os_sanity_check_init\n\n\n    int \n    os_sanity_check_init(struct os_sanity_check *sc)    \n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n os_sanity_check_list_lock \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here", 
            "title": "Sanity"
        }, 
        {
            "location": "/os/sanity/#sanity", 
            "text": "Insert synopsis here", 
            "title": "Sanity"
        }, 
        {
            "location": "/os/sanity/#description", 
            "text": "Describe OS feature here", 
            "title": "Description"
        }, 
        {
            "location": "/os/sanity/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/sanity/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_sanity_check_init  os_sanity_check_list_lock  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/sanity/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/os/sanity/#os_sanity_check_init", 
            "text": "int \n    os_sanity_check_init(struct os_sanity_check *sc)       Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " os_sanity_check_init"
        }, 
        {
            "location": "/os/sanity/#os_sanity_check_list_lock", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " os_sanity_check_list_lock "
        }, 
        {
            "location": "/os/sanity/#next_one", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " next_one "
        }, 
        {
            "location": "/os/callout/", 
            "text": "Callout\n\n\nCallouts are MyNewt OS timers.\n\n\nDescription\n\n\nCallout is a way of setting up an OS timer. When the timer fires, it is delivered as an event to task's event queue.\n\n\nUser would initialize their callout structure using \nos_callout_init()\n, or \nos_callout_func_init()\n and then arm it with \nos_callout_reset()\n.\n\n\nIf user wants to cancel the timer before it expires, they can either use \nos_callout_reset()\n to arm it for later expiry, or stop it altogether by calling \nos_callout_stop()\n.\n\n\nThere are 2 different options for data structure to use. First is \nstruct os_callout\n, which is a bare-bones version. You would initialize this with \nos_callout_init()\n.\n\n\nSecond option is \nstruct os_callout_func\n. This you can use if you expect to have multiple different types of timers in your task, running concurrently. The structure contains a function pointer, and you would call that function from your task's event processing loop.\n\n\nTime unit when arming the timer is OS ticks. This rate of this ticker depends on the platform this is running on. You should use OS define \nOS_TICKS_PER_SEC\n to convert wallclock time to OS  ticks.\n\n\nCallout timer fires out just once. For periodic timer type of operation you need to rearm it once it fires.\n\n\nData structures\n\n\nstruct os_callout {\n    struct os_event c_ev;\n    struct os_eventq *c_evq;\n    uint32_t c_ticks;\n    TAILQ_ENTRY(os_callout) c_next;\n};\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nc_ev\n\n\nEvent structure of this callout\n\n\n\n\n\n\nc_evq\n\n\nEvent queue where this callout is placed on timer expiry\n\n\n\n\n\n\nc_ticks\n\n\nOS tick amount when timer fires\n\n\n\n\n\n\nc_next\n\n\nLinkage to other unexpired callouts\n\n\n\n\n\n\n\n\nstruct os_callout_func {\n    struct os_callout cf_c;\n    os_callout_func_t cf_func;\n    void *cf_arg;\n};\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncf_c\n\n\nstruct os_callout. See above\n\n\n\n\n\n\ncf_func\n\n\nFunction pointer which should be called by event queue processing\n\n\n\n\n\n\ncf_arg\n\n\nGeneric void * argument to that function\n\n\n\n\n\n\n\n\nList of Functions\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_callout_init\n\n\nos_callout_func_init\n\n\nos_callout_stop\n\n\nos_callout_reset\n\n\nos_callout_queued\n\n\n\n\nFunction Reference\n\n\n\n\nos_callout_init \n\n\nvoid os_callout_init(struct os_callout *c, struct os_eventq *evq, void *ev_arg)\n\n\n\n\nInitializes \nstruct os_callout\n. Event type will be set to \nOS_EVENT_T_TIMER\n.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nc\n\n\nPointer to os_callout to initialize\n\n\n\n\n\n\nevq\n\n\nEvent queue where this gets delivered to\n\n\n\n\n\n\nev_arg\n\n\nGeneric argument which is filled in for the event\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nBe careful not to call this if the callout is armed, because that will mess up the list of pending callouts.\nOr if the timer has already fired, it will mess up the event queue where the callout was delivered to.\n\n\nExample\n\n\n\n\nstruct os_eventq my_evq;\nstruct os_callout my_callouts[8];\n\n    for (i = 0; i \n 8; i++) {\n        os_callout_init(\nmy_callouts[i], \nmy_evq, (void *)i);\n    }\n\n\n\n\n\n\n os_callout_func_init \n\n\nvoid os_callout_func_init(struct os_callout_func *cf, struct os_eventq *evq, os_callout_func_t timo_func, void *ev_arg)\n\n\n\n\nInitializes the given \nstruct os_callout_func\n. Data structure is filled in with elements given as argument.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncf\n\n\nPointer to os_callout_func being initialized\n\n\n\n\n\n\nevq\n\n\nEvent queue where this gets delivered to\n\n\n\n\n\n\ntimo_func\n\n\nTimeout function. Event processing should call this\n\n\n\n\n\n\nev_arg\n\n\nGeneric argument for the event\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nThe same notes as with \nos_callout_init()\n.\n\n\nExample\n\n\n\n\nstruct os_callout_func g_native_cputimer;\nstruct os_eventq g_native_cputime_evq;\nvoid native_cputimer_cb(void *arg);\n\n    /* Initialize the callout function */\n    os_callout_func_init(\ng_native_cputimer,\n                         \ng_native_cputime_evq,\n                         native_cputimer_cb,\n                         NULL);\n\n\n\n\n\n\n\n os_callout_stop \n\n\nvoid os_callout_stop(struct os_callout *c)\n\n\n\n\nDisarms a timer.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nc\n\n\nPointer to os_callout being stopped\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nExample\n\n\n\n\nstruct os_callout_func g_native_cputimer;\n\n     os_callout_stop(\ng_native_cputimer.cf_c);\n\n\n\n\n\n\n os_callout_reset \n\n\nvoid os_callout_reset(struct os_callout *c, int32_t timo)\n\n\n\n\nResets the callout to happen \ntimo\n in OS ticks.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nc\n\n\nPointer to os_callout being reset\n\n\n\n\n\n\ntimo\n\n\nOS ticks the timer is being set to\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nExample\n\n\n\n\n    /* Re-start the timer (run every 50 msecs) */\n    os_callout_reset(\ng_bletest_timer.cf_c, OS_TICKS_PER_SEC / 20);\n\n\n\n\n\n\nos_callout_queued\n\n\nint os_callout_queued(struct os_callout *c)\n\n\n\n\nTells whether the callout has been armed or not.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nc\n\n\nPointer to callout being checked\n\n\n\n\n\n\n\n\nReturned values\n\n\n0: timer is not armed\nnon-zero: timer is armed\n\n\nNotes\n\n\nExample\n\n\n\n\nInsert the code snippet here", 
            "title": "Callout Functions"
        }, 
        {
            "location": "/os/callout/#callout", 
            "text": "Callouts are MyNewt OS timers.", 
            "title": "Callout"
        }, 
        {
            "location": "/os/callout/#description", 
            "text": "Callout is a way of setting up an OS timer. When the timer fires, it is delivered as an event to task's event queue.  User would initialize their callout structure using  os_callout_init() , or  os_callout_func_init()  and then arm it with  os_callout_reset() .  If user wants to cancel the timer before it expires, they can either use  os_callout_reset()  to arm it for later expiry, or stop it altogether by calling  os_callout_stop() .  There are 2 different options for data structure to use. First is  struct os_callout , which is a bare-bones version. You would initialize this with  os_callout_init() .  Second option is  struct os_callout_func . This you can use if you expect to have multiple different types of timers in your task, running concurrently. The structure contains a function pointer, and you would call that function from your task's event processing loop.  Time unit when arming the timer is OS ticks. This rate of this ticker depends on the platform this is running on. You should use OS define  OS_TICKS_PER_SEC  to convert wallclock time to OS  ticks.  Callout timer fires out just once. For periodic timer type of operation you need to rearm it once it fires.", 
            "title": "Description"
        }, 
        {
            "location": "/os/callout/#data-structures", 
            "text": "struct os_callout {\n    struct os_event c_ev;\n    struct os_eventq *c_evq;\n    uint32_t c_ticks;\n    TAILQ_ENTRY(os_callout) c_next;\n};     Element  Description      c_ev  Event structure of this callout    c_evq  Event queue where this callout is placed on timer expiry    c_ticks  OS tick amount when timer fires    c_next  Linkage to other unexpired callouts     struct os_callout_func {\n    struct os_callout cf_c;\n    os_callout_func_t cf_func;\n    void *cf_arg;\n};     Element  Description      cf_c  struct os_callout. See above    cf_func  Function pointer which should be called by event queue processing    cf_arg  Generic void * argument to that function", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/callout/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_callout_init  os_callout_func_init  os_callout_stop  os_callout_reset  os_callout_queued", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/callout/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/os/callout/#os_callout_init", 
            "text": "void os_callout_init(struct os_callout *c, struct os_eventq *evq, void *ev_arg)  Initializes  struct os_callout . Event type will be set to  OS_EVENT_T_TIMER .  Arguments     Arguments  Description      c  Pointer to os_callout to initialize    evq  Event queue where this gets delivered to    ev_arg  Generic argument which is filled in for the event     Returned values  N/A  Notes  Be careful not to call this if the callout is armed, because that will mess up the list of pending callouts.\nOr if the timer has already fired, it will mess up the event queue where the callout was delivered to.  Example   struct os_eventq my_evq;\nstruct os_callout my_callouts[8];\n\n    for (i = 0; i   8; i++) {\n        os_callout_init( my_callouts[i],  my_evq, (void *)i);\n    }", 
            "title": "os_callout_init "
        }, 
        {
            "location": "/os/callout/#os_callout_func_init", 
            "text": "void os_callout_func_init(struct os_callout_func *cf, struct os_eventq *evq, os_callout_func_t timo_func, void *ev_arg)  Initializes the given  struct os_callout_func . Data structure is filled in with elements given as argument.  Arguments     Arguments  Description      cf  Pointer to os_callout_func being initialized    evq  Event queue where this gets delivered to    timo_func  Timeout function. Event processing should call this    ev_arg  Generic argument for the event     Returned values  N/A  Notes  The same notes as with  os_callout_init() .  Example   struct os_callout_func g_native_cputimer;\nstruct os_eventq g_native_cputime_evq;\nvoid native_cputimer_cb(void *arg);\n\n    /* Initialize the callout function */\n    os_callout_func_init( g_native_cputimer,\n                          g_native_cputime_evq,\n                         native_cputimer_cb,\n                         NULL);", 
            "title": " os_callout_func_init "
        }, 
        {
            "location": "/os/callout/#os_callout_stop", 
            "text": "void os_callout_stop(struct os_callout *c)  Disarms a timer.  Arguments     Arguments  Description      c  Pointer to os_callout being stopped     Returned values  N/A  Notes  Example   struct os_callout_func g_native_cputimer;\n\n     os_callout_stop( g_native_cputimer.cf_c);", 
            "title": " os_callout_stop "
        }, 
        {
            "location": "/os/callout/#os_callout_reset", 
            "text": "void os_callout_reset(struct os_callout *c, int32_t timo)  Resets the callout to happen  timo  in OS ticks.  Arguments     Arguments  Description      c  Pointer to os_callout being reset    timo  OS ticks the timer is being set to     Returned values  N/A  Notes  Example       /* Re-start the timer (run every 50 msecs) */\n    os_callout_reset( g_bletest_timer.cf_c, OS_TICKS_PER_SEC / 20);", 
            "title": " os_callout_reset "
        }, 
        {
            "location": "/os/callout/#os_callout_queued", 
            "text": "int os_callout_queued(struct os_callout *c)  Tells whether the callout has been armed or not.  Arguments     Arguments  Description      c  Pointer to callout being checked     Returned values  0: timer is not armed\nnon-zero: timer is armed  Notes  Example   Insert the code snippet here", 
            "title": "os_callout_queued"
        }, 
        {
            "location": "/os/port_os/", 
            "text": "Porting Mynewt OS\n\n\nThis chapter describes how to adapt Newt OS to different processors. Adapting \u03bcC/OS-III to a microprocessor or a microcontroller is called porting. \n\n\nDescription\n\n\nInsert sections as you wish", 
            "title": "Porting to other Platforms"
        }, 
        {
            "location": "/os/port_os/#porting-mynewt-os", 
            "text": "This chapter describes how to adapt Newt OS to different processors. Adapting \u03bcC/OS-III to a microprocessor or a microcontroller is called porting.", 
            "title": "Porting Mynewt OS"
        }, 
        {
            "location": "/os/port_os/#description", 
            "text": "", 
            "title": "Description"
        }, 
        {
            "location": "/os/port_os/#insert-sections-as-you-wish", 
            "text": "", 
            "title": "Insert sections as you wish"
        }, 
        {
            "location": "/modules/console/", 
            "text": "Console\n\n\nThe console is an operating system window where users interact with system programs of the operating system or a console application by entering text input (typically from a keyboard) and reading text output (typically on the computer terminal or monitor). The text written on the console brings some information and is a sequence of characters sent by the OS or programs running on the OS. \n\n\nSupport is currently available for console access via the serial port on the hardware board.\n\n\nDescription\n\n\nIn the Mynewt OS, the console library comes in two versions:\n\n\n\n\nfull - containing the full implementation\n\n\nstub - containing stubs for the API\n\n\n\n\nBoth of these have \negg.yml\n file which states that they provide the \nconsole\n API. If an egg uses this API, it should list \nconsole\n as a requirement.\nFor example, the shell egg is defined by the following egg.yml file:\n\n\n    egg.name: libs/shell \n    egg.vers: 0.1\n    egg.deps:\n        - libs/os\n        - libs/util\n    egg.reqs:\n        - console\n    egg.identities:\n        - SHELL \n\n\n\n\nThe project .yml file decides which version of the console egg should be included. \nIf project requires the full console capability it lists dependency \nlibs/console/full\n in its egg.yml file. \nOn the other hand, a project may not have a physical console (e.g. a UART port to connect a terminal to) but may have a dependency on an egg that has console capability. In that case you would use a console stub. Another example would be the bootloader project where we want to keep the size of the image small. It includes the \nlibs/os\n egg that can print out messages on a console (e.g. if there is a hard fault) and the \nlibs/util\n egg that uses full console (but only if SHELL is present to provide a CLI). However, we do not want to use any console I/O capability in this particular bootloader project to keep the size small. We simply use the console stub instead and the egg.yml file for the project boot egg looks like the following:\n\n\n    project.name: boot\n    project.identities: bootloader\n    project.eggs:\n        - libs/os\n        - libs/bootutil\n        - libs/nffs\n        - libs/console/stub\n        - libs/util \n\n\n\n\nConsole has 2 modes for transmit; blocking and non-blocking mode. Usually the non-blocking mode is the active one; the output buffer is drained by getting TX completion interrupts from hardware, and more data is added based on these interrupts.\nBlocking mode is used when we don't want TX completion interrupts. This is used when system crashes, and we still want to output info related to that crash.\n\n\nData structures\n\n\nConsole interaction is intrinsically composed of two unidirectional systems. The console implementation uses two ring buffers containing input (receive) and output (transmit) characters, respectively. Read and write operations on the console_ring structure are managed by labeling the read location indicator the \ncr_tail\n and the write location indicator the \ncr_head\n. The console ring length is variable and is specified as the \ncr_size\n member of the data structure. \ncr_buf\n is the pointer to the actual array of data contained.\n\n\nstruct console_ring {\n  32     uint8_t cr_head;\n  33     uint8_t cr_tail;\n  34     uint8_t cr_size;\n  35     uint8_t _pad;\n  36     uint8_t *cr_buf;\n  37 }\n\n\n\n\nstruct console_tty {\n  40     struct console_ring ct_tx;\n  41     uint8_t ct_tx_buf[CONSOLE_TX_BUF_SZ]; /* must be after console_ring */\n  42     struct console_ring ct_rx;\n  43     uint8_t ct_rx_buf[CONSOLE_RX_BUF_SZ]; /* must be after console_ring */\n  44     console_rx_cb ct_rx_cb;     /* callback that input is ready */\n  45     console_write_char ct_write_char;\n  46 } console_tty\n\n\n\n\nList of Functions\n\n\nThe functions available in console are:\n\n\n\n\nconsole_printf\n\n\nconsole_add_char\n\n\nconsole_pull_char\n\n\nconsole_pull_char_head\n\n\nconsole_queue_char\n\n\nconsole_blocking_tx\n\n\nconsole_blocking_mode\n\n\nconsole_write\n\n\nconsole_read\n\n\nconsole_tx_char\n\n\nconsole_rx_char\n\n\nconsole_init\n\n\n\n\nFunction Reference\n\n\n\n\n console_printf\n\n\n    void \n    console_printf(const char *fmt, ...)\n\n\n\n\nWrites a formatted message instead of raw output to the console. It first composes a C string containing text specified as arguments to the function or containing the elements in the variable argument list passed to it using snprintf or vsnprintf, respectively. It then uses function \nconsole_write\n to output the formatted data (messages) on the console.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfmt\n\n\nPointer to C string that contains a format string that follows the same specifications as format in printf. The string is printed to console.\n\n\n\n\n\n\n...\n\n\nDepending on the format string, the function may expect either a sequence of additional arguments to be used to replace a format specifier in the format string or a variable arguments list. va_list is a special type defined in \n in stdarg.h.\n\n\n\n\n\n\n\n\nReturned values\n\n\nNone\n\n\nNotes\n\n\nWhile \nconsole_printf\n, with its well understood formatting options in C, is more convenient and easy on the eyes than the raw output of \nconsole_write\n, the associated code size is considerably larger.\n\n\nExample\n\n\nExample #1:\n\n\nchar adv_data_buf[32];\n\nvoid\ntask()\n{ \n   char adv_data_buf[32];\n\n   console_printf(\n%s\n, adv_data_buf);\n}\n\n\n\n\nExample #2:\n\n\nstruct exception_frame {\n    uint32_t r0;\n    uint32_t r1;\n\nstruct trap_frame {\n    struct exception_frame *ef;\n    uint32_t r2;\n    uint32_t r3;\n};\n\nvoid\ntask(struct trap_frame *tf)\n{\n     console_printf(\n r0:%8.8x  r1:%8.8x\n, tf-\nef-\nr0, tf-\nef-\nr1);\n     console_printf(\n r8:%8.8x  r9:%8.8x\n, tf-\nr2, tf-\nr3);\n}\n\n\n\n\n\n\n console_add_char\n\n\n   static void\n   console_add_char(struct console_ring *cr, char ch)\n\n\n\n\nAdds a character to the console ring buffer. When you store an item in the buffer you store it at the head location, and the head advances to the next location.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*cr\n\n\nPointer to a console ring data structure whose \ncr_head\nvariable is to be set to the second argument in this function call\n\n\n\n\n\n\nch\n\n\nCharacter to be inserted to the ring\n\n\n\n\n\n\n\n\nReturned values\n\n\nNone\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nAdd a new line character to the output (transmit) buffer.\n\n\nvoid\ntask()\n{\n     struct console_ring *tx = \nct-\nct_tx;\n\n     console_add_char(tx, '\\n');\n}\n\n\n\n\n\n\n console_pull_char \n\n\n   static uint8_t\n   console_pull_char(struct console_ring *cr)\n\n\n\n\nReads (remove) a byte from the console ring buffer. When you read (pull) an item, you read it at the current tail location, and the tail advances to the next position. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*cr\n\n\nPointer to the console ring buffer from where a character is to be removed\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns the character pulled from the ring buffer.\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nRead the characters in the ring buffer into a string.\n\n\nvoid\ntask(struct console_ring *cr, char *str, int cnt)\n{    \n     for (i = 0; i \n cnt; i++) {\n          if (cr-\ncr_head == cr-\ncr_tail) {\n              i = -1;\n              break;\n          }\n     ch = console_pull_char(cr);\n     *str++ = ch;\n     }\n}\n\n\n\n\n\n\n console_pull_char_head \n\n\n   static void\n   console_pull_char_head(struct console_ring *cr)\n\n\n\n\nRemoves the last character inserted into the ring buffer by moving back the head location and shrinking the ring size by 1. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncr\n\n\nPointer to the console ring buffer from which the last inserted character must be deleted\n\n\n\n\n\n\n\n\nReturned values\n\n\nNone\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nIn order to see a character getting deleted when a user hits backspace while typying a command, the following needs to happen in sequence:\n\n\n\n\noutput a backspace (move cursor back one character)\n\n\noutput space (erasing whatever character there was before)\n\n\noutput backspace (move cursor back one character)\n\n\nremove the previous character from incoming RX queue\n\n\n\n\nThe example below shows console_pull_char_head being used for the last step.\n\n\nvoid\ntask(uint8_t data)\n{\n      struct console_tty *ct = (struct console_tty *)arg;\n      struct console_ring *tx = \nct-\nct_tx;\n      struct console_ring *rx = \nct-\nct_rx;\n\n      switch (data) {\n      case '\\b':\n          console_add_char(tx, '\\b');\n          console_add_char(tx, ' ');\n          console_add_char(tx, '\\b');\n          console_pull_char_head(rx);\n          break;\n      }\n}\n\n\n\n\n\n\n\n console_queue_char \n\n\n   static void\n   console_queue_char(char ch)\n\n\n\n\nManage the buffer queue before inserting a character into it. If the head of the output (transmit) console ring is right up to its tail, the queue needs to be drained first before any data can be added. Then it uses console_add_char function to add the character.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nch\n\n\nCharacter to be inserted to the queue\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nFunction blocks interrupts as a way of protecting against concurrent access to TX buffer.\n\n\nIf TX buffer is full, the function waits for TX buffer to drain. And the way it does it currently is by calling os_time_delay(). Therefore this function should only be called from within a task context, not from an interrupt handler. We might want to change this...\n\n\nExample\n\n\nInsert example\n\n\n\n\n\n\n console_blocking_tx \n\n\n    static void\n    console_blocking_tx(char ch)\n\n\n\n\nCalls the hal function hal_uart_blocking_tx to transmit a byte to the console over UART in a blocking mode until the entire character has been sent. Hence it must be called with interrupts disabled. It is used when printing diagnostic output from system crash. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nch\n\n\n8 bit character (data) to be transmitted\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nHere is an example of a console output queue being flushed.\n\n\nvoid\ntask(void)\n{\n    struct console_tty *ct = \nconsole_tty;\n    uint8_t byte;\n\n    while (ct-\nct_tx.cr_head != ct-\nct_tx.cr_tail) {\n        byte = console_pull_char(\nct-\nct_tx);\n        console_blocking_tx(byte);\n    }\n}\n\n\n\n\n\n\n console_blocking_mode \n\n\n   void\n   console_blocking_mode(void)\n\n\n\n\nCalls the console_blocking_tx function to flush the buffered console output (transmit) queue. The function OS_ENTER_CRITICAL() is called to disable interrupts and OS_EXIT_CRITICAL() is called to enable interrupts back again once the buffer is flushed.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\n\n\nnone\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nHere is an example of calling \nconsole_blocking_mode\n and printing crash information from an assert to help debug.\n\n\nvoid\n_assert_func(const char *file, int line, const char *func, const char *e)\n{\n    int sr;\n\n    OS_ENTER_CRITICAL(sr);\n    (void)sr;\n    os_die_line = line;\n    os_die_module = file;\n    console_blocking_mode();\n    console_printf(\nAssert %s; failed in %s:%d\\n\n, e ? e : \n, file, line);\n    system_reset();\n}\n\n\n\n\n\n\n console_write \n\n\n   void\n   console_write(char *str, int cnt)\n\n\n\n\nTransmit characters to console display over serial port. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*str\n\n\npointer to the character or packet to be transmitted\n\n\n\n\n\n\ncnt\n\n\nsize of the character or packet\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nHere is an example of the function being used in an echo command with a newline at the end.\n\n\nstatic int\nshell_echo_cmd(int argc, char **argv)\n{\n    int i;\n\n    for (i = 1; i \n argc; i++) {\n        console_write(argv[i], strlen(argv[i]));\n        console_write(\n \n, sizeof(\n \n)-1);\n    }\n    console_write(\n\\n\n, sizeof(\n\\n\n)-1);\n\n    return (0);\n}\n\n\n\n\n\n\n console_read \n\n\n  int\n  console_read(char *str, int cnt)\n\n\n\n\nCalls hal function hal_uart_start_rx to start receiving input from console terminal over serial port.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nGive at least one example of usage.\n\n\n\n\n console_tx_char \n\n\n   static int\n   console_tx_char(void *arg)\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nGive at least one example of usage.\n\n\n\n\n console_rx_char \n\n\n   static int\n   console_rx_char(void *arg, uint8_t data)\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nGive at least one example of usage.\n\n\n\n\n console_init \n\n\n   int\n   console_init(console_rx_cb rx_cb)\n\n\n\n\nInitializes console receive buffer and calls hal funtions hal_uart_init_cbs and hal_uart_config to initialize serial port connection and configure it (e.g. baud rate, flow control etc.)\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nGive at least one example of usage.", 
            "title": "Console"
        }, 
        {
            "location": "/modules/console/#console", 
            "text": "The console is an operating system window where users interact with system programs of the operating system or a console application by entering text input (typically from a keyboard) and reading text output (typically on the computer terminal or monitor). The text written on the console brings some information and is a sequence of characters sent by the OS or programs running on the OS.   Support is currently available for console access via the serial port on the hardware board.", 
            "title": "Console"
        }, 
        {
            "location": "/modules/console/#description", 
            "text": "In the Mynewt OS, the console library comes in two versions:   full - containing the full implementation  stub - containing stubs for the API   Both of these have  egg.yml  file which states that they provide the  console  API. If an egg uses this API, it should list  console  as a requirement.\nFor example, the shell egg is defined by the following egg.yml file:      egg.name: libs/shell \n    egg.vers: 0.1\n    egg.deps:\n        - libs/os\n        - libs/util\n    egg.reqs:\n        - console\n    egg.identities:\n        - SHELL   The project .yml file decides which version of the console egg should be included. \nIf project requires the full console capability it lists dependency  libs/console/full  in its egg.yml file. \nOn the other hand, a project may not have a physical console (e.g. a UART port to connect a terminal to) but may have a dependency on an egg that has console capability. In that case you would use a console stub. Another example would be the bootloader project where we want to keep the size of the image small. It includes the  libs/os  egg that can print out messages on a console (e.g. if there is a hard fault) and the  libs/util  egg that uses full console (but only if SHELL is present to provide a CLI). However, we do not want to use any console I/O capability in this particular bootloader project to keep the size small. We simply use the console stub instead and the egg.yml file for the project boot egg looks like the following:      project.name: boot\n    project.identities: bootloader\n    project.eggs:\n        - libs/os\n        - libs/bootutil\n        - libs/nffs\n        - libs/console/stub\n        - libs/util   Console has 2 modes for transmit; blocking and non-blocking mode. Usually the non-blocking mode is the active one; the output buffer is drained by getting TX completion interrupts from hardware, and more data is added based on these interrupts.\nBlocking mode is used when we don't want TX completion interrupts. This is used when system crashes, and we still want to output info related to that crash.", 
            "title": "Description"
        }, 
        {
            "location": "/modules/console/#data-structures", 
            "text": "Console interaction is intrinsically composed of two unidirectional systems. The console implementation uses two ring buffers containing input (receive) and output (transmit) characters, respectively. Read and write operations on the console_ring structure are managed by labeling the read location indicator the  cr_tail  and the write location indicator the  cr_head . The console ring length is variable and is specified as the  cr_size  member of the data structure.  cr_buf  is the pointer to the actual array of data contained.  struct console_ring {\n  32     uint8_t cr_head;\n  33     uint8_t cr_tail;\n  34     uint8_t cr_size;\n  35     uint8_t _pad;\n  36     uint8_t *cr_buf;\n  37 }  struct console_tty {\n  40     struct console_ring ct_tx;\n  41     uint8_t ct_tx_buf[CONSOLE_TX_BUF_SZ]; /* must be after console_ring */\n  42     struct console_ring ct_rx;\n  43     uint8_t ct_rx_buf[CONSOLE_RX_BUF_SZ]; /* must be after console_ring */\n  44     console_rx_cb ct_rx_cb;     /* callback that input is ready */\n  45     console_write_char ct_write_char;\n  46 } console_tty", 
            "title": "Data structures"
        }, 
        {
            "location": "/modules/console/#list-of-functions", 
            "text": "The functions available in console are:   console_printf  console_add_char  console_pull_char  console_pull_char_head  console_queue_char  console_blocking_tx  console_blocking_mode  console_write  console_read  console_tx_char  console_rx_char  console_init", 
            "title": "List of Functions"
        }, 
        {
            "location": "/modules/console/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/modules/console/#console_printf", 
            "text": "void \n    console_printf(const char *fmt, ...)  Writes a formatted message instead of raw output to the console. It first composes a C string containing text specified as arguments to the function or containing the elements in the variable argument list passed to it using snprintf or vsnprintf, respectively. It then uses function  console_write  to output the formatted data (messages) on the console.  Arguments     Arguments  Description      fmt  Pointer to C string that contains a format string that follows the same specifications as format in printf. The string is printed to console.    ...  Depending on the format string, the function may expect either a sequence of additional arguments to be used to replace a format specifier in the format string or a variable arguments list. va_list is a special type defined in   in stdarg.h.     Returned values  None  Notes  While  console_printf , with its well understood formatting options in C, is more convenient and easy on the eyes than the raw output of  console_write , the associated code size is considerably larger.  Example  Example #1:  char adv_data_buf[32];\n\nvoid\ntask()\n{ \n   char adv_data_buf[32];\n\n   console_printf( %s , adv_data_buf);\n}  Example #2:  struct exception_frame {\n    uint32_t r0;\n    uint32_t r1;\n\nstruct trap_frame {\n    struct exception_frame *ef;\n    uint32_t r2;\n    uint32_t r3;\n};\n\nvoid\ntask(struct trap_frame *tf)\n{\n     console_printf(  r0:%8.8x  r1:%8.8x , tf- ef- r0, tf- ef- r1);\n     console_printf(  r8:%8.8x  r9:%8.8x , tf- r2, tf- r3);\n}", 
            "title": " console_printf"
        }, 
        {
            "location": "/modules/console/#console_add_char", 
            "text": "static void\n   console_add_char(struct console_ring *cr, char ch)  Adds a character to the console ring buffer. When you store an item in the buffer you store it at the head location, and the head advances to the next location.  Arguments     Arguments  Description      *cr  Pointer to a console ring data structure whose  cr_head variable is to be set to the second argument in this function call    ch  Character to be inserted to the ring     Returned values  None  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Add a new line character to the output (transmit) buffer.  void\ntask()\n{\n     struct console_ring *tx =  ct- ct_tx;\n\n     console_add_char(tx, '\\n');\n}", 
            "title": " console_add_char"
        }, 
        {
            "location": "/modules/console/#console_pull_char", 
            "text": "static uint8_t\n   console_pull_char(struct console_ring *cr)  Reads (remove) a byte from the console ring buffer. When you read (pull) an item, you read it at the current tail location, and the tail advances to the next position.   Arguments     Arguments  Description      *cr  Pointer to the console ring buffer from where a character is to be removed     Returned values  Returns the character pulled from the ring buffer.  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Read the characters in the ring buffer into a string.  void\ntask(struct console_ring *cr, char *str, int cnt)\n{    \n     for (i = 0; i   cnt; i++) {\n          if (cr- cr_head == cr- cr_tail) {\n              i = -1;\n              break;\n          }\n     ch = console_pull_char(cr);\n     *str++ = ch;\n     }\n}", 
            "title": " console_pull_char "
        }, 
        {
            "location": "/modules/console/#console_pull_char_head", 
            "text": "static void\n   console_pull_char_head(struct console_ring *cr)  Removes the last character inserted into the ring buffer by moving back the head location and shrinking the ring size by 1.   Arguments     Arguments  Description      cr  Pointer to the console ring buffer from which the last inserted character must be deleted     Returned values  None  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  In order to see a character getting deleted when a user hits backspace while typying a command, the following needs to happen in sequence:   output a backspace (move cursor back one character)  output space (erasing whatever character there was before)  output backspace (move cursor back one character)  remove the previous character from incoming RX queue   The example below shows console_pull_char_head being used for the last step.  void\ntask(uint8_t data)\n{\n      struct console_tty *ct = (struct console_tty *)arg;\n      struct console_ring *tx =  ct- ct_tx;\n      struct console_ring *rx =  ct- ct_rx;\n\n      switch (data) {\n      case '\\b':\n          console_add_char(tx, '\\b');\n          console_add_char(tx, ' ');\n          console_add_char(tx, '\\b');\n          console_pull_char_head(rx);\n          break;\n      }\n}", 
            "title": " console_pull_char_head "
        }, 
        {
            "location": "/modules/console/#console_queue_char", 
            "text": "static void\n   console_queue_char(char ch)  Manage the buffer queue before inserting a character into it. If the head of the output (transmit) console ring is right up to its tail, the queue needs to be drained first before any data can be added. Then it uses console_add_char function to add the character.  Arguments     Arguments  Description      ch  Character to be inserted to the queue     Returned values  List any values returned.\nError codes?  Notes  Function blocks interrupts as a way of protecting against concurrent access to TX buffer.  If TX buffer is full, the function waits for TX buffer to drain. And the way it does it currently is by calling os_time_delay(). Therefore this function should only be called from within a task context, not from an interrupt handler. We might want to change this...  Example  Insert example", 
            "title": " console_queue_char "
        }, 
        {
            "location": "/modules/console/#console_blocking_tx", 
            "text": "static void\n    console_blocking_tx(char ch)  Calls the hal function hal_uart_blocking_tx to transmit a byte to the console over UART in a blocking mode until the entire character has been sent. Hence it must be called with interrupts disabled. It is used when printing diagnostic output from system crash.   Arguments     Arguments  Description      ch  8 bit character (data) to be transmitted     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Here is an example of a console output queue being flushed.  void\ntask(void)\n{\n    struct console_tty *ct =  console_tty;\n    uint8_t byte;\n\n    while (ct- ct_tx.cr_head != ct- ct_tx.cr_tail) {\n        byte = console_pull_char( ct- ct_tx);\n        console_blocking_tx(byte);\n    }\n}", 
            "title": " console_blocking_tx "
        }, 
        {
            "location": "/modules/console/#console_blocking_mode", 
            "text": "void\n   console_blocking_mode(void)  Calls the console_blocking_tx function to flush the buffered console output (transmit) queue. The function OS_ENTER_CRITICAL() is called to disable interrupts and OS_EXIT_CRITICAL() is called to enable interrupts back again once the buffer is flushed.  Arguments     Arguments      none     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Here is an example of calling  console_blocking_mode  and printing crash information from an assert to help debug.  void\n_assert_func(const char *file, int line, const char *func, const char *e)\n{\n    int sr;\n\n    OS_ENTER_CRITICAL(sr);\n    (void)sr;\n    os_die_line = line;\n    os_die_module = file;\n    console_blocking_mode();\n    console_printf( Assert %s; failed in %s:%d\\n , e ? e :  , file, line);\n    system_reset();\n}", 
            "title": " console_blocking_mode "
        }, 
        {
            "location": "/modules/console/#console_write", 
            "text": "void\n   console_write(char *str, int cnt)  Transmit characters to console display over serial port.   Arguments     Arguments  Description      *str  pointer to the character or packet to be transmitted    cnt  size of the character or packet     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Here is an example of the function being used in an echo command with a newline at the end.  static int\nshell_echo_cmd(int argc, char **argv)\n{\n    int i;\n\n    for (i = 1; i   argc; i++) {\n        console_write(argv[i], strlen(argv[i]));\n        console_write(   , sizeof(   )-1);\n    }\n    console_write( \\n , sizeof( \\n )-1);\n\n    return (0);\n}", 
            "title": " console_write "
        }, 
        {
            "location": "/modules/console/#console_read", 
            "text": "int\n  console_read(char *str, int cnt)  Calls hal function hal_uart_start_rx to start receiving input from console terminal over serial port.  Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Give at least one example of usage.", 
            "title": " console_read "
        }, 
        {
            "location": "/modules/console/#console_tx_char", 
            "text": "static int\n   console_tx_char(void *arg)  Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Give at least one example of usage.", 
            "title": " console_tx_char "
        }, 
        {
            "location": "/modules/console/#console_rx_char", 
            "text": "static int\n   console_rx_char(void *arg, uint8_t data)  Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Give at least one example of usage.", 
            "title": " console_rx_char "
        }, 
        {
            "location": "/modules/console/#console_init", 
            "text": "int\n   console_init(console_rx_cb rx_cb)  Initializes console receive buffer and calls hal funtions hal_uart_init_cbs and hal_uart_config to initialize serial port connection and configure it (e.g. baud rate, flow control etc.)  Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Give at least one example of usage.", 
            "title": " console_init "
        }, 
        {
            "location": "/modules/shell/", 
            "text": "Shell\n\n\nThe shell is the program which puts up a prompt for a command, processes commands, and returns output. Interacting with the console of a device is done using a shell program.\n\n\nDescription\n\n\nShell processes console input one line at a time. Eggs can register handlers for their commands. Shell parses the input, matches it against the set of registered commands, and then calls the handler it finds.\n\n\nA few commands are currently available in the shell - \ntasks\n, \nlog\n, and \nstat stat\n. A $ prompt sign will be coming soon!\n\n\nCreate a sim target to check out these commands available in shell.\n\n\nuser@~/dev/larva$ newt target create blinky_sim\nCreating target blinky_sim\nTarget blinky_sim successfully created!\nuser@~/dev/larva$ newt target set blinky_sim name=blinky_sim\nTarget blinky_sim successfully set name to blinky_sim\nuser@~/dev/larva$ newt target set blinky_sim arch=sim\nTarget blinky_sim successfully set arch to sim\nuser@~/dev/larva$ newt target set blinky_sim project=blinky\nTarget blinky_sim successfully set project to blinky\nuser@~/dev/larva$ newt target set blinky_sim bsp=hw/bsp/native\nTarget blinky_sim successfully set bsp to hw/bsp/native\nuser@~/dev/larva$ newt target set blinky_sim compiler_def=debug\nTarget blinky_sim successfully set compiler_def to debug\nuser@~/dev/larva$ newt target set blinky_sim compiler=sim\nTarget blinky_sim successfully set compiler to sim\nuser@~/dev/larva$ newt target show\nblinky_sim\n    arch: sim\n    bsp: hw/bsp/native\n    compiler: sim\n    compiler_def: debug\n    name: blinky_sim\n    project: blinky\nuser@~/dev/larva$ newt target build blinky_sim\nBuilding target blinky_sim (project = blinky)\nCompiling case.c\nCompiling suite.c\nCompiling testutil.c\n..\n..\nBuilding project blinky\nLinking blinky.elf\nSuccessfully run!\n\nuser@~/dev/larva$ ./project/blinky/bin/blinky_sim/blinky.elf\nuart0 at /dev/ttys005\n\n\n\n\n\nOpen up a new terminal to run minicom, a text-based serial port control and terminal emulation program. Set device name to the serial port of the target. \n\n\nuser@~$ minicom -D /dev/ttys005\nWelcome to minicom 2.7\n\nOPTIONS: \nCompiled on Nov 24 2015, 16:14:21.\nPort /dev/ttys005, 11:32:17\n\nPress Meta-Z for help on special keys\n\nlog \n174578:[0] bla\n174578:[0] bab\n\ntasks\n217809:6 tasks: \n217809:  shell (prio: 3, nw: 0, flags: 0x0, ssize: 0, cswcnt: 59, tot_run_time: 0ms)\n217840:  idle (prio: 255, nw: 0, flags: 0x0, ssize: 0, cswcnt: 18763, tot_run_time: 217809ms)\n217878:  uart_poller (prio: 0, nw: 217819, flags: 0x0, ssize: 0, cswcnt: 18667, tot_run_time: 0ms)\n217923:  task1 (prio: 1, nw: 218710, flags: 0x0, ssize: 0, cswcnt: 218, tot_run_time: 0ms)\n217953:  os_sanity (prio: 254, nw: 218710, flags: 0x0, ssize: 0, cswcnt: 218, tot_run_time: 0ms)\n218010:  task2 (prio: 2, nw: 217709, flags: 0x3, ssize: 0, cswcnt: 218, tot_run_time: 0ms)\n\nstat stat\n229881:s0: 1\n\n\n\n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nshell_cmd_register\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\n shell_cmd_register \n\n\n    int \n    shell_cmd_register(struct shell_cmd *sc, char *cmd, shell_cmd_func_t func)\n\n\n\n\nRegister a shell command. When shell reads a line of input which starts with \ncmd\n, it calls the handler \nfunc\n. Caller must allocate data structure \nsc\n. Shell internally links this to it's list of command handlers.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsc\n\n\nPointer to data structure shell egg uses to store info about the registered command\n\n\n\n\n\n\ncmd\n\n\nCommand getting registered\n\n\n\n\n\n\nfunc\n\n\nFunction to call when command is received from console\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nShell splits the arguments following the command into an array of character pointers, and passes these to registered handler. The function will be called in shell task's context, so the command handler should look out for possible issues due to concurrency.\n\n\nExample\n\n\nHere is FS registering command for 'ls'.\n\n\nstatic struct shell_cmd fs_ls_struct;\n\nstatic int\nfs_ls_cmd(int argc, char **argv)\n{\n    /* XXX do some stuff */\n    console_printf(\n%d files\\n\n, file_cnt);\n    return 0;\n}\n\nvoid\nfs_cli_init(void)\n{\n    int rc;\n\n    rc = shell_cmd_register(\nfs_ls_struct, \nls\n, fs_ls_cmd);\n    if (rc != 0) {\n        return;\n    }\n}", 
            "title": "Shell"
        }, 
        {
            "location": "/modules/shell/#shell", 
            "text": "The shell is the program which puts up a prompt for a command, processes commands, and returns output. Interacting with the console of a device is done using a shell program.", 
            "title": "Shell"
        }, 
        {
            "location": "/modules/shell/#description", 
            "text": "Shell processes console input one line at a time. Eggs can register handlers for their commands. Shell parses the input, matches it against the set of registered commands, and then calls the handler it finds.  A few commands are currently available in the shell -  tasks ,  log , and  stat stat . A $ prompt sign will be coming soon!  Create a sim target to check out these commands available in shell.  user@~/dev/larva$ newt target create blinky_sim\nCreating target blinky_sim\nTarget blinky_sim successfully created!\nuser@~/dev/larva$ newt target set blinky_sim name=blinky_sim\nTarget blinky_sim successfully set name to blinky_sim\nuser@~/dev/larva$ newt target set blinky_sim arch=sim\nTarget blinky_sim successfully set arch to sim\nuser@~/dev/larva$ newt target set blinky_sim project=blinky\nTarget blinky_sim successfully set project to blinky\nuser@~/dev/larva$ newt target set blinky_sim bsp=hw/bsp/native\nTarget blinky_sim successfully set bsp to hw/bsp/native\nuser@~/dev/larva$ newt target set blinky_sim compiler_def=debug\nTarget blinky_sim successfully set compiler_def to debug\nuser@~/dev/larva$ newt target set blinky_sim compiler=sim\nTarget blinky_sim successfully set compiler to sim\nuser@~/dev/larva$ newt target show\nblinky_sim\n    arch: sim\n    bsp: hw/bsp/native\n    compiler: sim\n    compiler_def: debug\n    name: blinky_sim\n    project: blinky\nuser@~/dev/larva$ newt target build blinky_sim\nBuilding target blinky_sim (project = blinky)\nCompiling case.c\nCompiling suite.c\nCompiling testutil.c\n..\n..\nBuilding project blinky\nLinking blinky.elf\nSuccessfully run!\n\nuser@~/dev/larva$ ./project/blinky/bin/blinky_sim/blinky.elf\nuart0 at /dev/ttys005  Open up a new terminal to run minicom, a text-based serial port control and terminal emulation program. Set device name to the serial port of the target.   user@~$ minicom -D /dev/ttys005\nWelcome to minicom 2.7\n\nOPTIONS: \nCompiled on Nov 24 2015, 16:14:21.\nPort /dev/ttys005, 11:32:17\n\nPress Meta-Z for help on special keys\n\nlog \n174578:[0] bla\n174578:[0] bab\n\ntasks\n217809:6 tasks: \n217809:  shell (prio: 3, nw: 0, flags: 0x0, ssize: 0, cswcnt: 59, tot_run_time: 0ms)\n217840:  idle (prio: 255, nw: 0, flags: 0x0, ssize: 0, cswcnt: 18763, tot_run_time: 217809ms)\n217878:  uart_poller (prio: 0, nw: 217819, flags: 0x0, ssize: 0, cswcnt: 18667, tot_run_time: 0ms)\n217923:  task1 (prio: 1, nw: 218710, flags: 0x0, ssize: 0, cswcnt: 218, tot_run_time: 0ms)\n217953:  os_sanity (prio: 254, nw: 218710, flags: 0x0, ssize: 0, cswcnt: 218, tot_run_time: 0ms)\n218010:  task2 (prio: 2, nw: 217709, flags: 0x3, ssize: 0, cswcnt: 218, tot_run_time: 0ms)\n\nstat stat\n229881:s0: 1", 
            "title": "Description"
        }, 
        {
            "location": "/modules/shell/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/modules/shell/#list-of-functions", 
            "text": "The functions available in this OS feature are:   shell_cmd_register  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/modules/shell/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/modules/shell/#shell_cmd_register", 
            "text": "int \n    shell_cmd_register(struct shell_cmd *sc, char *cmd, shell_cmd_func_t func)  Register a shell command. When shell reads a line of input which starts with  cmd , it calls the handler  func . Caller must allocate data structure  sc . Shell internally links this to it's list of command handlers.  Arguments     Arguments  Description      sc  Pointer to data structure shell egg uses to store info about the registered command    cmd  Command getting registered    func  Function to call when command is received from console     Returned values  List any values returned.\nError codes?  Notes  Shell splits the arguments following the command into an array of character pointers, and passes these to registered handler. The function will be called in shell task's context, so the command handler should look out for possible issues due to concurrency.  Example  Here is FS registering command for 'ls'.  static struct shell_cmd fs_ls_struct;\n\nstatic int\nfs_ls_cmd(int argc, char **argv)\n{\n    /* XXX do some stuff */\n    console_printf( %d files\\n , file_cnt);\n    return 0;\n}\n\nvoid\nfs_cli_init(void)\n{\n    int rc;\n\n    rc = shell_cmd_register( fs_ls_struct,  ls , fs_ls_cmd);\n    if (rc != 0) {\n        return;\n    }\n}", 
            "title": " shell_cmd_register "
        }, 
        {
            "location": "/modules/bootloader/", 
            "text": "Bootloader\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe module here, special features, how pieces fit together etc.\n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nboot_slot_addr\n\n\nboot_find_image_slot\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\n boot_slot_addr \n\n\n    static void\n    boot_slot_addr(int slot_num, uint8_t *flash_id, uint32_t *address)\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n boot_find_image_slot \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here", 
            "title": "Bootloader"
        }, 
        {
            "location": "/modules/bootloader/#bootloader", 
            "text": "Insert synopsis here", 
            "title": "Bootloader"
        }, 
        {
            "location": "/modules/bootloader/#description", 
            "text": "Describe module here, special features, how pieces fit together etc.", 
            "title": "Description"
        }, 
        {
            "location": "/modules/bootloader/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/modules/bootloader/#list-of-functions", 
            "text": "The functions available in this OS feature are:   boot_slot_addr  boot_find_image_slot  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/modules/bootloader/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/modules/bootloader/#boot_slot_addr", 
            "text": "static void\n    boot_slot_addr(int slot_num, uint8_t *flash_id, uint32_t *address)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " boot_slot_addr "
        }, 
        {
            "location": "/modules/bootloader/#boot_find_image_slot", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " boot_find_image_slot "
        }, 
        {
            "location": "/modules/bootloader/#next_one", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " next_one "
        }, 
        {
            "location": "/modules/filesystem/", 
            "text": "Filesystem\n\n\nMynewt provides a Flash File System abstraction layer (fs) to allow you to swap out the default Newtron File System (nffs) with a different file system of your choice. \n\n\nDescription\n\n\nThe default file system used in the Mynewt OS is the Newtron Flash File System (nffs). Hence the \nnffs\n egg description lists \nlibs/fs\n as a dependency. \n\n\negg.name: libs/nffs\negg.vers: 0.1\negg.identities: NFFS\negg.deps:\n    - libs/os\n    - libs/fs\n    - libs/testutil\n    - hw/hal\n\n\n\n\nIf the user wishes to use a different flash file system (say, \"ownffs\"), the directory containing \"ownffs\" code must include the \negg.yml\n file stating the dependency on \nlibs/fs\n listed as shown above. \"ownffs\" uses the \nlibs/fs\n API available in mynewt, thus minimizing changes to other parts of the project.\n\n\nNote that this generic file system (\nfs\n) API does not expose any file system detection, initialization, and formatting functions. These function calls remain specific to the chosen file system. For example, Project Slinky uses the default Newtron File System (nffs) and therefore calls nffs_init() to initialize the nffs memory and data structures before any other file system operations are attempted. As shown below, the egg for Project Slinky includes the \nlibs/imgmgr\n egg which in turn includes the \nlibs/bootutil\n egg. The egg description for \nlibs/bootutil\n specifies \nfs/nffs\n as a dependency.\n\n\n\n    egg.name: project/slinky\n    egg.vers: 0.1\n    egg.deps:\n        - libs/os\n        - libs/console/full\n        - libs/shell\n        - libs/newtmgr\n        - libs/imgmgr\n        - sys/config\n        - sys/log\n        - sys/stats\n\n\n\n\n\n    egg.name: libs/imgmgr\n    egg.vers: 0.1\n    egg.deps:\n        - libs/newtmgr\n        - libs/bootutil\n    egg.deps.FS:\n        - fs/fs\n    egg.cflags.FS: -DFS_PRESENT\n\n\n\n\n\n    egg.name: libs/bootutil\n    egg.vers: 0.1 \n    egg.deps: \n        - fs/nffs\n        - libs/os \n        - libs/testutil\n        - hw/hal\n\n\n\n\nData Structures\n\n\nAPI\n\n\n   struct fs_file;\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nfs_open\n\n\nfs_close\n\n\nfs_read\n\n\nfs_write\n\n\nfs_seek\n\n\nfs_getpos\n\n\nfs_filelen\n\n\nfs_unlink\n\n\nfs_rename\n\n\nfs_mkdir\n\n\nfs_opendir\n\n\nfs_readdir\n\n\nfs_closedir\n\n\nfs_dirent_name\n\n\nfs_dirent_is_dir\n\n\n\n\nAdditional file system utilities that bundle some of the basic functions above are:\n\n\n\n\nfsutil_read_file\n\n\nfsutil_write_file\n\n\n\n\nAPI Reference\n\n\n\n\n fs_open \n\n\n    int\n    fs_open(const char *filename, uint8_t access_flags, struct fs_file **out_file);\n\n\n\n\nOpens a file at the specified path.  The result of opening a nonexistent file depends on the access flags specified.  All intermediate directories must already exist.\n\n\nThe mode strings passed to fopen() map to fs_open()'s access flags as follows:\n\n\n    \nr\n  -  FS_ACCESS_READ\n    \nr+\n -  FS_ACCESS_READ | FS_ACCESS_WRITE\n    \nw\n  -  FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE\n    \nw+\n -  FS_ACCESS_READ | FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE\n    \na\n  -  FS_ACCESS_WRITE | FS_ACCESS_APPEND\n    \na+\n -  FS_ACCESS_READ | FS_ACCESS_WRITE | FS_ACCESS_APPEND\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfilename\n\n\nPointer to the file created at the path of the specified filename\n\n\n\n\n\n\naccess_flags\n\n\nFlags controlling file access; see above table\n\n\n\n\n\n\nout_file\n\n\nOn success, a pointer to the newly-created file handle gets written here\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nnonzero on failure\n\n\n\n\nNotes\n\n\nThere is no concept of current working directory. Therefore all file names should start with '/'.\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n fs_close \n\n\n   int\n   fs_close(struct fs_file *file)\n\n\n\n\nCloses the specified file and invalidates the file handle.  If the file has already been unlinked, and this is the last open handle to the file, this operation causes the file to be deleted from disk.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nPointer to the file to close\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nnonzero on failure\n\n\n\n\nNotes\n\n\nDon't use file handle after closing the file.\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n fs_read \n\n\n   int\n   fs_read(struct fs_file *file, uint32_t len, void *out_data, uint32_t *out_len);\n\n\n\n\nReads data from the specified file.  If more data is requested than remains in the file, all available data is retrieved. Function returns in \nout_len\n the actual number of bytes read (less or equal to \nlen\n).\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nPointer to the the file to read from\n\n\n\n\n\n\nlen\n\n\nThe number of bytes to attempt to read\n\n\n\n\n\n\nout_data\n\n\nThe destination buffer to read into\n\n\n\n\n\n\nout_len\n\n\nOn success, the number of bytes actually read gets written here.  Pass null if you don't care.\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nnonzero on failure\n\n\n\n\nNotes\n\n\nThis type of short read results in a success return code.\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n fs_write \n\n\n   int\n   fs_write(struct fs_file *file, const void *data, int len);\n\n\n\n\nWrites the supplied data to the current offset of the specified file handle.  \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nPointer to the file to write to\n\n\n\n\n\n\ndata\n\n\nThe data to write\n\n\n\n\n\n\nlen\n\n\nThe number of bytes to write\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nnonzero on failure\n\n\n\n\nNotes\n\n\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n fs_seek \n\n\n   int\n   fs_seek(struct fs_file *file, uint32_t offset);\n\n\n\n\nPositions a file's read and write pointer at the specified offset.  The offset is expressed as the number of bytes from the start of the file (i.e., seeking to offset 0 places the pointer at the first byte in the file). \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nPointer to the file to reposition\n\n\n\n\n\n\noffset\n\n\nThe 0-based file offset to seek to\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nnonzero on failure\n\n\n\n\nNotes\n\n\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n fs_getpos \n\n\n   uint32_t\n   fs_getpos(const struct fs_file *file);\n\n\n\n\nRetrieves the current read and write position of the specified open file. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nPointer to the file to query\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\nThe file offset, in bytes\n\n\n\n\nNotes\n\n\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n fs_filelen \n\n\n   int\n   fs_filelen(const struct fs_file *file, uint32_t *out_len);\n\n\n\n\n\nRetrieves the current length of the specified open file.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nPointer to the file to query\n\n\n\n\n\n\nout_len\n\n\nOn success, the number of bytes in the file gets written here\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nnonzero on failure\n\n\n\n\nNotes\n\n\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n fs_unlink \n\n\n   int\n   fs_unlink(const char *filename);\n\n\n\n\n\nUnlinks the file or directory at the specified path.  If the path refers to a directory, all the directory's descendants are recursively unlinked.  Any open file handles refering to an unlinked file remain valid, and can be read from and written to.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfilename\n\n\nThe path of the file or directory to unlink\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nnonzero on failure\n\n\n\n\nNotes\n\n\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n fs_rename \n\n\n   int\n   fs_rename(const char *from, const char *to);\n\n\n\n\n\nPerforms a rename and / or move of the specified source path to the specified destination.  \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfrom\n\n\nThe source path\n\n\n\n\n\n\nto\n\n\nThe destination path\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nnonzero on failure\n\n\n\n\nNotes\n\n\nThe source path can refer to either a file or a directory.  All intermediate directories in the destination path must already exist.  If the source path refers to a file, the destination path must contain a full filename path, rather than just the new parent directory.  If an object already exists at the specified destination path, this function causes it to be unlinked prior to the rename (i.e., the destination gets clobbered).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n fs_mkdir \n\n\n   int\n   fs_mkdir(const char *path);\n\n\n\n\n\nCreates the directory represented by the specified path.  \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nPointer to the directory to create\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nnonzero on failure.\n\n\n\n\nNotes\n\n\nAll intermediate directories must already exist.  The specified path must start with a '/' character.\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n fs_opendir \n\n\n\n   int\n   fs_opendir(const char *path, struct fs_dir **out_dir);\n\n\n\n\n\nOpens the directory at the specified path.  The directory's contents can be read with subsequent calls to fs_readdir().  When you are done with the directory handle, close it with fs_closedir(). \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nPointer to the directory to create\n\n\n\n\n\n\nout_dir\n\n\nOn success, points to the directory handle\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS_ENOENT if the specified directory does not exist (no such file)\n\n\nOther nonzero on error.\n\n\n\n\nNotes\n\n\nUnlinking files from the directory while it is open may result in unpredictable behavior.  New files can be created inside the directory.\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n fs_readdir \n\n\n   int\n   fs_readdir(struct fs_dir *dir, struct fs_dirent **out_dirent);\n\n\n\n\n\nReads the next entry in an open directory. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndir\n\n\nThe directory handle to read from\n\n\n\n\n\n\nout_dirent\n\n\nOn success, points to the next child entry in the specified directory\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS_ENOENT if there are no more entries in the parent directory\n\n\nOther nonzero on error.\n\n\n\n\nNotes\n\n\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n fs_closedir \n\n\n   int\n   fs_closedir(struct fs_dir *dir);\n\n\n\n\n\nCloses the specified directory handle. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndir\n\n\nPointer to the directory to close\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nnonzero on failure\n\n\n\n\nNotes\n\n\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n fs_dirent_name \n\n\n   int\n   fs_dirent_name(const struct fs_dirent *dirent, size_t max_len,\n     char *out_name, uint8_t *out_name_len);\n\n\n\n\n\nRetrieves the filename of the specified directory entry. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndirent\n\n\nPointer to the directory entry to query\n\n\n\n\n\n\nmax_len\n\n\nSize of the \"out_name\" character buffer\n\n\n\n\n\n\nout_name\n\n\nOn success, the entry's filename is written here; always null-terminated\n\n\n\n\n\n\nout_name_len\n\n\nOn success, contains the actual length of the filename, NOT including the null-terminator\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nnonzero on failure\n\n\n\n\nNotes\n\n\nThe retrieved filename is always null-terminated.  To ensure enough space to hold the full filename plus a null-termintor, a destination buffer of size  (filename max length + 1) should be used.\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n fs_dirent_is_dir \n\n\n   int\n   fs_dirent_is_dir(const struct fs_dirent *dirent);\n\n\n\n\n\nTells you whether the specified directory entry is a sub-directory or a regular file. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndirent\n\n\nPointer to the directory entry to query\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n1: The entry is a directory\n\n\n0: The entry is a regular file.\n\n\n\n\nNotes\n\n\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n fsutil_read_file \n\n\n   int\n   fsutil_read_file(const char *path, uint32_t offset, uint32_t len, void *dst,\n                    uint32_t *out_len);\n\n\n\n\nCalls fs_open(), fs_read(), and fs_close() to open a file at the specified path, retrieve data from the file starting from the specified offset, and close the file and invalidate the file handle.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nPointer to the directory entry to query\n\n\n\n\n\n\noffset\n\n\nPosition of the file's read pointer\n\n\n\n\n\n\nlen\n\n\nNumber of bytes to attempt to read\n\n\n\n\n\n\ndst\n\n\nDestination buffer to read into\n\n\n\n\n\n\nout_len\n\n\nOn success, the number of bytes actually read gets written here.  Pass null if you don't care.\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nnonzero on failure\n\n\n\n\nNotes\n\n\nThis is a convenience function. You can use it if the file is small (caller has enough buffer space to hold all the file contents in memory).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n fsutil_write_file \n\n\n   int\n   fsutil_write_file(const char *path, const void *data, uint32_t len);\n\n\n\n\nCalls fs_open(), fs_write(), and fs_close() to open a file at the specified path, write the supplied data to the current offset of the specified file handle, and close the file and invalidate the file handle.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nPointer to the file to write to\n\n\n\n\n\n\ndata\n\n\nThe data to write\n\n\n\n\n\n\nlen\n\n\nThe number of bytes to write\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nnonzero on failure\n\n\n\n\nNotes\n\n\n\n\nExample\n\n\n\n\nInsert the code snippet here", 
            "title": "File System Abstraction"
        }, 
        {
            "location": "/modules/filesystem/#filesystem", 
            "text": "Mynewt provides a Flash File System abstraction layer (fs) to allow you to swap out the default Newtron File System (nffs) with a different file system of your choice.", 
            "title": "Filesystem"
        }, 
        {
            "location": "/modules/filesystem/#description", 
            "text": "The default file system used in the Mynewt OS is the Newtron Flash File System (nffs). Hence the  nffs  egg description lists  libs/fs  as a dependency.   egg.name: libs/nffs\negg.vers: 0.1\negg.identities: NFFS\negg.deps:\n    - libs/os\n    - libs/fs\n    - libs/testutil\n    - hw/hal  If the user wishes to use a different flash file system (say, \"ownffs\"), the directory containing \"ownffs\" code must include the  egg.yml  file stating the dependency on  libs/fs  listed as shown above. \"ownffs\" uses the  libs/fs  API available in mynewt, thus minimizing changes to other parts of the project.  Note that this generic file system ( fs ) API does not expose any file system detection, initialization, and formatting functions. These function calls remain specific to the chosen file system. For example, Project Slinky uses the default Newtron File System (nffs) and therefore calls nffs_init() to initialize the nffs memory and data structures before any other file system operations are attempted. As shown below, the egg for Project Slinky includes the  libs/imgmgr  egg which in turn includes the  libs/bootutil  egg. The egg description for  libs/bootutil  specifies  fs/nffs  as a dependency.  \n    egg.name: project/slinky\n    egg.vers: 0.1\n    egg.deps:\n        - libs/os\n        - libs/console/full\n        - libs/shell\n        - libs/newtmgr\n        - libs/imgmgr\n        - sys/config\n        - sys/log\n        - sys/stats  \n    egg.name: libs/imgmgr\n    egg.vers: 0.1\n    egg.deps:\n        - libs/newtmgr\n        - libs/bootutil\n    egg.deps.FS:\n        - fs/fs\n    egg.cflags.FS: -DFS_PRESENT  \n    egg.name: libs/bootutil\n    egg.vers: 0.1 \n    egg.deps: \n        - fs/nffs\n        - libs/os \n        - libs/testutil\n        - hw/hal", 
            "title": "Description"
        }, 
        {
            "location": "/modules/filesystem/#data-structures", 
            "text": "", 
            "title": "Data Structures"
        }, 
        {
            "location": "/modules/filesystem/#api", 
            "text": "struct fs_file;  The functions available in this OS feature are:   fs_open  fs_close  fs_read  fs_write  fs_seek  fs_getpos  fs_filelen  fs_unlink  fs_rename  fs_mkdir  fs_opendir  fs_readdir  fs_closedir  fs_dirent_name  fs_dirent_is_dir   Additional file system utilities that bundle some of the basic functions above are:   fsutil_read_file  fsutil_write_file", 
            "title": "API"
        }, 
        {
            "location": "/modules/filesystem/#api-reference", 
            "text": "", 
            "title": "API Reference"
        }, 
        {
            "location": "/modules/filesystem/#fs_open", 
            "text": "int\n    fs_open(const char *filename, uint8_t access_flags, struct fs_file **out_file);  Opens a file at the specified path.  The result of opening a nonexistent file depends on the access flags specified.  All intermediate directories must already exist.  The mode strings passed to fopen() map to fs_open()'s access flags as follows:       r   -  FS_ACCESS_READ\n     r+  -  FS_ACCESS_READ | FS_ACCESS_WRITE\n     w   -  FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE\n     w+  -  FS_ACCESS_READ | FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE\n     a   -  FS_ACCESS_WRITE | FS_ACCESS_APPEND\n     a+  -  FS_ACCESS_READ | FS_ACCESS_WRITE | FS_ACCESS_APPEND  Arguments     Arguments  Description      filename  Pointer to the file created at the path of the specified filename    access_flags  Flags controlling file access; see above table    out_file  On success, a pointer to the newly-created file handle gets written here     Returned values   0 on success  nonzero on failure   Notes  There is no concept of current working directory. Therefore all file names should start with '/'.  Example    Insert the code snippet here", 
            "title": " fs_open "
        }, 
        {
            "location": "/modules/filesystem/#fs_close", 
            "text": "int\n   fs_close(struct fs_file *file)  Closes the specified file and invalidates the file handle.  If the file has already been unlinked, and this is the last open handle to the file, this operation causes the file to be deleted from disk.  Arguments     Arguments  Description      file  Pointer to the file to close     Returned values   0 on success  nonzero on failure   Notes  Don't use file handle after closing the file.  Example    Insert the code snippet here", 
            "title": " fs_close "
        }, 
        {
            "location": "/modules/filesystem/#fs_read", 
            "text": "int\n   fs_read(struct fs_file *file, uint32_t len, void *out_data, uint32_t *out_len);  Reads data from the specified file.  If more data is requested than remains in the file, all available data is retrieved. Function returns in  out_len  the actual number of bytes read (less or equal to  len ).  Arguments     Arguments  Description      file  Pointer to the the file to read from    len  The number of bytes to attempt to read    out_data  The destination buffer to read into    out_len  On success, the number of bytes actually read gets written here.  Pass null if you don't care.     Returned values   0 on success  nonzero on failure   Notes  This type of short read results in a success return code.  Example   Insert the code snippet here", 
            "title": " fs_read "
        }, 
        {
            "location": "/modules/filesystem/#fs_write", 
            "text": "int\n   fs_write(struct fs_file *file, const void *data, int len);  Writes the supplied data to the current offset of the specified file handle.    Arguments     Arguments  Description      file  Pointer to the file to write to    data  The data to write    len  The number of bytes to write     Returned values   0 on success  nonzero on failure   Notes   Example   Insert the code snippet here", 
            "title": " fs_write "
        }, 
        {
            "location": "/modules/filesystem/#fs_seek", 
            "text": "int\n   fs_seek(struct fs_file *file, uint32_t offset);  Positions a file's read and write pointer at the specified offset.  The offset is expressed as the number of bytes from the start of the file (i.e., seeking to offset 0 places the pointer at the first byte in the file).   Arguments     Arguments  Description      file  Pointer to the file to reposition    offset  The 0-based file offset to seek to     Returned values   0 on success  nonzero on failure   Notes   Example   Insert the code snippet here", 
            "title": " fs_seek "
        }, 
        {
            "location": "/modules/filesystem/#fs_getpos", 
            "text": "uint32_t\n   fs_getpos(const struct fs_file *file);  Retrieves the current read and write position of the specified open file.   Arguments     Arguments  Description      file  Pointer to the file to query     Returned values   The file offset, in bytes   Notes   Example   Insert the code snippet here", 
            "title": " fs_getpos "
        }, 
        {
            "location": "/modules/filesystem/#fs_filelen", 
            "text": "int\n   fs_filelen(const struct fs_file *file, uint32_t *out_len);  Retrieves the current length of the specified open file.  Arguments     Arguments  Description      file  Pointer to the file to query    out_len  On success, the number of bytes in the file gets written here     Returned values   0 on success  nonzero on failure   Notes   Example   Insert the code snippet here", 
            "title": " fs_filelen "
        }, 
        {
            "location": "/modules/filesystem/#fs_unlink", 
            "text": "int\n   fs_unlink(const char *filename);  Unlinks the file or directory at the specified path.  If the path refers to a directory, all the directory's descendants are recursively unlinked.  Any open file handles refering to an unlinked file remain valid, and can be read from and written to.  Arguments     Arguments  Description      filename  The path of the file or directory to unlink     Returned values   0 on success  nonzero on failure   Notes   Example   Insert the code snippet here", 
            "title": " fs_unlink "
        }, 
        {
            "location": "/modules/filesystem/#fs_rename", 
            "text": "int\n   fs_rename(const char *from, const char *to);  Performs a rename and / or move of the specified source path to the specified destination.    Arguments     Arguments  Description      from  The source path    to  The destination path     Returned values   0 on success  nonzero on failure   Notes  The source path can refer to either a file or a directory.  All intermediate directories in the destination path must already exist.  If the source path refers to a file, the destination path must contain a full filename path, rather than just the new parent directory.  If an object already exists at the specified destination path, this function causes it to be unlinked prior to the rename (i.e., the destination gets clobbered).  Example   Insert the code snippet here", 
            "title": " fs_rename "
        }, 
        {
            "location": "/modules/filesystem/#fs_mkdir", 
            "text": "int\n   fs_mkdir(const char *path);  Creates the directory represented by the specified path.    Arguments     Arguments  Description      path  Pointer to the directory to create     Returned values   0 on success  nonzero on failure.   Notes  All intermediate directories must already exist.  The specified path must start with a '/' character.  Example   Insert the code snippet here", 
            "title": " fs_mkdir "
        }, 
        {
            "location": "/modules/filesystem/#fs_opendir", 
            "text": "int\n   fs_opendir(const char *path, struct fs_dir **out_dir);  Opens the directory at the specified path.  The directory's contents can be read with subsequent calls to fs_readdir().  When you are done with the directory handle, close it with fs_closedir().   Arguments     Arguments  Description      path  Pointer to the directory to create    out_dir  On success, points to the directory handle     Returned values   0 on success  FS_ENOENT if the specified directory does not exist (no such file)  Other nonzero on error.   Notes  Unlinking files from the directory while it is open may result in unpredictable behavior.  New files can be created inside the directory.  Example   Insert the code snippet here", 
            "title": " fs_opendir "
        }, 
        {
            "location": "/modules/filesystem/#fs_readdir", 
            "text": "int\n   fs_readdir(struct fs_dir *dir, struct fs_dirent **out_dirent);  Reads the next entry in an open directory.   Arguments     Arguments  Description      dir  The directory handle to read from    out_dirent  On success, points to the next child entry in the specified directory     Returned values   0 on success  FS_ENOENT if there are no more entries in the parent directory  Other nonzero on error.   Notes   Example   Insert the code snippet here", 
            "title": " fs_readdir "
        }, 
        {
            "location": "/modules/filesystem/#fs_closedir", 
            "text": "int\n   fs_closedir(struct fs_dir *dir);  Closes the specified directory handle.   Arguments     Arguments  Description      dir  Pointer to the directory to close     Returned values   0 on success  nonzero on failure   Notes   Example   Insert the code snippet here", 
            "title": " fs_closedir "
        }, 
        {
            "location": "/modules/filesystem/#fs_dirent_name", 
            "text": "int\n   fs_dirent_name(const struct fs_dirent *dirent, size_t max_len,\n     char *out_name, uint8_t *out_name_len);  Retrieves the filename of the specified directory entry.   Arguments     Arguments  Description      dirent  Pointer to the directory entry to query    max_len  Size of the \"out_name\" character buffer    out_name  On success, the entry's filename is written here; always null-terminated    out_name_len  On success, contains the actual length of the filename, NOT including the null-terminator     Returned values   0 on success  nonzero on failure   Notes  The retrieved filename is always null-terminated.  To ensure enough space to hold the full filename plus a null-termintor, a destination buffer of size  (filename max length + 1) should be used.  Example   Insert the code snippet here", 
            "title": " fs_dirent_name "
        }, 
        {
            "location": "/modules/filesystem/#fs_dirent_is_dir", 
            "text": "int\n   fs_dirent_is_dir(const struct fs_dirent *dirent);  Tells you whether the specified directory entry is a sub-directory or a regular file.   Arguments     Arguments  Description      dirent  Pointer to the directory entry to query     Returned values   1: The entry is a directory  0: The entry is a regular file.   Notes   Example   Insert the code snippet here", 
            "title": " fs_dirent_is_dir "
        }, 
        {
            "location": "/modules/filesystem/#fsutil_read_file", 
            "text": "int\n   fsutil_read_file(const char *path, uint32_t offset, uint32_t len, void *dst,\n                    uint32_t *out_len);  Calls fs_open(), fs_read(), and fs_close() to open a file at the specified path, retrieve data from the file starting from the specified offset, and close the file and invalidate the file handle.  Arguments     Arguments  Description      path  Pointer to the directory entry to query    offset  Position of the file's read pointer    len  Number of bytes to attempt to read    dst  Destination buffer to read into    out_len  On success, the number of bytes actually read gets written here.  Pass null if you don't care.     Returned values   0 on success  nonzero on failure   Notes  This is a convenience function. You can use it if the file is small (caller has enough buffer space to hold all the file contents in memory).  Example   Insert the code snippet here", 
            "title": " fsutil_read_file "
        }, 
        {
            "location": "/modules/filesystem/#fsutil_write_file", 
            "text": "int\n   fsutil_write_file(const char *path, const void *data, uint32_t len);  Calls fs_open(), fs_write(), and fs_close() to open a file at the specified path, write the supplied data to the current offset of the specified file handle, and close the file and invalidate the file handle.  Arguments     Arguments  Description      path  Pointer to the file to write to    data  The data to write    len  The number of bytes to write     Returned values   0 on success  nonzero on failure   Notes   Example   Insert the code snippet here", 
            "title": " fsutil_write_file "
        }, 
        {
            "location": "/modules/nffs/", 
            "text": "Newtron Flash Filesystem (nffs)\n\n\nMynewt comes with the flash file system called the Newtron Flash File System (nffs) which is designed with two priorities that makes it suitable for embedded use: \n\n\n\n\nMinimal RAM usage\n\n\nReliability\n\n\n\n\nMynewt also provides an abstraction layer API (fs) to allow you to swap out nffs with a different file system of your choice.\n\n\nDescription\n\n\nDescribe module here, special features, how pieces fit together etc.\n\n\nDisk and data structures\n\n\nAt the top level, an nffs disk is partitioned into areas.  An area is a region\nof disk with the following properties:\n\n\n\n\nAn area can be fully erased without affecting any other areas.\n\n\nA write to one area does not restrict writes to other areas.\n\n\n\n\nNote\n: Some flash hardware divides its memory space into \"blocks.\"  Writes within a block must be sequential, but writes to one block have no effect on what parts of other blocks can be written.  Thus, for flash hardware with such a restriction, each area must comprise a discrete number of blocks.\n\n\nWhile not strictly necessary, it is recommended that all areas have the same\nsize.\n\n\nOn disk, each area is prefixed with the following header:\n\n\n/** On-disk representation of an area header. */\nstruct nffs_disk_area {\n    uint32_t nda_magic[4];  /* NFFS_AREA_MAGIC{0,1,2,3} */\n    uint32_t nda_length;    /* Total size of area, in bytes. */\n    uint8_t nda_ver;        /* Current nffs version: 0 */\n    uint8_t nda_gc_seq;     /* Garbage collection count. */\n    uint8_t reserved8;\n    uint8_t nda_id;         /* 0xff if scratch area. */\n};\n\n\n\n\nBeyond its header, an area contains a sequence of disk objects, representing\nthe contents of the file system.  There are two types of objects: \ninodes\n and\n\ndata blocks\n.  An inode represents a file or directory; a data block represents\npart of a file's contents.\n\n\n/** On-disk representation of an inode (file or directory). */\nstruct nffs_disk_inode {\n    uint32_t ndi_magic;         /* NFFS_INODE_MAGIC */\n    uint32_t ndi_id;            /* Unique object ID. */\n    uint32_t ndi_seq;           /* Sequence number; greater supersedes\n                                   lesser. */\n    uint32_t ndi_parent_id;     /* Object ID of parent directory inode. */\n    uint8_t reserved8;\n    uint8_t ndi_filename_len;   /* Length of filename, in bytes. */\n    uint16_t ndi_crc16;         /* Covers rest of header and filename. */\n    /* Followed by filename. */\n};\n\n\n\n\nAn inode filename's length cannot exceed 256 bytes.  The filename is not\nnull-terminated.  The following ASCII characters are not allowed in a\nfilename:\n    * /  (slash character)\n    * \\0 (NUL character)\n\n\n/** On-disk representation of a data block. */\nstruct nffs_disk_block {\n    uint32_t ndb_magic;     /* NFFS_BLOCK_MAGIC */\n    uint32_t ndb_id;        /* Unique object ID. */\n    uint32_t ndb_seq;       /* Sequence number; greater supersedes lesser. */\n    uint32_t ndb_inode_id;  /* Object ID of owning inode. */\n    uint32_t ndb_prev_id;   /* Object ID of previous block in file;\n                               NFFS_ID_NONE if this is the first block. */\n    uint16_t ndb_data_len;  /* Length of data contents, in bytes. */\n    uint16_t ndb_crc16;     /* Covers rest of header and data. */\n    /* Followed by 'ndb_data_len' bytes of data. */\n};\n\n\n\n\nEach data block contains the ID of the previous data block in the file.\nTogether, the set of blocks in a file form a reverse singly-linked list.\n\n\nThe maximum number of data bytes that a block can contain is determined at\ninitialization-time.  The result is the greatest number which satisfies all of\nthe following restrictions:\n    o No more than 2048.\n    o At least two maximum-sized blocks can fit in the smallest area.\n\n\nThe 2048 number was chosen somewhat arbitrarily, and may change in the future.\n\n\nID space\n\n\nAll disk objects have a unique 32-bit ID.  The ID space is partitioned as\nfollows:\n      * 0x00000000 - 0x0fffffff: Directory inodes.\n      * 0x10000000 - 0x7fffffff: File inodes.\n      * 0x80000000 - 0xfffffffe: Data blocks.\n      * 0xffffffff             : Reserved (NFFS_ID_NONE)\n\n\nScratch area\n\n\nA valid nffs file system must contain a single \"scratch area.\"  The scratch\narea does not contain any objects of its own, and is only used during garbage\ncollection.  The scratch area must have a size greater than or equal to each\nof the other areas in flash.\n\n\nRAM representation\n\n\nEvery object in the file system is stored in a 256-entry hash table.  An\nobject's hash key is derived from its 32-bit ID.  Each list in the hash table\nis sorted by time of use; most-recently-used is at the front of the list. All\nobjects are represented by the following structure:\n\n\n/**\n * What gets stored in the hash table.  Each entry represents a data block or\n * an inode.\n */\nstruct nffs_hash_entry {\n    SLIST_ENTRY(nffs_hash_entry) nhe_next;\n    uint32_t nhe_id;        /* 0 - 0x7fffffff if inode; else if block. */\n    uint32_t nhe_flash_loc; /* Upper-byte = area idx; rest = area offset. */\n};\n\n\n\n\nFor each data block, the above structure is all that is stored in RAM.  To\nacquire more information about a data block, the block header must be read\nfrom flash.\n\n\nInodes require a fuller RAM representation to capture the structure of the\nfile system.  There are two types of inodes: \nfiles\n and \ndirectories\n.  Each\ninode hash entry is actually an instance of the following structure:\n\n\n/** Each inode hash entry is actually one of these. */\nstruct nffs_inode_entry {\n    struct nffs_hash_entry nie_hash_entry;\n    SLIST_ENTRY(nffs_inode_entry) nie_sibling_next;\n    union {\n        struct nffs_inode_list nie_child_list;           /* If directory */\n        struct nffs_hash_entry *nie_last_block_entry;    /* If file */\n    };\n    uint8_t nie_refcnt;\n};\n\n\n\n\nA directory inode contains a list of its child files and directories\n(fie_child_list).  These entries are sorted alphabetically using the ASCII\ncharacter set.\n\n\nA file inode contains a pointer to the last data block in the file\n(nie_last_block_entry).  For most file operations, the reversed block list must\nbe walked backwards.  This introduces a number of speed inefficiencies:\n    * All data blocks must be read to determine the length of the file.\n    * Data blocks often need to be processed sequentially.  The reversed\n      nature of the block list transforms this from linear time to an O(n^2)\n      operation.\n\n\nFurthermore, obtaining information about any constituent data block requires a\nseparate flash read.\n\n\nInode cache and Data Block cache\n\n\nThe speed issues are addressed by a pair of caches.  Cached inodes entries\ncontain the file length and a much more convenient doubly-linked list of\ncached data blocks.  The benefit of using caches is that the size of the\ncaches need not be proportional to the size of the file system.  In other\nwords, caches can address speed efficiency concerns without negatively\nimpacting the file system's scalability.\n\n\nnffs requires both caches during normal operation, so it is not possible to\ndisable them.  However, the cache sizes are configurable, and both caches can\nbe configured with a size of one if RAM usage must be minimized.\n\n\nThe following data structures are used in the inode and data block caches.\n\n\n/** Full data block representation; not stored permanently in RAM. */\nstruct nffs_block {\n    struct nffs_hash_entry *nb_hash_entry;   /* Points to real block entry. */\n    uint32_t nb_seq;                         /* Sequence number; greater\n                                                supersedes lesser. */\n    struct nffs_inode_entry *nb_inode_entry; /* Owning inode. */\n    struct nffs_hash_entry *nb_prev;         /* Previous block in file. */\n    uint16_t nb_data_len;                    /* # of data bytes in block. */\n    uint16_t reserved16;\n};\n\n/** Represents a single cached data block. */\nstruct nffs_cache_block {\n    TAILQ_ENTRY(nffs_cache_block) ncb_link; /* Next / prev cached block. */\n    struct nffs_block ncb_block;            /* Full data block. */\n    uint32_t ncb_file_offset;               /* File offset of this block. */\n};\n\n/** Full inode representation; not stored permanently in RAM. */\nstruct nffs_inode {\n    struct nffs_inode_entry *ni_inode_entry; /* Points to real inode entry. */\n    uint32_t ni_seq;                         /* Sequence number; greater\n                                                supersedes lesser. */\n    struct nffs_inode_entry *ni_parent;      /* Points to parent directory. */\n    uint8_t ni_filename_len;                 /* # chars in filename. */\n    uint8_t ni_filename[NFFS_SHORT_FILENAME_LEN]; /* First 3 bytes. */\n};\n\n/** Doubly-linked tail queue of cached blocks; contained in cached inodes. */\nTAILQ_HEAD(nffs_block_cache_list, nffs_block_cache_entry);\n\n/** Represents a single cached file inode. */\nstruct nffs_cache_inode {\n    TAILQ_ENTRY(nffs_cache_inode) nci_link;        /* Sorted; LRU at tail. */\n    struct nffs_inode nci_inode;                   /* Full inode. */\n    struct nffs_cache_block_list nci_block_list;   /* List of cached blocks. */\n    uint32_t nci_file_size;                        /* Total file size. */\n};\n\n\n\n\nOnly file inodes are cached; directory inodes are never cached.\n\n\nWithin a cached inode, all cached data blocks are contiguous.  E.g., if the\nstart and end of a file are cached, then the middle must also be cached.  A\ndata block is only cached if its owning file is also cached.\n\n\nInternally, cached inodes are stored in a singly-linked list, ordered by time\nof use.  The most-recently-used entry is the first element in the list.  If a\nnew inode needs to be cached, but the inode cache is full, the\nleast-recently-used entry is freed to make room for the new one.  The\nfollowing operations cause an inode to be cached:\n\n\n\n\nQuerying a file's length.\n\n\nSeeking within a file.\n\n\nReading from a file.\n\n\nWriting to a file.\n\n\n\n\nThe following operations cause a data block to be cached:\n\n\n\n\nReading from the block.\n\n\nWriting to the block.\n\n\n\n\nIf one of the above operations is applied to a data block that is not currently\ncached, nffs uses the following procedure to cache the necessary block:\n\n\n\n\nIf none of the owning inode's blocks are currently cached, allocate a\n       cached block entry corresponding to the requested block and insert it\n       into the inode's list.\n\n\nElse if the requested file offset is less than that of the first cached\n       block, bridge the gap between the inode's sequence of cached blocks and\n       the block that now needs to be cached.  This is accomplished by caching\n       each block in the gap, finishing with the requested block.\n\n\nElse (the requested offset is beyond the end of the cache),\n   a. If the requested offset belongs to the block that immediately follows the end of the cache, cache the block and append it to the list.\n   b. Else, clear the cache, and populate it with the single entry corresponding to the requested block.\n\n\n\n\nIf the system is unable to allocate a cached block entry at any point during\nthe above procedure, the system frees up other blocks currently in the cache. This is accomplished as follows:\n\n\n\n\nIterate the inode cache in reverse (i.e., start with the least-recently-used entry).  For each entry:\n   a. If the entry's cached block list is empty, advance to the next entry.\n   b. Else, free all the cached blocks in the entry's list.\n\n\n\n\nBecause the system imposes a minimum block cache size of one, the above\nprocedure will always reclaim at least one cache block entry.  The above\nprocedure may result in the freeing of the block list that belongs to the very\ninode being operated on.  This is OK, as the final block to get cached is\nalways the block being requested.\n\n\nConfiguration\n\n\nThe file system is configured by populating fields in a global structure.\nEach field in the structure corresponds to a setting.  All configuration must\nbe done prior to calling nffs_init().  The configuration structure is defined\nas follows:\n\n\n\nstruct nffs_config {\n    /** Maximum number of inodes; default=1024. */\n    uint32_t nc_num_inodes;\n\n    /** Maximum number of data blocks; default=4096. */\n    uint32_t nc_num_blocks;\n\n    /** Maximum number of open files; default=4. */\n    uint32_t nc_num_files;\n\n    /** Inode cache size; default=4. */\n    uint32_t nc_num_cache_inodes;\n\n    /** Data block cache size; default=64. */\n    uint32_t nc_num_cache_blocks;\n    };\n\nextern struct nffs_config nffs_config;\n\n\n\n\nAny fields that are set to 0 (or not set at all) inherit the corresponding\ndefault value.  This means that it is impossible to configure any setting with\na value of zero.\n\n\nInitialization\n\n\nThere are two means of initializing an nffs file system:\n\n\n\n\nRestore an existing file system via detection.\n\n\nCreate a new file system via formatting.\n\n\n\n\nBoth methods require the user to describe how the flash memory is divided into\nareas.  This is accomplished with an array of struct nffs_area_desc, defined as\nfollows:\n\n\nstruct nffs_area_desc {\n    uint32_t nad_offset;    /* Flash offset of start of area. */\n    uint32_t nad_length;    /* Size of area, in bytes. */\n};\n\n\n\n\nAn array of area descriptors is terminated by an entry with a fad_length field\nof 0.\n\n\nOne common initialization sequence is the following:\n\n\n\n\nDetect an nffs file system anywhere in flash.\n\n\nIf no file system detected, format a new file system in a specific\n        region of flash.\n\n\n\n\nDetection\n\n\nThe file system detection process consists of scanning a specified set of\nflash regions for valid nffs areas, and then populating the RAM representation\nof the file system with the detected objects.  Detection is initiated with the\nfollowing function:\n\n\n/**\n * Searches for a valid nffs file system among the specified areas.  This\n * function succeeds if a file system is detected among any subset of the\n * supplied areas.  If the area set does not contain a valid file system,\n * a new one can be created via a separate call to nffs_format().\n *\n * @param area_descs        The area set to search.  This array must be\n *                              terminated with a 0-length area.\n *\n * @return                  0 on success;\n *                          NFFS_ECORRUPT if no valid file system was detected;\n *                          other nonzero on error.\n */\nint nffs_detect(const struct nffs_area_desc *area_descs);\n\n\n\n\nAs indicated, not every area descriptor needs to reference a valid nffs area.\nDetection is successful as long as a complete file system is detected\nsomewhere in the specified regions of flash.  If an application is unsure\nwhere a file system might be located, it can initiate detection across the\nentire flash region.\n\n\nA detected file system is valid if:\n\n\n\n\nAt least one non-scratch area is present.\n\n\nAt least one scratch area is present (only the first gets used if there is more than one).\n\n\nThe root directory inode is present.\n\n\n\n\nDuring detection, each indicated region of flash is checked for a valid area\nheader.  The contents of each valid non-scratch area are then restored into\nthe nffs RAM representation.  The following procedure is applied to each object\nin the area:\n\n\n\n\n\n\nVerify the object's integrity via a crc16 check.  If invalid, the object is discarded and the procedure restarts on the next object in the area.\n\n\n\n\n\n\nConvert the disk object into its corresponding RAM representation and insert it into the hash table.  If the object is an inode, its reference count is initialized to 1, indicating ownership by its parent directory.\n\n\n\n\n\n\nIf an object with the same ID is already present, then one supersedes the other.  Accept the object with the greater sequence number and discard the other.\n\n\n\n\n\n\nIf the object references a nonexistant inode (parent directory in the case of an inode; owning file in the case of a data block), insert a temporary \"dummy\" inode into the hash table so that inter-object links can be maintained until the absent inode is eventually restored.  Dummy inodes are identified by a reference count of 0.\n\n\n\n\n\n\nIf a delete record for an inode is encountered, the inode's parent pointer is set to null to indicate that it should be removed from RAM.\n\n\n\n\n\n\nIf nffs encounters an object that cannot be identified (i.e., its magic number\nis not valid), it scans the remainder of the flash area for the next valid\nmagic number.  Upon encountering a valid object, nffs resumes the procedure\ndescribed above.\n\n\nAfter all areas have been restored, a sweep is performed across the entire RAM\nrepresentation so that invalid inodes can be deleted from memory.\n\n\nFor each directory inode:\n\n\n\n\nIf its reference count is 0 (i.e., it is a dummy), migrate its children to the /lost+found directory, and delete it from the RAM representation. This should only happen in the case of file system corruption.\n\n\nIf its parent reference is null (i.e., it was deleted), delete it and all its children from the RAM representation.\n\n\n\n\nFor each file inode:\n\n\n\n\nIf its reference count is 0 (i.e., it is a dummy), delete it from the RAM representation.  This should only happen in the case of file system corruption.  (We should try to migrate the file to the lost+found directory in this case, as mentioned in the todo section).\n\n\n\n\nWhen an object is deleted during this sweep, it is only deleted from the RAM\nrepresentation; nothing is written to disk.\n\n\nWhen objects are migrated to the lost+found directory, their parent inode\nreference is permanently updated on the disk.\n\n\nIn addition, a single scratch area is identified during the detection process.\nThe first area whose 'fda_id' value is set to 0xff is designated as the file\nsystem scratch area.  If no valid scratch area is found, the cause could be\nthat the system was restarted while a garbage collection cycle was in progress.\nSuch a condition is identified by the presence of two areas with the same ID.\nIn such a case, the shorter of the two areas is erased and designated as the\nscratch area.\n\n\nFormatting\n\n\nA new file system is created via formatting.  Formatting is achieved via the\nfollowing function:\n\n\n/**\n * Erases all the specified areas and initializes them with a clean nffs\n * file system.\n *\n * @param area_descs        The set of areas to format.\n *\n * @return                  0 on success;\n *                          nonzero on failure.\n */\nint nffs_format(const struct nffs_area_desc *area_descs);\n\n\n\n\nOn success, an area header is written to each of the specified locations.  The\nlargest area in the set is designated as the initial scratch area.\n\n\nFlash writes\n\n\nThe nffs implementation always writes in a strictly sequential fashion within an\narea.  For each area, the system keeps track of the current offset.  Whenever\nan object gets written to an area, it gets written to that area's current\noffset, and the offset is increased by the object's disk size.\n\n\nWhen a write needs to be performed, the nffs implementation selects the\nappropriate destination area by iterating though each area until one with\nsufficient free space is encountered.\n\n\nThere is no write buffering.  Each call to a write function results in a write\noperation being sent to the flash hardware.\n\n\nNew objects\n\n\nWhenever a new object is written to disk, it is assigned the following\nproperties:\n    * ID: A unique value is selected from the 32-bit ID space, as appropriate\n      for the object's type.\n    * Sequence number: 0\n\n\nWhen a new file or directory is created, a corresponding inode is written to\nflash.  Likewise, a new data block also results in the writing of a\ncorresponding disk object.\n\n\nMoving/Renaming files and directories\n\n\nWhen a file or directory is moved or renamed, its corresponding inode is\nrewritten to flash with the following properties:\n\n\n\n\nID: Unchanged\n\n\nSequence number: Previous value plus one.\n\n\nParent inode: As specified by the move / rename operation.\n\n\nFilename: As specified by the move / rename operation.\n\n\n\n\nBecause the inode's ID is unchanged, all dependent objects remain valid.\n\n\nUnlinking files and directories\n\n\nWhen a file or directory is unlinked from its parent directory, a deletion\nrecord for the unlinked inode gets written to flash.  The deletion record is an\ninode with the following properties:\n\n\n\n\nID: Unchanged\n\n\nSequence number: Previous value plus one.\n\n\nParent inode ID: NFFS_ID_NONE\n\n\n\n\nWhen an inode is unlinked, no deletion records need to be written for the\ninode's dependent objects (constituent data blocks or child inodes).  During\nthe next file system detection, it is recognized that the objects belong to\na deleted inode, so they are not restored into the RAM representation.\n\n\nIf a file has an open handle at the time it gets unlinked, application code\ncan continued to use the file handle to read and write data.  All files retain\na reference count, and a file isn't deleted from the RAM representation until\nits reference code drops to 0.  Any attempt to open an unlinked file fails,\neven if the file is referenced by other file handles.\n\n\nWriting to a file\n\n\nThe following procedure is used whenever the application code writes to a file.\nFirst, if the write operation specifies too much data to fit into a single\nblock, the operation is split into several separate write operations.  Then,\nfor each write operation:\n\n\n1. Determine which existing blocks the write operation overlaps (n = number of overwritten blocks).\n\n\n2. If n = 0, this is an append operation.  Write a data block with the following properties:\n\n\n\n\nID: New unique value.\n\n\nSequence number: 0.\n\n\n\n\n3. Else (n \n 1), this write overlaps existing data.\n\n\n(a) For each block in [1, 2, ... n-1], write a new block containing the updated contents.  Each new block supersedes the block it overwrites.  That is, each block has the following properties:\n\n\n\n\nID: Unchanged\n\n\nSequence number: Previous value plus one.\n\n\n\n\n(b) Write the nth block.  The nth block includes all appended data, if any.  As with the other blocks, its ID is unchanged and its sequence number is incremented.\n\n\nAppended data can only be written to the end of the file.  That is, \"holes\" are\nnot supported.\n\n\nGarbage collection\n\n\nWhen the file system is too full to accomodate a write operation, the system\nmust perform garbage collection to make room.  The garbage collection\nprocedure is described below:\n\n\n\n\n\n\nThe non-scratch area with the lowest garbage collection sequence number is selected as the \"source area.\"  If there are other areas with the same sequence number, the one with the smallest flash offset is selected. \n\n\n\n\n\n\nThe source area's ID is written to the scratch area's header, transforming it into a non-scratch ID.  This former scratch area is now known as the \"destination area.\"\n\n\n\n\n\n\nThe RAM representation is exhaustively searched for collectible objects.  The following procedure is applied to each inode in the system:\n\n\n\n\nIf the inode is resident in the source area, copy the inode record to the destination area.\n\n\nIf the inode is a file inode, walk the inode's list of data blocks, starting with the last block in the file.  Each block that is resident in the source area is copied to the destination area.  If there is a run of two or more blocks that are resident in the source area, they are consolidated and copied to the destination area as a single new block (subject to the maximum block size restriction).\n\n\n\n\n\n\n\n\nThe source area is reformatted as a scratch sector (i.e., is is fully erased, and its header is rewritten with an ID of 0xff).  The area's garbage collection sequence number is incremented prior to rewriting the header.  This area is now the new scratch sector.\n\n\n\n\n\n\nMiscellaneous measures\n\n\n\n\n\n\nRAM usage:\n\n\n\n\n24 bytes per inode\n\n\n12 bytes per data block\n\n\n36 bytes per inode cache entry\n\n\n32 bytes per data block cache entry\n\n\n\n\n\n\n\n\nMaximum filename size: 256 characters (no null terminator required)\n\n\n\n\nDisallowed filename characters: '/' and '\\0'\n\n\n\n\nFuture enhancements\n\n\n\n\nAPI function to traverse a directory.\n\n\nMigrate corrupt files to the /lost+found directory during restore, rather than discarding them from RAM.\n\n\nError correction.\n\n\nEncryption.\n\n\nCompression.", 
            "title": "Newtron Flash File System"
        }, 
        {
            "location": "/modules/nffs/#newtron-flash-filesystem-nffs", 
            "text": "Mynewt comes with the flash file system called the Newtron Flash File System (nffs) which is designed with two priorities that makes it suitable for embedded use:    Minimal RAM usage  Reliability   Mynewt also provides an abstraction layer API (fs) to allow you to swap out nffs with a different file system of your choice.", 
            "title": "Newtron Flash Filesystem (nffs)"
        }, 
        {
            "location": "/modules/nffs/#description", 
            "text": "Describe module here, special features, how pieces fit together etc.", 
            "title": "Description"
        }, 
        {
            "location": "/modules/nffs/#disk-and-data-structures", 
            "text": "At the top level, an nffs disk is partitioned into areas.  An area is a region\nof disk with the following properties:   An area can be fully erased without affecting any other areas.  A write to one area does not restrict writes to other areas.   Note : Some flash hardware divides its memory space into \"blocks.\"  Writes within a block must be sequential, but writes to one block have no effect on what parts of other blocks can be written.  Thus, for flash hardware with such a restriction, each area must comprise a discrete number of blocks.  While not strictly necessary, it is recommended that all areas have the same\nsize.  On disk, each area is prefixed with the following header:  /** On-disk representation of an area header. */\nstruct nffs_disk_area {\n    uint32_t nda_magic[4];  /* NFFS_AREA_MAGIC{0,1,2,3} */\n    uint32_t nda_length;    /* Total size of area, in bytes. */\n    uint8_t nda_ver;        /* Current nffs version: 0 */\n    uint8_t nda_gc_seq;     /* Garbage collection count. */\n    uint8_t reserved8;\n    uint8_t nda_id;         /* 0xff if scratch area. */\n};  Beyond its header, an area contains a sequence of disk objects, representing\nthe contents of the file system.  There are two types of objects:  inodes  and data blocks .  An inode represents a file or directory; a data block represents\npart of a file's contents.  /** On-disk representation of an inode (file or directory). */\nstruct nffs_disk_inode {\n    uint32_t ndi_magic;         /* NFFS_INODE_MAGIC */\n    uint32_t ndi_id;            /* Unique object ID. */\n    uint32_t ndi_seq;           /* Sequence number; greater supersedes\n                                   lesser. */\n    uint32_t ndi_parent_id;     /* Object ID of parent directory inode. */\n    uint8_t reserved8;\n    uint8_t ndi_filename_len;   /* Length of filename, in bytes. */\n    uint16_t ndi_crc16;         /* Covers rest of header and filename. */\n    /* Followed by filename. */\n};  An inode filename's length cannot exceed 256 bytes.  The filename is not\nnull-terminated.  The following ASCII characters are not allowed in a\nfilename:\n    * /  (slash character)\n    * \\0 (NUL character)  /** On-disk representation of a data block. */\nstruct nffs_disk_block {\n    uint32_t ndb_magic;     /* NFFS_BLOCK_MAGIC */\n    uint32_t ndb_id;        /* Unique object ID. */\n    uint32_t ndb_seq;       /* Sequence number; greater supersedes lesser. */\n    uint32_t ndb_inode_id;  /* Object ID of owning inode. */\n    uint32_t ndb_prev_id;   /* Object ID of previous block in file;\n                               NFFS_ID_NONE if this is the first block. */\n    uint16_t ndb_data_len;  /* Length of data contents, in bytes. */\n    uint16_t ndb_crc16;     /* Covers rest of header and data. */\n    /* Followed by 'ndb_data_len' bytes of data. */\n};  Each data block contains the ID of the previous data block in the file.\nTogether, the set of blocks in a file form a reverse singly-linked list.  The maximum number of data bytes that a block can contain is determined at\ninitialization-time.  The result is the greatest number which satisfies all of\nthe following restrictions:\n    o No more than 2048.\n    o At least two maximum-sized blocks can fit in the smallest area.  The 2048 number was chosen somewhat arbitrarily, and may change in the future.  ID space  All disk objects have a unique 32-bit ID.  The ID space is partitioned as\nfollows:\n      * 0x00000000 - 0x0fffffff: Directory inodes.\n      * 0x10000000 - 0x7fffffff: File inodes.\n      * 0x80000000 - 0xfffffffe: Data blocks.\n      * 0xffffffff             : Reserved (NFFS_ID_NONE)  Scratch area  A valid nffs file system must contain a single \"scratch area.\"  The scratch\narea does not contain any objects of its own, and is only used during garbage\ncollection.  The scratch area must have a size greater than or equal to each\nof the other areas in flash.  RAM representation  Every object in the file system is stored in a 256-entry hash table.  An\nobject's hash key is derived from its 32-bit ID.  Each list in the hash table\nis sorted by time of use; most-recently-used is at the front of the list. All\nobjects are represented by the following structure:  /**\n * What gets stored in the hash table.  Each entry represents a data block or\n * an inode.\n */\nstruct nffs_hash_entry {\n    SLIST_ENTRY(nffs_hash_entry) nhe_next;\n    uint32_t nhe_id;        /* 0 - 0x7fffffff if inode; else if block. */\n    uint32_t nhe_flash_loc; /* Upper-byte = area idx; rest = area offset. */\n};  For each data block, the above structure is all that is stored in RAM.  To\nacquire more information about a data block, the block header must be read\nfrom flash.  Inodes require a fuller RAM representation to capture the structure of the\nfile system.  There are two types of inodes:  files  and  directories .  Each\ninode hash entry is actually an instance of the following structure:  /** Each inode hash entry is actually one of these. */\nstruct nffs_inode_entry {\n    struct nffs_hash_entry nie_hash_entry;\n    SLIST_ENTRY(nffs_inode_entry) nie_sibling_next;\n    union {\n        struct nffs_inode_list nie_child_list;           /* If directory */\n        struct nffs_hash_entry *nie_last_block_entry;    /* If file */\n    };\n    uint8_t nie_refcnt;\n};  A directory inode contains a list of its child files and directories\n(fie_child_list).  These entries are sorted alphabetically using the ASCII\ncharacter set.  A file inode contains a pointer to the last data block in the file\n(nie_last_block_entry).  For most file operations, the reversed block list must\nbe walked backwards.  This introduces a number of speed inefficiencies:\n    * All data blocks must be read to determine the length of the file.\n    * Data blocks often need to be processed sequentially.  The reversed\n      nature of the block list transforms this from linear time to an O(n^2)\n      operation.  Furthermore, obtaining information about any constituent data block requires a\nseparate flash read.  Inode cache and Data Block cache  The speed issues are addressed by a pair of caches.  Cached inodes entries\ncontain the file length and a much more convenient doubly-linked list of\ncached data blocks.  The benefit of using caches is that the size of the\ncaches need not be proportional to the size of the file system.  In other\nwords, caches can address speed efficiency concerns without negatively\nimpacting the file system's scalability.  nffs requires both caches during normal operation, so it is not possible to\ndisable them.  However, the cache sizes are configurable, and both caches can\nbe configured with a size of one if RAM usage must be minimized.  The following data structures are used in the inode and data block caches.  /** Full data block representation; not stored permanently in RAM. */\nstruct nffs_block {\n    struct nffs_hash_entry *nb_hash_entry;   /* Points to real block entry. */\n    uint32_t nb_seq;                         /* Sequence number; greater\n                                                supersedes lesser. */\n    struct nffs_inode_entry *nb_inode_entry; /* Owning inode. */\n    struct nffs_hash_entry *nb_prev;         /* Previous block in file. */\n    uint16_t nb_data_len;                    /* # of data bytes in block. */\n    uint16_t reserved16;\n};\n\n/** Represents a single cached data block. */\nstruct nffs_cache_block {\n    TAILQ_ENTRY(nffs_cache_block) ncb_link; /* Next / prev cached block. */\n    struct nffs_block ncb_block;            /* Full data block. */\n    uint32_t ncb_file_offset;               /* File offset of this block. */\n};\n\n/** Full inode representation; not stored permanently in RAM. */\nstruct nffs_inode {\n    struct nffs_inode_entry *ni_inode_entry; /* Points to real inode entry. */\n    uint32_t ni_seq;                         /* Sequence number; greater\n                                                supersedes lesser. */\n    struct nffs_inode_entry *ni_parent;      /* Points to parent directory. */\n    uint8_t ni_filename_len;                 /* # chars in filename. */\n    uint8_t ni_filename[NFFS_SHORT_FILENAME_LEN]; /* First 3 bytes. */\n};\n\n/** Doubly-linked tail queue of cached blocks; contained in cached inodes. */\nTAILQ_HEAD(nffs_block_cache_list, nffs_block_cache_entry);\n\n/** Represents a single cached file inode. */\nstruct nffs_cache_inode {\n    TAILQ_ENTRY(nffs_cache_inode) nci_link;        /* Sorted; LRU at tail. */\n    struct nffs_inode nci_inode;                   /* Full inode. */\n    struct nffs_cache_block_list nci_block_list;   /* List of cached blocks. */\n    uint32_t nci_file_size;                        /* Total file size. */\n};  Only file inodes are cached; directory inodes are never cached.  Within a cached inode, all cached data blocks are contiguous.  E.g., if the\nstart and end of a file are cached, then the middle must also be cached.  A\ndata block is only cached if its owning file is also cached.  Internally, cached inodes are stored in a singly-linked list, ordered by time\nof use.  The most-recently-used entry is the first element in the list.  If a\nnew inode needs to be cached, but the inode cache is full, the\nleast-recently-used entry is freed to make room for the new one.  The\nfollowing operations cause an inode to be cached:   Querying a file's length.  Seeking within a file.  Reading from a file.  Writing to a file.   The following operations cause a data block to be cached:   Reading from the block.  Writing to the block.   If one of the above operations is applied to a data block that is not currently\ncached, nffs uses the following procedure to cache the necessary block:   If none of the owning inode's blocks are currently cached, allocate a\n       cached block entry corresponding to the requested block and insert it\n       into the inode's list.  Else if the requested file offset is less than that of the first cached\n       block, bridge the gap between the inode's sequence of cached blocks and\n       the block that now needs to be cached.  This is accomplished by caching\n       each block in the gap, finishing with the requested block.  Else (the requested offset is beyond the end of the cache),\n   a. If the requested offset belongs to the block that immediately follows the end of the cache, cache the block and append it to the list.\n   b. Else, clear the cache, and populate it with the single entry corresponding to the requested block.   If the system is unable to allocate a cached block entry at any point during\nthe above procedure, the system frees up other blocks currently in the cache. This is accomplished as follows:   Iterate the inode cache in reverse (i.e., start with the least-recently-used entry).  For each entry:\n   a. If the entry's cached block list is empty, advance to the next entry.\n   b. Else, free all the cached blocks in the entry's list.   Because the system imposes a minimum block cache size of one, the above\nprocedure will always reclaim at least one cache block entry.  The above\nprocedure may result in the freeing of the block list that belongs to the very\ninode being operated on.  This is OK, as the final block to get cached is\nalways the block being requested.", 
            "title": "Disk and data structures"
        }, 
        {
            "location": "/modules/nffs/#configuration", 
            "text": "The file system is configured by populating fields in a global structure.\nEach field in the structure corresponds to a setting.  All configuration must\nbe done prior to calling nffs_init().  The configuration structure is defined\nas follows:  \nstruct nffs_config {\n    /** Maximum number of inodes; default=1024. */\n    uint32_t nc_num_inodes;\n\n    /** Maximum number of data blocks; default=4096. */\n    uint32_t nc_num_blocks;\n\n    /** Maximum number of open files; default=4. */\n    uint32_t nc_num_files;\n\n    /** Inode cache size; default=4. */\n    uint32_t nc_num_cache_inodes;\n\n    /** Data block cache size; default=64. */\n    uint32_t nc_num_cache_blocks;\n    };\n\nextern struct nffs_config nffs_config;  Any fields that are set to 0 (or not set at all) inherit the corresponding\ndefault value.  This means that it is impossible to configure any setting with\na value of zero.", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/nffs/#initialization", 
            "text": "There are two means of initializing an nffs file system:   Restore an existing file system via detection.  Create a new file system via formatting.   Both methods require the user to describe how the flash memory is divided into\nareas.  This is accomplished with an array of struct nffs_area_desc, defined as\nfollows:  struct nffs_area_desc {\n    uint32_t nad_offset;    /* Flash offset of start of area. */\n    uint32_t nad_length;    /* Size of area, in bytes. */\n};  An array of area descriptors is terminated by an entry with a fad_length field\nof 0.  One common initialization sequence is the following:   Detect an nffs file system anywhere in flash.  If no file system detected, format a new file system in a specific\n        region of flash.", 
            "title": "Initialization"
        }, 
        {
            "location": "/modules/nffs/#detection", 
            "text": "The file system detection process consists of scanning a specified set of\nflash regions for valid nffs areas, and then populating the RAM representation\nof the file system with the detected objects.  Detection is initiated with the\nfollowing function:  /**\n * Searches for a valid nffs file system among the specified areas.  This\n * function succeeds if a file system is detected among any subset of the\n * supplied areas.  If the area set does not contain a valid file system,\n * a new one can be created via a separate call to nffs_format().\n *\n * @param area_descs        The area set to search.  This array must be\n *                              terminated with a 0-length area.\n *\n * @return                  0 on success;\n *                          NFFS_ECORRUPT if no valid file system was detected;\n *                          other nonzero on error.\n */\nint nffs_detect(const struct nffs_area_desc *area_descs);  As indicated, not every area descriptor needs to reference a valid nffs area.\nDetection is successful as long as a complete file system is detected\nsomewhere in the specified regions of flash.  If an application is unsure\nwhere a file system might be located, it can initiate detection across the\nentire flash region.  A detected file system is valid if:   At least one non-scratch area is present.  At least one scratch area is present (only the first gets used if there is more than one).  The root directory inode is present.   During detection, each indicated region of flash is checked for a valid area\nheader.  The contents of each valid non-scratch area are then restored into\nthe nffs RAM representation.  The following procedure is applied to each object\nin the area:    Verify the object's integrity via a crc16 check.  If invalid, the object is discarded and the procedure restarts on the next object in the area.    Convert the disk object into its corresponding RAM representation and insert it into the hash table.  If the object is an inode, its reference count is initialized to 1, indicating ownership by its parent directory.    If an object with the same ID is already present, then one supersedes the other.  Accept the object with the greater sequence number and discard the other.    If the object references a nonexistant inode (parent directory in the case of an inode; owning file in the case of a data block), insert a temporary \"dummy\" inode into the hash table so that inter-object links can be maintained until the absent inode is eventually restored.  Dummy inodes are identified by a reference count of 0.    If a delete record for an inode is encountered, the inode's parent pointer is set to null to indicate that it should be removed from RAM.    If nffs encounters an object that cannot be identified (i.e., its magic number\nis not valid), it scans the remainder of the flash area for the next valid\nmagic number.  Upon encountering a valid object, nffs resumes the procedure\ndescribed above.  After all areas have been restored, a sweep is performed across the entire RAM\nrepresentation so that invalid inodes can be deleted from memory.  For each directory inode:   If its reference count is 0 (i.e., it is a dummy), migrate its children to the /lost+found directory, and delete it from the RAM representation. This should only happen in the case of file system corruption.  If its parent reference is null (i.e., it was deleted), delete it and all its children from the RAM representation.   For each file inode:   If its reference count is 0 (i.e., it is a dummy), delete it from the RAM representation.  This should only happen in the case of file system corruption.  (We should try to migrate the file to the lost+found directory in this case, as mentioned in the todo section).   When an object is deleted during this sweep, it is only deleted from the RAM\nrepresentation; nothing is written to disk.  When objects are migrated to the lost+found directory, their parent inode\nreference is permanently updated on the disk.  In addition, a single scratch area is identified during the detection process.\nThe first area whose 'fda_id' value is set to 0xff is designated as the file\nsystem scratch area.  If no valid scratch area is found, the cause could be\nthat the system was restarted while a garbage collection cycle was in progress.\nSuch a condition is identified by the presence of two areas with the same ID.\nIn such a case, the shorter of the two areas is erased and designated as the\nscratch area.", 
            "title": "Detection"
        }, 
        {
            "location": "/modules/nffs/#formatting", 
            "text": "A new file system is created via formatting.  Formatting is achieved via the\nfollowing function:  /**\n * Erases all the specified areas and initializes them with a clean nffs\n * file system.\n *\n * @param area_descs        The set of areas to format.\n *\n * @return                  0 on success;\n *                          nonzero on failure.\n */\nint nffs_format(const struct nffs_area_desc *area_descs);  On success, an area header is written to each of the specified locations.  The\nlargest area in the set is designated as the initial scratch area.", 
            "title": "Formatting"
        }, 
        {
            "location": "/modules/nffs/#flash-writes", 
            "text": "The nffs implementation always writes in a strictly sequential fashion within an\narea.  For each area, the system keeps track of the current offset.  Whenever\nan object gets written to an area, it gets written to that area's current\noffset, and the offset is increased by the object's disk size.  When a write needs to be performed, the nffs implementation selects the\nappropriate destination area by iterating though each area until one with\nsufficient free space is encountered.  There is no write buffering.  Each call to a write function results in a write\noperation being sent to the flash hardware.  New objects  Whenever a new object is written to disk, it is assigned the following\nproperties:\n    * ID: A unique value is selected from the 32-bit ID space, as appropriate\n      for the object's type.\n    * Sequence number: 0  When a new file or directory is created, a corresponding inode is written to\nflash.  Likewise, a new data block also results in the writing of a\ncorresponding disk object.  Moving/Renaming files and directories  When a file or directory is moved or renamed, its corresponding inode is\nrewritten to flash with the following properties:   ID: Unchanged  Sequence number: Previous value plus one.  Parent inode: As specified by the move / rename operation.  Filename: As specified by the move / rename operation.   Because the inode's ID is unchanged, all dependent objects remain valid.  Unlinking files and directories  When a file or directory is unlinked from its parent directory, a deletion\nrecord for the unlinked inode gets written to flash.  The deletion record is an\ninode with the following properties:   ID: Unchanged  Sequence number: Previous value plus one.  Parent inode ID: NFFS_ID_NONE   When an inode is unlinked, no deletion records need to be written for the\ninode's dependent objects (constituent data blocks or child inodes).  During\nthe next file system detection, it is recognized that the objects belong to\na deleted inode, so they are not restored into the RAM representation.  If a file has an open handle at the time it gets unlinked, application code\ncan continued to use the file handle to read and write data.  All files retain\na reference count, and a file isn't deleted from the RAM representation until\nits reference code drops to 0.  Any attempt to open an unlinked file fails,\neven if the file is referenced by other file handles.  Writing to a file  The following procedure is used whenever the application code writes to a file.\nFirst, if the write operation specifies too much data to fit into a single\nblock, the operation is split into several separate write operations.  Then,\nfor each write operation:  1. Determine which existing blocks the write operation overlaps (n = number of overwritten blocks).  2. If n = 0, this is an append operation.  Write a data block with the following properties:   ID: New unique value.  Sequence number: 0.   3. Else (n   1), this write overlaps existing data.  (a) For each block in [1, 2, ... n-1], write a new block containing the updated contents.  Each new block supersedes the block it overwrites.  That is, each block has the following properties:   ID: Unchanged  Sequence number: Previous value plus one.   (b) Write the nth block.  The nth block includes all appended data, if any.  As with the other blocks, its ID is unchanged and its sequence number is incremented.  Appended data can only be written to the end of the file.  That is, \"holes\" are\nnot supported.", 
            "title": "Flash writes"
        }, 
        {
            "location": "/modules/nffs/#garbage-collection", 
            "text": "When the file system is too full to accomodate a write operation, the system\nmust perform garbage collection to make room.  The garbage collection\nprocedure is described below:    The non-scratch area with the lowest garbage collection sequence number is selected as the \"source area.\"  If there are other areas with the same sequence number, the one with the smallest flash offset is selected.     The source area's ID is written to the scratch area's header, transforming it into a non-scratch ID.  This former scratch area is now known as the \"destination area.\"    The RAM representation is exhaustively searched for collectible objects.  The following procedure is applied to each inode in the system:   If the inode is resident in the source area, copy the inode record to the destination area.  If the inode is a file inode, walk the inode's list of data blocks, starting with the last block in the file.  Each block that is resident in the source area is copied to the destination area.  If there is a run of two or more blocks that are resident in the source area, they are consolidated and copied to the destination area as a single new block (subject to the maximum block size restriction).     The source area is reformatted as a scratch sector (i.e., is is fully erased, and its header is rewritten with an ID of 0xff).  The area's garbage collection sequence number is incremented prior to rewriting the header.  This area is now the new scratch sector.", 
            "title": "Garbage collection"
        }, 
        {
            "location": "/modules/nffs/#miscellaneous-measures", 
            "text": "RAM usage:   24 bytes per inode  12 bytes per data block  36 bytes per inode cache entry  32 bytes per data block cache entry     Maximum filename size: 256 characters (no null terminator required)   Disallowed filename characters: '/' and '\\0'", 
            "title": "Miscellaneous measures"
        }, 
        {
            "location": "/modules/nffs/#future-enhancements", 
            "text": "API function to traverse a directory.  Migrate corrupt files to the /lost+found directory during restore, rather than discarding them from RAM.  Error correction.  Encryption.  Compression.", 
            "title": "Future enhancements"
        }, 
        {
            "location": "/modules/testutil/", 
            "text": "testutil\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe module here, special features, how pieces fit together etc.\n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\ntu_init\n\n\ntu_restart\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\n tu_init \n\n\n    int\n    tu_init(void)\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n tu_restart \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here", 
            "title": "Test Utilities"
        }, 
        {
            "location": "/modules/testutil/#testutil", 
            "text": "Insert synopsis here", 
            "title": "testutil"
        }, 
        {
            "location": "/modules/testutil/#description", 
            "text": "Describe module here, special features, how pieces fit together etc.", 
            "title": "Description"
        }, 
        {
            "location": "/modules/testutil/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/modules/testutil/#list-of-functions", 
            "text": "The functions available in this OS feature are:   tu_init  tu_restart  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/modules/testutil/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/modules/testutil/#tu_init", 
            "text": "int\n    tu_init(void)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " tu_init "
        }, 
        {
            "location": "/modules/testutil/#tu_restart", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " tu_restart "
        }, 
        {
            "location": "/modules/testutil/#next_one", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " next_one "
        }, 
        {
            "location": "/modules/imgmgr/", 
            "text": "Bootloader\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe module here, special features, how pieces fit together etc.\n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nboot_slot_addr\n\n\nboot_find_image_slot\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\n boot_slot_addr \n\n\n    static void\n    boot_slot_addr(int slot_num, uint8_t *flash_id, uint32_t *address)\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n boot_find_image_slot \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here", 
            "title": "Image Manager"
        }, 
        {
            "location": "/modules/imgmgr/#bootloader", 
            "text": "Insert synopsis here", 
            "title": "Bootloader"
        }, 
        {
            "location": "/modules/imgmgr/#description", 
            "text": "Describe module here, special features, how pieces fit together etc.", 
            "title": "Description"
        }, 
        {
            "location": "/modules/imgmgr/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/modules/imgmgr/#list-of-functions", 
            "text": "The functions available in this OS feature are:   boot_slot_addr  boot_find_image_slot  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/modules/imgmgr/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/modules/imgmgr/#boot_slot_addr", 
            "text": "static void\n    boot_slot_addr(int slot_num, uint8_t *flash_id, uint32_t *address)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " boot_slot_addr "
        }, 
        {
            "location": "/modules/imgmgr/#boot_find_image_slot", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " boot_find_image_slot "
        }, 
        {
            "location": "/modules/imgmgr/#next_one", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " next_one "
        }, 
        {
            "location": "/modules/baselibc/", 
            "text": "Baselibc\n\n\nbaselibc is a very simple libc for embedded systems geared primarily for 32-bit microcontrollers in the 10-100kB memory range. The library of basic system calls and facilities compiles to less than 5kB total on Cortex-M3, and much less if some functions aren't used.\n\n\nThe code is based on klibc and tinyprintf modules, and licensed under the BSD license.\n\n\nDescription\n\n\nMynewt Os comes bundled with libc (the standard C library). However, you may choose to replace libc functions with baselibc ones for a reduced image size.\n\n\nHow to switch to baselibc\n\n\nIn order to switch from using libc to using baselibc you have to add the baselibc egg as dependency in the project egg. Specifying this dependency ensures that the linker first looks for the functions in baselibc before falling back to libc while creating the executable. For example, project \nboot\n uses baselibc. Its project description file \nboot.yml\n looks like the following:\n\n\n   project.name: boot\n   project.identities: bootloader\n   project.eggs:\n       - libs/os\n       - libs/bootutil\n       - libs/nffs\n       - libs/console/stub\n       - libs/util\n       - libs/baselibc\n ```\n\n## List of Functions\n\nThe functions available in this OS feature are listed below. Documentation is available in the form of  on-line manual pages or at [https://www.freebsd.org/cgi/man.cgi](#https://www.freebsd.org/cgi/man.cgi).  `mynewt.c` adds two new functions listed in the Function reference section.\n\n* asprintf.c    \n* atoi.c    \n* atol.c\n* atoll.c   \n* bsearch.c \n* bzero.c   \n* calloc.c  \n* fgets.c    \n* inline.c  \n* jrand48.c \n* lrand48.c \n* malloc.c  \n* malloc.h  \n* memccpy.c \n* memchr.c  \n* memcmp.c  \n* memcpy.c  \n* memfile.c \n* memmem.c  \n* memmove.c \n* memrchr.c \n* memset.c  \n* memswap.c \n* mrand48.c \n* mynewt.c  \n* nrand48.c \n* qsort.c   \n* realloc.c \n* sprintf.c \n* srand48.c \n* sscanf.c  \n* strcasecmp.c  \n* strcat.c  \n* strchr.c  \n* strcmp.c  \n* strcpy.c  \n* strcspn.c \n* strdup.c  \n* strlcat.c \n* strlcpy.c \n* strlen.c  \n* strncasecmp.c \n* strncat.c \n* strncmp.c \n* strncpy.c \n* strndup.c \n* strnlen.c \n* strntoimax.c  \n* strntoumax.c  \n* strpbrk.c \n* strrchr.c \n* strsep.c  \n* strspn.c  \n* strstr.c  \n* strtoimax.c   \n* strtok.c  \n* strtok_r.c    \n* strtol.c  \n* strtoll.c \n* strtoul.c \n* strtoull.c    \n* strtoumax.c   \n* templates \n* test  \n* tinyprintf.c  \n* vasprintf.c   \n* vprintf.c \n* vsprintf.c    \n* vsscanf.c \n\n## Function Reference\n\n------------------\n\n## \nfont color=\nF2853F\n style=\nfont-size:24pt\n stdin_read \n/font\n\n\n```no-highlight\n    static size_t\n    stdin_read(FILE *fp, char *bp, size_t n)\n\n\n\n\nRead from a file.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfp\n\n\npointer to the input file\n\n\n\n\n\n\nbp\n\n\npointer to the string to be read\n\n\n\n\n\n\nn\n\n\nsize of buffer (number of characters) to be read\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nN/A\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n stdout_write \n\n\n   static size_t\n   stdout_write(FILE *fp, const char *bp, size_t n)\n\n\n\n\nWrite to a file or console. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfp\n\n\npointer to the output file\n\n\n\n\n\n\nbp\n\n\npointer to the string to be written\n\n\n\n\n\n\nn\n\n\nsize of buffer (number of characters) to be output\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nN/A\n\n\nExample\n\n\n\n\nInsert the code snippet here", 
            "title": "Baselibc library"
        }, 
        {
            "location": "/modules/baselibc/#baselibc", 
            "text": "baselibc is a very simple libc for embedded systems geared primarily for 32-bit microcontrollers in the 10-100kB memory range. The library of basic system calls and facilities compiles to less than 5kB total on Cortex-M3, and much less if some functions aren't used.  The code is based on klibc and tinyprintf modules, and licensed under the BSD license.", 
            "title": "Baselibc"
        }, 
        {
            "location": "/modules/baselibc/#description", 
            "text": "Mynewt Os comes bundled with libc (the standard C library). However, you may choose to replace libc functions with baselibc ones for a reduced image size.", 
            "title": "Description"
        }, 
        {
            "location": "/modules/baselibc/#how-to-switch-to-baselibc", 
            "text": "In order to switch from using libc to using baselibc you have to add the baselibc egg as dependency in the project egg. Specifying this dependency ensures that the linker first looks for the functions in baselibc before falling back to libc while creating the executable. For example, project  boot  uses baselibc. Its project description file  boot.yml  looks like the following:     project.name: boot\n   project.identities: bootloader\n   project.eggs:\n       - libs/os\n       - libs/bootutil\n       - libs/nffs\n       - libs/console/stub\n       - libs/util\n       - libs/baselibc\n ```\n\n## List of Functions\n\nThe functions available in this OS feature are listed below. Documentation is available in the form of  on-line manual pages or at [https://www.freebsd.org/cgi/man.cgi](#https://www.freebsd.org/cgi/man.cgi).  `mynewt.c` adds two new functions listed in the Function reference section.\n\n* asprintf.c    \n* atoi.c    \n* atol.c\n* atoll.c   \n* bsearch.c \n* bzero.c   \n* calloc.c  \n* fgets.c    \n* inline.c  \n* jrand48.c \n* lrand48.c \n* malloc.c  \n* malloc.h  \n* memccpy.c \n* memchr.c  \n* memcmp.c  \n* memcpy.c  \n* memfile.c \n* memmem.c  \n* memmove.c \n* memrchr.c \n* memset.c  \n* memswap.c \n* mrand48.c \n* mynewt.c  \n* nrand48.c \n* qsort.c   \n* realloc.c \n* sprintf.c \n* srand48.c \n* sscanf.c  \n* strcasecmp.c  \n* strcat.c  \n* strchr.c  \n* strcmp.c  \n* strcpy.c  \n* strcspn.c \n* strdup.c  \n* strlcat.c \n* strlcpy.c \n* strlen.c  \n* strncasecmp.c \n* strncat.c \n* strncmp.c \n* strncpy.c \n* strndup.c \n* strnlen.c \n* strntoimax.c  \n* strntoumax.c  \n* strpbrk.c \n* strrchr.c \n* strsep.c  \n* strspn.c  \n* strstr.c  \n* strtoimax.c   \n* strtok.c  \n* strtok_r.c    \n* strtol.c  \n* strtoll.c \n* strtoul.c \n* strtoull.c    \n* strtoumax.c   \n* templates \n* test  \n* tinyprintf.c  \n* vasprintf.c   \n* vprintf.c \n* vsprintf.c    \n* vsscanf.c \n\n## Function Reference\n\n------------------\n\n##  font color= F2853F  style= font-size:24pt  stdin_read  /font \n\n```no-highlight\n    static size_t\n    stdin_read(FILE *fp, char *bp, size_t n)  Read from a file.  Arguments     Arguments  Description      fp  pointer to the input file    bp  pointer to the string to be read    n  size of buffer (number of characters) to be read     Returned values  N/A  Notes  N/A  Example   Insert the code snippet here", 
            "title": "How to switch to baselibc"
        }, 
        {
            "location": "/modules/baselibc/#stdout_write", 
            "text": "static size_t\n   stdout_write(FILE *fp, const char *bp, size_t n)  Write to a file or console.   Arguments     Arguments  Description      fp  pointer to the output file    bp  pointer to the string to be written    n  size of buffer (number of characters) to be output     Returned values  N/A  Notes  N/A  Example   Insert the code snippet here", 
            "title": " stdout_write "
        }, 
        {
            "location": "/modules/elua/", 
            "text": "Bootloader\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe module here, special features, how pieces fit together etc.\n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nboot_slot_addr\n\n\nboot_find_image_slot\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\n boot_slot_addr \n\n\n    static void\n    boot_slot_addr(int slot_num, uint8_t *flash_id, uint32_t *address)\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n boot_find_image_slot \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here", 
            "title": "Embedded Lua"
        }, 
        {
            "location": "/modules/elua/#bootloader", 
            "text": "Insert synopsis here", 
            "title": "Bootloader"
        }, 
        {
            "location": "/modules/elua/#description", 
            "text": "Describe module here, special features, how pieces fit together etc.", 
            "title": "Description"
        }, 
        {
            "location": "/modules/elua/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/modules/elua/#list-of-functions", 
            "text": "The functions available in this OS feature are:   boot_slot_addr  boot_find_image_slot  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/modules/elua/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/modules/elua/#boot_slot_addr", 
            "text": "static void\n    boot_slot_addr(int slot_num, uint8_t *flash_id, uint32_t *address)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " boot_slot_addr "
        }, 
        {
            "location": "/modules/elua/#boot_find_image_slot", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " boot_find_image_slot "
        }, 
        {
            "location": "/modules/elua/#next_one", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " next_one "
        }, 
        {
            "location": "/modules/json/", 
            "text": "Bootloader\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe module here, special features, how pieces fit together etc.\n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nboot_slot_addr\n\n\nboot_find_image_slot\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\n boot_slot_addr \n\n\n    static void\n    boot_slot_addr(int slot_num, uint8_t *flash_id, uint32_t *address)\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n boot_find_image_slot \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\nInsert the code snippet here", 
            "title": "JSON"
        }, 
        {
            "location": "/modules/json/#bootloader", 
            "text": "Insert synopsis here", 
            "title": "Bootloader"
        }, 
        {
            "location": "/modules/json/#description", 
            "text": "Describe module here, special features, how pieces fit together etc.", 
            "title": "Description"
        }, 
        {
            "location": "/modules/json/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/modules/json/#list-of-functions", 
            "text": "The functions available in this OS feature are:   boot_slot_addr  boot_find_image_slot  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/modules/json/#function-reference", 
            "text": "", 
            "title": "Function Reference"
        }, 
        {
            "location": "/modules/json/#boot_slot_addr", 
            "text": "static void\n    boot_slot_addr(int slot_num, uint8_t *flash_id, uint32_t *address)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " boot_slot_addr "
        }, 
        {
            "location": "/modules/json/#boot_find_image_slot", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " boot_find_image_slot "
        }, 
        {
            "location": "/modules/json/#next_one", 
            "text": "Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example   Insert the code snippet here", 
            "title": " next_one "
        }, 
        {
            "location": "/newtmgr/overview/", 
            "text": "Newt Manager\n\n\nNewt Manager (newtmgr) is the application tool that enables a user to communicate with and manage remote instances of Mynewt OS. \n\n\nDescription\n\n\nCommand List\n\n\nAvailable high-level commands\n\n\n    help        Lists commands and flags available \n    conn        Manage newtmgr connection profiles\n    echo        Send data to remote endpoint using newtmgr, and receive data back\n    image       Manage images on remote instance\n    stat        Read statistics from a remote endpoint\n    taskstats   Read statistics from a remote endpoint\n    mpstats     Read statistics from a remote endpoint\n    config      Read or write config value on target\n\n\n\n\nAvailable Flags\n\n\n  -c, --connection string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nnewtmgr -caditi03 taskstats\n\n\n\n\n\n\n\n\n\n\n\n\nhelp\n\n\nUsage:\n\n\n    newtmgr help [input1]\n\n\n\n\nYou can also use \"newtmgr [command] --help\" to display the help text for a newtmgr command.\n\n\nFlags:\n\n\n  -c, --connection string      connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nAvailable Flags\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\ntaskstats\n\n\nnewtmgr -cprofile1 taskstats\n\n\nRun the taskstats subcommand on the device connected via the 'profile1' connection\n\n\n\n\n\n\n\n\nconn\n\n\nUsage:\n\n\n    newtmgr conn [flags]\n    newtmgr conn [command]\n\n\n\n\nAvailable commands: \n\n\n    add         Add a newtmgr connection profile\n    delete      Delete a newtmgr connection profile\n    show        Show newtmgr connection profiles\n\n\n\n\nFlags:\n\n\n  -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)\n\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSub-command\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nadd\n\n\nAdds a connection profile. A properly defined profile needs a name, a connection type, and the physical or virtual port to be used for communication.\n\n\n\n\n\n\ndelete\n\n\nDeletes a connection profile associated with the given name\n\n\n\n\n\n\nshow\n\n\nList the specified or all the connection profiles with the name, connection type, and the controlling terminal or port.\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nadd\n\n\nnewtmgr conn add myserial02 type=serial connstring=/dev/ttys002\n\n\nAdds a newtmgr connection profile for the serial port /dev/ttys002 and names it 'myserial02'\n\n\n\n\n\n\ndelete\n\n\nnewtmgr conn delete myserial02\n\n\nDeletes the connection profile named 'myserial02'\n\n\n\n\n\n\nshow\n\n\nnewtmgr conn show myserial01\n\n\nShows the details of the profile named 'myserial01'\n\n\n\n\n\n\nshow\n\n\nnewtmgr conn show\n\n\nShows all the current profiles defined\n\n\n\n\n\n\n\n\necho\n\n\nUsage:\n\n\n    newtmgr echo [flags] [text]\n\n\n\n\nThis command sends the text to the remote device at the other end of the connection specified with the -c flag and outputs the text when it gets a response from the device. If the device is not responding or if the connection profile is invalid it displays errors. \n\n\nFlags:\n\n\n  -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\necho\n\n\nnewtmgr echo -c profile01 hello\n\n\nSends the string 'hello' to the remote device over the connection profile 'profile01' and receives the string back and displays it.\n\n\n\n\n\n\n\n\nimage\n\n\nUsage:\n\n\n  newtmgr image [flags]\n  newtmgr image [command]\n\n\n\n\nAvailable commands: \n\n\n    list         Show target images\n    upload       Upload image to target\n    boot         Which image to boot\n    fileupload   Upload file to target\n    filedownload Download file from target\n\n\n\n\nFlags:\n\n\n  -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)\n\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSub-command\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nlist\n\n\nAdds a connection profile. A properly defined profile needs a name, a connection type, and the physical or virtual port to be used for communication.\n\n\n\n\n\n\nupload\n\n\nDeletes a connection profile associated with the given name\n\n\n\n\n\n\nboot\n\n\nSpecify the image to boot\n\n\n\n\n\n\nfileupload\n\n\nupload file to the remote target\n\n\n\n\n\n\nfiledownload\n\n\ndownload/retrieve file from remote target\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nlist\n\n\nnewtmgr list\n\n\n\n\n\n\n\n\nupload\n\n\nnewtmgr upload\n\n\n\n\n\n\n\n\nboot\n\n\nnewtmgr boot\n\n\n\n\n\n\n\n\nfileupload\n\n\nnewtmgr fileupload\n\n\n\n\n\n\n\n\nfiledownload\n\n\nnewtmgr filedownload\n\n\n\n\n\n\n\n\n\n\nstat\n\n\nUsage:\n\n\n  newtmgr stat [flags]\n  newtmgr stat [command]\n\n\n\n\nFlags:\n\n\n  -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nstat\n\n\nnewtmgr stat\n\n\n\n\n\n\n\n\n\n\ntaskstats\n\n\nUsage:\n\n\n  newtmgr taskstats [flags]\n  newtmgr taskstats [command]\n\n\n\n\nLists all the tasks running on the remote endpoint at the end of the specified connection and for each task lists statistics such as priority, task id, runtime (how long the task has been running in ms), context switch count, stack size allocated, actual stack usage, last sanity checkin, next sanity check-in. \n\n\nFlags:\n\n\n  -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nstat\n\n\nnewtmgr taskstats -c profile01\n\n\nLists all the tasks running on the remote device at the end of connection named 'profile01'\n\n\n\n\n\n\n\n\nExample output\n\n\n$ newtmgr  -c profile01 taskstats\nReturn Code = 0\n  idle (prio=255 tid=0 runtime=3299340 cswcnt=280342 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  os_sanity (prio=254 tid=1 runtime=0 cswcnt=3287 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  shell (prio=3 tid=2 runtime=0 cswcnt=165 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  uart_poller (prio=0 tid=3 runtime=0 cswcnt=279368 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  newtmgr (prio=4 tid=4 runtime=0 cswcnt=14 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  task1 (prio=1 tid=5 runtime=0 cswcnt=3287 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  task2 (prio=2 tid=6 runtime=0 cswcnt=3287 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)", 
            "title": "Overview"
        }, 
        {
            "location": "/newtmgr/overview/#newt-manager", 
            "text": "Newt Manager (newtmgr) is the application tool that enables a user to communicate with and manage remote instances of Mynewt OS.", 
            "title": "Newt Manager"
        }, 
        {
            "location": "/newtmgr/overview/#description", 
            "text": "", 
            "title": "Description"
        }, 
        {
            "location": "/newtmgr/overview/#command-list", 
            "text": "Available high-level commands      help        Lists commands and flags available \n    conn        Manage newtmgr connection profiles\n    echo        Send data to remote endpoint using newtmgr, and receive data back\n    image       Manage images on remote instance\n    stat        Read statistics from a remote endpoint\n    taskstats   Read statistics from a remote endpoint\n    mpstats     Read statistics from a remote endpoint\n    config      Read or write config value on target  Available Flags    -c, --connection string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)  Examples     Sub-command  Usage  Explanation      newtmgr -caditi03 taskstats       help  Usage:      newtmgr help [input1]  You can also use \"newtmgr [command] --help\" to display the help text for a newtmgr command.  Flags:    -c, --connection string      connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)  Examples     Sub-command  Available Flags  Explanation      taskstats  newtmgr -cprofile1 taskstats  Run the taskstats subcommand on the device connected via the 'profile1' connection     conn  Usage:      newtmgr conn [flags]\n    newtmgr conn [command]  Available commands:       add         Add a newtmgr connection profile\n    delete      Delete a newtmgr connection profile\n    show        Show newtmgr connection profiles  Flags:    -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)  Description     Sub-command  Explanation      add  Adds a connection profile. A properly defined profile needs a name, a connection type, and the physical or virtual port to be used for communication.    delete  Deletes a connection profile associated with the given name    show  List the specified or all the connection profiles with the name, connection type, and the controlling terminal or port.     Examples     Sub-command  Usage  Explanation      add  newtmgr conn add myserial02 type=serial connstring=/dev/ttys002  Adds a newtmgr connection profile for the serial port /dev/ttys002 and names it 'myserial02'    delete  newtmgr conn delete myserial02  Deletes the connection profile named 'myserial02'    show  newtmgr conn show myserial01  Shows the details of the profile named 'myserial01'    show  newtmgr conn show  Shows all the current profiles defined     echo  Usage:      newtmgr echo [flags] [text]  This command sends the text to the remote device at the other end of the connection specified with the -c flag and outputs the text when it gets a response from the device. If the device is not responding or if the connection profile is invalid it displays errors.   Flags:    -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)  Examples     Sub-command  Usage  Explanation      echo  newtmgr echo -c profile01 hello  Sends the string 'hello' to the remote device over the connection profile 'profile01' and receives the string back and displays it.     image  Usage:    newtmgr image [flags]\n  newtmgr image [command]  Available commands:       list         Show target images\n    upload       Upload image to target\n    boot         Which image to boot\n    fileupload   Upload file to target\n    filedownload Download file from target  Flags:    -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)  Description     Sub-command  Explanation      list  Adds a connection profile. A properly defined profile needs a name, a connection type, and the physical or virtual port to be used for communication.    upload  Deletes a connection profile associated with the given name    boot  Specify the image to boot    fileupload  upload file to the remote target    filedownload  download/retrieve file from remote target     Examples     Sub-command  Usage  Explanation      list  newtmgr list     upload  newtmgr upload     boot  newtmgr boot     fileupload  newtmgr fileupload     filedownload  newtmgr filedownload      stat  Usage:    newtmgr stat [flags]\n  newtmgr stat [command]  Flags:    -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)  Examples     Sub-command  Usage  Explanation      stat  newtmgr stat      taskstats  Usage:    newtmgr taskstats [flags]\n  newtmgr taskstats [command]  Lists all the tasks running on the remote endpoint at the end of the specified connection and for each task lists statistics such as priority, task id, runtime (how long the task has been running in ms), context switch count, stack size allocated, actual stack usage, last sanity checkin, next sanity check-in.   Flags:    -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)  Examples     Sub-command  Usage  Explanation      stat  newtmgr taskstats -c profile01  Lists all the tasks running on the remote device at the end of connection named 'profile01'     Example output  $ newtmgr  -c profile01 taskstats\nReturn Code = 0\n  idle (prio=255 tid=0 runtime=3299340 cswcnt=280342 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  os_sanity (prio=254 tid=1 runtime=0 cswcnt=3287 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  shell (prio=3 tid=2 runtime=0 cswcnt=165 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  uart_poller (prio=0 tid=3 runtime=0 cswcnt=279368 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  newtmgr (prio=4 tid=4 runtime=0 cswcnt=14 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  task1 (prio=1 tid=5 runtime=0 cswcnt=3287 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  task2 (prio=2 tid=6 runtime=0 cswcnt=3287 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)", 
            "title": "Command List"
        }, 
        {
            "location": "/newtmgr/protocol/", 
            "text": "Newt Manager Protocol\n\n\n \n\n\nDescription\n\n\nHow it works", 
            "title": "Protocol"
        }, 
        {
            "location": "/newtmgr/protocol/#newt-manager-protocol", 
            "text": "", 
            "title": "Newt Manager Protocol"
        }, 
        {
            "location": "/newtmgr/protocol/#description", 
            "text": "", 
            "title": "Description"
        }, 
        {
            "location": "/newtmgr/protocol/#how-it-works", 
            "text": "", 
            "title": "How it works"
        }, 
        {
            "location": "/newtmgr/project-slinky/", 
            "text": "Project Slinky\n\n\nObjective\n\n\nThe goal of the project is to enable and demonstate remote communications with a device or target via newt manager (newtmgr). We will first build the project image for a simulated device and then build an image for a hardware target. Next, the tool newtmgr has to be installed and a connection established with the target. Finally, various available commands in newtmgr will be used to query the target, upgrade image, and collect data from the endpoint.\n\n\nWhat you need\n\n\n\n\nSTM32-E407 development board from Olimex. You can order it from \nhttp://www.mouser.com\n, \nhttp://www.digikey.com\n, and other places.\n\n\nARM-USB-TINY-H connector with JTAG interface for debugging ARM microcontrollers (comes with the ribbon cable to hook up to the board)\n\n\nUSB A-B type cable to connect the debugger to your personal computer\n\n\nA USB to TTL Serial Cable with female wiring harness. An example is \nhttp://www.amazon.com/JBtek\u00ae-WINDOWS-Supported-Raspberry-Programming/dp/B00QT7LQ88/ref=lp_464404_1_9?s=pc\nie=UTF8\nqid=1454631303\nsr=1-9\n\n\nPersonal Computer\n\n\n\n\nThe instructions assume the user is using a Bourne-compatible shell (e.g. bash or zsh) on your computer. The given instructions have been tested with the following releases of operating systems:\n\n\n\n\nMac: OS X Yosemite Version 10.10.5\n\n\n\n\nOverview of steps\n\n\n\n\nDefine targets using the newt tool\n\n\nBuild executables for the targets using the newt tool\n\n\nSet up serial connection with the targets - both the physical connection with a hardware target and the connection profile using the newtmgr tool\n\n\nUse the newtmgr tool to communicate with the targets\n\n\n\n\nThe following instructions will walk you through the update of the larva nest and the installation of newtmgr as well.\n\n\nCreating local repository\n\n\nMake sure Mynewt's default nest \nlarva\n is up to date by downloading the latest from the Apache mynewt repository (\nhttps://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva\n).\n\n\n        $ pwd\n        /Users/\nuser\n/dev/larva\n        $ ls -al\n        total 72\n        drwxr-xr-x  18 \nuser\n  staff    612 Feb  3 15:47 .\n        drwxr-xr-x   5 \nuser\n  staff    170 Feb  3 13:32 ..\n        drwxr-xr-x  13 \nuser\n  staff    442 Feb  3 13:32 .git\n        -rw-r--r--   1 \nuser\n  staff     66 Feb  3 13:32 .gitignore\n        -rw-r--r--   1 \nuser\n  staff      0 Feb  3 13:32 .gitmodules\n        drwxr-xr-x   4 \nuser\n  staff    136 Feb  3 16:13 .nest\n        -rw-r--r--   1 \nuser\n  staff  11358 Feb  3 13:32 LICENSE\n        ...\n        ...\n        drwxr-xr-x   5 \nuser\n  staff    170 Feb  3 13:32 sys\n        $ git pull origin master\n\n\n\n\nInstalling Newtmgr\n\n\nYou will first download the source code for newt. Currently, you need to create a symbolic link for all the directory references in the go scripts to work correctly.\n\n\n        $ cd ~/dev\n        $ go get git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt\n        $ ln -s ~/dev/go/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git ~/dev/go/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt\n\n        $ pwd\n       /Users/\nuser\n/dev/go\n        $ ls\n         bin    pkg    src\n        $ cd src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt/newt\n        $ ls\n        newt    newtmgr    newtvm   util\n        $ cd newtmgr\n        $ go build\n        $ \n\n\n\n\nNote: If the \ngo build\n command results in errors indicating some package cannot be found, do a \ngo get\n to download all the third-party files needed from github.com and then run \ngo build\n again. \n\n\nBuilding Targets\n\n\nYou will create a total of 4 targets. The first one is a simulation target and the second a hardware target (for STM32-E407 Olimex development board). In order to run an image from the flash on the Olimex board, a bootloader is required. You will build two additional targets (bootloader and bin2img) as explained in Project Blinky under \nUsing flash to make LED blink\n and as shown below.\n\n\nHere;'s how to create the target for simulation.\n\n\n        $ newt target create slinky_sim\n        Creating target slinky_sim\n        Target slinky_sim sucessfully created!\n        $ newt target set slinky_sim arch=sim\n        Target slinky_sim successfully set arch to sim\n        $ newt target set slinky_sim compiler=sim\n        Target slinky_sim successfully set compiler to sim\n        $ newt target set slinky_sim project=slinky\n        Target slinky_sim successfully set project to slinky\n        $ newt target set slinky_sim compiler_def=debug\n        Target slinky_sim successfully set compiler_def to debug\n        $ newt target set slinky_sim bsp=hw/bsp/native\n        Target slinky_sim successfully set bsp to hw/bsp/native\n        $ newt target show slinky_sim\n        slinky_sim\n            arch: sim\n            bsp: hw/bsp/native\n            compiler: sim\n            compiler_def: debug\n            name: slinky_sim\n            project: slinky     \n\n\n\n\nRepeat the above steps using the attribute information for each target from the target output shown below to create the remaining three targets. The four target definitions are:\n\n\n        $ newt target show\n        bin2img\n            arch: sim\n            bsp: hw/bsp/native\n            compiler: sim\n            compiler_def: debug\n            name: bin2img\n            project: bin2img\n        boot_olimex\n            arch: cortex_m4\n            bsp: hw/bsp/olimex_stm32-e407_devboard\n            compiler: arm-none-eabi-m4\n            compiler_def: optimized\n            name: boot_olimex\n            project: boot\n        slinky1\n            arch: cortex_m4\n            bsp: hw/bsp/olimex_stm32-e407_devboard\n            compiler: arm-none-eabi-m4\n            compiler_def: debug\n            name: slinky1\n            project: slinky\n        slinky_sim\n            arch: sim\n            bsp: hw/bsp/native\n            compiler: sim\n            compiler_def: debug\n            name: slinky_sim\n            project: slinky\n\n\n\n\nGo ahead and build all the targets. The build command for slinky_sim is shown below.\n\n\n        $ newt target build slinky_sim\n        Building target slinky_sim (project = slinky)\n        Compiling base64.c\n        Compiling cbmem.c\n        ...\n        Archiving libnative.a\n        Compiling main.c\n        Building project slinky\n        Linking slinky.elf\n        Successfully run!\n\n\n\n\nNow run the \nnewt target build\n command for the remaining three targets.\n\n\nUsing newtmgr with a sim target\n\n\n\n\nRun the executable you have build for the simulated environment. The serial port name on which the simulated target is connected is shown in the output.\n\n\n\n\n        $ pwd\n        /Users/\nuser\n/dev/larva/project/slinky\n        $ ./bin/slinky_sim/slinky.elf\n        uart0 at /dev/ttys007\n\n\n\n\n\n\nYou will now set up a connection profile using \nnewtmgr\n for the serial port connection and start communicating with the simulated remote device.\n\n\n\n\n        $ newtmgr conn add sim1 type=serial connstring=/dev/ttys007\n        Connection profile sim1 successfully added\n        $ newtmgr conn show\n        Connection profiles: \n          sim1: type=serial, connstring='/dev/ttys007'\n        $ newtmgr -c sim1 taskstats\n        Return Code = 0\n          uart_poller (prio=0 tid=3 runtime=0 cswcnt=43810 stksize=1024 stkusage=325 last_checkin=0 next_checkin=0)\n          newtmgr (prio=4 tid=4 runtime=0 cswcnt=6 stksize=1024 stkusage=585 last_checkin=0 next_checkin=0)\n          task1 (prio=1 tid=5 runtime=0 cswcnt=551 stksize=1024 stkusage=83 last_checkin=0 next_checkin=0)\n          task2 (prio=2 tid=6 runtime=0 cswcnt=551 stksize=1024 stkusage=85 last_checkin=0 next_checkin=0)\n          idle (prio=255 tid=0 runtime=552525 cswcnt=44005 stksize=1024 stkusage=529 last_checkin=0 next_checkin=0)\n          os_sanity (prio=254 tid=1 runtime=0 cswcnt=551 stksize=1024 stkusage=82 last_checkin=0 next_checkin=0)\n          shell (prio=3 tid=2 runtime=0 cswcnt=20 stksize=1024 stkusage=142 last_checkin=0 next_checkin=0)\n        $ newtmgr -c sim1 stat stat\n        Return Code = 0\n        Stats Name: stat\n          s0: 1\n\n\n\n\nUsing newtmgr with a remote target\n\n\n\n\n\n\nFirst make sure the USB A-B type cable is connected to the ARM-USB-TINY-H debugger connector on the Olimex board. \n\n\nNext go the to project directory and download the slinky project image to the flash of the Olimex board. You will see the executables in the \nslinky1\n directory created for the Olimex target to run the slinky project.\n\n\n\n\n\n\n        $ pwd\n        /Users/\nuser\n/dev/larva/project/slinky\n        $ ls\n        bin     egg.yml     slinky.yml  src\n        $ ls bin\n        slinky1     slinky_sim\n        $ ls bin/slinky1\n        slinky.elf  slinky.elf.bin  slinky.elf.cmd    slinky.elf.img    slinky.elf.lst    slinky.elf.map\n        $ newt target download boot_olimex\n        Downloading with /Users/\nuser\n/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_download.sh\n        $ newt target download slinky1\n        Downloading with /Users/\nuser\n/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_download.sh\n\n\n\n\nYou can now disconnect the debugging cable from the board. You should see the green LED blinking. If not, try powercycling the board.\n\n\n\n\n\n\nNow you have to set up the serial connection from your computer to the Olimex board. Locate the PC6/USART6_TX (pin#3), PC7/USART6_RX (pin#4), and GND (pin#2) of the UEXT connector on the Olimex board. More information on the UEXT connector can be found at \nhttps://www.olimex.com/Products/Modules/UEXT/\n. The schematic of the board can be found at \nhttps://www.olimex.com/Products/ARM/ST/STM32-E407/resources/STM32-E407_sch.pdf\n for reference.\n\n\n\n\n\n\nConnect the female RX pin of the USB-TTL serial cable to the TX of the UEXT connector on the board. \n\n\nConnect the female TX pin of the USB-TTL serial cable to the RX of the UEXT connector on the board. \n\n\nConnect the GND pin of the USB-TTL serial cable to the GND of the UEXT connector on the board.\n\n\n\n\n\n\n\n\nLocate the serial connection established in the /dev directory of your computer. It should be of the type \ntty.usbserial-\nsome identifier\n.\n\n\n\n\n\n\n        $ ls /dev/tty.usbserial-AJ03HAQQ \n        /dev/tty.usbserial-AJ03HAQQ\n\n\n\n\n\n\nYou now have to define a connection profile using newtmgr. You can give it any name you want. The example below shows the connection profile being named as the very imaginative \nolimex01\n.\n\n\n\n\n        $ pwd\n        /Users/\nuser\n/dev/larva/project/slinky\n        $ newtmgr conn add olimex01 type=serial connstring=/dev/tty.usbserial-AJ03HAQQ \n        Connection profile olimex01 successfully added\n        $ newtmgr conn show\n        Connection profiles: \n          sim1: type=serial, connstring='/dev/ttys007'\n          olimex01: type=serial, connstring='/dev/tty.usbserial-AJ03HAQQ'\n\n\n\n\n\n\nNow go ahead and query the Olimex board to get responses back. The simplest command is the \necho\n command to ask it to respond with the text you send it. \n\n\n\n\n        $ newtmgr echo -c olimex01 hello\n        {\nr\n: \nhello\n}\n        $ newtmgr image -c olimex01 list\n        Images:\n            0 : 11.22.33.44\n        $ newtmgr -c olimex01 taskstats\n        Return Code = 0\n          shell (prio=3 tid=1 runtime=0 cswcnt=5 stksize=1024 stkusage=60 last_checkin=0 next_checkin=0)\n          newtmgr (prio=4 tid=2 runtime=0 cswcnt=4 stksize=1024 stkusage=256 last_checkin=0 next_checkin=0)\n          task1 (prio=1 tid=3 runtime=0 cswcnt=23 stksize=1024 stkusage=32 last_checkin=0 next_checkin=0)\n          task2 (prio=2 tid=4 runtime=0 cswcnt=24 stksize=1024 stkusage=33 last_checkin=0 next_checkin=0)\n          idle (prio=255 tid=0 runtime=23121 cswcnt=26 stksize=32 stkusage=16 last_checkin=0 next_checkin=0)", 
            "title": "Project Slinky"
        }, 
        {
            "location": "/newtmgr/project-slinky/#project-slinky", 
            "text": "Objective  The goal of the project is to enable and demonstate remote communications with a device or target via newt manager (newtmgr). We will first build the project image for a simulated device and then build an image for a hardware target. Next, the tool newtmgr has to be installed and a connection established with the target. Finally, various available commands in newtmgr will be used to query the target, upgrade image, and collect data from the endpoint.  What you need   STM32-E407 development board from Olimex. You can order it from  http://www.mouser.com ,  http://www.digikey.com , and other places.  ARM-USB-TINY-H connector with JTAG interface for debugging ARM microcontrollers (comes with the ribbon cable to hook up to the board)  USB A-B type cable to connect the debugger to your personal computer  A USB to TTL Serial Cable with female wiring harness. An example is  http://www.amazon.com/JBtek\u00ae-WINDOWS-Supported-Raspberry-Programming/dp/B00QT7LQ88/ref=lp_464404_1_9?s=pc ie=UTF8 qid=1454631303 sr=1-9  Personal Computer   The instructions assume the user is using a Bourne-compatible shell (e.g. bash or zsh) on your computer. The given instructions have been tested with the following releases of operating systems:   Mac: OS X Yosemite Version 10.10.5   Overview of steps   Define targets using the newt tool  Build executables for the targets using the newt tool  Set up serial connection with the targets - both the physical connection with a hardware target and the connection profile using the newtmgr tool  Use the newtmgr tool to communicate with the targets   The following instructions will walk you through the update of the larva nest and the installation of newtmgr as well.  Creating local repository  Make sure Mynewt's default nest  larva  is up to date by downloading the latest from the Apache mynewt repository ( https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva ).          $ pwd\n        /Users/ user /dev/larva\n        $ ls -al\n        total 72\n        drwxr-xr-x  18  user   staff    612 Feb  3 15:47 .\n        drwxr-xr-x   5  user   staff    170 Feb  3 13:32 ..\n        drwxr-xr-x  13  user   staff    442 Feb  3 13:32 .git\n        -rw-r--r--   1  user   staff     66 Feb  3 13:32 .gitignore\n        -rw-r--r--   1  user   staff      0 Feb  3 13:32 .gitmodules\n        drwxr-xr-x   4  user   staff    136 Feb  3 16:13 .nest\n        -rw-r--r--   1  user   staff  11358 Feb  3 13:32 LICENSE\n        ...\n        ...\n        drwxr-xr-x   5  user   staff    170 Feb  3 13:32 sys\n        $ git pull origin master  Installing Newtmgr  You will first download the source code for newt. Currently, you need to create a symbolic link for all the directory references in the go scripts to work correctly.          $ cd ~/dev\n        $ go get git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git/newt\n        $ ln -s ~/dev/go/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git ~/dev/go/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt\n\n        $ pwd\n       /Users/ user /dev/go\n        $ ls\n         bin    pkg    src\n        $ cd src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt/newt\n        $ ls\n        newt    newtmgr    newtvm   util\n        $ cd newtmgr\n        $ go build\n        $   Note: If the  go build  command results in errors indicating some package cannot be found, do a  go get  to download all the third-party files needed from github.com and then run  go build  again.   Building Targets  You will create a total of 4 targets. The first one is a simulation target and the second a hardware target (for STM32-E407 Olimex development board). In order to run an image from the flash on the Olimex board, a bootloader is required. You will build two additional targets (bootloader and bin2img) as explained in Project Blinky under  Using flash to make LED blink  and as shown below.  Here;'s how to create the target for simulation.          $ newt target create slinky_sim\n        Creating target slinky_sim\n        Target slinky_sim sucessfully created!\n        $ newt target set slinky_sim arch=sim\n        Target slinky_sim successfully set arch to sim\n        $ newt target set slinky_sim compiler=sim\n        Target slinky_sim successfully set compiler to sim\n        $ newt target set slinky_sim project=slinky\n        Target slinky_sim successfully set project to slinky\n        $ newt target set slinky_sim compiler_def=debug\n        Target slinky_sim successfully set compiler_def to debug\n        $ newt target set slinky_sim bsp=hw/bsp/native\n        Target slinky_sim successfully set bsp to hw/bsp/native\n        $ newt target show slinky_sim\n        slinky_sim\n            arch: sim\n            bsp: hw/bsp/native\n            compiler: sim\n            compiler_def: debug\n            name: slinky_sim\n            project: slinky       Repeat the above steps using the attribute information for each target from the target output shown below to create the remaining three targets. The four target definitions are:          $ newt target show\n        bin2img\n            arch: sim\n            bsp: hw/bsp/native\n            compiler: sim\n            compiler_def: debug\n            name: bin2img\n            project: bin2img\n        boot_olimex\n            arch: cortex_m4\n            bsp: hw/bsp/olimex_stm32-e407_devboard\n            compiler: arm-none-eabi-m4\n            compiler_def: optimized\n            name: boot_olimex\n            project: boot\n        slinky1\n            arch: cortex_m4\n            bsp: hw/bsp/olimex_stm32-e407_devboard\n            compiler: arm-none-eabi-m4\n            compiler_def: debug\n            name: slinky1\n            project: slinky\n        slinky_sim\n            arch: sim\n            bsp: hw/bsp/native\n            compiler: sim\n            compiler_def: debug\n            name: slinky_sim\n            project: slinky  Go ahead and build all the targets. The build command for slinky_sim is shown below.          $ newt target build slinky_sim\n        Building target slinky_sim (project = slinky)\n        Compiling base64.c\n        Compiling cbmem.c\n        ...\n        Archiving libnative.a\n        Compiling main.c\n        Building project slinky\n        Linking slinky.elf\n        Successfully run!  Now run the  newt target build  command for the remaining three targets.  Using newtmgr with a sim target   Run the executable you have build for the simulated environment. The serial port name on which the simulated target is connected is shown in the output.           $ pwd\n        /Users/ user /dev/larva/project/slinky\n        $ ./bin/slinky_sim/slinky.elf\n        uart0 at /dev/ttys007   You will now set up a connection profile using  newtmgr  for the serial port connection and start communicating with the simulated remote device.           $ newtmgr conn add sim1 type=serial connstring=/dev/ttys007\n        Connection profile sim1 successfully added\n        $ newtmgr conn show\n        Connection profiles: \n          sim1: type=serial, connstring='/dev/ttys007'\n        $ newtmgr -c sim1 taskstats\n        Return Code = 0\n          uart_poller (prio=0 tid=3 runtime=0 cswcnt=43810 stksize=1024 stkusage=325 last_checkin=0 next_checkin=0)\n          newtmgr (prio=4 tid=4 runtime=0 cswcnt=6 stksize=1024 stkusage=585 last_checkin=0 next_checkin=0)\n          task1 (prio=1 tid=5 runtime=0 cswcnt=551 stksize=1024 stkusage=83 last_checkin=0 next_checkin=0)\n          task2 (prio=2 tid=6 runtime=0 cswcnt=551 stksize=1024 stkusage=85 last_checkin=0 next_checkin=0)\n          idle (prio=255 tid=0 runtime=552525 cswcnt=44005 stksize=1024 stkusage=529 last_checkin=0 next_checkin=0)\n          os_sanity (prio=254 tid=1 runtime=0 cswcnt=551 stksize=1024 stkusage=82 last_checkin=0 next_checkin=0)\n          shell (prio=3 tid=2 runtime=0 cswcnt=20 stksize=1024 stkusage=142 last_checkin=0 next_checkin=0)\n        $ newtmgr -c sim1 stat stat\n        Return Code = 0\n        Stats Name: stat\n          s0: 1  Using newtmgr with a remote target    First make sure the USB A-B type cable is connected to the ARM-USB-TINY-H debugger connector on the Olimex board.   Next go the to project directory and download the slinky project image to the flash of the Olimex board. You will see the executables in the  slinky1  directory created for the Olimex target to run the slinky project.            $ pwd\n        /Users/ user /dev/larva/project/slinky\n        $ ls\n        bin     egg.yml     slinky.yml  src\n        $ ls bin\n        slinky1     slinky_sim\n        $ ls bin/slinky1\n        slinky.elf  slinky.elf.bin  slinky.elf.cmd    slinky.elf.img    slinky.elf.lst    slinky.elf.map\n        $ newt target download boot_olimex\n        Downloading with /Users/ user /dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_download.sh\n        $ newt target download slinky1\n        Downloading with /Users/ user /dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_download.sh  You can now disconnect the debugging cable from the board. You should see the green LED blinking. If not, try powercycling the board.    Now you have to set up the serial connection from your computer to the Olimex board. Locate the PC6/USART6_TX (pin#3), PC7/USART6_RX (pin#4), and GND (pin#2) of the UEXT connector on the Olimex board. More information on the UEXT connector can be found at  https://www.olimex.com/Products/Modules/UEXT/ . The schematic of the board can be found at  https://www.olimex.com/Products/ARM/ST/STM32-E407/resources/STM32-E407_sch.pdf  for reference.    Connect the female RX pin of the USB-TTL serial cable to the TX of the UEXT connector on the board.   Connect the female TX pin of the USB-TTL serial cable to the RX of the UEXT connector on the board.   Connect the GND pin of the USB-TTL serial cable to the GND of the UEXT connector on the board.     Locate the serial connection established in the /dev directory of your computer. It should be of the type  tty.usbserial- some identifier .            $ ls /dev/tty.usbserial-AJ03HAQQ \n        /dev/tty.usbserial-AJ03HAQQ   You now have to define a connection profile using newtmgr. You can give it any name you want. The example below shows the connection profile being named as the very imaginative  olimex01 .           $ pwd\n        /Users/ user /dev/larva/project/slinky\n        $ newtmgr conn add olimex01 type=serial connstring=/dev/tty.usbserial-AJ03HAQQ \n        Connection profile olimex01 successfully added\n        $ newtmgr conn show\n        Connection profiles: \n          sim1: type=serial, connstring='/dev/ttys007'\n          olimex01: type=serial, connstring='/dev/tty.usbserial-AJ03HAQQ'   Now go ahead and query the Olimex board to get responses back. The simplest command is the  echo  command to ask it to respond with the text you send it.            $ newtmgr echo -c olimex01 hello\n        { r :  hello }\n        $ newtmgr image -c olimex01 list\n        Images:\n            0 : 11.22.33.44\n        $ newtmgr -c olimex01 taskstats\n        Return Code = 0\n          shell (prio=3 tid=1 runtime=0 cswcnt=5 stksize=1024 stkusage=60 last_checkin=0 next_checkin=0)\n          newtmgr (prio=4 tid=2 runtime=0 cswcnt=4 stksize=1024 stkusage=256 last_checkin=0 next_checkin=0)\n          task1 (prio=1 tid=3 runtime=0 cswcnt=23 stksize=1024 stkusage=32 last_checkin=0 next_checkin=0)\n          task2 (prio=2 tid=4 runtime=0 cswcnt=24 stksize=1024 stkusage=33 last_checkin=0 next_checkin=0)\n          idle (prio=255 tid=0 runtime=23121 cswcnt=26 stksize=32 stkusage=16 last_checkin=0 next_checkin=0)", 
            "title": "Project Slinky"
        }, 
        {
            "location": "/packaging/dist/", 
            "text": "", 
            "title": "Creating Packages"
        }
    ]
}