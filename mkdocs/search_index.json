{
    "docs": [
        {
            "location": "/", 
            "text": "Apache Mynewt is a community-driven, permissively licensed open source initiative for constrained, embedded applications. The emergence of the Internet of Things is proving that \nanything that can be connected will be connected \n. Many of these connected devices\u2014wristbands and other wearables, light bulbs and locks\u2014must be operated for long periods of time, but are constrained in terms of power, memory, and storage. Apache Mynewt flexibly addresses these constraints while remaining hardware agnostic.", 
            "title": "Home"
        }, 
        {
            "location": "/about/", 
            "text": "Features\n\n\nApache Mynewt's open-source embedded software is designed with the following components:\n\n\n\n\nMynewt OS: Real-time operating system kernel (Scheduler, Mutexes, Semaphores, etc.)\n\n\nNewt tool: Command line package management and build system \n\n\nHardware Abstraction Layer unifying common MCU features (e.g. GPIOs, High Resolution Timers, PWM interfaces, UARTs, ADCs, etc.)\n\n\nBoard Support Infrastructure, that defines the framework for building software for various board architectures.\n\n\nImage management and upgrade using the secure bootloader, and flash filesystem.\n\n\nSystem configuration that allows collection of logs and statistics for all packages (with filtering options) ranging from OS-level resources such as memory pools, priorities to interface level counters such as packet exchange and queues\n\n\nCore dump captures to enable remote diagnosis of device failures and hiccups\n\n\nNetwork protocol stacks \n\n\nFirst fully open-source BLE 4.2 stack\n\n\nSupport for PDUs of up to 251 bytes for high throughput\n\n\nSupport for all 4 roles to be run concurrently - Broadcaster, Observer, Peripheral, Central\n\n\nRandom addresses for link-layer security\n\n\nSecurity Manager Protocol\n\n\nLE Secure Connections\n\n\n\n\n\n\n\n\n\n\n\n\nRoadmap\n\n\n\n\n\n\n\n\nRelease Version\n\n\nDescriptor\n\n\nDate\n\n\nFeatures\n\n\n\n\n\n\n\n\n\n\n0.8.0b2\n\n\nBeta #2 before pre-GA release #1\n\n\nmid-March, 2016\n\n\n* Arduino Zero support\n\n\n\n\n\n\n\n\n\n\n\n\n* OS Time\n\n\n\n\n\n\n\n\n\n\n\n\n* Several new tutorials for OS\n\n\n\n\n\n\n\n\n\n\n\n\n* Tutorials for BLE 4.2\n\n\n\n\n\n\n\n\n\n\n\n\n* BLE 4.2: Random static address\n\n\n\n\n\n\n0.8.0\n\n\npre-GA release #1\n\n\nmid-April, 2016\n\n\n* HAL extensions in OS\n\n\n\n\n\n\n\n\n\n\n\n\n* Arduino DUE support\n\n\n\n\n\n\n\n\n\n\n\n\n* Image verification\n\n\n\n\n\n\n\n\n\n\n\n\n* BLE 4.2 stats and logs\n\n\n\n\n\n\n\n\n\n\n\n\n* Crash dump capture and retrieval\n\n\n\n\n\n\n0.9.0b1\n\n\nBeta before pre-GA release #2\n\n\nmid-May, 2016\n\n\n* Support images in external flash\n\n\n\n\n\n\n\n\n\n\n\n\n* Support for low power modes in multiple SoCs\n\n\n\n\n\n\n\n\n\n\n\n\n* BLE 4.2: LE legacy pairing\n\n\n\n\n\n\n\n\n\n\n\n\n* BLE 4.2: LE Secure Connections\n\n\n\n\n\n\n\n\n\n\n\n\n* BLE 4.2: Host and Controller separation\n\n\n\n\n\n\n\n\n\n\n\n\n* BLE 4.2: Random private resolvable addresses\n\n\n\n\n\n\n\n\n\n\n\n\n* BLE 4.2 stats and logs\n\n\n\n\n\n\n0.9.0\n\n\npre-GA release #2\n\n\nmid-June, 2016\n\n\n* Test coverage improvements\n\n\n\n\n\n\n\n\n\n\n\n\n* BLE 4.2: GATT based BLE profiles for Mynewt\n\n\n\n\n\n\n\n\n\n\n\n\n* BLE 4.2: Configurability improvements\n\n\n\n\n\n\n\n\n The detailed roadmap is tracked on \nJIRA for Mynewt\n. \n\n\nFeature Request\n\n\nThe WISHLIST at the top of the roadmap on \nJIRA for Mynewt\n features all the new ideas awaiting discussion and review. Once the community decides to go ahead with a request, it is scheduled into a release. Generally, effort is made to schedule a requested feature into a particular version no later than 6 weeks prior to the planned release date.\n\n\nIf you have suggestions for a new feature, use case, or implementation improvements, file a JIRA ticket with Issue Type set to \"Wish\". Introduce it in the \ndev@\n mailing list with a link to the JIRA ticket. This assumes you have signed up for an account on JIRA and submitted a request to the dev@ mailing list for your JIRA username to be added to the Apache Mynewt (MYNEWT) project. \n\n\nFAQ\n\n\n Questions? \n Click \nhere", 
            "title": "About"
        }, 
        {
            "location": "/about/#features", 
            "text": "Apache Mynewt's open-source embedded software is designed with the following components:   Mynewt OS: Real-time operating system kernel (Scheduler, Mutexes, Semaphores, etc.)  Newt tool: Command line package management and build system   Hardware Abstraction Layer unifying common MCU features (e.g. GPIOs, High Resolution Timers, PWM interfaces, UARTs, ADCs, etc.)  Board Support Infrastructure, that defines the framework for building software for various board architectures.  Image management and upgrade using the secure bootloader, and flash filesystem.  System configuration that allows collection of logs and statistics for all packages (with filtering options) ranging from OS-level resources such as memory pools, priorities to interface level counters such as packet exchange and queues  Core dump captures to enable remote diagnosis of device failures and hiccups  Network protocol stacks   First fully open-source BLE 4.2 stack  Support for PDUs of up to 251 bytes for high throughput  Support for all 4 roles to be run concurrently - Broadcaster, Observer, Peripheral, Central  Random addresses for link-layer security  Security Manager Protocol  LE Secure Connections", 
            "title": "Features"
        }, 
        {
            "location": "/about/#roadmap", 
            "text": "Release Version  Descriptor  Date  Features      0.8.0b2  Beta #2 before pre-GA release #1  mid-March, 2016  * Arduino Zero support       * OS Time       * Several new tutorials for OS       * Tutorials for BLE 4.2       * BLE 4.2: Random static address    0.8.0  pre-GA release #1  mid-April, 2016  * HAL extensions in OS       * Arduino DUE support       * Image verification       * BLE 4.2 stats and logs       * Crash dump capture and retrieval    0.9.0b1  Beta before pre-GA release #2  mid-May, 2016  * Support images in external flash       * Support for low power modes in multiple SoCs       * BLE 4.2: LE legacy pairing       * BLE 4.2: LE Secure Connections       * BLE 4.2: Host and Controller separation       * BLE 4.2: Random private resolvable addresses       * BLE 4.2 stats and logs    0.9.0  pre-GA release #2  mid-June, 2016  * Test coverage improvements       * BLE 4.2: GATT based BLE profiles for Mynewt       * BLE 4.2: Configurability improvements      The detailed roadmap is tracked on  JIRA for Mynewt .", 
            "title": "Roadmap"
        }, 
        {
            "location": "/about/#feature-request", 
            "text": "The WISHLIST at the top of the roadmap on  JIRA for Mynewt  features all the new ideas awaiting discussion and review. Once the community decides to go ahead with a request, it is scheduled into a release. Generally, effort is made to schedule a requested feature into a particular version no later than 6 weeks prior to the planned release date.  If you have suggestions for a new feature, use case, or implementation improvements, file a JIRA ticket with Issue Type set to \"Wish\". Introduce it in the  dev@  mailing list with a link to the JIRA ticket. This assumes you have signed up for an account on JIRA and submitted a request to the dev@ mailing list for your JIRA username to be added to the Apache Mynewt (MYNEWT) project.", 
            "title": "Feature Request"
        }, 
        {
            "location": "/about/#faq", 
            "text": "Questions?   Click  here", 
            "title": "FAQ"
        }, 
        {
            "location": "/documentation/", 
            "text": "Documentation Organization\n\n\nThe technical literature for Apache Mynewt is organized into three manuals. The first describes the Real Time Operating System (RTOS), its features and capabilites, and how to get it running on your target device. The second one demonstrates how to use the build and packaging tool, \nNewt\n, to easily choose firmware modules for your target and compose them into a working executable. The third manual shows how the device management tool, \nNewtmgr\n, can communicate with a remote device running Mynewt OS and monitor, configure, and upgrade it.\n\n\nFor you to learn and get some hands-on experience, each manual includes one or more tutorials. We encourage that you try them, and do send us your feedback.", 
            "title": "Documentation"
        }, 
        {
            "location": "/documentation/#documentation-organization", 
            "text": "The technical literature for Apache Mynewt is organized into three manuals. The first describes the Real Time Operating System (RTOS), its features and capabilites, and how to get it running on your target device. The second one demonstrates how to use the build and packaging tool,  Newt , to easily choose firmware modules for your target and compose them into a working executable. The third manual shows how the device management tool,  Newtmgr , can communicate with a remote device running Mynewt OS and monitor, configure, and upgrade it.  For you to learn and get some hands-on experience, each manual includes one or more tutorials. We encourage that you try them, and do send us your feedback.", 
            "title": "Documentation Organization"
        }, 
        {
            "location": "/download/", 
            "text": "Code in development \n\n\nWhile the use of one of the official releases listed above is generally recommended, you may be interested in seeing work in progress. The most recent code resides in the \ndevelop\n branch of the Mynewt git repository. You may access the code for Mynewt OS and Newt Tool from the Apache mirror on github.com.\n\n\n\n\nApache Mynewt OS mirror on github.com\n\n\nApache Newt Tool mirror on github.com\n\n\n\n\n\n\n\n\nFor general information on using Git at Apache, go to https://git-wip-us.apache.org.", 
            "title": "Download"
        }, 
        {
            "location": "/download/#code-in-development", 
            "text": "While the use of one of the official releases listed above is generally recommended, you may be interested in seeing work in progress. The most recent code resides in the  develop  branch of the Mynewt git repository. You may access the code for Mynewt OS and Newt Tool from the Apache mirror on github.com.   Apache Mynewt OS mirror on github.com  Apache Newt Tool mirror on github.com     For general information on using Git at Apache, go to https://git-wip-us.apache.org.", 
            "title": " Code in development "
        }, 
        {
            "location": "/community/", 
            "text": "Mailing Lists\n\n\nWe welcome you to join our mailing lists and get in touch with us! \n\n \nTo complete your subscription you have to confirm it by replying to the response sent to you when you email your subscription request!", 
            "title": "Community"
        }, 
        {
            "location": "/community/#mailing-lists", 
            "text": "We welcome you to join our mailing lists and get in touch with us!    To complete your subscription you have to confirm it by replying to the response sent to you when you email your subscription request!", 
            "title": "Mailing Lists"
        }, 
        {
            "location": "/events/", 
            "text": "Events\n\n\nPlease take a look at our upcoming events! We hope to see you there.", 
            "title": "Events"
        }, 
        {
            "location": "/events/#events", 
            "text": "Please take a look at our upcoming events! We hope to see you there.", 
            "title": "Events"
        }, 
        {
            "location": "/os/get_started/introduction/", 
            "text": "Introduction\n\n\nWelcome to Apache Mynewt\n\n\nApache Mynewt is an operating system that makes it easy to develop\napplications for microcontroller environments where power and cost \nare driving factors. Examples of these devices are connected locks, \nlights, and wearables.\n\n\nMicrocontroller environments have a number of characteristics that \nmakes the operating system requirements for them unique: \n\n\n\n\n\n\nLow memory footprint: memory on these systems range from \n8-16KB (on the low end) to 16MB (on the high end).\n\n\n\n\n\n\nReduced code size: code often runs out of flash, and total available code size ranges from 64-128KB to 16-32MB.\n\n\n\n\n\n\nLow processing speed: processor speeds vary from 10-12MHz to 160-200MHz.  \n\n\n\n\n\n\nLow power operation: devices operate in mostly sleeping mode, in order to conserve\nbattery power and maximize power usage.\n\n\n\n\n\n\nAs more and more devices get connected, these interconnected devices perform complex tasks. To\nperform these tasks, you need low-level operational functionality built into the operating system.\nTypically, connected devices built with these microcontrollers perform a myriad of functions: \n\n\n\n\n\n\nNetworking Stacks: Bluetooth Low Energy and Thread\n\n\n\n\n\n\nPeripherals: PWM to drive motors, ADCs to measure sensor data, and RTCs\nto keep time.\n\n\n\n\n\n\nScheduled Processing: actions must happen on a calendared or periodic basis.\n\n\n\n\n\n\nApache Mynewt accomplishes all the above easily, by providing a complete\noperating system for constrained devices, including:\n\n\n\n\n\n\nA fully open-source Bluetooth Low Energy stack with both Host and \nController implementations. \n\n\n\n\n\n\nA pre-emptive, multi-tasking Real Time operating system kernel\n\n\n\n\n\n\nA Hardware Abstraction Layer (HAL) that abstracts the MCU's \nperipheral functions, allowing developers to easily write cross-platform\ncode.\n\n\n\n\n\n\nNewt\n\n\nIn order to provide all this functionality, and operate in an \nextremely low resource environment, Mynewt provides a very fine-grained source \npackage management and build system tool, called \nnewt\n. \n\n\nYou can install and build \nnewt\n for \nLinux\n or \nMac\n. \n\n\nBuild your first Mynewt App with Newt\n\n\nBefore you start your first Mynewt application, you must first create a new Mynewt\nproject with the \nnewt\n tool: \n\n\n$ newt new my_project\nDownloading project skeleton from apache/incubator-mynewt-blinky...\nInstalling skeleton in my_app...\nProject my_app successfully created.\n\n\n\n\n\nNewt populates this new project with a base skeleton of a new Apache Mynewt \nproject.  It has the following structure:\n\n\n$ cd my_project\n$ tree -L 3\n.\n\u251c\u2500\u2500 DISCLAIMER\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 NOTICE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 apps\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 blinky\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 pkg.yml\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 src\n\u251c\u2500\u2500 project.yml\n\u2514\u2500\u2500 targets\n    \u251c\u2500\u2500 my_blinky_sim\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 pkg.yml\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 target.yml\n    \u2514\u2500\u2500 unittest\n        \u251c\u2500\u2500 pkg.yml\n        \u2514\u2500\u2500 target.yml\n\n6 directories, 10 files\n$ \n\n\n\n\n\nOnce you've switched into your new project's directory, the next step is to fetch\nany dependencies this project has.  By default, all Newt projects rely on a single\nremote repository, apache-mynewt-core.  Newt install will fetch this locally:\n\n\n$ newt install\napache-mynewt-core\n$\n\n\n\n\n\nNOTE:\n \napache-mynewt-core\n may take a while to download, to see progress, use\nthe \n-v\n (verbose) option to install. \n\n\nOnce \nnewt install\n has successfully finished, the contents of \napache-mynewt-core\n\nwill have been downloaded into your local directory.  You can view them by issuing the \nfollowing commands in the base directory of the new project:\n\n\n$ cd repos/apache-mynewt-core\n$ tree -L2\n.\n\nsnip\n\n\u251c\u2500\u2500 fs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 fs\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 nffs\n\u251c\u2500\u2500 hw\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 bsp\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 hal\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 mcu\n\u251c\u2500\u2500 libs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 baselibc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 bootutil\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 cmsis-core\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 console\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 elua\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 flash_test\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 imgmgr\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 json\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mbedtls\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 newtmgr\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 os\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 shell\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 testreport\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 testutil\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 util\n\u251c\u2500\u2500 net\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 nimble\n\nsnip\n\n\n\n\n\n\nAs you can see, the core of the Apache Mynewt operating system has been brought \ninto your local directory!  \n\n\nNew projects created with Newt, come with by default an example application \n(\napps/blinky\n) and an example target (\nmy_blinky_sim\n) which allows you to \nbuild that application for the simulated platform.  \n\n\nWith your new project, all you need to build and run your new application is to \nissue the following commands: \n\n\n$ newt build my_blinky_sim \nCompiling base64.c\nCompiling cbmem.c\nCompiling datetime.c\nCompiling tpq.c\nArchiving util.a\nCompiling main.c\nArchiving blinky.a\nCompiling flash_map.c\nCompiling hal_flash.c\nArchiving hal.a\nCompiling cons_fmt.c\nCompiling cons_tty.c\n\nsnip\n\nLinking blinky.elf\nApp successfully built: /Users/sterling/dev/tmp/my_app/bin/my_blinky_sim/apps/blinky/blinky.elf\n$ newt run my_blinky_sim\n(runs target my_blinky_sim on the simulator)\n\n\n\n\n\nAt this point you have your first Mynewt application!\n\n\nApache Mynewt has a lot more functionality than just running simulated applications.  It provides all \nthe features you'll need to cross-compile your application, run it on real hardware and develop a \nfull featured application.\n\n\nIf you're interested in learning more, a good next step is to choose a project to \n\nGet Started\n with, and begin to familiarize \nyourself with operating within the newt environment.  These projects will get your toolchain installed, \nand get you blinking an LED with the Apache Mynewt OS.\n\n\nAfter you've tried a few getting started projects, there are plenty of tutorials that will help \nexpose you to much of the functionality provided by the Apache Mynewt Core Operating System.   There is \nalso full reference documentation for all of the Core Apache Mynewt APIs.\n\n\nHappy Hacking!", 
            "title": "Introduction"
        }, 
        {
            "location": "/os/get_started/introduction/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/os/get_started/introduction/#welcome-to-apache-mynewt", 
            "text": "Apache Mynewt is an operating system that makes it easy to develop\napplications for microcontroller environments where power and cost \nare driving factors. Examples of these devices are connected locks, \nlights, and wearables.  Microcontroller environments have a number of characteristics that \nmakes the operating system requirements for them unique:     Low memory footprint: memory on these systems range from \n8-16KB (on the low end) to 16MB (on the high end).    Reduced code size: code often runs out of flash, and total available code size ranges from 64-128KB to 16-32MB.    Low processing speed: processor speeds vary from 10-12MHz to 160-200MHz.      Low power operation: devices operate in mostly sleeping mode, in order to conserve\nbattery power and maximize power usage.    As more and more devices get connected, these interconnected devices perform complex tasks. To\nperform these tasks, you need low-level operational functionality built into the operating system.\nTypically, connected devices built with these microcontrollers perform a myriad of functions:     Networking Stacks: Bluetooth Low Energy and Thread    Peripherals: PWM to drive motors, ADCs to measure sensor data, and RTCs\nto keep time.    Scheduled Processing: actions must happen on a calendared or periodic basis.    Apache Mynewt accomplishes all the above easily, by providing a complete\noperating system for constrained devices, including:    A fully open-source Bluetooth Low Energy stack with both Host and \nController implementations.     A pre-emptive, multi-tasking Real Time operating system kernel    A Hardware Abstraction Layer (HAL) that abstracts the MCU's \nperipheral functions, allowing developers to easily write cross-platform\ncode.", 
            "title": "Welcome to Apache Mynewt"
        }, 
        {
            "location": "/os/get_started/introduction/#newt", 
            "text": "In order to provide all this functionality, and operate in an \nextremely low resource environment, Mynewt provides a very fine-grained source \npackage management and build system tool, called  newt .   You can install and build  newt  for  Linux  or  Mac .", 
            "title": "Newt"
        }, 
        {
            "location": "/os/get_started/introduction/#build-your-first-mynewt-app-with-newt", 
            "text": "Before you start your first Mynewt application, you must first create a new Mynewt\nproject with the  newt  tool:   $ newt new my_project\nDownloading project skeleton from apache/incubator-mynewt-blinky...\nInstalling skeleton in my_app...\nProject my_app successfully created.  Newt populates this new project with a base skeleton of a new Apache Mynewt \nproject.  It has the following structure:  $ cd my_project\n$ tree -L 3\n.\n\u251c\u2500\u2500 DISCLAIMER\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 NOTICE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 apps\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 blinky\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 pkg.yml\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 src\n\u251c\u2500\u2500 project.yml\n\u2514\u2500\u2500 targets\n    \u251c\u2500\u2500 my_blinky_sim\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 pkg.yml\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 target.yml\n    \u2514\u2500\u2500 unittest\n        \u251c\u2500\u2500 pkg.yml\n        \u2514\u2500\u2500 target.yml\n\n6 directories, 10 files\n$   Once you've switched into your new project's directory, the next step is to fetch\nany dependencies this project has.  By default, all Newt projects rely on a single\nremote repository, apache-mynewt-core.  Newt install will fetch this locally:  $ newt install\napache-mynewt-core\n$  NOTE:   apache-mynewt-core  may take a while to download, to see progress, use\nthe  -v  (verbose) option to install.   Once  newt install  has successfully finished, the contents of  apache-mynewt-core \nwill have been downloaded into your local directory.  You can view them by issuing the \nfollowing commands in the base directory of the new project:  $ cd repos/apache-mynewt-core\n$ tree -L2\n. snip \n\u251c\u2500\u2500 fs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 fs\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 nffs\n\u251c\u2500\u2500 hw\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 bsp\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 hal\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 mcu\n\u251c\u2500\u2500 libs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 baselibc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 bootutil\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 cmsis-core\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 console\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 elua\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 flash_test\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 imgmgr\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 json\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mbedtls\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 newtmgr\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 os\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 shell\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 testreport\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 testutil\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 util\n\u251c\u2500\u2500 net\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 nimble snip   As you can see, the core of the Apache Mynewt operating system has been brought \ninto your local directory!    New projects created with Newt, come with by default an example application \n( apps/blinky ) and an example target ( my_blinky_sim ) which allows you to \nbuild that application for the simulated platform.    With your new project, all you need to build and run your new application is to \nissue the following commands:   $ newt build my_blinky_sim \nCompiling base64.c\nCompiling cbmem.c\nCompiling datetime.c\nCompiling tpq.c\nArchiving util.a\nCompiling main.c\nArchiving blinky.a\nCompiling flash_map.c\nCompiling hal_flash.c\nArchiving hal.a\nCompiling cons_fmt.c\nCompiling cons_tty.c snip \nLinking blinky.elf\nApp successfully built: /Users/sterling/dev/tmp/my_app/bin/my_blinky_sim/apps/blinky/blinky.elf\n$ newt run my_blinky_sim\n(runs target my_blinky_sim on the simulator)  At this point you have your first Mynewt application!  Apache Mynewt has a lot more functionality than just running simulated applications.  It provides all \nthe features you'll need to cross-compile your application, run it on real hardware and develop a \nfull featured application.  If you're interested in learning more, a good next step is to choose a project to  Get Started  with, and begin to familiarize \nyourself with operating within the newt environment.  These projects will get your toolchain installed, \nand get you blinking an LED with the Apache Mynewt OS.  After you've tried a few getting started projects, there are plenty of tutorials that will help \nexpose you to much of the functionality provided by the Apache Mynewt Core Operating System.   There is \nalso full reference documentation for all of the Core Apache Mynewt APIs.  Happy Hacking!", 
            "title": "Build your first Mynewt App with Newt"
        }, 
        {
            "location": "/os/get_started/native_tools/", 
            "text": "Installing Native Mynewt Tools\n\n\nThis page shows how to install tools for native Mynewt targets. This\nallows you to run Mynewt OS as a native application.  It also allows\nyou to run the test suites for all packages not requiring HW support. \n\n\nThis page provides guidance for MAC and Linux. See the relevant sections below.\n\n\nSet up toolchain for Mac\n\n\nInstall Brew\n\n\nif you have not already installed Homebrew from the \n\nnewt\n tutorials pages\n. \n\n\nInstall gcc/libc\n\n\nUse brew to install gcc.\n\n\n        $ brew install gcc\n        ...\n        ...\n        ==\n Summary\n        \ud83c\udf7a  /usr/local/Cellar/gcc/5.2.0: 1353 files, 248M\n\n\n\n\n\nInstall gdb\n\n\n        $ brew install gdb\n        ...\n        ...\n        ==\n Summary\n        \ud83c\udf7a  /usr/local/Cellar/gdb/7.10.1: XXX files,YYM\n\n\n\n\n\nNOTE: When running a program with gdb, you may need to sign your gdb\nexecutable.  \nThis page\n\nshows a recipe for gdb signing. Alternately you can skip this step and\ncontinue without the ability to debug your mynewt application on your PC.\n\n\nSet up toolchain for Linux\n\n\nInstall gcc/libc that will produce 32-bit executables:\n\n\n        $ sudo apt-get install gcc-multilib libc6-i386\n\n\n\n\n\nInstall gdb\n\n\n$sudo apt-get install gdb\n\nReading package lists... Done\nBuilding dependency tree       \nReading state information... Done\nSuggested packages:\n  gdb-doc gdbserver\nThe following NEW packages will be installed:\n  gdb\n...\nProcessing triggers for man-db (2.6.7.1-1ubuntu1) ...\nSetting up gdb (7.7.1-0ubuntu5~14.04.2) ...\n$ \n\n\n\n\n\nAt this point you have installed all the necessary software to build and test code on a simluator for Linux. Proceed to the \nBuild test code on simulator\n section.", 
            "title": "Installing Native Tools"
        }, 
        {
            "location": "/os/get_started/native_tools/#installing-native-mynewt-tools", 
            "text": "This page shows how to install tools for native Mynewt targets. This\nallows you to run Mynewt OS as a native application.  It also allows\nyou to run the test suites for all packages not requiring HW support.   This page provides guidance for MAC and Linux. See the relevant sections below.", 
            "title": "Installing Native Mynewt Tools"
        }, 
        {
            "location": "/os/get_started/native_tools/#set-up-toolchain-for-mac", 
            "text": "", 
            "title": "Set up toolchain for Mac"
        }, 
        {
            "location": "/os/get_started/native_tools/#install-brew", 
            "text": "if you have not already installed Homebrew from the  newt  tutorials pages .", 
            "title": "Install Brew"
        }, 
        {
            "location": "/os/get_started/native_tools/#install-gcclibc", 
            "text": "Use brew to install gcc.          $ brew install gcc\n        ...\n        ...\n        ==  Summary\n        \ud83c\udf7a  /usr/local/Cellar/gcc/5.2.0: 1353 files, 248M", 
            "title": "Install gcc/libc"
        }, 
        {
            "location": "/os/get_started/native_tools/#install-gdb", 
            "text": "$ brew install gdb\n        ...\n        ...\n        ==  Summary\n        \ud83c\udf7a  /usr/local/Cellar/gdb/7.10.1: XXX files,YYM  NOTE: When running a program with gdb, you may need to sign your gdb\nexecutable.   This page \nshows a recipe for gdb signing. Alternately you can skip this step and\ncontinue without the ability to debug your mynewt application on your PC.", 
            "title": "Install gdb"
        }, 
        {
            "location": "/os/get_started/native_tools/#set-up-toolchain-for-linux", 
            "text": "", 
            "title": "Set up toolchain for Linux"
        }, 
        {
            "location": "/os/get_started/native_tools/#install-gcclibc-that-will-produce-32-bit-executables", 
            "text": "$ sudo apt-get install gcc-multilib libc6-i386", 
            "title": "Install gcc/libc that will produce 32-bit executables:"
        }, 
        {
            "location": "/os/get_started/native_tools/#install-gdb_1", 
            "text": "$sudo apt-get install gdb\n\nReading package lists... Done\nBuilding dependency tree       \nReading state information... Done\nSuggested packages:\n  gdb-doc gdbserver\nThe following NEW packages will be installed:\n  gdb\n...\nProcessing triggers for man-db (2.6.7.1-1ubuntu1) ...\nSetting up gdb (7.7.1-0ubuntu5~14.04.2) ...\n$   At this point you have installed all the necessary software to build and test code on a simluator for Linux. Proceed to the  Build test code on simulator  section.", 
            "title": "Install gdb"
        }, 
        {
            "location": "/os/get_started/project_create/", 
            "text": "Creating a Mynewt Project\n\n\nThis page shows how to create a Mynewt Project using \nnewt\n\n\nPre-Requisites\n\n\n\n\nEnsure you have installed \nnewt\n and that the \nnewt command is in your system path.\n\n\nYou must have Internet connectivity to fetch remote Mynewt components\n\n\nYou must \ninstall the compiler tools\n to \nsupport native compiling to build the project this tutorial creates.  \n\n\n\n\nNewt New\n\n\nChose a project name. For this tutorial we will call this project \nmyproj\n.\nEnter the \nnewt new myproj\n command. Your put\n\n\n    $ newt new myproj\n    Downloading project skeleton from apache/incubator-mynewt-blinky...\n    Installing skeleton in myproj...\n    Project myproj successfully created.\n\n\n\n\n\nThe \nnewt\n tool has created a project directory structure like the one below:\n\n\n    \u2500\u2500\u2500 myproj\n        \u251c\u2500\u2500 DISCLAIMER\n        \u251c\u2500\u2500 LICENSE\n        \u251c\u2500\u2500 NOTICE\n        \u251c\u2500\u2500 README.md\n        \u251c\u2500\u2500 apps\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 blinky\n        \u2502\u00a0\u00a0     \u251c\u2500\u2500 pkg.yml\n        \u2502\u00a0\u00a0     \u2514\u2500\u2500 src\n        \u2502\u00a0\u00a0         \u2514\u2500\u2500 main.c\n        \u251c\u2500\u2500 project.yml\n        \u2514\u2500\u2500 targets\n            \u251c\u2500\u2500 my_blinky_sim\n            \u2502\u00a0\u00a0 \u251c\u2500\u2500 pkg.yml\n            \u2502\u00a0\u00a0 \u2514\u2500\u2500 target.yml\n            \u2514\u2500\u2500 unittest\n                \u251c\u2500\u2500 pkg.yml\n                \u2514\u2500\u2500 target.yml\n\n\n\n\n\nnewt\n has installed the base files for a project comprising the following.\n\n\n\n\nfile \nproject.yml\n contains the repository list that the project uses to fetch\nits packages. Your project is a collection of repositories.  In this case, the project just\ncomprises the core mynewt repository.  Later you will add more repositories\nto include other mynewt components.\n\n\nthe file \napps/blinky/pkg.yml\n contains the description of your application\nand its package dependencies.\n\n\nA target directory containing \nmy_blinky_sim\n, a target descriptor used to\nbuild a version of myproj.  Use \nnewt target show\n to see available build \ntargets.\n\n\nA non-build-able target called \nunittest\n.  This is used\ninternally by \nnewt\n and is not a formal build target.\n\n\n\n\nNOTE: the actual code and package files are not installed \n(except the template for \nmain.c\n.  See the next step for installing \nthe packages.\n\n\nNewt Install\n\n\nchange into the \nmyproj\n directory.  Then ask newt to install all the \nproject package dependencies using \nnewt install\n\n\n    $ newt install -v \n    apache-mynewt-core\n    Downloading repository description for apache-mynewt-core... success!\n    Downloading repository incubator-mynewt-core (branch: master; commit: mynewt_0_8_0_b2_tag) at https://github.com/apache/incubator-mynewt-core.git\n    Cloning into \n/var/folders/7l/7b3w9m4n2mg3sqmgw2q1b9p80000gn/T/newt-repo969988348\n...\n    remote: Counting objects: 17935, done.\n    remote: Compressing objects: 100% (234/234), done.\n    remote: Total 17935 (delta 101), reused 0 (delta 0), pack-reused 17686\n    Receiving objects: 100% (17935/17935), 6.18 MiB | 315.00 KiB/s, done.\n    Resolving deltas: 100% (10541/10541), done.\n    Checking connectivity... done.\n    apache-mynewt-core successfully installed version 0.7.9-none\n    $ \n\n\n\n\n\nNow you will have installed packages required to build your project. Note in \nthe package you now have dependent packages stored in the \nrepos\n directory\nunder the specific repository you have included in the base project.  \n\n\n    .\n    \u251c\u2500\u2500 apps\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 blinky\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 src\n    \u251c\u2500\u2500 repos\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 apache-mynewt-core\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 apps\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 compiler\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 fs\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 hw\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 libs\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 net\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 scripts\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 sys\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 targets\n    \u2514\u2500\u2500 targets\n        \u251c\u2500\u2500 my_blinky_sim\n        \u2514\u2500\u2500 unittest\n\n\n\n\n\nWithin each of these directories are the packages required to build your\nproject for the various targets.\n\n\nTesting the Project\n\n\nTo validate, you can also run all the units test through simulation.\n\n\n    $ newt test all\n    ...lots of compiling and testing...\n    ...about 2 minutes later ...\n    Archiving bootutil.a\n    Linking test_bootutil\n    Executing test: /myproj/bin/unittest/libs/bootutil/test_bootutil\n    Passed tests: [net/nimble/host fs/nffs libs/os hw/hal libs/mbedtls libs/util sys/config libs/bootutil]\n    All tests passed\n\n\n\n\n\nBuilding the Project\n\n\nTo build the project you can use \nnewt build\n using the target \n\n\n    $ newt build my_blinky_sim\n    App successfully built: /bin/my_blinky_sim/apps/blinky/blinky.elf\n\n\n\n\n\nYou can run the simulated version of your project and see the simulated LED\nblink\n\n\n    ./bin/my_blinky_sim/apps/blinky/blinky.elf\n    hal_gpio set pin  1 to 0\n\n\n\n\n\nJust do \nctrl-c\n to exit.\n\n\nComplete\n\n\nCongratulations, you have created your first project.  This project contains \nthe core OS, a simple application to blink an LED and all of the dependencies\nrequired.", 
            "title": "Creating Your First Project"
        }, 
        {
            "location": "/os/get_started/project_create/#creating-a-mynewt-project", 
            "text": "This page shows how to create a Mynewt Project using  newt", 
            "title": "Creating a Mynewt Project"
        }, 
        {
            "location": "/os/get_started/project_create/#pre-requisites", 
            "text": "Ensure you have installed  newt  and that the \nnewt command is in your system path.  You must have Internet connectivity to fetch remote Mynewt components  You must  install the compiler tools  to \nsupport native compiling to build the project this tutorial creates.", 
            "title": "Pre-Requisites"
        }, 
        {
            "location": "/os/get_started/project_create/#newt-new", 
            "text": "Chose a project name. For this tutorial we will call this project  myproj .\nEnter the  newt new myproj  command. Your put      $ newt new myproj\n    Downloading project skeleton from apache/incubator-mynewt-blinky...\n    Installing skeleton in myproj...\n    Project myproj successfully created.  The  newt  tool has created a project directory structure like the one below:      \u2500\u2500\u2500 myproj\n        \u251c\u2500\u2500 DISCLAIMER\n        \u251c\u2500\u2500 LICENSE\n        \u251c\u2500\u2500 NOTICE\n        \u251c\u2500\u2500 README.md\n        \u251c\u2500\u2500 apps\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 blinky\n        \u2502\u00a0\u00a0     \u251c\u2500\u2500 pkg.yml\n        \u2502\u00a0\u00a0     \u2514\u2500\u2500 src\n        \u2502\u00a0\u00a0         \u2514\u2500\u2500 main.c\n        \u251c\u2500\u2500 project.yml\n        \u2514\u2500\u2500 targets\n            \u251c\u2500\u2500 my_blinky_sim\n            \u2502\u00a0\u00a0 \u251c\u2500\u2500 pkg.yml\n            \u2502\u00a0\u00a0 \u2514\u2500\u2500 target.yml\n            \u2514\u2500\u2500 unittest\n                \u251c\u2500\u2500 pkg.yml\n                \u2514\u2500\u2500 target.yml  newt  has installed the base files for a project comprising the following.   file  project.yml  contains the repository list that the project uses to fetch\nits packages. Your project is a collection of repositories.  In this case, the project just\ncomprises the core mynewt repository.  Later you will add more repositories\nto include other mynewt components.  the file  apps/blinky/pkg.yml  contains the description of your application\nand its package dependencies.  A target directory containing  my_blinky_sim , a target descriptor used to\nbuild a version of myproj.  Use  newt target show  to see available build \ntargets.  A non-build-able target called  unittest .  This is used\ninternally by  newt  and is not a formal build target.   NOTE: the actual code and package files are not installed \n(except the template for  main.c .  See the next step for installing \nthe packages.", 
            "title": "Newt New"
        }, 
        {
            "location": "/os/get_started/project_create/#newt-install", 
            "text": "change into the  myproj  directory.  Then ask newt to install all the \nproject package dependencies using  newt install      $ newt install -v \n    apache-mynewt-core\n    Downloading repository description for apache-mynewt-core... success!\n    Downloading repository incubator-mynewt-core (branch: master; commit: mynewt_0_8_0_b2_tag) at https://github.com/apache/incubator-mynewt-core.git\n    Cloning into  /var/folders/7l/7b3w9m4n2mg3sqmgw2q1b9p80000gn/T/newt-repo969988348 ...\n    remote: Counting objects: 17935, done.\n    remote: Compressing objects: 100% (234/234), done.\n    remote: Total 17935 (delta 101), reused 0 (delta 0), pack-reused 17686\n    Receiving objects: 100% (17935/17935), 6.18 MiB | 315.00 KiB/s, done.\n    Resolving deltas: 100% (10541/10541), done.\n    Checking connectivity... done.\n    apache-mynewt-core successfully installed version 0.7.9-none\n    $   Now you will have installed packages required to build your project. Note in \nthe package you now have dependent packages stored in the  repos  directory\nunder the specific repository you have included in the base project.        .\n    \u251c\u2500\u2500 apps\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 blinky\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 src\n    \u251c\u2500\u2500 repos\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 apache-mynewt-core\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 apps\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 compiler\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 fs\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 hw\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 libs\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 net\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 scripts\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 sys\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 targets\n    \u2514\u2500\u2500 targets\n        \u251c\u2500\u2500 my_blinky_sim\n        \u2514\u2500\u2500 unittest  Within each of these directories are the packages required to build your\nproject for the various targets.", 
            "title": "Newt Install"
        }, 
        {
            "location": "/os/get_started/project_create/#testing-the-project", 
            "text": "To validate, you can also run all the units test through simulation.      $ newt test all\n    ...lots of compiling and testing...\n    ...about 2 minutes later ...\n    Archiving bootutil.a\n    Linking test_bootutil\n    Executing test: /myproj/bin/unittest/libs/bootutil/test_bootutil\n    Passed tests: [net/nimble/host fs/nffs libs/os hw/hal libs/mbedtls libs/util sys/config libs/bootutil]\n    All tests passed", 
            "title": "Testing the Project"
        }, 
        {
            "location": "/os/get_started/project_create/#building-the-project", 
            "text": "To build the project you can use  newt build  using the target       $ newt build my_blinky_sim\n    App successfully built: /bin/my_blinky_sim/apps/blinky/blinky.elf  You can run the simulated version of your project and see the simulated LED\nblink      ./bin/my_blinky_sim/apps/blinky/blinky.elf\n    hal_gpio set pin  1 to 0  Just do  ctrl-c  to exit.", 
            "title": "Building the Project"
        }, 
        {
            "location": "/os/get_started/project_create/#complete", 
            "text": "Congratulations, you have created your first project.  This project contains \nthe core OS, a simple application to blink an LED and all of the dependencies\nrequired.", 
            "title": "Complete"
        }, 
        {
            "location": "/os/get_started/cross_tools/", 
            "text": "Installing Cross Tools for ARM\n\n\nThis page shows how to install tools to use some ARM based platforms \nwith mynewt.\n\n\nInstall Cross tools for ARM MAC\n\n\nInstall Tool Chain\n\n\nInstall the PX4 Toolchain and check the version installed. ARM maintains a pre-built GNU toolchain with a GCC source branch targeted at Embedded ARM Processors, namely Cortex-R/Cortex-M processor families. After installing, ensure that the symbolic link installed by Homebrew points to the correct version of the debugger. If not, you can either change the symbolic link using the \"ln -f -s\" command or just go ahead and try with the version it points to!\n\n\n        $ brew tap PX4/homebrew-px4\n        $ brew update\n        $ brew install gcc-arm-none-eabi-49\n        $ arm-none-eabi-gcc --version  \n        arm-none-eabi-gcc (GNU Tools for ARM Embedded Processors) 4.9.3 20150529 (release) [ARM/embedded-4_9-branch revision 224288]\n        Copyright (C) 2014 Free Software Foundation, Inc.\n        This is free software; see the source for copying conditions.  There is NO\n        warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n        $ ls -al /usr/local/bin/arm-none-eabi-gdb\n        lrwxr-xr-x  1 aditihilbert  admin  69 Sep 22 17:16 /usr/local/bin/arm-none-eabi-gdb -\n /usr/local/Cellar/gcc-arm-none-eabi-49/20150609/bin/arm-none-eabi-gdb\n\n\n\n\n\nNote: If no version is specified, brew will install the latest version available. Mynewt OS will eventually work with multiple versions available, including the latest releases. However, at present we have tested only with this version and recommend it for getting started. \n\n\nInstall OpenOCD\n\n\nInstall OpenOCD (Open On-Chip Debugger), which is an open-source software that will allow you to interface with the JTAG debug connector/adaptor for the Olimex board, debug, and test embedded target devices, including the Olimex board. For more on OpenOCD go to \nhttp://openocd.org\n.\n\n\n        $ brew install open-ocd\n        $ which openocd\n        /usr/local/bin/openocd\n        $ ls -l $(which openocd)\n        lrwxr-xr-x  1 \nuser\n  admin  36 Sep 17 16:22 /usr/local/bin/openocd -\n ../Cellar/open-ocd/0.9.0/bin/openocd\n\n\n\n\n\nInstall cross arm tools for Linux\n\n\nInstall Tool Chain\n\n\nFor the LED project on the Olimex hardware, you should install gcc for AM 4.9.3.  This package can be installed with apt-get as documented below. The steps are explained in depth at \nhttps://launchpad.net/~terry.guo/+archive/ubuntu/gcc-arm-embedded\n.\n\n\n        $ sudo apt-get remove binutils-arm-none-eabi gcc-arm-none-eabi \n        $ sudo add-apt-repository ppa:terry.guo/gcc-arm-embedded \n        $ sudo apt-get update \n        $ sudo apt-get install gcc-arm-none-eabi\n\n\n\n\n\nInstall OpenOCD\n\n\nAnd finally, install OpenOCD (Open On-Chip Debugger), which is an open-source software that will allow you to interface with the JTAG debug connector/adaptor for the Olimex board, debug your program and test embedded target devices which, including the Olimex board.\n\n\nIf you are running Ubuntu 15.x, then you are in luck and you can simply run: \n\n\n        $ sudo apt-get install openocd \n\n\n\n\n\nFor this project, you should download the openocd 0.8.0 package from \nhttps://launchpad.net/ubuntu/vivid/+source/openocd\n. The direct link to the amd64 build is \nhttp://launchpadlibrarian.net/188260097/openocd_0.8.0-4_amd64.deb\n.", 
            "title": "Installing Cross Tools for ARM"
        }, 
        {
            "location": "/os/get_started/cross_tools/#installing-cross-tools-for-arm", 
            "text": "This page shows how to install tools to use some ARM based platforms \nwith mynewt.", 
            "title": "Installing Cross Tools for ARM"
        }, 
        {
            "location": "/os/get_started/cross_tools/#install-cross-tools-for-arm-mac", 
            "text": "", 
            "title": "Install Cross tools for ARM MAC"
        }, 
        {
            "location": "/os/get_started/cross_tools/#install-tool-chain", 
            "text": "Install the PX4 Toolchain and check the version installed. ARM maintains a pre-built GNU toolchain with a GCC source branch targeted at Embedded ARM Processors, namely Cortex-R/Cortex-M processor families. After installing, ensure that the symbolic link installed by Homebrew points to the correct version of the debugger. If not, you can either change the symbolic link using the \"ln -f -s\" command or just go ahead and try with the version it points to!          $ brew tap PX4/homebrew-px4\n        $ brew update\n        $ brew install gcc-arm-none-eabi-49\n        $ arm-none-eabi-gcc --version  \n        arm-none-eabi-gcc (GNU Tools for ARM Embedded Processors) 4.9.3 20150529 (release) [ARM/embedded-4_9-branch revision 224288]\n        Copyright (C) 2014 Free Software Foundation, Inc.\n        This is free software; see the source for copying conditions.  There is NO\n        warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n        $ ls -al /usr/local/bin/arm-none-eabi-gdb\n        lrwxr-xr-x  1 aditihilbert  admin  69 Sep 22 17:16 /usr/local/bin/arm-none-eabi-gdb -  /usr/local/Cellar/gcc-arm-none-eabi-49/20150609/bin/arm-none-eabi-gdb  Note: If no version is specified, brew will install the latest version available. Mynewt OS will eventually work with multiple versions available, including the latest releases. However, at present we have tested only with this version and recommend it for getting started.", 
            "title": "Install Tool Chain"
        }, 
        {
            "location": "/os/get_started/cross_tools/#install-openocd", 
            "text": "Install OpenOCD (Open On-Chip Debugger), which is an open-source software that will allow you to interface with the JTAG debug connector/adaptor for the Olimex board, debug, and test embedded target devices, including the Olimex board. For more on OpenOCD go to  http://openocd.org .          $ brew install open-ocd\n        $ which openocd\n        /usr/local/bin/openocd\n        $ ls -l $(which openocd)\n        lrwxr-xr-x  1  user   admin  36 Sep 17 16:22 /usr/local/bin/openocd -  ../Cellar/open-ocd/0.9.0/bin/openocd", 
            "title": "Install OpenOCD"
        }, 
        {
            "location": "/os/get_started/cross_tools/#install-cross-arm-tools-for-linux", 
            "text": "", 
            "title": "Install cross arm tools for Linux"
        }, 
        {
            "location": "/os/get_started/cross_tools/#install-tool-chain_1", 
            "text": "For the LED project on the Olimex hardware, you should install gcc for AM 4.9.3.  This package can be installed with apt-get as documented below. The steps are explained in depth at  https://launchpad.net/~terry.guo/+archive/ubuntu/gcc-arm-embedded .          $ sudo apt-get remove binutils-arm-none-eabi gcc-arm-none-eabi \n        $ sudo add-apt-repository ppa:terry.guo/gcc-arm-embedded \n        $ sudo apt-get update \n        $ sudo apt-get install gcc-arm-none-eabi", 
            "title": "Install Tool Chain"
        }, 
        {
            "location": "/os/get_started/cross_tools/#install-openocd_1", 
            "text": "And finally, install OpenOCD (Open On-Chip Debugger), which is an open-source software that will allow you to interface with the JTAG debug connector/adaptor for the Olimex board, debug your program and test embedded target devices which, including the Olimex board.  If you are running Ubuntu 15.x, then you are in luck and you can simply run:           $ sudo apt-get install openocd   For this project, you should download the openocd 0.8.0 package from  https://launchpad.net/ubuntu/vivid/+source/openocd . The direct link to the amd64 build is  http://launchpadlibrarian.net/188260097/openocd_0.8.0-4_amd64.deb .", 
            "title": "Install OpenOCD"
        }, 
        {
            "location": "/os/get_started/vocabulary/", 
            "text": "Concepts\n\n\nThis page is meant to introduce you to some of the concepts inherent to \nthe Apache Mynewt Operating System, and \nNewt\n the tool that stitches a \nproject built on Apache Mynewt together.\n\n\nProject\n\n\nThe project is the base directory of your embedded software tree.  It is a \nworkspace that contains a logical collection of source code, for one or \nmore of your applications.  A project consists of the following items:\n\n\n\n\nProject Definition: defines project level dependencies, and parameters\n    (located in \nproject.yml\n)\n\n\nPackages\n\n\n\n\nPackages\n are described in detail in the section below.  \n\n\nHere is an example project definition file from the default Apache Mynewt \nproject: \n\n\n$ more project.yml \n\nsnip\n\nproject.name: \nmy_project\n\n\nproject.repositories:\n    - apache-mynewt-core\n\n# Use github\ns distribution mechanism for core ASF libraries.\n# This provides mirroring automatically for us.\n#\nrepository.apache-mynewt-core:\n    type: github\n    vers: 0-latest\n    user: apache\n    repo: incubator-mynewt-core\n$ \n\n\n\n\n\nA couple of things to note in the project definition:\n\n\n\n\n\n\nproject.repositories\n: Defines the remote repositories that this project\nrelies upon.\n\n\n\n\n\n\nrepository.apache-mynewt-core\n: Defines the repository information for \nthe \napache-mynewt-core\n repository.\n\n\n\n\n\n\nRepositories are versioned collections of packages.  \n\n\nProjects can rely on remote repositories for functionality, and the newt tool \nwill resolve those remote repositories, and download the correct version into \nyour local source tree.  Newly fetched repositories are put in the \nrepos\n\ndirectory of your project, and can be referenced throughout the system by using\nthe \n@\n specifier.  \n\n\nBy default, the \n@apache-mynewt-core\n repository is included in every \nproject.  Apache Mynewt Core contains all the base functionality of the Apache \nMynewt Operating System, including the Real Time Kernel, Bluetooth Networking \nStack, Flash File System, Console, Shell and Bootloader.\n\n\nNOTE:\n Any project can be converted into a repository by providing it with a \n\nrepository.yml\n file and putting it up onto Github.  More information\nabout repositories can be found in the Newt documentation.\n\n\nPackage\n\n\nA package is a collection items that form a fundamental unit in the Mynewt \nOperating System.  Packages can be:\n\n\n\n\nApplications\n\n\nLibraries\n\n\nCompiler definitions\n\n\nTargets\n\n\n\n\nA package is identified by having a \npkg.yml\n file in it's base \ndirectory.  Here is a sample \npkg.yml\n file for the blinky applicaton:\n\n\n$ more pkg.yml \n\nsnip\n\npkg.name: apps/blinky\npkg.type: app\npkg.description: Basic example application which blinks an LED.\npkg.author: \nApache Mynewt \ndev@mynewt.incubator.apache.org\n\npkg.homepage: \nhttp://mynewt.apache.org/\n\npkg.keywords:\n\npkg.deps:\n    - \n@apache-mynewt-core/libs/os\n\n    - \n@apache-mynewt-core/hw/hal\n\n    - \n@apache-mynewt-core/libs/console/full\n\n\n\n\n\n\nPackages have a few features worth noting:\n\n\n\n\nDependencies: Packages can rely upon other packages, and when they do\n    they will inherit their functionality (header files, library definitions, etc.)\n\n\nAPIs: Packages can export named APIs, and they can require that certain \n    APIs be present, in order to compile.\n\n\nFeatures: Packages can operate differently depending on what named features are \n    present in the system.  Packages can also export features to the rest of the \n    Mynewt system.\n\n\n\n\nEverything that newt knows about within a project's directory is a package.  This \nmakes it very clean and easy to write re-usable components, which can describe their \nDependencies and APIs to the rest of the system.\n\n\nTarget\n\n\nA target in Apache Mynewt is very similar to a target in \nmake\n.  It is the collection\nof parameters that must be passed to Newt in order to generate a reproducable build.  A \ntarget represents the top of the build tree, and any packages or parameters specified at \nthe target level, cascade down to all dependencies.\n\n\nTargets are also packages, and are stored in the \ntargets/\n directory at the base \nof your project.  Most targets consist of: \n\n\n\n\napp\n: The application to build.\n\n\nbsp\n: The board support package to combine with that application\n\n\nbuild_profile\n: Either \ndebug\n or \noptimized\n. \n\n\n\n\nTargets can also have additional items specified, including: \n\n\n\n\ncflags\n: Any additional compiler flags you might want to specify to the build.\n\n\nfeatures\n: Any system level features you want to enable.\n\n\n\n\nIn order to create and manipulate targets, the \nnewt\n tool offers a set of helper commands,\nyou can find more information about these by issuing:\n\n\n$ newt target\n\nUsage: \n  newt target [flags]\n  newt target [command]\n\nAvailable Commands: \n  show        View target configuration variables\n  set         Set target configuration variable\n  create      Create a target\n  delete      Delete target\n  copy        Copy target\n  vars        Show variable names\n\nFlags:\n  -h, --help=false: help for target\n\nGlobal Flags:\n  -l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n  -o, --outfile=\n: Filename to tee log output to\n  -q, --quiet=false: Be quiet; only display error output.\n  -s, --silent=false: Be silent; don\nt output anything.\n  -v, --verbose=false: Enable verbose output when executing commands.\n\nAdditional help topics:\n\n\nUse \nnewt help [command]\n for more information about a command.\n$", 
            "title": "toc"
        }, 
        {
            "location": "/os/get_started/vocabulary/#concepts", 
            "text": "This page is meant to introduce you to some of the concepts inherent to \nthe Apache Mynewt Operating System, and  Newt  the tool that stitches a \nproject built on Apache Mynewt together.", 
            "title": "Concepts"
        }, 
        {
            "location": "/os/get_started/vocabulary/#project", 
            "text": "The project is the base directory of your embedded software tree.  It is a \nworkspace that contains a logical collection of source code, for one or \nmore of your applications.  A project consists of the following items:   Project Definition: defines project level dependencies, and parameters\n    (located in  project.yml )  Packages   Packages  are described in detail in the section below.    Here is an example project definition file from the default Apache Mynewt \nproject:   $ more project.yml  snip \nproject.name:  my_project \n\nproject.repositories:\n    - apache-mynewt-core\n\n# Use github s distribution mechanism for core ASF libraries.\n# This provides mirroring automatically for us.\n#\nrepository.apache-mynewt-core:\n    type: github\n    vers: 0-latest\n    user: apache\n    repo: incubator-mynewt-core\n$   A couple of things to note in the project definition:    project.repositories : Defines the remote repositories that this project\nrelies upon.    repository.apache-mynewt-core : Defines the repository information for \nthe  apache-mynewt-core  repository.    Repositories are versioned collections of packages.    Projects can rely on remote repositories for functionality, and the newt tool \nwill resolve those remote repositories, and download the correct version into \nyour local source tree.  Newly fetched repositories are put in the  repos \ndirectory of your project, and can be referenced throughout the system by using\nthe  @  specifier.    By default, the  @apache-mynewt-core  repository is included in every \nproject.  Apache Mynewt Core contains all the base functionality of the Apache \nMynewt Operating System, including the Real Time Kernel, Bluetooth Networking \nStack, Flash File System, Console, Shell and Bootloader.  NOTE:  Any project can be converted into a repository by providing it with a  repository.yml  file and putting it up onto Github.  More information\nabout repositories can be found in the Newt documentation.", 
            "title": "Project"
        }, 
        {
            "location": "/os/get_started/vocabulary/#package", 
            "text": "A package is a collection items that form a fundamental unit in the Mynewt \nOperating System.  Packages can be:   Applications  Libraries  Compiler definitions  Targets   A package is identified by having a  pkg.yml  file in it's base \ndirectory.  Here is a sample  pkg.yml  file for the blinky applicaton:  $ more pkg.yml  snip \npkg.name: apps/blinky\npkg.type: app\npkg.description: Basic example application which blinks an LED.\npkg.author:  Apache Mynewt  dev@mynewt.incubator.apache.org \npkg.homepage:  http://mynewt.apache.org/ \npkg.keywords:\n\npkg.deps:\n    -  @apache-mynewt-core/libs/os \n    -  @apache-mynewt-core/hw/hal \n    -  @apache-mynewt-core/libs/console/full   Packages have a few features worth noting:   Dependencies: Packages can rely upon other packages, and when they do\n    they will inherit their functionality (header files, library definitions, etc.)  APIs: Packages can export named APIs, and they can require that certain \n    APIs be present, in order to compile.  Features: Packages can operate differently depending on what named features are \n    present in the system.  Packages can also export features to the rest of the \n    Mynewt system.   Everything that newt knows about within a project's directory is a package.  This \nmakes it very clean and easy to write re-usable components, which can describe their \nDependencies and APIs to the rest of the system.", 
            "title": "Package"
        }, 
        {
            "location": "/os/get_started/vocabulary/#target", 
            "text": "A target in Apache Mynewt is very similar to a target in  make .  It is the collection\nof parameters that must be passed to Newt in order to generate a reproducable build.  A \ntarget represents the top of the build tree, and any packages or parameters specified at \nthe target level, cascade down to all dependencies.  Targets are also packages, and are stored in the  targets/  directory at the base \nof your project.  Most targets consist of:    app : The application to build.  bsp : The board support package to combine with that application  build_profile : Either  debug  or  optimized .    Targets can also have additional items specified, including:    cflags : Any additional compiler flags you might want to specify to the build.  features : Any system level features you want to enable.   In order to create and manipulate targets, the  newt  tool offers a set of helper commands,\nyou can find more information about these by issuing:  $ newt target\n\nUsage: \n  newt target [flags]\n  newt target [command]\n\nAvailable Commands: \n  show        View target configuration variables\n  set         Set target configuration variable\n  create      Create a target\n  delete      Delete target\n  copy        Copy target\n  vars        Show variable names\n\nFlags:\n  -h, --help=false: help for target\n\nGlobal Flags:\n  -l, --loglevel= WARN : Log level, defaults to WARN.\n  -o, --outfile= : Filename to tee log output to\n  -q, --quiet=false: Be quiet; only display error output.\n  -s, --silent=false: Be silent; don t output anything.\n  -v, --verbose=false: Enable verbose output when executing commands.\n\nAdditional help topics:\n\n\nUse  newt help [command]  for more information about a command.\n$", 
            "title": "Target"
        }, 
        {
            "location": "/os/tutorials/olimex/", 
            "text": "Blinky, Your Hello World!\n\n\nObjective\n\n\nLearn how to use packages from a default application repository of Mynewt to build your first \nHello World\n application (Blinky) on a target board. Once built using the \nnewt\n tool, this application will blink the LED lights on the target board. Fun stuff!\n\n\nThis tutorial will guide you to achieve the following, assuming you have already set up the environment on your computer to use Mynewt OS and newt tool:\n\n\n\n\nDownload packages and use tools to create a runtime image for a board to make its LED blink. You have two choices here:\n\n\nDownload an image to SRAM\n, or \n\n\nDownload it to flash\n.\n\n\n\n\n\n\n\n\n\n\n Time Requirement\n: Allow yourself a couple of hours for this project if you are relatively new to embedded systems and playing with development boards. Those jumpers can be pesky!\n\n\n\n\nWhat you need\n\n\n\n\nSTM32-E407 development board from Olimex. You can order it from \nhttp://www.mouser.com\n, \nhttp://www.digikey.com\n, and other places.\n\n\nARM-USB-TINY-H connector with JTAG interface for debugging ARM microcontrollers (comes with the ribbon cable to hook up to the board)\n\n\nUSB A-B type cable to connect the debugger to your personal computer\n\n\nPersonal Computer with Mac OS (Mac: OS X Yosemite Version 10.10.5) or Linux box (Ubuntu 14.10: Utopic Unicorn)\n\n\nAn account on Github repository and \ngit\n installed on your computer.\n\n\nIt is assumed you have already installed newt tool. \n\n\nIt is assumed you already installed native tools as described \nhere\n\n\n\n\nAlso, we assume that you're familiar with UNIX shells. Let's gets started!\n\n\n\n\nUse SRAM to make LED blink\n\n\nIf you wish to build the image to run from the onboard SRAM on Olimex board, follow the steps below:\n\n\n\n\nPrepare the Software\n\n\n\n\nMake sure the PATH environment variable includes the $HOME/dev/go/bin directory. \n\n\n\n\n\n\nCreate a project.\n\n\nCreate a new project to hold your work.  For a deeper understanding, you can read about project creation in \n\nGet Started -- Creating Your First Project\n\nor just follow the commands below.\n\n\n    $ mkdir ~/dev\n    $ cd ~/dev\n    $ newt new myproj\n    Downloading project skeleton from apache/incubator-mynewt-blinky...\n    Installing skeleton in myproj...\n    Project myproj successfully created.\n\n    $cd myproj\n\n    $ newt install -v \n    apache-mynewt-core\n    Downloading repository description for apache-mynewt-core... success!\n    ...\n    apache-mynewt-core successfully installed version 0.7.9-none\n\n\n\n\n\n\n\nCreate a target\n\n\nChange directory to ~/dev/core directory and define the \nblinky\n target inside core, using the \nnewt\n tool. Starting with the target name, assign specific aspects of the project, as shown below, to pull the appropriate packages and build the right bundle or list for the board. For example, we set the build_profile, board support package (bsp), and app.\n\n\n    $ newt target create blinky\n    Target targets/blinky successfully created\n    $ newt target set blinky build_profile=debug\n    Target targets/blinky successfully set target.compiler_def to debug\n    $ newt target set blinky bsp=@apache-mynewt-core/hw/bsp/olimex_stm32-e407_devboard\n    Target targets/blinky successfully set target.bsp to ...\n    $ newt target set blinky app=@apache-mynewt-core/apps/blinky\n    Target targets/blinky successfully set target.app to apps/blinky\n    $ newt target show blinky\n    targets/boot_olimex\n        app=apps/blinky\n        bsp=hw/bsp/olimex_stm32-e407_devboard\n        build_profile=debug\n\n\n\n\n\n\n\nBuild the image\n\n\nNext, let's build the image with the above values assigned. By default, the linker script within the \nhw/bsp/olimex_stm32-e407_devboard\n package builds an image for flash memory, which we don't want; instead, we want an image for the SRAM, so you need to switch that script with \nrun_from_sram.ld\n. \n\n\n\n(We are working to simplify this scheme whereby an executable for a project will correctly elect the linker scripts and generate the relevant image. For example, the scheme will key on project identity such as bootloader, RAM, Flash (default) and build accordingly.) \n.\n\n\nAfer you build the target, you can find the executable \nblinky.elf\n in the project directory \n~/dev/core/bin/blinky/apps/blinky/.\n \n\n\n    $ cd ~/dev/core/hw/bsp/olimex_stm32-e407_devboard\n    $ diff olimex_stm32-e407_devboard.ld run_from_sram.ld\n    (some diff will be displayed)\n    $ cp run_from_sram.ld olimex_stm32-e407_devboard.ld\n    $ cd ~/dev/core\n    $ newt build blinky\n    Compiling case.c\n    Compiling suite.c\n    ...\n    Linking blinky.elf\n    App successfully built:~/dev/core/bin/blinky/apps/blinky/blinky.elf    \n    $ ls bin/blinky/apps/blinky/\n        blinky.elf      blinky.elf.bin     blinky.elf.cmd  \n        blinky.elf.lst  blinky.elf.map\n\n\n\n\n\n\n\nPrepare the hardware to boot from embedded SRAM\n\n\n\n\nLocate the boot jumpers on the board.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nB1_1/B1_0 and B0_1/B0_0 are PTH jumpers. Note that because the markings on the board may not always be accurate, when in doubt, you should always refer to the manual for the correct positioning. Since the jumpers are a pair, they should move together, and as such, the pair is responsible for the boot mode when bootloader is present. \nTo locate the bootloader, the board searches in three places: User Flash Memory, System Memory or the Embedded SRAM. For this Blinky project, we will configure it to boot from SRAM by jumpering \nB0_1\n and \nB1_1\n.\n\n\n\n\n\n\nConnect USB-OTG#2 in the picture above to a USB port on your computer (or a powered USB hub to make sure there is enough power available to the board). \n\n\n\n\n\n\nThe red PWR LED should be lit. \n\n\n\n\n\n\nConnect the JTAG connector to the SWD/JTAG interface on the board. The other end of the cable should be connected to the USB port or hub of your computer.\n\n\n\n\n\n\n\n\nLet's Go!\n\n\n\n\nEnsure that you are in the blinky project directory with the \nblinky.elf\n executable. Run the debug command in the \nnewt\n tool. You'll see some status messages as shown below. In case you need to halt the debugging session, you can issue an \n-c \"reset halt\"\n command.\n\n\n\n\n    $ cd ~/dev/core\n    $ newt debug blinky\n    Debugging with ~/dev/core/hw/bsp/olimex_...\n    Debugging ~/dev/core/project/blinky/bin/blinky/blinky.elf\n    GNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\n    Copyright (C) 2014 Free Software Foundation, Inc.\n    License GPLv3+: GNU GPL version 3 \nhttp://gnu.org/licenses/gpl.html\n\n    ...\n    (info)\n    ...\n    target state: halted\n    target halted due to debug-request, current mode: Thread \n    xPSR: 0x01000000 pc: 0x080003c0 msp: 0x10010000\n    Info : accepting \ngdb\n connection on tcp/3333\n    Info : device id = 0x10036413\n    Info : flash size = 1024kbytes\n\n\n\n\n\n\n\nCheck the value of the msp (main service pointer) register. If it is not 0x10010000 as indicated above, you will have to manually set it after you open the gdb tool and load the image on it. For example, \n\n\n        (gdb) set $msp=0x10010000\n\n\n\n\n\n\n\nNow load the image and type \"c\" or \"continue\" from the GNU debugger. \n\n\n        (gdb) load ~/dev/core/bin/blinky/apps/blinky/blinky.elf      \n        Loading section .text, size 0x16b88 lma 0x20000000\n        Loading section .ARM.exidx, size 0x18 lma 0x20016b88\n        Loading section .data, size 0x9ec lma 0x20016ba0\n        Start address 0x200004b8, load size 95628\n        Transfer rate: 74 KB/sec, 3825 bytes/write.\n        (gdb) c\n        Continuing.\n\n\n\n\n\n\n\nVoil\u00e0! The board's LED should be blinking at 1 Hz. Success!\n\n\n\n\n\n\nUse flash to make LED blink\n\n\nIf you wish to build the image to run from the onboard flash memory on Olimex board, follow the steps below:\n\n\n\n\n\n\nConfigure the board to boot from flash by moving the two jumpers together to \nB0_0\n and \nB1_0\n. Refer to the pictures of the board under the section titled \n\"Prepare the hardware to boot from embedded SRAM\"\n.\n\n\nYou will have to reset the board once the image is uploaded to it.\n\n\n\n\n\n\nIf you skipped the first option for the project \n(downloading an image to SRAM)\n, then skip this step. Otherwise, continue with this step. \n\n\n\n\n\n\nBy default, the linker script (\nolimex_stm32-e407_devboard.ld\n) is configured to run from bootloader and flash. However, if you first ran the image from SRAM you had changed \nolimex_stm32-e407_devboard.ld\n to match \nrun_from_sram.ld\n. You will, therefore, return to defaults with \nolimex_stm32-e407_devboard.ld\n linker script matching the contents of 'run_from_loader.ld'. Return to the project directory.\n\n\n    $ cd ~/dev/core/hw/bsp/olimex_stm32-e407_devboard\n    $ diff olimex_stm32-e407_devboard.ld run_from_sram.ld\n    $ diff olimex_stm32-e407_devboard.ld run_from_loader.ld\n    (some diff will be displayed)\n    $ cp run_from_loader.ld olimex_stm32-e407_devboard.ld\n    $ cd ~/dev/core\n\n\n\n\n\n\n\n\n\nIn order to run the image from flash, you need to build the bootloader as well. The bootloader does the initial set up of the Olimex board and then transfers control to the image stored at a location in flash known to it. \n\n\n\n\nLet\ns create boot_olimex:\n\n```no-highlight\n    $ newt target create boot_olimex\n    Creating target boot_olimex\n    Target boot_olimex successfully created!\n    $ newt target set boot_olimex build_profile=optimized\n    Target boot_olimex successfully set compiler_def to optimized\n    $ newt target set boot_olimex @apache-mynewt-core/hw/bsp/olimex_stm32-e407_devboard\n    Target boot_olimex successfully set bsp to ...\n    $ newt target set boot_olimex app=@apache-mynewt-core/apps/boot\n    Target targets/boot_olimex successfully set target.app to apps/boot\n    $ newt target show boot_olimex\n    targets/boot_olimex\n        app=app=@apache-mynewt-core/apps/boot\n        bsp=@apache-mynewt-core/hw/bsp/olimex_stm32-e407_devboar\n        build_profile=optimized\n\n\n\n\n\n\n\n\n\nNow let's build both targets now.\n\n\n\n\n    $ newt build boot_olimex\n    ...\n    App successfully built: ~/dev/core/bin/boot_olimex/apps/boot/boot_olimex.elf\n    $ newt build blinky\n    ...\n    Linking blinky.elf\n    App successfully built: ~/dev/core/bin/blinky/apps/blinky/blinky.elf\n\n\n\n\n\n\n\n\n\nCreate the blinky image and download the bootloader and the image to flash ... in a flash! \nWhen creating an image, you can assign a version number to your image; here we use '1.2.3'\n\n\n\n\n    $ newt create-image blinky 1.2.3\n    App image successfully generated: ~/dev/core/bin/blinky/apps/blinky/blinky.img\n    Build manifest: ~/dev/core/bin/blinky/apps/blinky/manifest.json\n    $ newt load boot_olimex\n    Downloading ~/dev/core/bin/boot_olimex/apps/boot/boot.elf.bin to 0x08000000\n    Open On-Chip Debugger 0.9.0 (2015-11-15-13:10)\n    ...\n    shutdown command invoked\n    $ newt load blinky\n    Downloading ~/dev/core/bin/blinky/apps/blinky/blinky.img to 0x08020000\n    Open On-Chip Debugger 0.9.0 (2015-11-15-13:10)\n    ...\n    shutdown command invoked\n\n\n\n\n\n\n\n\n\nVoil\u00e0! The LED should be blinking! Success!\n\n\n\n\n\n\nBut wait...not so fast.\n Let's double check that it is indeed booting from flash and making the LED blink from the image in flash. Pull the USB cable off the Olimex JTAG adaptor, severing the debug connection to the JTAG port. Next power off the Olimex board by pulling out the USB cable from the board. Wait for a couple of seconds and plug the USB cable back to the board. \n\n\nThe LED light will start blinking again. Success!\n\n\nNote #1:\n If you want to download the image to flash and a gdb session opened up, use \nnewt debug blinky\n after \nnewt download blinky\n.\n\n\n    $ newt debug blinky\n    Debugging with ~/dev/core/hw/bsp/olimex_stm32-e407_...\n    Debugging ~/dev/core/project/blinky/bin/blinky/blinky.elf\n    GNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\n    Copyright (C) 2014 Free Software Foundation, Inc.\n    License GPLv3+: GNU GPL version 3 \nhttp://gnu.org/licenses/gpl.html\n\n    ...\n    (info)\n    ...\n    target state: halted\n    target halted due to debug-request, current mode: Thread \n    xPSR: 0x01000000 pc: 0x08000250 msp: 0x10010000\n    Info : accepting \ngdb\n connection from 3333\n    Info : device id = 0x10036413\n    Info : flash size = 1024kbytes\n    Reset_Handler () at startup_STM32F40x.s:199\n    199     ldr    r1, =__etext\n    (gdb)\n\n\n\n\n\n\n\nNote #2:\n If you want to erase the flash and load the image again you may use the following commands from within gdb. \nflash erase_sector 0 0 x\n tells it to erase sectors 0 through x. When you ask it to display (in hex notation) the contents of the sector starting at location 'lma,' you should see all f's. The memory location 0x8000000 is the start or origin of the flash memory contents and is specified in the olimex_stm32-e407_devboard.ld linker script. The flash memory locations is specific to the processor.\n\n\n    (gdb) monitor flash erase_sector 0 0 4\n    erased sectors 0 through 4 on flash bank 0 in 2.296712s\n    (gdb) monitor mdw 0x08000000 16\n    0x08000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \n    (0x08000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \n    (0x08000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \n    (0x08000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff         \n    (gdb) monitor flash info 0\n\n\n\n\n\nConclusion\n\n\nCongratulations! You have now tried out a project on actual hardware. If this is your first time to embedded systems, this must feel like the best hands-on and low-level \"Hello World\" program ever. \n\n\nGood, we have more fun tutorials for you to get your hands dirty. Be bold and try other Blinky-like \ntutorials\n.\n\n\nIf you see anything missing or want to send us feedback, please do so by signing up for appropriate mailing lists on our \nCommunity Page\n\n\nKeep on hacking and blinking!", 
            "title": "Blinky on Olimex"
        }, 
        {
            "location": "/os/tutorials/olimex/#blinky-your-hello-world", 
            "text": "", 
            "title": "Blinky, Your Hello World!"
        }, 
        {
            "location": "/os/tutorials/olimex/#objective", 
            "text": "Learn how to use packages from a default application repository of Mynewt to build your first  Hello World  application (Blinky) on a target board. Once built using the  newt  tool, this application will blink the LED lights on the target board. Fun stuff!  This tutorial will guide you to achieve the following, assuming you have already set up the environment on your computer to use Mynewt OS and newt tool:   Download packages and use tools to create a runtime image for a board to make its LED blink. You have two choices here:  Download an image to SRAM , or   Download it to flash .       Time Requirement : Allow yourself a couple of hours for this project if you are relatively new to embedded systems and playing with development boards. Those jumpers can be pesky!", 
            "title": "Objective"
        }, 
        {
            "location": "/os/tutorials/olimex/#what-you-need", 
            "text": "STM32-E407 development board from Olimex. You can order it from  http://www.mouser.com ,  http://www.digikey.com , and other places.  ARM-USB-TINY-H connector with JTAG interface for debugging ARM microcontrollers (comes with the ribbon cable to hook up to the board)  USB A-B type cable to connect the debugger to your personal computer  Personal Computer with Mac OS (Mac: OS X Yosemite Version 10.10.5) or Linux box (Ubuntu 14.10: Utopic Unicorn)  An account on Github repository and  git  installed on your computer.  It is assumed you have already installed newt tool.   It is assumed you already installed native tools as described  here   Also, we assume that you're familiar with UNIX shells. Let's gets started!", 
            "title": "What you need"
        }, 
        {
            "location": "/os/tutorials/olimex/#use-sram-to-make-led-blink", 
            "text": "If you wish to build the image to run from the onboard SRAM on Olimex board, follow the steps below:", 
            "title": "Use SRAM to make LED blink"
        }, 
        {
            "location": "/os/tutorials/olimex/#prepare-the-software", 
            "text": "Make sure the PATH environment variable includes the $HOME/dev/go/bin directory.", 
            "title": "Prepare the Software"
        }, 
        {
            "location": "/os/tutorials/olimex/#create-a-project", 
            "text": "Create a new project to hold your work.  For a deeper understanding, you can read about project creation in  Get Started -- Creating Your First Project \nor just follow the commands below.      $ mkdir ~/dev\n    $ cd ~/dev\n    $ newt new myproj\n    Downloading project skeleton from apache/incubator-mynewt-blinky...\n    Installing skeleton in myproj...\n    Project myproj successfully created.\n\n    $cd myproj\n\n    $ newt install -v \n    apache-mynewt-core\n    Downloading repository description for apache-mynewt-core... success!\n    ...\n    apache-mynewt-core successfully installed version 0.7.9-none", 
            "title": "Create a project."
        }, 
        {
            "location": "/os/tutorials/olimex/#create-a-target", 
            "text": "Change directory to ~/dev/core directory and define the  blinky  target inside core, using the  newt  tool. Starting with the target name, assign specific aspects of the project, as shown below, to pull the appropriate packages and build the right bundle or list for the board. For example, we set the build_profile, board support package (bsp), and app.      $ newt target create blinky\n    Target targets/blinky successfully created\n    $ newt target set blinky build_profile=debug\n    Target targets/blinky successfully set target.compiler_def to debug\n    $ newt target set blinky bsp=@apache-mynewt-core/hw/bsp/olimex_stm32-e407_devboard\n    Target targets/blinky successfully set target.bsp to ...\n    $ newt target set blinky app=@apache-mynewt-core/apps/blinky\n    Target targets/blinky successfully set target.app to apps/blinky\n    $ newt target show blinky\n    targets/boot_olimex\n        app=apps/blinky\n        bsp=hw/bsp/olimex_stm32-e407_devboard\n        build_profile=debug", 
            "title": "Create a target"
        }, 
        {
            "location": "/os/tutorials/olimex/#build-the-image", 
            "text": "Next, let's build the image with the above values assigned. By default, the linker script within the  hw/bsp/olimex_stm32-e407_devboard  package builds an image for flash memory, which we don't want; instead, we want an image for the SRAM, so you need to switch that script with  run_from_sram.ld .   \n(We are working to simplify this scheme whereby an executable for a project will correctly elect the linker scripts and generate the relevant image. For example, the scheme will key on project identity such as bootloader, RAM, Flash (default) and build accordingly.)  .  Afer you build the target, you can find the executable  blinky.elf  in the project directory  ~/dev/core/bin/blinky/apps/blinky/.        $ cd ~/dev/core/hw/bsp/olimex_stm32-e407_devboard\n    $ diff olimex_stm32-e407_devboard.ld run_from_sram.ld\n    (some diff will be displayed)\n    $ cp run_from_sram.ld olimex_stm32-e407_devboard.ld\n    $ cd ~/dev/core\n    $ newt build blinky\n    Compiling case.c\n    Compiling suite.c\n    ...\n    Linking blinky.elf\n    App successfully built:~/dev/core/bin/blinky/apps/blinky/blinky.elf    \n    $ ls bin/blinky/apps/blinky/\n        blinky.elf      blinky.elf.bin     blinky.elf.cmd  \n        blinky.elf.lst  blinky.elf.map", 
            "title": "Build the image"
        }, 
        {
            "location": "/os/tutorials/olimex/#prepare-the-hardware-to-boot-from-embedded-sram", 
            "text": "Locate the boot jumpers on the board.         B1_1/B1_0 and B0_1/B0_0 are PTH jumpers. Note that because the markings on the board may not always be accurate, when in doubt, you should always refer to the manual for the correct positioning. Since the jumpers are a pair, they should move together, and as such, the pair is responsible for the boot mode when bootloader is present. \nTo locate the bootloader, the board searches in three places: User Flash Memory, System Memory or the Embedded SRAM. For this Blinky project, we will configure it to boot from SRAM by jumpering  B0_1  and  B1_1 .    Connect USB-OTG#2 in the picture above to a USB port on your computer (or a powered USB hub to make sure there is enough power available to the board).     The red PWR LED should be lit.     Connect the JTAG connector to the SWD/JTAG interface on the board. The other end of the cable should be connected to the USB port or hub of your computer.", 
            "title": "Prepare the hardware to boot from embedded SRAM"
        }, 
        {
            "location": "/os/tutorials/olimex/#lets-go", 
            "text": "Ensure that you are in the blinky project directory with the  blinky.elf  executable. Run the debug command in the  newt  tool. You'll see some status messages as shown below. In case you need to halt the debugging session, you can issue an  -c \"reset halt\"  command.       $ cd ~/dev/core\n    $ newt debug blinky\n    Debugging with ~/dev/core/hw/bsp/olimex_...\n    Debugging ~/dev/core/project/blinky/bin/blinky/blinky.elf\n    GNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\n    Copyright (C) 2014 Free Software Foundation, Inc.\n    License GPLv3+: GNU GPL version 3  http://gnu.org/licenses/gpl.html \n    ...\n    (info)\n    ...\n    target state: halted\n    target halted due to debug-request, current mode: Thread \n    xPSR: 0x01000000 pc: 0x080003c0 msp: 0x10010000\n    Info : accepting  gdb  connection on tcp/3333\n    Info : device id = 0x10036413\n    Info : flash size = 1024kbytes   Check the value of the msp (main service pointer) register. If it is not 0x10010000 as indicated above, you will have to manually set it after you open the gdb tool and load the image on it. For example,           (gdb) set $msp=0x10010000   Now load the image and type \"c\" or \"continue\" from the GNU debugger.           (gdb) load ~/dev/core/bin/blinky/apps/blinky/blinky.elf      \n        Loading section .text, size 0x16b88 lma 0x20000000\n        Loading section .ARM.exidx, size 0x18 lma 0x20016b88\n        Loading section .data, size 0x9ec lma 0x20016ba0\n        Start address 0x200004b8, load size 95628\n        Transfer rate: 74 KB/sec, 3825 bytes/write.\n        (gdb) c\n        Continuing.   Voil\u00e0! The board's LED should be blinking at 1 Hz. Success!", 
            "title": "Let's Go!"
        }, 
        {
            "location": "/os/tutorials/olimex/#use-flash-to-make-led-blink", 
            "text": "If you wish to build the image to run from the onboard flash memory on Olimex board, follow the steps below:    Configure the board to boot from flash by moving the two jumpers together to  B0_0  and  B1_0 . Refer to the pictures of the board under the section titled  \"Prepare the hardware to boot from embedded SRAM\" .  You will have to reset the board once the image is uploaded to it.    If you skipped the first option for the project  (downloading an image to SRAM) , then skip this step. Otherwise, continue with this step.     By default, the linker script ( olimex_stm32-e407_devboard.ld ) is configured to run from bootloader and flash. However, if you first ran the image from SRAM you had changed  olimex_stm32-e407_devboard.ld  to match  run_from_sram.ld . You will, therefore, return to defaults with  olimex_stm32-e407_devboard.ld  linker script matching the contents of 'run_from_loader.ld'. Return to the project directory.      $ cd ~/dev/core/hw/bsp/olimex_stm32-e407_devboard\n    $ diff olimex_stm32-e407_devboard.ld run_from_sram.ld\n    $ diff olimex_stm32-e407_devboard.ld run_from_loader.ld\n    (some diff will be displayed)\n    $ cp run_from_loader.ld olimex_stm32-e407_devboard.ld\n    $ cd ~/dev/core    In order to run the image from flash, you need to build the bootloader as well. The bootloader does the initial set up of the Olimex board and then transfers control to the image stored at a location in flash known to it.    Let s create boot_olimex:\n\n```no-highlight\n    $ newt target create boot_olimex\n    Creating target boot_olimex\n    Target boot_olimex successfully created!\n    $ newt target set boot_olimex build_profile=optimized\n    Target boot_olimex successfully set compiler_def to optimized\n    $ newt target set boot_olimex @apache-mynewt-core/hw/bsp/olimex_stm32-e407_devboard\n    Target boot_olimex successfully set bsp to ...\n    $ newt target set boot_olimex app=@apache-mynewt-core/apps/boot\n    Target targets/boot_olimex successfully set target.app to apps/boot\n    $ newt target show boot_olimex\n    targets/boot_olimex\n        app=app=@apache-mynewt-core/apps/boot\n        bsp=@apache-mynewt-core/hw/bsp/olimex_stm32-e407_devboar\n        build_profile=optimized    Now let's build both targets now.       $ newt build boot_olimex\n    ...\n    App successfully built: ~/dev/core/bin/boot_olimex/apps/boot/boot_olimex.elf\n    $ newt build blinky\n    ...\n    Linking blinky.elf\n    App successfully built: ~/dev/core/bin/blinky/apps/blinky/blinky.elf    Create the blinky image and download the bootloader and the image to flash ... in a flash! \nWhen creating an image, you can assign a version number to your image; here we use '1.2.3'       $ newt create-image blinky 1.2.3\n    App image successfully generated: ~/dev/core/bin/blinky/apps/blinky/blinky.img\n    Build manifest: ~/dev/core/bin/blinky/apps/blinky/manifest.json\n    $ newt load boot_olimex\n    Downloading ~/dev/core/bin/boot_olimex/apps/boot/boot.elf.bin to 0x08000000\n    Open On-Chip Debugger 0.9.0 (2015-11-15-13:10)\n    ...\n    shutdown command invoked\n    $ newt load blinky\n    Downloading ~/dev/core/bin/blinky/apps/blinky/blinky.img to 0x08020000\n    Open On-Chip Debugger 0.9.0 (2015-11-15-13:10)\n    ...\n    shutdown command invoked    Voil\u00e0! The LED should be blinking! Success!    But wait...not so fast.  Let's double check that it is indeed booting from flash and making the LED blink from the image in flash. Pull the USB cable off the Olimex JTAG adaptor, severing the debug connection to the JTAG port. Next power off the Olimex board by pulling out the USB cable from the board. Wait for a couple of seconds and plug the USB cable back to the board.   The LED light will start blinking again. Success!  Note #1:  If you want to download the image to flash and a gdb session opened up, use  newt debug blinky  after  newt download blinky .      $ newt debug blinky\n    Debugging with ~/dev/core/hw/bsp/olimex_stm32-e407_...\n    Debugging ~/dev/core/project/blinky/bin/blinky/blinky.elf\n    GNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\n    Copyright (C) 2014 Free Software Foundation, Inc.\n    License GPLv3+: GNU GPL version 3  http://gnu.org/licenses/gpl.html \n    ...\n    (info)\n    ...\n    target state: halted\n    target halted due to debug-request, current mode: Thread \n    xPSR: 0x01000000 pc: 0x08000250 msp: 0x10010000\n    Info : accepting  gdb  connection from 3333\n    Info : device id = 0x10036413\n    Info : flash size = 1024kbytes\n    Reset_Handler () at startup_STM32F40x.s:199\n    199     ldr    r1, =__etext\n    (gdb)   Note #2:  If you want to erase the flash and load the image again you may use the following commands from within gdb.  flash erase_sector 0 0 x  tells it to erase sectors 0 through x. When you ask it to display (in hex notation) the contents of the sector starting at location 'lma,' you should see all f's. The memory location 0x8000000 is the start or origin of the flash memory contents and is specified in the olimex_stm32-e407_devboard.ld linker script. The flash memory locations is specific to the processor.      (gdb) monitor flash erase_sector 0 0 4\n    erased sectors 0 through 4 on flash bank 0 in 2.296712s\n    (gdb) monitor mdw 0x08000000 16\n    0x08000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \n    (0x08000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \n    (0x08000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \n    (0x08000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff         \n    (gdb) monitor flash info 0", 
            "title": "Use flash to make LED blink"
        }, 
        {
            "location": "/os/tutorials/olimex/#conclusion", 
            "text": "Congratulations! You have now tried out a project on actual hardware. If this is your first time to embedded systems, this must feel like the best hands-on and low-level \"Hello World\" program ever.   Good, we have more fun tutorials for you to get your hands dirty. Be bold and try other Blinky-like  tutorials .  If you see anything missing or want to send us feedback, please do so by signing up for appropriate mailing lists on our  Community Page  Keep on hacking and blinking!", 
            "title": "Conclusion"
        }, 
        {
            "location": "/os/tutorials/STM32F303/", 
            "text": "Blinky on STM32F303 board\n\n\nObjective\n\n\nDownload a generic firmware skeleton (\"bootstrap image\") that applies to any hardware and then throw in additional applicable pkgs to generate a build for a specific board, namely the STM32F303VC MCU from STMicroelectronics.\n\n\nHardware needed\n\n\n\n\nDiscovery kit with STM32F303VC MCU\n\n\nLaptop running Mac OS\n\n\n\n\nStep by Step Instructions to build image\n\n\n\n\nThe first step is to download the generic skeleton of the project. The pkgs constituting the skeleton are not hardware architecture specific. The skeleton is maintained as an app in a separate repository on Apache. You know it is an app because there is an app.yml file. \n\n\n\n\n        [\nuser\n:\n~/dev\n]\n$\n \nnewt\n \napp\n \ncreate\n \ntest_project\n\n        \nDownloading\n \napp\n \nskeleton\n \nfrom\n \nhttps\n:\n//git-wip-us.apache.org/repos/asf/incubator-mynewt-tadpole.git... ok!\n\n        \napp\n \ntest_project\n \nsuccessfully\n \ncreated\n \nin\n \n~/dev/go/test_project\n\n\n        [\nuser\n:\n~/dev\n]\n$\n \ncd\n \ntest_project/\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nls\n\n        \nREADME\n.\nmd\n   \ncompiler\n    \nhw\n      \nlibs\n    \napp\n.\nyml\n\n\n\n\n\n\n\n\nNext, the pkg-list named larva is added from the app (also named larva) from another repository on Apache. This step simply downloads the pkg-list description file and does not actually install the pkgs that constitute the pkg-list. The pkg-list description file (\npkg-list.yml\n) will be used to check dependencies during the pkg install to ensure completeness. It serves as a reference for all the pkgs in the pkg-list that one can choose from and install.\n\n\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \napp\n \nadd-pkg-list\n \nlarva\n \nhttps\n:\n//git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git\n\n        \nDownloading\n \npkg-list\n.\nyml\n \nfrom\n \nhttps\n:\n//git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git/master... ok!\n\n        \nVerifying\n \npkg-list\n.\nyml\n \nformat\n...\n        \nok!\n\n        \npkg-list\n \nlarva\n \nsuccessfully\n \ninstalled\n \nto\n \napp\n.\n\n\n\n\n\n\n\nThe next step is to install relevant pkgs from the larva app from git server on Apache. The instructions assume that you know what application or project you are interested in (the blinky application, in this case), what hardware you are using (STM32F3DISCOVERY board, in this case) and hence, what board support package you need. \n\n\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \npkg\n \ninstall\n \nproject/blinky\n          \n        \nDownloading\n \nlarva\n \nfrom\n \nhttps\n:\n//git-wip-us.apache.org/repos/asf/incubator-mynewt-larva/master... ok!\n\n        \nInstalling\n \nproject/blinky\n\n        \nInstalling\n \nlibs/console/full\n\n        \nInstalling\n \nlibs/shell\n\n        \nInstallation\n \nwas\n \na\n \nsuccess!\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \npkg\n \ninstall\n \nhw/bsp/stm32f3discovery\n\n        \nDownloading\n \nlarva\n \nfrom\n \nhttps\n:\n//git-wip-us.apache.org/repos/asf/incubator-mynewt-larva/master... ok!\n\n        \nInstalling\n \nhw/bsp/stm32f3discovery\n\n        \nInstalling\n \nhw/mcu/stm/stm32f3xx\n\n        \nInstalling\n \nlibs/cmsis-core\n\n        \nInstalling\n \ncompiler/arm-none-eabi-m4\n\n        \nInstallation\n \nwas\n \na\n \nsuccess!\n\n\n\n\n\n\n\n\nIt's time to create a targets for the project and define the target attributes. STM32F3 BSP expects bootloader, so create targets for both blinky and bootloader.\n\n\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \ncreate\n \nblink_f3disc\n\n        \nCreating\n \ntarget\n \nblink_f3disc\n\n        \nTarget\n \nblink_f3disc\n \nsuccessfully\n \ncreated!\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \nset\n \nblink_f3disc\n \nproject=blinky\n\n        \nTarget\n \nblink_f3disc\n \nsuccessfully\n \nset\n \nproject\n \nto\n \nblinky\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \nset\n \nblink_f3disc\n \nbsp=hw/bsp/stm32f3discovery\n\n        \nTarget\n \nblink_f3disc\n \nsuccessfully\n \nset\n \nbsp\n \nto\n \nhw/bsp/stm32f3discovery\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \nset\n \nblink_f3disc\n \ncompiler_def=debug\n\n        \nTarget\n \nblink_f3disc\n \nsuccessfully\n \nset\n \ncompiler_def\n \nto\n \ndebug\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \nset\n \nblink_f3disc\n \ncompiler=arm-none-eabi-m4\n\n        \nTarget\n \nblink_f3disc\n \nsuccessfully\n \nset\n \ncompiler\n \nto\n \narm-none-eabi-m4\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \nset\n \nblink_f3disc\n \narch=cortex_m4\n\n        \nTarget\n \nblink_f3disc\n \nsuccessfully\n \nset\n \narch\n \nto\n \ncortex_m4\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \ncreate\n \nboot_f3disc\n\n        \nCreating\n \ntarget\n \nboot_f3disc\n\n        \nTarget\n \nboot_f3disc\n \nsuccessfully\n \ncreated!\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \nset\n \nboot_f3disc\n \nproject=boot\n\n        \nTarget\n \nblink_f3disc\n \nsuccessfully\n \nset\n \nproject\n \nto\n \nblinky\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \nset\n \nboot_f3disc\n \nbsp=hw/bsp/stm32f3discovery\n\n        \nTarget\n \nboot_f3disc\n \nsuccessfully\n \nset\n \nbsp\n \nto\n \nhw/bsp/stm32f3discovery\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \nset\n \nboot_f3disc\n \ncompiler_def=optimized\n\n        \nTarget\n \nboot_f3disc\n \nsuccessfully\n \nset\n \ncompiler_def\n \nto\n \ndebug\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \nset\n \nboot_f3disc\n \ncompiler=arm-none-eabi-m4\n\n        \nTarget\n \nboot_f3disc\n \nsuccessfully\n \nset\n \ncompiler\n \nto\n \narm-none-eabi-m4\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \nset\n \nboot_f3disc\n \narch=cortex_m4\n\n        \nTarget\n \nboot_f3disc\n \nsuccessfully\n \nset\n \narch\n \nto\n \ncortex_m4\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \nshow\n \nblink_f3disc\n\n        \nblink_f3disc\n\n            \narch=cortex_m4\n\n            \nbsp=hw/bsp/stm32f3discovery\n\n            \ncompiler=arm-none-eabi-m4\n\n            \ncompiler_def=debug\n\n            \nname=blink_f3disc\n\n            \nproject=blinky\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \nshow\n \nboot_f3disc\n\n        \nboot_f3disc\n\n            \narch=cortex_m4\n\n            \nbsp=hw/bsp/stm32f3discovery\n\n            \ncompiler=arm-none-eabi-m4\n\n            \ncompiler_def=debug\n\n            \nname=blink_f3disc\n\n            \nproject=boot\n\n\n\n\n\n\n\n\nSTM32F3 blinky project is too large to operate with newlib libc. You need to modify project/blinky/pkg.yml, and switch over to using baselibc.\n\n\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \ncat\n \nproject/blinky/pkg\n.\nyml\n \n        \n#\n\n        \n# Licensed to the Apache Software Foundation (ASF) under one\n\n        \n# or more contributor license agreements.  See the NOTICE file\n\n        \n# distributed with this work for additional information\n\n        \n# regarding copyright ownership.  The ASF licenses this file\n\n        \n# to you under the Apache License, Version 2.0 (the\n\n        \n# \nLicense\n); you may not use this file except in compliance\n\n        \n# with the License.  You may obtain a copy of the License at\n\n        \n#\n\n        \n#  http:\n//www.apache.org/licenses/LICENSE-2.0\n\n        \n#\n\n        \n# Unless required by applicable law or agreed to in writing,\n\n        \n# software distributed under the License is distributed on an\n\n        \n# \nAS IS\n BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n\n        \n# KIND, either express or implied.  See the License for the\n\n        \n# specific language governing permissions and limitations\n\n        \n# under the License.\n\n        \n#\n\n\n        \npkg\n.\nname\n: \nproject/blinky\n\n        \npkg\n.\nvers\n: \n0.8.0\n\n        \npkg\n.\ndescription\n: \nBasic\n \nexample\n \napplication\n \nwhich\n \nblinks\n \nan\n \nLED\n.\n        \npkg\n.\nauthor\n: \nMarko\n \nKiiskila\n \nmarko@runtime\n.\nio\n\n        \npkg\n.\nhomepage\n: \nhttp\n:\n//mynewt.apache.org/os/get_acclimated/project2/\n\n        \npkg\n.\nrepository\n: \nhttps\n:\n//git-wip-us.apache.org/repos/asf/incubator-mynewt-larva\n\n        \npkg\n.\nkeywords\n:\n\n        \npkg\n.\ndeps\n:\n            \n-\n \nlibs/console/full\n\n            \n-\n \nlibs/newtmgr\n\n            \n-\n \nlibs/os\n\n            \n-\n \nlibs/shell\n\n            \n-\n \nsys/config\n\n            \n-\n \nsys/log\n\n            \n-\n \nsys/stats\n\n            \n-\n \nlibs/baselibc\n\n\n\n\n\n\n\n\n\n\nNext, you get to build the targets and generate an executable that can then be uploaded to the board. The STM32F3DISCOVERY board includes an ST-LINK/V2 embedded debug tool interface that will be used to program/debug the board. To program the MCU on the board, simply plug in the two jumpers on CN4, as shown in the picture in red. If you want to learn more about the board you will find the User Manual at \nhttp://www.st.com/st-web-ui/static/active/jp/resource/technical/document/user_manual/DM00063382.pdf\n\n\n\n\n\n\n\n\n\n\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \nbuild\n \nboot_f3disc\n\n        \nBuilding\n \ntarget\n \nboot_f3\n (\nproject\n \n=\n \nboot\n)\n        \nCompiling\n \nasprintf\n.\nc\n\n        \nCompiling\n \natoi\n.\nc\n\n        ...\n        ...\n        \nAssembling\n \nstartup_stm32f303xc\n.\ns\n\n        \nArchiving\n \nlibstm32f3discovery\n.\na\n\n        \nCompiling\n \nboot\n.\nc\n\n        \nBuilding\n \nproject\n \nboot\n\n        \nLinking\n \nboot\n.\nelf\n\n        \nSuccessfully\n \nrun!\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \nbuild\n \nblink_f3disc\n\n        \nBuilding\n \ntarget\n \nblink_f3disc\n (\nproject\n \n=\n \nblinky\n)\n        \nCompiling\n \nasprintf\n.\nc\n\n        \nCompiling\n \natoi\n.\nc\n\n        ...\n        ...\n        \nAssembling\n \nstartup_stm32f303xc\n.\ns\n\n        \nArchiving\n \nlibstm32f3discovery\n.\na\n\n        \nCompiling\n \nmain\n.\nc\n\n        \nBuilding\n \nproject\n \nblinky\n\n        \nLinking\n \nblinky\n.\nelf\n\n        \nSuccessfully\n \nrun!\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \nbuild\n \nboot_f3disc\n\n        \nBuilding\n \ntarget\n \nboot_f3disc\n (\nproject\n \n=\n \nboot\n)\n        \nBuilding\n \nproject\n \nboot\n\n        \nSuccessfully\n \nrun!\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \ncreate-image\n \nblink_f3disc\n \n0.0.1\n\n        \nBuilding\n \ntarget\n \nblink_f3disc\n (\nproject\n \n=\n \nblinky\n)\n        \nBuilding\n \nproject\n \nblinky\n\n\n\n\n\n\n\n\nFinally, you have to download the image on to the board. You will see a blue light start to blink.\n\n\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \ndownload\n \nboot_f3disc\n\n        \nDownloading\n \nwith\n \n/Users/user/dev/test_project/hw/bsp/stm32f3discovery/stm32f3discovery_download\n.\nsh\n\n\n        [\nuser\n:\n~/dev/test_project\n]\n$\n \nnewt\n \ntarget\n \ndownload\n \nblink_f3disc\n\n        \nDownloading\n \nwith\n \n/Users/user/dev/test_project/hw/bsp/stm32f3discovery/stm32f3discovery_download\n.\nsh", 
            "title": "Blinky on STM32F303"
        }, 
        {
            "location": "/os/tutorials/STM32F303/#blinky-on-stm32f303-board", 
            "text": "", 
            "title": "Blinky on STM32F303 board"
        }, 
        {
            "location": "/os/tutorials/STM32F303/#objective", 
            "text": "Download a generic firmware skeleton (\"bootstrap image\") that applies to any hardware and then throw in additional applicable pkgs to generate a build for a specific board, namely the STM32F303VC MCU from STMicroelectronics.", 
            "title": "Objective"
        }, 
        {
            "location": "/os/tutorials/STM32F303/#hardware-needed", 
            "text": "Discovery kit with STM32F303VC MCU  Laptop running Mac OS", 
            "title": "Hardware needed"
        }, 
        {
            "location": "/os/tutorials/STM32F303/#step-by-step-instructions-to-build-image", 
            "text": "The first step is to download the generic skeleton of the project. The pkgs constituting the skeleton are not hardware architecture specific. The skeleton is maintained as an app in a separate repository on Apache. You know it is an app because there is an app.yml file.            [ user : ~/dev ] $   newt   app   create   test_project \n         Downloading   app   skeleton   from   https : //git-wip-us.apache.org/repos/asf/incubator-mynewt-tadpole.git... ok! \n         app   test_project   successfully   created   in   ~/dev/go/test_project \n\n        [ user : ~/dev ] $   cd   test_project/ \n        [ user : ~/dev/test_project ] $   ls \n         README . md     compiler      hw        libs      app . yml    Next, the pkg-list named larva is added from the app (also named larva) from another repository on Apache. This step simply downloads the pkg-list description file and does not actually install the pkgs that constitute the pkg-list. The pkg-list description file ( pkg-list.yml ) will be used to check dependencies during the pkg install to ensure completeness. It serves as a reference for all the pkgs in the pkg-list that one can choose from and install.           [ user : ~/dev/test_project ] $   newt   app   add-pkg-list   larva   https : //git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git \n         Downloading   pkg-list . yml   from   https : //git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git/master... ok! \n         Verifying   pkg-list . yml   format ...\n         ok! \n         pkg-list   larva   successfully   installed   to   app .   The next step is to install relevant pkgs from the larva app from git server on Apache. The instructions assume that you know what application or project you are interested in (the blinky application, in this case), what hardware you are using (STM32F3DISCOVERY board, in this case) and hence, what board support package you need.            [ user : ~/dev/test_project ] $   newt   pkg   install   project/blinky           \n         Downloading   larva   from   https : //git-wip-us.apache.org/repos/asf/incubator-mynewt-larva/master... ok! \n         Installing   project/blinky \n         Installing   libs/console/full \n         Installing   libs/shell \n         Installation   was   a   success! \n\n        [ user : ~/dev/test_project ] $   newt   pkg   install   hw/bsp/stm32f3discovery \n         Downloading   larva   from   https : //git-wip-us.apache.org/repos/asf/incubator-mynewt-larva/master... ok! \n         Installing   hw/bsp/stm32f3discovery \n         Installing   hw/mcu/stm/stm32f3xx \n         Installing   libs/cmsis-core \n         Installing   compiler/arm-none-eabi-m4 \n         Installation   was   a   success!    It's time to create a targets for the project and define the target attributes. STM32F3 BSP expects bootloader, so create targets for both blinky and bootloader.           [ user : ~/dev/test_project ] $   newt   target   create   blink_f3disc \n         Creating   target   blink_f3disc \n         Target   blink_f3disc   successfully   created! \n\n        [ user : ~/dev/test_project ] $   newt   target   set   blink_f3disc   project=blinky \n         Target   blink_f3disc   successfully   set   project   to   blinky \n\n        [ user : ~/dev/test_project ] $   newt   target   set   blink_f3disc   bsp=hw/bsp/stm32f3discovery \n         Target   blink_f3disc   successfully   set   bsp   to   hw/bsp/stm32f3discovery \n\n        [ user : ~/dev/test_project ] $   newt   target   set   blink_f3disc   compiler_def=debug \n         Target   blink_f3disc   successfully   set   compiler_def   to   debug \n\n        [ user : ~/dev/test_project ] $   newt   target   set   blink_f3disc   compiler=arm-none-eabi-m4 \n         Target   blink_f3disc   successfully   set   compiler   to   arm-none-eabi-m4 \n\n        [ user : ~/dev/test_project ] $   newt   target   set   blink_f3disc   arch=cortex_m4 \n         Target   blink_f3disc   successfully   set   arch   to   cortex_m4 \n\n        [ user : ~/dev/test_project ] $   newt   target   create   boot_f3disc \n         Creating   target   boot_f3disc \n         Target   boot_f3disc   successfully   created! \n\n        [ user : ~/dev/test_project ] $   newt   target   set   boot_f3disc   project=boot \n         Target   blink_f3disc   successfully   set   project   to   blinky \n\n        [ user : ~/dev/test_project ] $   newt   target   set   boot_f3disc   bsp=hw/bsp/stm32f3discovery \n         Target   boot_f3disc   successfully   set   bsp   to   hw/bsp/stm32f3discovery \n\n        [ user : ~/dev/test_project ] $   newt   target   set   boot_f3disc   compiler_def=optimized \n         Target   boot_f3disc   successfully   set   compiler_def   to   debug \n\n        [ user : ~/dev/test_project ] $   newt   target   set   boot_f3disc   compiler=arm-none-eabi-m4 \n         Target   boot_f3disc   successfully   set   compiler   to   arm-none-eabi-m4 \n\n        [ user : ~/dev/test_project ] $   newt   target   set   boot_f3disc   arch=cortex_m4 \n         Target   boot_f3disc   successfully   set   arch   to   cortex_m4 \n\n        [ user : ~/dev/test_project ] $   newt   target   show   blink_f3disc \n         blink_f3disc \n             arch=cortex_m4 \n             bsp=hw/bsp/stm32f3discovery \n             compiler=arm-none-eabi-m4 \n             compiler_def=debug \n             name=blink_f3disc \n             project=blinky \n\n        [ user : ~/dev/test_project ] $   newt   target   show   boot_f3disc \n         boot_f3disc \n             arch=cortex_m4 \n             bsp=hw/bsp/stm32f3discovery \n             compiler=arm-none-eabi-m4 \n             compiler_def=debug \n             name=blink_f3disc \n             project=boot    STM32F3 blinky project is too large to operate with newlib libc. You need to modify project/blinky/pkg.yml, and switch over to using baselibc.           [ user : ~/dev/test_project ] $   cat   project/blinky/pkg . yml  \n         # \n         # Licensed to the Apache Software Foundation (ASF) under one \n         # or more contributor license agreements.  See the NOTICE file \n         # distributed with this work for additional information \n         # regarding copyright ownership.  The ASF licenses this file \n         # to you under the Apache License, Version 2.0 (the \n         #  License ); you may not use this file except in compliance \n         # with the License.  You may obtain a copy of the License at \n         # \n         #  http: //www.apache.org/licenses/LICENSE-2.0 \n         # \n         # Unless required by applicable law or agreed to in writing, \n         # software distributed under the License is distributed on an \n         #  AS IS  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY \n         # KIND, either express or implied.  See the License for the \n         # specific language governing permissions and limitations \n         # under the License. \n         # \n\n         pkg . name :  project/blinky \n         pkg . vers :  0.8.0 \n         pkg . description :  Basic   example   application   which   blinks   an   LED .\n         pkg . author :  Marko   Kiiskila   marko@runtime . io \n         pkg . homepage :  http : //mynewt.apache.org/os/get_acclimated/project2/ \n         pkg . repository :  https : //git-wip-us.apache.org/repos/asf/incubator-mynewt-larva \n         pkg . keywords :\n\n         pkg . deps :\n             -   libs/console/full \n             -   libs/newtmgr \n             -   libs/os \n             -   libs/shell \n             -   sys/config \n             -   sys/log \n             -   sys/stats \n             -   libs/baselibc     Next, you get to build the targets and generate an executable that can then be uploaded to the board. The STM32F3DISCOVERY board includes an ST-LINK/V2 embedded debug tool interface that will be used to program/debug the board. To program the MCU on the board, simply plug in the two jumpers on CN4, as shown in the picture in red. If you want to learn more about the board you will find the User Manual at  http://www.st.com/st-web-ui/static/active/jp/resource/technical/document/user_manual/DM00063382.pdf               [ user : ~/dev/test_project ] $   newt   target   build   boot_f3disc \n         Building   target   boot_f3  ( project   =   boot )\n         Compiling   asprintf . c \n         Compiling   atoi . c \n        ...\n        ...\n         Assembling   startup_stm32f303xc . s \n         Archiving   libstm32f3discovery . a \n         Compiling   boot . c \n         Building   project   boot \n         Linking   boot . elf \n         Successfully   run! \n\n        [ user : ~/dev/test_project ] $   newt   target   build   blink_f3disc \n         Building   target   blink_f3disc  ( project   =   blinky )\n         Compiling   asprintf . c \n         Compiling   atoi . c \n        ...\n        ...\n         Assembling   startup_stm32f303xc . s \n         Archiving   libstm32f3discovery . a \n         Compiling   main . c \n         Building   project   blinky \n         Linking   blinky . elf \n         Successfully   run! \n\n        [ user : ~/dev/test_project ] $   newt   target   build   boot_f3disc \n         Building   target   boot_f3disc  ( project   =   boot )\n         Building   project   boot \n         Successfully   run! \n\n        [ user : ~/dev/test_project ] $   newt   target   create-image   blink_f3disc   0.0.1 \n         Building   target   blink_f3disc  ( project   =   blinky )\n         Building   project   blinky    Finally, you have to download the image on to the board. You will see a blue light start to blink.           [ user : ~/dev/test_project ] $   newt   target   download   boot_f3disc \n         Downloading   with   /Users/user/dev/test_project/hw/bsp/stm32f3discovery/stm32f3discovery_download . sh \n\n        [ user : ~/dev/test_project ] $   newt   target   download   blink_f3disc \n         Downloading   with   /Users/user/dev/test_project/hw/bsp/stm32f3discovery/stm32f3discovery_download . sh", 
            "title": "Step by Step Instructions to build image"
        }, 
        {
            "location": "/os/tutorials/nRF52/", 
            "text": "Blinky on nRF52 board\n\n\nObjective\n\n\nDownload a generic firmware skeleton (\"bootstrap image\") that applies to any hardware and then throw in additional applicable pkgs to generate a build for a specific board, namely the\nnRF52 Series chip from Nordic Semiconductors.\n\n\nHardware needed\n\n\n\n\nnRF52 Development Kit\n\n\nLaptop running Mac OS\n\n\n\n\nStep by Step Instructions to build image\n\n\n\n\nThe first step is to download the generic skeleton of the project. The eggs installed are not hardware architecture specific.\n\n\n\n\n        []\nuser@~/dev\n]\n$\n \nnewt\n \nnest\n \ncreate\n \nnordic_blinky\n\n        \nDownloading\n \nnest\n \nskeleton\n \nfrom\n \nhttps\n:\n//www.github.com/mynewt/tadpole... ok!\n\n        \nNest\n \nnordic_blinky\n \nsuccessfully\n \ncreated\n \nin\n \n~dev/nordic_blinky\n\n\n        \nuser@~/dev$\n \ncd\n \nnordic_blinky/\n\n\n\n\n\n\n\n\nThen, the clutch of eggs named larva is added from the nest (also named larva) on the github. This step simply downloads the clutch description file and does not actually install the eggs that constitute the clutch. The clutch description file (\nclutch.yml\n) will be used to check dependencies during the egg install to ensure completeness. It serves as a reference for all the eggs in the clutch that one can choose from and install.\n\n\n\n\n        []\nuser@~/dev/nordic_blinky\n]\n$\n \nnewt\n \nnest\n \nadd-clutch\n \nlarva\n \nhttps\n:\n//github.com/mynewt/larva\n\n        \nDownloading\n \nclutch\n.\nyml\n \nfrom\n \nhttps\n:\n//github.com/mynewt/larva/master... ok!\n\n        \nVerifying\n \nclutch\n.\nyml\n \nformat\n...\nok!\n\n        \nClutch\n \nlarva\n \nsuccessfully\n \ninstalled\n \nto\n \nNest\n.\n\n\n\n\n\n\n\nThe next step is to install relevant eggs from the larva nest on github. The instructions assume that you know what application or project you are interested in (the blinky application, in this case), what hardware you are using (STM32F3DISCOVERY board, in this case) and hence, what board support package you need. \n\n\n\n\n        [\nuser@~/dev/nordic_blinky\n]\n$\n \nnewt\n \negg\n \ninstall\n \nproject/blinky\n \n        \nDownloading\n \nlarva\n \nfrom\n \nhttps\n:\n//github.com/mynewt/larva//master... ok!\n\n        \nInstalling\n \nproject/blinky\n\n        \nInstallation\n \nwas\n \na\n \nsuccess!\n\n\n\n        [\nuser@~/dev/nordic_blinky\n]\n$\n \nnewt\n \negg\n \ninstall\n \nhw/bsp/nrf52pdk\n\n        \nDownloading\n \nlarva\n \nfrom\n \nhttps\n:\n//github.com/mynewt/larva//master... ok!\n\n        \nInstalling\n \nhw/bsp/nrf52pdk\n\n        \nInstalling\n \nhw/mcu/nordic/nrf52xxx\n\n        \nInstalling\n \nlibs/cmsis-core\n\n        \nInstalling\n \ncompiler/arm-none-eabi-m4\n\n        \nInstallation\n \nwas\n \na\n \nsuccess!\n\n\n\n\n\n\n\n\nIt's time to create a target for the project and define the target attributes. \n\n\n\n\n        [\nuser@~/dev/nordic_blinky\n]\n$\n \nnewt\n \ntarget\n \ncreate\n \nblink_nordic\n\n        \nCreating\n \ntarget\n \nblink_nordic\n\n        \nTarget\n \nblink_nordic\n \nsuccessfully\n \ncreated!\n\n        [\nuser@~/dev/nordic_blinky\n]\n$\n \nnewt\n \ntarget\n \nset\n \nblink_nordic\n \nproject=blinky\n\n        \nTarget\n \nblink_nordic\n \nsuccessfully\n \nset\n \nproject\n \nto\n \nblinky\n\n        [\nuser@~/dev/nordic_blinky\n]\n$\n \nnewt\n \ntarget\n \nset\n \nblink_nordic\n \nbsp=hw/bsp/nrf52pdk\n\n        \nTarget\n \nblink_nordic\n \nsuccessfully\n \nset\n \nbsp\n \nto\n \nhw/bsp/nrf52pdk\n\n        [\nuser@~/dev/nordic_blinky\n]\n$\n \nnewt\n \ntarget\n \nset\n \nblink_nordic\n \ncompiler_def=debug\n\n        \nTarget\n \nblink_nordic\n \nsuccessfully\n \nset\n \ncompiler_def\n \nto\n \ndebug\n\n        [\nuser@~/dev/nordic_blinky\n]\n$\n \nnewt\n \ntarget\n \nset\n \nblink_nordic\n \ncompiler=arm-none-eabi-m4\n\n        \nTarget\n \nblink_nordic\n \nsuccessfully\n \nset\n \ncompiler\n \nto\n \narm-none-eabi-m4\n\n        [\nuser@~/dev/nordic_blinky\n]\n$\n \nnewt\n \ntarget\n \nset\n \nblink_nordic\n \narch=cortex_m4\n\n        \nTarget\n \nblink_nordic\n \nsuccessfully\n \nset\n \narch\n \nto\n \ncortex_m4\n\n        [\nuser@~/dev/nordic_blinky\n]\n$\n \nnewt\n \ntarget\n \nshow\n\n        \nblink_nordic\n\n            \ncompiler\n: \narm-none-eabi-m4\n\n            \nname\n: \nblink_nordic\n\n            \narch\n: \ncortex_m4\n\n            \nproject\n: \nblinky\n\n            \nbsp\n: \nhw/bsp/nrf52pdk\n\n            \ncompiler_def\n: \ndebug\n\n\n\n\n\n\n\n\nFinally, you get to build the target and generate an executable that can now be uploaded to the board via the on-board SEGGER J-Link debugger. \n\n\n\n\n        [\nuser@~/dev/nordic_blinky\n]\n$\n \nnewt\n \ntarget\n \nbuild\n \nblink_nordic\n\n        \nBuilding\n \ntarget\n \nblink_nordic\n (\nproject\n \n=\n \nblinky\n)\n        \nCompiling\n \ncase\n.\nc\n\n        \nCompiling\n \nsuite\n.\nc\n\n        \nCompiling\n \ntestutil\n.\nc\n\n        \nCompiling\n \ntestutil_arch_arm\n.\nc\n\n        \nArchiving\n \nlibtestutil\n.\na\n\n        \nCompiling\n \nos\n.\nc\n\n        \nCompiling\n \nos_callout\n.\nc\n\n        \nCompiling\n \nos_eventq\n.\nc\n\n        \nCompiling\n \nos_heap\n.\nc\n\n        \nCompiling\n \nos_mbuf\n.\nc\n\n        \nCompiling\n \nos_mempool\n.\nc\n\n        \nCompiling\n \nos_mutex\n.\nc\n\n        \nCompiling\n \nos_sanity\n.\nc\n\n        \nCompiling\n \nos_sched\n.\nc\n\n        \nCompiling\n \nos_sem\n.\nc\n\n        \nCompiling\n \nos_task\n.\nc\n\n        \nCompiling\n \nos_time\n.\nc\n\n        \nCompiling\n \nos_arch_arm\n.\nc\n\n        \nAssembling\n \nHAL_CM4\n.\ns\n\n        \nAssembling\n \nSVC_Table\n.\ns\n\n        \nArchiving\n \nlibos\n.\na\n\n        \nCompiling\n \nhal_cputime\n.\nc\n\n        \nCompiling\n \nhal_gpio\n.\nc\n\n        \nCompiling\n \nhal_uart\n.\nc\n\n        \nArchiving\n \nlibnrf52xxx\n.\na\n\n        \nCompiling\n \ncmsis_nvic\n.\nc\n\n        \nCompiling\n \nhal_bsp\n.\nc\n\n        \nCompiling\n \nlibc_stubs\n.\nc\n\n        \nCompiling\n \nos_bsp\n.\nc\n\n        \nCompiling\n \nsbrk\n.\nc\n\n        \nCompiling\n \nsystem_nrf52\n.\nc\n\n        \nAssembling\n \ngcc_startup_nrf52\n.\ns\n\n        \nArchiving\n \nlibnrf52pdk\n.\na\n\n        \nCompiling\n \nmain\n.\nc\n\n        \nBuilding\n \nproject\n \nblinky\n\n        \nLinking\n \nblinky\n.\nelf\n\n        \nSuccessfully\n \nrun!\n\n\n\n\n\n\n\n\n\n\nIn order to be able to communicate with the SEGGER J-Link debugger on the dev board, you have to download and install the J-Link GDB Server software on to your laptop. You may download the \"Software and documentation pack for Mac OS X\" from \nhttps://www.segger.com/jlink-software.html\n. The command line version of the server is used in the steps below. \n\n\n\n\n\n\nOpen a new terminal and start a J-Link session.\n\n\n\n\n\n\n        [\nuser@~/dev/nordic_blinky/project/blinky/bin\n]\n$\n \nwhich\n \nJLinkGDBServer\n\n        \n/usr/local/bin/JLinkGDBServer\n\n        [\nuser@~/dev/nordic_blinky/project/blinky/bin\n]\n$\n \nJLinkGDBServer\n \n-\nif\n \nSWD\n\n        \nSEGGER\n \nJ-Link\n \nGDB\n \nServer\n \nV5\n.02f\n \nCommand\n \nLine\n \nVersion\n\n\n        \nJLinkARM\n.\ndll\n \nV5\n.02f\n (\nDLL\n \ncompiled\n \nOct\n  \n2\n \n2015\n \n20\n:\n55\n:\n03\n)\n\n        \n-----GDB\n \nServer\n \nstart\n \nsettings-----\n\n        \nGDBInit\n \nfile\n:                  \nnone\n\n        \nGDB\n \nServer\n \nListening\n \nport\n:     \n2331\n\n        \nSWO\n \nraw\n \noutput\n \nlistening\n \nport\n: \n2332\n\n        \nTerminal\n \nI/O\n \nport\n:             \n2333\n\n        \nAccept\n \nremote\n \nconnection\n:      \nyes\n\n        \nGenerate\n \nlogfile\n:              \noff\n\n        \nVerify\n \ndownload\n:               \noff\n\n        \nInit\n \nregs\n \non\n \nstart\n:            \noff\n\n        \nSilent\n \nmode\n:                   \noff\n\n        \nSingle\n \nrun\n \nmode\n:               \noff\n\n        \nTarget\n \nconnection\n \ntimeout\n:     \n0\n \nms\n\n        \n------J-Link\n \nrelated\n \nsettings------\n\n        \nJ-Link\n \nHost\n \ninterface\n:         \nUSB\n\n        \nJ-Link\n \nscript\n:                 \nnone\n\n        \nJ-Link\n \nsettings\n \nfile\n:          \nnone\n\n        \n------Target\n \nrelated\n \nsettings------\n\n        \nTarget\n \ndevice\n:                 \nunspecified\n\n        \nTarget\n \ninterface\n:              \nSWD\n\n        \nTarget\n \ninterface\n \nspeed\n:        \n1000\nkHz\n\n        \nTarget\n \nendian\n:                 \nlittle\n\n\n        \nConnecting\n \nto\n \nJ-Link\n...\n        \nJ-Link\n \nis\n \nconnected\n.\n        \nFirmware\n: \nJ-Link\n \nOB-SAM3U128-V2-NordicSemi\n \ncompiled\n \nAug\n \n28\n \n2015\n \n19\n:\n26\n:\n24\n\n        \nHardware\n: \nV1\n.00\n\n        \nS/N\n: \n682371959\n\n        \nChecking\n \ntarget\n \nvoltage\n...\n        \nTarget\n \nvoltage\n: \n3.30\n \nV\n\n        \nListening\n \non\n \nTCP/IP\n \nport\n \n2331\n\n        \nConnecting\n \nto\n \ntarget\n...\nConnected\n \nto\n \ntarget\n\n        \nWaiting\n \nfor\n \nGDB\n \nconnection\n...\nConnected\n \nto\n \n127.0.0.1\n\n\n\n\n\n\n\n\nYou need a configuration file for the GDB session to be opened correctly and the image (\"blinky.elf\") you built for this target downloaded to flash. A sample config script is given below. Alternatively, you could choose to type each command at the gdb prompt.\n\n\n\n\n         [\nuser@~/dev/nordic_blinky/project/blinky/bin/blink_nordic\n]\n$\n \ncat\n \njlink-gdb\n.\ncfg\n \n         \necho\n \n***Setting\n \nup\n \nthe\n \nenvironment\n \nfor\n \ndebugging\n \ngdb\n.\n***\\n\n\n         \nset\n \ncomplaints\n \n1\n\n         \nset\n \nprompt\n (\ngdb\n) \n         \nset\n \nendian\n \nlittle\n\n         \necho\n \n\\n***\n \nSet\n \ntarget\n \ncharset\n \nASCII\\n\n\n         \nset\n \ntarget-charset\n \nASCII\n\n         \necho\n \n\\n***\n \nConnecting\n \nover\n \nport\n \n#\n2331\n \n***\\n\n\n         \ntarget\n \nremote\n \nlocalhost\n:\n2331\n\n         \necho\n \n\\n***\n \nEnable\n \nflash\n \nwrite\n \nand\n \nset\n \ndevice\n \nto\n \nnrf52\n \n***\\n\n\n         \nmonitor\n \nflash\n \ndownload=\n1\n\n         \nmonitor\n \nflash\n \ndevice=nRF52\n\n         \necho\n \n\\n***\n \nloading\n \nblinky\n.\nelf\n \n***\\n\n\n         \nload\n \n~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky\n.\nelf\n \n         \nsymbol-file\n \n~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky\n.\nelf\n\n         \necho\n \n\\n***\n \nResetting\n \ntarget\n \n***\\n\n\n         \nmonitor\n \nreset\n\n         \necho\n \n\\n***\n \nHalting\n \ntarget\n \n***\\n\n\n         \nmonitor\n \nhalt\n\n\n\n\n\n\n\n\nStart the gdb session and monitor that it loads the image, resets the target, and halts for a command to continue. \n\n\n\n\n        [\nuser@~/dev/nordic_blinky/project/blinky/bin/blink_nordic\n]\n$\n \narm-none-eabi-gdb\n \n-x\n \n~/dev/nordic_blinky/project/blinky/bin/blink_nordic/jlink-gdb\n.\ncfg\n\n\n        \nGNU\n \ngdb\n (\nGNU\n \nTools\n \nfor\n \nARM\n \nEmbedded\n \nProcessors\n) \n7.8.0.20150604\n-cvs\n\n        \nCopyright\n (\nC\n) \n2014\n \nFree\n \nSoftware\n \nFoundation\n, \nInc\n.\n        \nLicense\n \nGPLv3+:\n \nGNU\n \nGPL\n \nversion\n \n3\n \nor\n \nlater\n \nhttp\n:\n//gnu.org/licenses/gpl.html\n\n        \nThis\n \nis\n \nfree\n \nsoftware\n: \nyou\n \nare\n \nfree\n \nto\n \nchange\n \nand\n \nredistribute\n \nit\n.\n        \nThere\n \nis\n \nNO\n \nWARRANTY\n, \nto\n \nthe\n \nextent\n \npermitted\n \nby\n \nlaw\n.  \nType\n \nshow copying\n\n        \nand\n \nshow warranty\n \nfor\n \ndetails\n.\n        \nThis\n \nGDB\n \nwas\n \nconfigured\n \nas\n \n--host=x86_64-apple-darwin10 --target=arm-none-eabi\n.\n        \nType\n \nshow configuration\n \nfor\n \nconfiguration\n \ndetails\n.\n        \nFor\n \nbug\n \nreporting\n \ninstructions\n, \nplease\n \nsee\n:\n        \nhttp\n:\n//www.gnu.org/software/gdb/bugs/\n.\n\n        \nFind\n \nthe\n \nGDB\n \nmanual\n \nand\n \nother\n \ndocumentation\n \nresources\n \nonline\n \nat\n:\n        \nhttp\n:\n//www.gnu.org/software/gdb/documentation/\n.\n\n        \nFor\n \nhelp\n, \ntype\n \nhelp\n.\n        \nType\n \napropos word\n \nto\n \nsearch\n \nfor\n \ncommands\n \nrelated\n \nto\n \nword\n.\n\n        \n***Setting\n \nup\n \nthe\n \nenvironment\n \nfor\n \ndebugging\n \ngdb\n.\n***\n\n        \nThe\n \ntarget\n \nis\n \nassumed\n \nto\n \nbe\n \nlittle\n \nendian\n\n\n        \n***\n \nSet\n \ntarget\n \ncharset\n \nASCII\n\n\n        \n***\n \nConnecting\n \nover\n \nport\n \n#\n2331\n \n***\n\n        \n0x00003c34\n \nin\n \n??\n ()\n\n        \n***\n \nEnable\n \nflash\n \nwrite\n \nand\n \nset\n \ndevice\n \nto\n \nnrf52\n \n***\n\n        \nFlash\n \ndownload\n \nenabled\n\n        \nSelecting\n \ndevice\n: \nnRF52\n\n\n        \n***\n \nloading\n \nblinky\n.\nelf\n \n***\n\n        \nLoading\n \nsection\n .\ntext\n, \nsize\n \n0x5c84\n \nlma\n \n0x0\n\n        \nLoading\n \nsection\n .\nARM\n.\nextab\n, \nsize\n \n0x24\n \nlma\n \n0x5c84\n\n        \nLoading\n \nsection\n .\nARM\n.\nexidx\n, \nsize\n \n0xd8\n \nlma\n \n0x5ca8\n\n        \nLoading\n \nsection\n .\ndata\n, \nsize\n \n0x8f8\n \nlma\n \n0x5d80\n\n        \nStart\n \naddress\n \n0x48c\n, \nload\n \nsize\n \n26232\n\n        \nTransfer\n \nrate\n: \n12808\n \nKB/sec\n, \n2914\n \nbytes/write\n.\n        \nDuring\n \nsymbol\n \nreading\n, \nunexpected\n \noverlap\n \nbetween\n:\n         (\nA\n) \nsection\n \n`\n.\ntext\n \nfrom\n \n`~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky\n.\nelf\n [\n0x0\n, \n0x5c84\n)\n         (\nB\n) \nsection\n \n`*COM*\n \nfrom\n \n`~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky\n.\nelf\n [\n0x0\n, \n0x0\n).\n        \nWill\n \nignore\n \nsection\n \nB\n.\n\n        \n***\n \nResetting\n \ntarget\n \n***\n\n        \nResetting\n \ntarget\n\n\n        \n***\n \nHalting\n \ntarget\n \n***\n\n\n\n\n\n\n\n\nType 'c' to continue. The LED on the board will start to blink. You will also see some activity in the terminal showing the open J-Link GDB server connection. The LED will continue to blink after you quit out of that connection.\n\n\n\n\n        (\ngdb\n) \nc\n\n        \nContinuing\n.", 
            "title": "Blinky on nRF52"
        }, 
        {
            "location": "/os/tutorials/nRF52/#blinky-on-nrf52-board", 
            "text": "", 
            "title": "Blinky on nRF52 board"
        }, 
        {
            "location": "/os/tutorials/nRF52/#objective", 
            "text": "Download a generic firmware skeleton (\"bootstrap image\") that applies to any hardware and then throw in additional applicable pkgs to generate a build for a specific board, namely the\nnRF52 Series chip from Nordic Semiconductors.", 
            "title": "Objective"
        }, 
        {
            "location": "/os/tutorials/nRF52/#hardware-needed", 
            "text": "nRF52 Development Kit  Laptop running Mac OS", 
            "title": "Hardware needed"
        }, 
        {
            "location": "/os/tutorials/nRF52/#step-by-step-instructions-to-build-image", 
            "text": "The first step is to download the generic skeleton of the project. The eggs installed are not hardware architecture specific.           [] user@~/dev ] $   newt   nest   create   nordic_blinky \n         Downloading   nest   skeleton   from   https : //www.github.com/mynewt/tadpole... ok! \n         Nest   nordic_blinky   successfully   created   in   ~dev/nordic_blinky \n\n         user@~/dev$   cd   nordic_blinky/    Then, the clutch of eggs named larva is added from the nest (also named larva) on the github. This step simply downloads the clutch description file and does not actually install the eggs that constitute the clutch. The clutch description file ( clutch.yml ) will be used to check dependencies during the egg install to ensure completeness. It serves as a reference for all the eggs in the clutch that one can choose from and install.           [] user@~/dev/nordic_blinky ] $   newt   nest   add-clutch   larva   https : //github.com/mynewt/larva \n         Downloading   clutch . yml   from   https : //github.com/mynewt/larva/master... ok! \n         Verifying   clutch . yml   format ... ok! \n         Clutch   larva   successfully   installed   to   Nest .   The next step is to install relevant eggs from the larva nest on github. The instructions assume that you know what application or project you are interested in (the blinky application, in this case), what hardware you are using (STM32F3DISCOVERY board, in this case) and hence, what board support package you need.            [ user@~/dev/nordic_blinky ] $   newt   egg   install   project/blinky  \n         Downloading   larva   from   https : //github.com/mynewt/larva//master... ok! \n         Installing   project/blinky \n         Installation   was   a   success! \n\n\n        [ user@~/dev/nordic_blinky ] $   newt   egg   install   hw/bsp/nrf52pdk \n         Downloading   larva   from   https : //github.com/mynewt/larva//master... ok! \n         Installing   hw/bsp/nrf52pdk \n         Installing   hw/mcu/nordic/nrf52xxx \n         Installing   libs/cmsis-core \n         Installing   compiler/arm-none-eabi-m4 \n         Installation   was   a   success!    It's time to create a target for the project and define the target attributes.            [ user@~/dev/nordic_blinky ] $   newt   target   create   blink_nordic \n         Creating   target   blink_nordic \n         Target   blink_nordic   successfully   created! \n        [ user@~/dev/nordic_blinky ] $   newt   target   set   blink_nordic   project=blinky \n         Target   blink_nordic   successfully   set   project   to   blinky \n        [ user@~/dev/nordic_blinky ] $   newt   target   set   blink_nordic   bsp=hw/bsp/nrf52pdk \n         Target   blink_nordic   successfully   set   bsp   to   hw/bsp/nrf52pdk \n        [ user@~/dev/nordic_blinky ] $   newt   target   set   blink_nordic   compiler_def=debug \n         Target   blink_nordic   successfully   set   compiler_def   to   debug \n        [ user@~/dev/nordic_blinky ] $   newt   target   set   blink_nordic   compiler=arm-none-eabi-m4 \n         Target   blink_nordic   successfully   set   compiler   to   arm-none-eabi-m4 \n        [ user@~/dev/nordic_blinky ] $   newt   target   set   blink_nordic   arch=cortex_m4 \n         Target   blink_nordic   successfully   set   arch   to   cortex_m4 \n        [ user@~/dev/nordic_blinky ] $   newt   target   show \n         blink_nordic \n             compiler :  arm-none-eabi-m4 \n             name :  blink_nordic \n             arch :  cortex_m4 \n             project :  blinky \n             bsp :  hw/bsp/nrf52pdk \n             compiler_def :  debug    Finally, you get to build the target and generate an executable that can now be uploaded to the board via the on-board SEGGER J-Link debugger.            [ user@~/dev/nordic_blinky ] $   newt   target   build   blink_nordic \n         Building   target   blink_nordic  ( project   =   blinky )\n         Compiling   case . c \n         Compiling   suite . c \n         Compiling   testutil . c \n         Compiling   testutil_arch_arm . c \n         Archiving   libtestutil . a \n         Compiling   os . c \n         Compiling   os_callout . c \n         Compiling   os_eventq . c \n         Compiling   os_heap . c \n         Compiling   os_mbuf . c \n         Compiling   os_mempool . c \n         Compiling   os_mutex . c \n         Compiling   os_sanity . c \n         Compiling   os_sched . c \n         Compiling   os_sem . c \n         Compiling   os_task . c \n         Compiling   os_time . c \n         Compiling   os_arch_arm . c \n         Assembling   HAL_CM4 . s \n         Assembling   SVC_Table . s \n         Archiving   libos . a \n         Compiling   hal_cputime . c \n         Compiling   hal_gpio . c \n         Compiling   hal_uart . c \n         Archiving   libnrf52xxx . a \n         Compiling   cmsis_nvic . c \n         Compiling   hal_bsp . c \n         Compiling   libc_stubs . c \n         Compiling   os_bsp . c \n         Compiling   sbrk . c \n         Compiling   system_nrf52 . c \n         Assembling   gcc_startup_nrf52 . s \n         Archiving   libnrf52pdk . a \n         Compiling   main . c \n         Building   project   blinky \n         Linking   blinky . elf \n         Successfully   run!     In order to be able to communicate with the SEGGER J-Link debugger on the dev board, you have to download and install the J-Link GDB Server software on to your laptop. You may download the \"Software and documentation pack for Mac OS X\" from  https://www.segger.com/jlink-software.html . The command line version of the server is used in the steps below.     Open a new terminal and start a J-Link session.            [ user@~/dev/nordic_blinky/project/blinky/bin ] $   which   JLinkGDBServer \n         /usr/local/bin/JLinkGDBServer \n        [ user@~/dev/nordic_blinky/project/blinky/bin ] $   JLinkGDBServer   - if   SWD \n         SEGGER   J-Link   GDB   Server   V5 .02f   Command   Line   Version \n\n         JLinkARM . dll   V5 .02f  ( DLL   compiled   Oct    2   2015   20 : 55 : 03 )\n\n         -----GDB   Server   start   settings----- \n         GDBInit   file :                   none \n         GDB   Server   Listening   port :      2331 \n         SWO   raw   output   listening   port :  2332 \n         Terminal   I/O   port :              2333 \n         Accept   remote   connection :       yes \n         Generate   logfile :               off \n         Verify   download :                off \n         Init   regs   on   start :             off \n         Silent   mode :                    off \n         Single   run   mode :                off \n         Target   connection   timeout :      0   ms \n         ------J-Link   related   settings------ \n         J-Link   Host   interface :          USB \n         J-Link   script :                  none \n         J-Link   settings   file :           none \n         ------Target   related   settings------ \n         Target   device :                  unspecified \n         Target   interface :               SWD \n         Target   interface   speed :         1000 kHz \n         Target   endian :                  little \n\n         Connecting   to   J-Link ...\n         J-Link   is   connected .\n         Firmware :  J-Link   OB-SAM3U128-V2-NordicSemi   compiled   Aug   28   2015   19 : 26 : 24 \n         Hardware :  V1 .00 \n         S/N :  682371959 \n         Checking   target   voltage ...\n         Target   voltage :  3.30   V \n         Listening   on   TCP/IP   port   2331 \n         Connecting   to   target ... Connected   to   target \n         Waiting   for   GDB   connection ... Connected   to   127.0.0.1    You need a configuration file for the GDB session to be opened correctly and the image (\"blinky.elf\") you built for this target downloaded to flash. A sample config script is given below. Alternatively, you could choose to type each command at the gdb prompt.            [ user@~/dev/nordic_blinky/project/blinky/bin/blink_nordic ] $   cat   jlink-gdb . cfg  \n          echo   ***Setting   up   the   environment   for   debugging   gdb . ***\\n \n          set   complaints   1 \n          set   prompt  ( gdb ) \n          set   endian   little \n          echo   \\n***   Set   target   charset   ASCII\\n \n          set   target-charset   ASCII \n          echo   \\n***   Connecting   over   port   # 2331   ***\\n \n          target   remote   localhost : 2331 \n          echo   \\n***   Enable   flash   write   and   set   device   to   nrf52   ***\\n \n          monitor   flash   download= 1 \n          monitor   flash   device=nRF52 \n          echo   \\n***   loading   blinky . elf   ***\\n \n          load   ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky . elf  \n          symbol-file   ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky . elf \n          echo   \\n***   Resetting   target   ***\\n \n          monitor   reset \n          echo   \\n***   Halting   target   ***\\n \n          monitor   halt    Start the gdb session and monitor that it loads the image, resets the target, and halts for a command to continue.            [ user@~/dev/nordic_blinky/project/blinky/bin/blink_nordic ] $   arm-none-eabi-gdb   -x   ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/jlink-gdb . cfg \n\n         GNU   gdb  ( GNU   Tools   for   ARM   Embedded   Processors )  7.8.0.20150604 -cvs \n         Copyright  ( C )  2014   Free   Software   Foundation ,  Inc .\n         License   GPLv3+:   GNU   GPL   version   3   or   later   http : //gnu.org/licenses/gpl.html \n         This   is   free   software :  you   are   free   to   change   and   redistribute   it .\n         There   is   NO   WARRANTY ,  to   the   extent   permitted   by   law .   Type   show copying \n         and   show warranty   for   details .\n         This   GDB   was   configured   as   --host=x86_64-apple-darwin10 --target=arm-none-eabi .\n         Type   show configuration   for   configuration   details .\n         For   bug   reporting   instructions ,  please   see :\n         http : //www.gnu.org/software/gdb/bugs/ . \n         Find   the   GDB   manual   and   other   documentation   resources   online   at :\n         http : //www.gnu.org/software/gdb/documentation/ . \n         For   help ,  type   help .\n         Type   apropos word   to   search   for   commands   related   to   word .\n\n         ***Setting   up   the   environment   for   debugging   gdb . *** \n         The   target   is   assumed   to   be   little   endian \n\n         ***   Set   target   charset   ASCII \n\n         ***   Connecting   over   port   # 2331   *** \n         0x00003c34   in   ??  ()\n\n         ***   Enable   flash   write   and   set   device   to   nrf52   *** \n         Flash   download   enabled \n         Selecting   device :  nRF52 \n\n         ***   loading   blinky . elf   *** \n         Loading   section  . text ,  size   0x5c84   lma   0x0 \n         Loading   section  . ARM . extab ,  size   0x24   lma   0x5c84 \n         Loading   section  . ARM . exidx ,  size   0xd8   lma   0x5ca8 \n         Loading   section  . data ,  size   0x8f8   lma   0x5d80 \n         Start   address   0x48c ,  load   size   26232 \n         Transfer   rate :  12808   KB/sec ,  2914   bytes/write .\n         During   symbol   reading ,  unexpected   overlap   between :\n         ( A )  section   ` . text   from   `~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky . elf  [ 0x0 ,  0x5c84 )\n         ( B )  section   `*COM*   from   `~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky . elf  [ 0x0 ,  0x0 ).\n         Will   ignore   section   B .\n\n         ***   Resetting   target   *** \n         Resetting   target \n\n         ***   Halting   target   ***    Type 'c' to continue. The LED on the board will start to blink. You will also see some activity in the terminal showing the open J-Link GDB server connection. The LED will continue to blink after you quit out of that connection.           ( gdb )  c \n         Continuing .", 
            "title": "Step by Step Instructions to build image"
        }, 
        {
            "location": "/os/tutorials/arduino_zero/", 
            "text": "Running Mynewt on Arduino Zero\n\n\nThis tutorial describes how to run Mynewt OS on Arduino Zero.  \n\n\nPrerequisites\n\n\nBefore tackling this tutorial, it's best to read about Mynewt in the \nIntroduction\n section of this documentation.\n\n\nEquipment\n\n\nYou will need the following equipment\n\n\n\n\nAn Arduino Zero board.  NOTE: There are many flavors of Arduino. Ensure that \nyou have an Arduino Zero. See below for the verions of Arduino Zero that are\ncompatible with this tutorial\n\n\nA computer that can connect to the Arduino Zero over USB\n\n\nA USB cable (Type A to micro B) that can connect the computer to the Arduino\n\n\nThe Mynewt Release\n\n\n\n\nArduino Boards\n\n\nThis tutorial has been tested on the following two Arduino Zero boards.\n\n\n\n\n\n\nSteps\n\n\nFollow these simple steps and your board will be blinking in no time!\n\n\nInstall Mynewt and Newt\n\n\nIf you have not already done so, install Newt as shown in the \nNewt install tutorial\n and cloned the Mynewt OS repository as shown in the \nGet Started tutorial for Blinky\n\n\nFetch External Packages for Atmel SAMD21\n\n\nMynewt uses source code provided directly from the chip manufacturer for \nlow level operations. This code is licensed only for Atmel parts, and \ncannot live in the Apache Mynewt repository. Fetch the package from \nthe runtime github repository.\n\n\nTo fetch the package from the runtime git repository, you need to add \nthe repository to the \nproject.yml\n file in your base project directory.\n\n\nHere is an example \nproject.yml\n file with the Arduino Zero repository\nadded:\n\n\n$ more project.yml \nproject.name: \nmy_project\n\n\nproject.repositories:\n    - apache-mynewt-core\n    - mynewt_arduino_zero\n\nrepository.apache-mynewt-core:\n    type: github\n    vers: 0-latest\n    user: apache\n    repo: incubator-mynewt-core\n\nrepository.mynewt_arduino_zero:\n    type: github\n    vers: 0-latest\n    user: runtimeinc\n    repo: mynewt_arduino_zero\n$ \n\n\n\n\n\nIn the above, the sections with \nmynewt_arduino_zero\n need to be added to \nyour project file.\n\n\nOnce you've edited your \nproject.yml\n file, the next step is to install the \nproject dependencies, this can be done with the \nnewt install\n command \n(to see more output, provide the \n-v\n verbose option.): \n\n\n$ newt install \napache-mynewt-core\nmynewt_arduino_zero\n$\n\n\n\n\n\nCreate your bootloader Target\n\n\nNext, you need to tell Newt what to build.  For the Arduino Zero, we are going to \ngenerate both a bootloader, and an image target.\n\n\nTo generate the bootloader target, you need to specify the following options:\n\n\n$ newt target create arduino_boot \nTarget targets/arduino_boot successfully created\n$ newt target set arduino_boot bsp=@mynewt_arduino_zero/hw/bsp/arduino_zero \nTarget targets/arduino_boot successfully set target.bsp to @mynewt_arduino_zero/hw/bsp/arduino_zero\n$ newt target set arduino_boot app=@apache-mynewt-core/apps/boot \nTarget targets/arduino_boot successfully set target.app to @apache-mynewt-core/apps/boot\n$ newt target set arduino_boot features=arduino_zero_pro \nTarget targets/arduino_boot successfully set pkg.features to arduino_zero_pro\n\n\n\n\n\nThese commands do a few things: \n\n\n\n\nCreate a target named \narduino_boot\n, in order to build the Arduino Zero Bootloader.\n\n\nSet the application for the \narduino_boot\n target to the default Apache Mynewt \n    bootloader (\n@apache-mynewt-core/apps/boot\n)\n\n\nSet the board support package for the target to \n    \n@mynewt_arduino_zero/hw/bsp/arduino_zero\n.  This is a reference to the downloaded \n    Arduino Zero support from Github.\n\n\nTells the Board Support Package to enable support for the Arduino Zero Pro, and not \n    the Arduino Zero.  This is done through setting a build feature.  If you are building \n    for an Arduino Zero, and not a Zero Pro, this feature should be set to \narduino_zero\n.\n\n\n\n\nOnce you've configured the bootloader target, the next step is to build the bootloader for\nyour Arduino, you can do this by using the \nnewt build\n command:\n\n\n$ newt build arduino_boot \nCompiling asprintf.c\nCompiling atoi.c\nCompiling atol.c\nCompiling atoll.c\nCompiling bsearch.c\nCompiling bzero.c\nCompiling calloc.c\nCompiling fgets.c\nCompiling inline.c\n\nsnip\n\nApp successfully built: myproject/bin/arduino_boot/apps/boot/boot.elf\n\n\n\n\n\nIf this command finishes successfully, you have successfully built the Arduino \nbootloader, and the next step is to build your application for the Arduino \nboard.\n\n\nTo create and download your application, you create another target, this one pointing\nto the application you want to download to the Arduino board.  In this tutorial, \nwe will use the default application that comes with your project, \napps/blinky\n:\n\n\n$ newt target create arduino_blinky \nTarget targets/arduino_blinky successfully created\n$ newt target set arduino_blinky app=apps/blinky \nTarget targets/arduino_blinky successfully set target.app to apps/blinky\n$ newt target set arduino_blinky bsp=@mynewt_arduino_zero/hw/bsp/arduino_zero\nTarget targets/arduino_blinky successfully set target.bsp to @mynewt_arduino_zero/hw/bsp/arduino_zero\n$ newt target set arduino_blinky build_profile=debug \nTarget targets/arduino_blinky successfully set target.build_profile to debug\n$ newt target set arduino_blinky features=arduino_zero_pro \nTarget targets/arduino_blinky successfully set pkg.features to arduino_zero_pro\n$ \n\n\n\n\n\nYou can now build the target, with \nnewt build\n: \n\n\n$ newt build arduino_blinky \nCompiling main.c\nArchiving blinky.a\nCompiling cons_fmt.c\nCompiling cons_tty.c\nArchiving full.a\nCompiling case.c\nCompiling suite.c\nCompiling testutil.c\nArchiving testutil.a\n\nsnip\n\nApp successfully built: myproject/bin/arduino_blinky/apps/blinky/blinky.elf\n\n\n\n\n\nCongratulations!  You have successfully built your application, now it's \ntime to load the bootloader and application onto the target.\n\n\nConnect the Target\n\n\nConnect your computer to the Arduino Zero (from now on we'll call this the \ntarget) with the Micro-USB cable through the Programming Port as shown below. \nMynewt will download and debug the target through this port. You should see a \nlittle green LED come on. That means the board has power.\n\n\nNo external debugger is required.  The Arduino Zero comes with an internal\ndebugger that can be accessed by Mynewt.\n\n\nA image below shows the Arduino Zero Programming Port.\n\n\n\n\n\n\nDownload the Bootloader\n\n\nExecute the command to download the bootloader. \n\n\n    \n$\n \nnewt\n \nload\n \narduino_boot\n\n\n\n\n\n\nIf the newt tool finishes without error, that means the bootloader has been \nsuccessfully loaded onto the target.\n\n\nRun the Image\n\n\nNow that the bootloader is downloaded to the target, the next step is to load \nyour image onto the Arduino Zero.  The easiest way to do this, is to use the \n\nnewt run\n command.  \nnewt run\n will automatically rebuild your program\n(if necessary), create an image, and load it onto the target device.\n\n\nHere, we will load our \narduino_blinky\n target onto the device, and we \nshould see it run:\n\n\n$ newt run arduino_blinky 0.0.0 \nDebugging myproject/bin/arduino_blinky/apps/blinky/blinky.elf\nOpen On-Chip Debugger 0.9.0 (2015-09-23-21:46)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.org/doc/doxygen/bugs.html\nInfo : only one transport option; autoselect \nswd\n\nadapter speed: 500 kHz\nadapter_nsrst_delay: 100\ncortex_m reset_config sysresetreq\nInfo : CMSIS-DAP: SWD  Supported\nInfo : CMSIS-DAP: JTAG Supported\nInfo : CMSIS-DAP: Interface Initialised (SWD)\nInfo : CMSIS-DAP: FW Version = 01.1F.0118\nInfo : SWCLK/TCK = 1 SWDIO/TMS = 1 TDI = 1 TDO = 1 nTRST = 0 nRESET = 1\nInfo : CMSIS-DAP: Interface ready\nInfo : clock speed 500 kHz\nInfo : SWD IDCODE 0x0bc11477\nInfo : at91samd21g18.cpu: hardware has 4 breakpoints, 2 watchpoints\nGNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later \nhttp://gnu.org/licenses/gpl.html\n\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \nshow copying\n\nand \nshow warranty\n for details.\nThis GDB was configured as \n--host=x86_64-apple-darwin10 --target=arm-none-eabi\n.\nType \nshow configuration\n for configuration details.\nFor bug reporting instructions, please see:\n\nhttp://www.gnu.org/software/gdb/bugs/\n.\nFind the GDB manual and other documentation resources online at:\n\nhttp://www.gnu.org/software/gdb/documentation/\n.\nFor help, type \nhelp\n.\nType \napropos word\n to search for commands related to \nword\n...\nReading symbols from myproject/bin/arduino_blinky/apps/blinky/blinky.elf...done.\ntarget state: halted\ntarget halted due to debug-request, current mode: Thread \nxPSR: 0x21000000 pc: 0x0000030e msp: 0x20008000\nInfo : accepting \ngdb\n connection on tcp/3333\nInfo : SAMD MCU: SAMD21G18A (256KB Flash, 32KB RAM)\n0x0000030e in ?? ()\n(gdb) r\nThe \nremote\n target does not support \nrun\n.  Try \nhelp target\n or \ncontinue\n.\n(gdb) c\nContinuing.\n\n\n\n\n\nNOTE:\n The 0.0.0 specified after the target name to newt run, is the version \nof the image to load.  If you are not providing remote upgrade, and are just \ndeveloping locally, you can provide 0.0.0 for every image version.\n\n\nIf you want the image to run without the debugger connected, simply quit the \ndebugger and restart the board.  The image you programmed will come and run on the \nArduino on next boot!  \n\n\nWatch the LED blink\n\n\nCongratulations! You have created a Mynewt operating system running on the \nArduino Zero. The LED right next to the power LED should be blinking. It is toggled by one task running on the Mynewt OS.", 
            "title": "Blinky on Arduino Zero"
        }, 
        {
            "location": "/os/tutorials/arduino_zero/#running-mynewt-on-arduino-zero", 
            "text": "This tutorial describes how to run Mynewt OS on Arduino Zero.", 
            "title": "Running Mynewt on Arduino Zero"
        }, 
        {
            "location": "/os/tutorials/arduino_zero/#prerequisites", 
            "text": "Before tackling this tutorial, it's best to read about Mynewt in the  Introduction  section of this documentation.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/os/tutorials/arduino_zero/#equipment", 
            "text": "You will need the following equipment   An Arduino Zero board.  NOTE: There are many flavors of Arduino. Ensure that \nyou have an Arduino Zero. See below for the verions of Arduino Zero that are\ncompatible with this tutorial  A computer that can connect to the Arduino Zero over USB  A USB cable (Type A to micro B) that can connect the computer to the Arduino  The Mynewt Release", 
            "title": "Equipment"
        }, 
        {
            "location": "/os/tutorials/arduino_zero/#arduino-boards", 
            "text": "This tutorial has been tested on the following two Arduino Zero boards.", 
            "title": "Arduino Boards"
        }, 
        {
            "location": "/os/tutorials/arduino_zero/#steps", 
            "text": "Follow these simple steps and your board will be blinking in no time!", 
            "title": "Steps"
        }, 
        {
            "location": "/os/tutorials/arduino_zero/#install-mynewt-and-newt", 
            "text": "If you have not already done so, install Newt as shown in the  Newt install tutorial  and cloned the Mynewt OS repository as shown in the  Get Started tutorial for Blinky", 
            "title": "Install Mynewt and Newt"
        }, 
        {
            "location": "/os/tutorials/arduino_zero/#fetch-external-packages-for-atmel-samd21", 
            "text": "Mynewt uses source code provided directly from the chip manufacturer for \nlow level operations. This code is licensed only for Atmel parts, and \ncannot live in the Apache Mynewt repository. Fetch the package from \nthe runtime github repository.  To fetch the package from the runtime git repository, you need to add \nthe repository to the  project.yml  file in your base project directory.  Here is an example  project.yml  file with the Arduino Zero repository\nadded:  $ more project.yml \nproject.name:  my_project \n\nproject.repositories:\n    - apache-mynewt-core\n    - mynewt_arduino_zero\n\nrepository.apache-mynewt-core:\n    type: github\n    vers: 0-latest\n    user: apache\n    repo: incubator-mynewt-core\n\nrepository.mynewt_arduino_zero:\n    type: github\n    vers: 0-latest\n    user: runtimeinc\n    repo: mynewt_arduino_zero\n$   In the above, the sections with  mynewt_arduino_zero  need to be added to \nyour project file.  Once you've edited your  project.yml  file, the next step is to install the \nproject dependencies, this can be done with the  newt install  command \n(to see more output, provide the  -v  verbose option.):   $ newt install \napache-mynewt-core\nmynewt_arduino_zero\n$", 
            "title": "Fetch External Packages for Atmel SAMD21"
        }, 
        {
            "location": "/os/tutorials/arduino_zero/#create-your-bootloader-target", 
            "text": "Next, you need to tell Newt what to build.  For the Arduino Zero, we are going to \ngenerate both a bootloader, and an image target.  To generate the bootloader target, you need to specify the following options:  $ newt target create arduino_boot \nTarget targets/arduino_boot successfully created\n$ newt target set arduino_boot bsp=@mynewt_arduino_zero/hw/bsp/arduino_zero \nTarget targets/arduino_boot successfully set target.bsp to @mynewt_arduino_zero/hw/bsp/arduino_zero\n$ newt target set arduino_boot app=@apache-mynewt-core/apps/boot \nTarget targets/arduino_boot successfully set target.app to @apache-mynewt-core/apps/boot\n$ newt target set arduino_boot features=arduino_zero_pro \nTarget targets/arduino_boot successfully set pkg.features to arduino_zero_pro  These commands do a few things:    Create a target named  arduino_boot , in order to build the Arduino Zero Bootloader.  Set the application for the  arduino_boot  target to the default Apache Mynewt \n    bootloader ( @apache-mynewt-core/apps/boot )  Set the board support package for the target to \n     @mynewt_arduino_zero/hw/bsp/arduino_zero .  This is a reference to the downloaded \n    Arduino Zero support from Github.  Tells the Board Support Package to enable support for the Arduino Zero Pro, and not \n    the Arduino Zero.  This is done through setting a build feature.  If you are building \n    for an Arduino Zero, and not a Zero Pro, this feature should be set to  arduino_zero .   Once you've configured the bootloader target, the next step is to build the bootloader for\nyour Arduino, you can do this by using the  newt build  command:  $ newt build arduino_boot \nCompiling asprintf.c\nCompiling atoi.c\nCompiling atol.c\nCompiling atoll.c\nCompiling bsearch.c\nCompiling bzero.c\nCompiling calloc.c\nCompiling fgets.c\nCompiling inline.c snip \nApp successfully built: myproject/bin/arduino_boot/apps/boot/boot.elf  If this command finishes successfully, you have successfully built the Arduino \nbootloader, and the next step is to build your application for the Arduino \nboard.  To create and download your application, you create another target, this one pointing\nto the application you want to download to the Arduino board.  In this tutorial, \nwe will use the default application that comes with your project,  apps/blinky :  $ newt target create arduino_blinky \nTarget targets/arduino_blinky successfully created\n$ newt target set arduino_blinky app=apps/blinky \nTarget targets/arduino_blinky successfully set target.app to apps/blinky\n$ newt target set arduino_blinky bsp=@mynewt_arduino_zero/hw/bsp/arduino_zero\nTarget targets/arduino_blinky successfully set target.bsp to @mynewt_arduino_zero/hw/bsp/arduino_zero\n$ newt target set arduino_blinky build_profile=debug \nTarget targets/arduino_blinky successfully set target.build_profile to debug\n$ newt target set arduino_blinky features=arduino_zero_pro \nTarget targets/arduino_blinky successfully set pkg.features to arduino_zero_pro\n$   You can now build the target, with  newt build :   $ newt build arduino_blinky \nCompiling main.c\nArchiving blinky.a\nCompiling cons_fmt.c\nCompiling cons_tty.c\nArchiving full.a\nCompiling case.c\nCompiling suite.c\nCompiling testutil.c\nArchiving testutil.a snip \nApp successfully built: myproject/bin/arduino_blinky/apps/blinky/blinky.elf  Congratulations!  You have successfully built your application, now it's \ntime to load the bootloader and application onto the target.", 
            "title": "Create your bootloader Target"
        }, 
        {
            "location": "/os/tutorials/arduino_zero/#connect-the-target", 
            "text": "Connect your computer to the Arduino Zero (from now on we'll call this the \ntarget) with the Micro-USB cable through the Programming Port as shown below. \nMynewt will download and debug the target through this port. You should see a \nlittle green LED come on. That means the board has power.  No external debugger is required.  The Arduino Zero comes with an internal\ndebugger that can be accessed by Mynewt.  A image below shows the Arduino Zero Programming Port.", 
            "title": "Connect the Target"
        }, 
        {
            "location": "/os/tutorials/arduino_zero/#download-the-bootloader", 
            "text": "Execute the command to download the bootloader.        $   newt   load   arduino_boot   If the newt tool finishes without error, that means the bootloader has been \nsuccessfully loaded onto the target.", 
            "title": "Download the Bootloader"
        }, 
        {
            "location": "/os/tutorials/arduino_zero/#run-the-image", 
            "text": "Now that the bootloader is downloaded to the target, the next step is to load \nyour image onto the Arduino Zero.  The easiest way to do this, is to use the  newt run  command.   newt run  will automatically rebuild your program\n(if necessary), create an image, and load it onto the target device.  Here, we will load our  arduino_blinky  target onto the device, and we \nshould see it run:  $ newt run arduino_blinky 0.0.0 \nDebugging myproject/bin/arduino_blinky/apps/blinky/blinky.elf\nOpen On-Chip Debugger 0.9.0 (2015-09-23-21:46)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.org/doc/doxygen/bugs.html\nInfo : only one transport option; autoselect  swd \nadapter speed: 500 kHz\nadapter_nsrst_delay: 100\ncortex_m reset_config sysresetreq\nInfo : CMSIS-DAP: SWD  Supported\nInfo : CMSIS-DAP: JTAG Supported\nInfo : CMSIS-DAP: Interface Initialised (SWD)\nInfo : CMSIS-DAP: FW Version = 01.1F.0118\nInfo : SWCLK/TCK = 1 SWDIO/TMS = 1 TDI = 1 TDO = 1 nTRST = 0 nRESET = 1\nInfo : CMSIS-DAP: Interface ready\nInfo : clock speed 500 kHz\nInfo : SWD IDCODE 0x0bc11477\nInfo : at91samd21g18.cpu: hardware has 4 breakpoints, 2 watchpoints\nGNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later  http://gnu.org/licenses/gpl.html \nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type  show copying \nand  show warranty  for details.\nThis GDB was configured as  --host=x86_64-apple-darwin10 --target=arm-none-eabi .\nType  show configuration  for configuration details.\nFor bug reporting instructions, please see: http://www.gnu.org/software/gdb/bugs/ .\nFind the GDB manual and other documentation resources online at: http://www.gnu.org/software/gdb/documentation/ .\nFor help, type  help .\nType  apropos word  to search for commands related to  word ...\nReading symbols from myproject/bin/arduino_blinky/apps/blinky/blinky.elf...done.\ntarget state: halted\ntarget halted due to debug-request, current mode: Thread \nxPSR: 0x21000000 pc: 0x0000030e msp: 0x20008000\nInfo : accepting  gdb  connection on tcp/3333\nInfo : SAMD MCU: SAMD21G18A (256KB Flash, 32KB RAM)\n0x0000030e in ?? ()\n(gdb) r\nThe  remote  target does not support  run .  Try  help target  or  continue .\n(gdb) c\nContinuing.  NOTE:  The 0.0.0 specified after the target name to newt run, is the version \nof the image to load.  If you are not providing remote upgrade, and are just \ndeveloping locally, you can provide 0.0.0 for every image version.  If you want the image to run without the debugger connected, simply quit the \ndebugger and restart the board.  The image you programmed will come and run on the \nArduino on next boot!", 
            "title": "Run the Image"
        }, 
        {
            "location": "/os/tutorials/arduino_zero/#watch-the-led-blink", 
            "text": "Congratulations! You have created a Mynewt operating system running on the \nArduino Zero. The LED right next to the power LED should be blinking. It is toggled by one task running on the Mynewt OS.", 
            "title": "Watch the LED blink"
        }, 
        {
            "location": "/os/tutorials/unit_test/", 
            "text": "How To Write A Test Suite for Your Package\n\n\nThis document presents a tutorial which guides the reader through writing\na test suite for a Mynewt package (new or existing).\n\n\nIntroduction\n\n\nWriting a test suite involves using the \nlibs/testutil\n\n package within Mynewt core os. The \ntestutil\n library provides the interface to \nthe \nnewt\n command tool and also provides the compile time hooks to include\ntest suites into your code.  Review the \n[\ntestutil\n introduction page ] (../modules/testutil/testutil.md)\nto learn about how the library works.\n\n\nIdentify Your Package\n\n\nIdentify the package for which you are writing a test suite.  For this example\nwe will use \nlibs/json\n.  To create a new package, see \nthis Tutorial\n.\n\n\nModify Pkg.yml\n\n\nEdit the package (\npkg.yml\n) file for your package and add the test dependency\nfor the Mynewt core OS \nlibs/testutil\n.\n\n\npkg\n.\ndeps\n.\nTEST\n:\n   \n-\n \nlibs/testutil\n\n\n\n\n\n\nCreate Your Test Suite Template\n\n\nCreate a subdirectory \ntest\n under your package main directory. \nCreate a file pair for your test code and header files within the \ntest\n\ndirectory created above.  Below shows the \nlibs/json\n directory within the \nMynewt core, including the test directory. In this example, we used the \nconvention \ntest_xxx.c/h\n (in this case \ntest_json\n).\n\n\n\u251c\u2500\u2500\n \nMSJSON_COPYING\n\n\n\u251c\u2500\u2500\n \ninclude\n\n\n\u2502\u00a0\u00a0\n \n\u2514\u2500\u2500\n \njson\n\n\n\u2502\u00a0\u00a0\n     \n\u2514\u2500\u2500\n \njson\n.\nh\n\n\n\u251c\u2500\u2500\n \npkg\n.\nyml\n\n\n\u2514\u2500\u2500\n \nsrc\n\n    \n\u251c\u2500\u2500\n \njson_decode\n.\nc\n\n    \n\u251c\u2500\u2500\n \njson_encode\n.\nc\n\n    \n\u2514\u2500\u2500\n \ntest\n\n        \n\u251c\u2500\u2500\n \ntest_json\n.\nc\n\n        \n\u2514\u2500\u2500\n \ntest_json\n.\nh\n\n\n\n\n\n\nCreate Your Test Suite Code\n\n\nEdit the \ntest_json.c\n file and add your test suite definition.  NOTE that \nthe test suite code requires \n#include \ntestutil/testutil.h\n to get the \nMynewt testutil definitions.\n\n\nYour test suite \ntest_json.c\n file contains at a minimum two functions:\n\n\n\n\nA test Suite which is empty for now, but will contain calls to your test\ncases.  \n\n\nA main function which must be \n#ifdef\n'd using \nMYNEWT_SELFTEST\n to ensure\nthat is does not get compiled in when this test suite is run with \ntest suites from other packages \n\n\n\n\nBelow shows the contents of the \ntest_json.c\n file.\n\n\n#include \ntestutil/testutil.h\n\n\n\nTEST_SUITE\n(\ntest_json_suite\n) {\n    \n/* empty for now, add test cases later */\n\n}\n\n\n#ifdef MYNEWT_SELFTEST\n\n\nint\n\n\nmain\n(\nint\n \nargc\n, \nchar\n \n**argv\n)\n{\n    \ntu_config\n.\ntc_print_results\n \n=\n \n1\n;\n    \ntu_init\n();\n    \ntest_json_suite\n();\n    \nreturn\n \ntu_any_failed\n;\n}\n\n#endif\n\n\n\n\n\n\nTry It Out\n\n\nAt this point, you have a working test suite with \nno\n tests.\n\nThis will by default pass the test.  Your output will look\nsomething like this.\n\n\nYou can use the \nnewt test\n command to run the unit tests for any package.\n\nJust include the package name.  These unit tests run via the project \n\nunittest\n which is a native project automatically included in the core\nos package.  Below shows some of the test output of this command.\n\n\n$\n \nnewt\n \ntest\n \nlibs/json\n\n\nArchiving\n \nutil\n.\na\n\n\nLinking\n \ntest_json\n\n\nTesting\n \npackage\n \nlibs/json\n\n\nTest\n ...\n/bin/unittest/libs/json/test_json\n \nok!\n\n\n\n\n\n\nCreate a Test\n\n\nTo create a test within your test suite, there are two things to do.\n\n\n\n\nAdd the functions to your test suite\n\n\nImplement the function using the \ntestutil\n macros\n\n\n\n\nFor this tutorial we will create two functions: one to test a simple json\nencode and one to test the decode of this simple message to ensure its \ncoherent.\n\n\nFollow These steps;\n\n\n1. Create function prototypes in \ntest_json.h\n for your test functions. \nA macro in \ntestutil.h\n hides the actual prototype, but as of this writing\nthe prototype is \nint test_func(void);\n.  \n\n\n#ifndef TEST_JSON_H\n\n\n#define TEST_JSON_H\n\n\n\nTEST_CASE_DECL\n(\ntest_json_simple_encode\n);\n\nTEST_CASE_DECL\n(\ntest_json_simple_decode\n);\n\n\n#endif /* TEST_JSON_H \n\n\n\n\n\n\n2. create a new file \ntest_json_simple.c\n to define these two functions.  For\nnow you can stub these functions. Below shows the contents of this file. \nThe functions are defined using macros which reference back to the \n\ntestutil\n library so the test can be enumerated and recorded automatically.\n\n\n#include \ntestutil/testutil.h\n\n\n#include \ntest_json.h\n\n\n\nTEST_CASE\n(\ntest_json_simple_encode\n) {\n}\n\n\nTEST_CASE\n(\ntest_json_simple_decode\n) {\n}\n\n#endif /* TEST_JSON_H \n\n\n\n\n\n\n3. Add the tests to your test suite in \ntest_json.c\n as shown below.\n\n\nTEST_SUITE\n(\ntest_json_suite\n) {\n    \ntest_json_simple_encode\n();\n    \ntest_json_simple_decode\n();\n}\n\n\n\n\n\nYour test suite should still pass as shown below\n\n\n$newt\n \ntest\n \nlibs/json\n\n\nTesting\n \npackage\n \nlibs/json\n\n\nTest\n ...\n/bin/unittest/libs/json/test_json\n \nok!\n\n\n\n\n\n\nAdd Contents to your Tests\n\n\nAt this point, you can add contents to your test and verify that \nthe test suites pass.  For now, lets just add a simple failure to show\nwhat it would look like when running from Newt.\n\n\n\n\nEdit \ntest_json_simple.c\n and add a \nTEST_ASSERT\n to a test funtion. The\ntest assert will fail if its argument is \nfalse\n.\n\n\n\n\nTEST_CASE\n(\ntest_json_simple_encode\n) {\n    \nTEST_ASSERT\n(\n0\n);\n}\n\n\n\n\n\nWhen running newt, you will see the test suite fails with something like\nthe message shown below.\n\n\nTesting\n \npackage\n \nlibs/json\n\n[\nFAIL\n] \ntest_json_suite/\n(\nnull\n) \n|test_json_simple\n.\nc\n:\n24\n|\n \nfailed\n \nassertion\n: \n0\n\n\nError\n: \nTest\n \ncrashed\n: ..\n/bin/unittest/libs/json/test_json\n\n\nexit\n \nstatus\n \n1\n\n\n\n\n\n\nCongratulations\n\n\nNow you can begin the work of adding your test cases and test.\n\n\nTesting on your target", 
            "title": "Unit Testing a Package"
        }, 
        {
            "location": "/os/tutorials/unit_test/#how-to-write-a-test-suite-for-your-package", 
            "text": "This document presents a tutorial which guides the reader through writing\na test suite for a Mynewt package (new or existing).", 
            "title": "How To Write A Test Suite for Your Package"
        }, 
        {
            "location": "/os/tutorials/unit_test/#introduction", 
            "text": "Writing a test suite involves using the  libs/testutil \n package within Mynewt core os. The  testutil  library provides the interface to \nthe  newt  command tool and also provides the compile time hooks to include\ntest suites into your code.  Review the \n[ testutil  introduction page ] (../modules/testutil/testutil.md)\nto learn about how the library works.", 
            "title": "Introduction"
        }, 
        {
            "location": "/os/tutorials/unit_test/#identify-your-package", 
            "text": "Identify the package for which you are writing a test suite.  For this example\nwe will use  libs/json .  To create a new package, see  this Tutorial .", 
            "title": "Identify Your Package"
        }, 
        {
            "location": "/os/tutorials/unit_test/#modify-pkgyml", 
            "text": "Edit the package ( pkg.yml ) file for your package and add the test dependency\nfor the Mynewt core OS  libs/testutil .  pkg . deps . TEST :\n    -   libs/testutil", 
            "title": "Modify Pkg.yml"
        }, 
        {
            "location": "/os/tutorials/unit_test/#create-your-test-suite-template", 
            "text": "Create a subdirectory  test  under your package main directory. \nCreate a file pair for your test code and header files within the  test \ndirectory created above.  Below shows the  libs/json  directory within the \nMynewt core, including the test directory. In this example, we used the \nconvention  test_xxx.c/h  (in this case  test_json ).  \u251c\u2500\u2500   MSJSON_COPYING  \u251c\u2500\u2500   include  \u2502\u00a0\u00a0   \u2514\u2500\u2500   json  \u2502\u00a0\u00a0       \u2514\u2500\u2500   json . h  \u251c\u2500\u2500   pkg . yml  \u2514\u2500\u2500   src \n     \u251c\u2500\u2500   json_decode . c \n     \u251c\u2500\u2500   json_encode . c \n     \u2514\u2500\u2500   test \n         \u251c\u2500\u2500   test_json . c \n         \u2514\u2500\u2500   test_json . h", 
            "title": "Create Your Test Suite Template"
        }, 
        {
            "location": "/os/tutorials/unit_test/#create-your-test-suite-code", 
            "text": "Edit the  test_json.c  file and add your test suite definition.  NOTE that \nthe test suite code requires  #include  testutil/testutil.h  to get the \nMynewt testutil definitions.  Your test suite  test_json.c  file contains at a minimum two functions:   A test Suite which is empty for now, but will contain calls to your test\ncases.    A main function which must be  #ifdef 'd using  MYNEWT_SELFTEST  to ensure\nthat is does not get compiled in when this test suite is run with \ntest suites from other packages    Below shows the contents of the  test_json.c  file.  #include  testutil/testutil.h  TEST_SUITE ( test_json_suite ) {\n     /* empty for now, add test cases later */ \n} #ifdef MYNEWT_SELFTEST  int  main ( int   argc ,  char   **argv )\n{\n     tu_config . tc_print_results   =   1 ;\n     tu_init ();\n     test_json_suite ();\n     return   tu_any_failed ;\n} #endif", 
            "title": "Create Your Test Suite Code"
        }, 
        {
            "location": "/os/tutorials/unit_test/#try-it-out", 
            "text": "At this point, you have a working test suite with  no  tests. \nThis will by default pass the test.  Your output will look\nsomething like this.  You can use the  newt test  command to run the unit tests for any package. \nJust include the package name.  These unit tests run via the project  unittest  which is a native project automatically included in the core\nos package.  Below shows some of the test output of this command.  $   newt   test   libs/json  Archiving   util . a  Linking   test_json  Testing   package   libs/json  Test  ... /bin/unittest/libs/json/test_json   ok!", 
            "title": "Try It Out"
        }, 
        {
            "location": "/os/tutorials/unit_test/#create-a-test", 
            "text": "To create a test within your test suite, there are two things to do.   Add the functions to your test suite  Implement the function using the  testutil  macros   For this tutorial we will create two functions: one to test a simple json\nencode and one to test the decode of this simple message to ensure its \ncoherent.  Follow These steps;  1. Create function prototypes in  test_json.h  for your test functions. \nA macro in  testutil.h  hides the actual prototype, but as of this writing\nthe prototype is  int test_func(void); .    #ifndef TEST_JSON_H  #define TEST_JSON_H  TEST_CASE_DECL ( test_json_simple_encode ); TEST_CASE_DECL ( test_json_simple_decode ); #endif /* TEST_JSON_H    2. create a new file  test_json_simple.c  to define these two functions.  For\nnow you can stub these functions. Below shows the contents of this file. \nThe functions are defined using macros which reference back to the  testutil  library so the test can be enumerated and recorded automatically.  #include  testutil/testutil.h  #include  test_json.h  TEST_CASE ( test_json_simple_encode ) {\n} TEST_CASE ( test_json_simple_decode ) {\n} #endif /* TEST_JSON_H    3. Add the tests to your test suite in  test_json.c  as shown below.  TEST_SUITE ( test_json_suite ) {\n     test_json_simple_encode ();\n     test_json_simple_decode ();\n}  Your test suite should still pass as shown below  $newt   test   libs/json  Testing   package   libs/json  Test  ... /bin/unittest/libs/json/test_json   ok!", 
            "title": "Create a Test"
        }, 
        {
            "location": "/os/tutorials/unit_test/#add-contents-to-your-tests", 
            "text": "At this point, you can add contents to your test and verify that \nthe test suites pass.  For now, lets just add a simple failure to show\nwhat it would look like when running from Newt.   Edit  test_json_simple.c  and add a  TEST_ASSERT  to a test funtion. The\ntest assert will fail if its argument is  false .   TEST_CASE ( test_json_simple_encode ) {\n     TEST_ASSERT ( 0 );\n}  When running newt, you will see the test suite fails with something like\nthe message shown below.  Testing   package   libs/json \n[ FAIL ]  test_json_suite/ ( null )  |test_json_simple . c : 24 |   failed   assertion :  0  Error :  Test   crashed : .. /bin/unittest/libs/json/test_json  exit   status   1", 
            "title": "Add Contents to your Tests"
        }, 
        {
            "location": "/os/tutorials/unit_test/#congratulations", 
            "text": "Now you can begin the work of adding your test cases and test.", 
            "title": "Congratulations"
        }, 
        {
            "location": "/os/tutorials/unit_test/#testing-on-your-target", 
            "text": "", 
            "title": "Testing on your target"
        }, 
        {
            "location": "/os/tutorials/air_quality_sensor/", 
            "text": "Air quality sensor project\n\n\nSetting up source tree for stuff you need\n\n\nTo start with, you need to create a new project under which you will do this development. So you type in:\n\n\n    $ mkdir $HOME/src\n    $ cd $HOME/src\n    $ newt new air_quality\n\n\n\n\n\nLet's say you are using STM32F3discovery board as the platform. You know you need the board support package for that hardware. You can look up its location, add it your project, and fetch that along with the core OS components.\n\n\nTo make this happen, you'll need to modify the project.yml in your project's root directory.\n\n\n    [user@IsMyLaptop:~/src/air_quality]$ emacs project.yml \n\n    [user@IsMyLaptop:~/src/air_quality]$ cat project.yml\n    project.name: \nair_quality\n\n\n    project.repositories:\n        - apache-mynewt-core\n        - mynewt_stm32f3\n\n    # Use github\ns distribution mechanism for core ASF libraries.\n    # This provides mirroring automatically for us.\n    #\n    repository.apache-mynewt-core:\n        type: github\n        vers: 0-latest\n        user: apache\n        repo: incubator-mynewt-core\n\n    repository.mynewt_stm32f3:\n        type: github\n        vers: 0-latest\n        user: runtimeinc\n        repo: mynewt_stm32f3\n    [user@IsMyLaptop:~/src/air_quality]$ newt install\n    apache-mynewt-core\n    mynewt_stm32f3\n    [user@IsMyLaptop:~/src/air_quality]$ ls repos/\n    apache-mynewt-core  mynewt_stm32f3\n\n\n\n\n\nGood. You want to make sure you have all the needed bits for supporting your board; so you decide to build the blinky project for the platform first.\n\n\nNow create a target for it and build it. Easiest way to proceed is to copy the existing target for blinky, and modify it to build for STM32F3Discovery board.\n\n\n[user@IsMyLaptop:~/src/air_quality]$ newt target copy my_blinky_sim blink_f3\nTarget successfully copied; targets/my_blinky_sim --\n targets/blink_f3\n[user@IsMyLaptop:~/src/air_quality]$ newt target set blink_f3 bsp=@mynewt_stm32f3/hw/bsp/stm32f3discovery\nTarget targets/blink_f3 successfully set target.bsp to @mynewt_stm32f3/hw/bsp/stm32f3discovery\n[user@IsMyLaptop:~/src/air_quality]$ newt build blink_f3\nCompiling hal_bsp.c\n...\nLinking blinky.elf\nApp successfully built: /Users/user/src/air_quality/bin/blink_f3/apps/blinky/blinky.elf\n\n\n\n\n\nGood.\n\n\nYou know that this platform uses bootloader, which means you have to create a target for that too.\n\n\n[user@IsMyLaptop:~/src/air_quality]$ newt target create boot_f3\nTarget targets/boot_f3 successfully created\n[user@IsMyLaptop:~/src/air_quality]$ newt target show\n@apache-mynewt-core/targets/unittest\n    bsp=hw/bsp/native\n    build_profile=debug\n    compiler=compiler/sim\ntargets/blink_f3\n    app=apps/blinky\n    bsp=@mynewt_stm32f3/hw/bsp/stm32f3discovery\n    build_profile=debug\ntargets/boot_f3\ntargets/my_blinky_sim\n    app=apps/blinky\n    bsp=@apache-mynewt-core/hw/bsp/native\n    build_profile=debug\n[user@IsMyLaptop:~/src/air_quality]$ newt target set boot_f3 bsp=@mynewt_stm32f3/hw/bsp/stm32f3discovery\nTarget targets/boot_f3 successfully set target.bsp to @mynewt_stm32f3/hw/bsp/stm32f3discovery\n[user@IsMyLaptop:~/src/air_quality]$ newt target set boot_f3 app=@apache-mynewt-core/apps/boot\nTarget targets/boot_f3 successfully set target.app to @apache-mynewt-core/apps/boot\n[user@IsMyLaptop:~/src/air_quality]$ newt target set boot_f3 build_profile=optimized\nTarget targets/boot_f3 successfully set target.build_profile to optimized\n\n\n\n\n\nAnd then build it, and load it onto the board.\n\n\nnewt build boot_f3\n....\nLinking boot.elf\nApp successfully built: /Users/user/src/air_quality/bin/boot_f3/apps/boot/boot.elf\n[user@IsMyLaptop:~/src/air_quality]$ newt load boot_f3\n\n\n\n\n\nNext you must download the targets to board, and see that the LED actually blinks. You plug in the STM32F3 discovery board to your laptop, and say:\n\n\n[user@IsMyLaptop:~/src/air_quality]$ newt load blink_f3\nDownloading /Users/user/src/air_quality/bin/blink_f3/apps/blinky/blinky.img to 0x08009000\nOpen On-Chip Debugger 0.9.0 (2015-05-28-12:05)\n....\nxPSR: 0x01000000 pc: 0x0800026c msp: 0x10002000\nauto erase enabled\nError: couldn\nt open /Users/user/src/air_quality/bin/blink_f3/apps/blinky/blinky.img\n\nError: exit status 1\n\nload - Load app image to target for \ntarget-name\n.\n\nUsage:\n  newt load [flags]\n\nExamples:\n  newt load \ntarget-name\n\n\n\nGlobal Flags:\n  -l, --loglevel string   Log level, defaults to WARN. (default \nWARN\n)\n  -o, --outfile string    Filename to tee log output to\n  -q, --quiet             Be quiet; only display error output.\n  -s, --silent            Be silent; don\nt output anything.\n  -v, --verbose           Enable verbose output when executing commands.\nexit status 1\n\n\n\n\n\nAh. Forgot to create an image out of the blinky binary. Note that every time you want to build and load a new firmware image to target board, you need to run 'create-image' on it.\n\n\n[user@IsMyLaptop:~/src/air_quality]$ newt create-image blink_f3 0.0.1\nApp image succesfully generated: /Users/user/src/air_quality/bin/blink_f3/apps/blinky/blinky.img\nBuild manifest: /Users/user/src/air_quality/bin/blink_f3/apps/blinky/manifest.json\n[user@IsMyLaptop:~/src/air_quality]$ newt load blink_f3 0.0.1\n\n\n\n\n\nAnd it's blinking.\n\n\nShortcut for doing build/create-image/load/debug steps all in one is 'newt run' command. Check out the usage from command line help.\n\n\nCreate test project\n\n\nNow that you have your system setup, you can start creating your own stuff.\nFirst you want to create a project for yourself - you can start by getting project template from blinky, as it pretty much has what you want.\n\n\n    [user@IsMyLaptop:~/src/air_quality]$ mkdir apps/air_quality\n    [user@IsMyLaptop:~/src/air_quality]$ cp repos/apache-mynewt-core/apps/blinky/pkg.yml apps/air_quality/\n    [user@IsMyLaptop:~/src/air_quality]$ mkdir apps/air_quality/src\n    [user@IsMyLaptop:~/src/air_quality]$ cp repos/apache-mynewt-core/apps/blinky/src/main.c apps/air_quality/src/\n\n\n\n\n\nThen you modify the apps/air_quality/pkg.yml for air_quality in order to change the \npkg.name\n to be \napps/air_quality\n.\nYou also need to point the package dependencies to point to packages in apache-mynewt-core repository.\nSTM32F3discovery board has limited amount of memory, so you must also switch your libc to be baselibc, instead of the standard one.\n\n\n[user@IsMyLaptop:~/src/air_quality]$ cat apps/air_quality/pkg.yml\npkg.name: apps/air_quality\npkg.type: app\npkg.description: Air quality sensor test\npkg.keywords:\n\npkg.deps:\n    - \n@apache-mynewt-core/libs/console/full\n\n    - \n@apache-mynewt-core/libs/newtmgr\n\n    - \n@apache-mynewt-core/libs/os\n\n    - \n@apache-mynewt-core/libs/shell\n\n    - \n@apache-mynewt-core/sys/config\n\n    - \n@apache-mynewt-core/sys/log\n\n    - \n@apache-mynewt-core/sys/stats\n\n    - \n@apache-mynewt-core/libs/baselibc\n\n\n\n\n\n\nAnd create a target for it:\n\n\n[user@IsMyLaptop:~/src/air_quality]$ newt target create air_q\nTarget targets/air_q successfully created\n[user@IsMyLaptop:~/src/air_quality]$ newt target set air_q bsp=@mynewt_stm32f3/hw/bsp/stm32f3discovery\nTarget targets/air_q successfully set target.bsp to @mynewt_stm32f3/hw/bsp/stm32f3discovery\n[user@IsMyLaptop:~/src/air_quality]$ newt target set air_q app=apps/air_quality \nTarget targets/air_q successfully set target.app to apps/air_quality\n[user@IsMyLaptop:~/src/air_quality]$ newt target set air_q build_profile=debug\nTarget targets/air_q successfully set target.build_profile to debug\n[user@IsMyLaptop:~/src/air_quality]$ newt build air_q\n ....\nLinking air_quality.elf\nApp successfully built: /Users/user/src/air_quality/bin/air_q/apps/air_quality/air_quality.elf\n\n\n\n\n\nCreate packages for drivers\n\n\nOne of the sensors you want to enable is SenseAir K30, which will connect to the board over serial port.\nTo start development of the driver, you first need to create a package description for it, and add stubs for sources.\n\n\nSo you add few files. pkg.yml to describe the driver, and then header stub followed by source stub.\n\n\n[user@IsMyLaptop:~/src/air_quality]$ cat libs/my_drivers/senseair/pkg.yml\n\n\n\n\n\n#\n\n\n# Licensed to the Apache Software Foundation (ASF) under one\n\n\n# or more contributor license agreements.  See the NOTICE file\n\n\n# distributed with this work for additional information\n\n\n# regarding copyright ownership.  The ASF licenses this file\n\n\n# to you under the Apache License, Version 2.0 (the\n\n\n# \nLicense\n); you may not use this file except in compliance\n\n\n# with the License.  You may obtain a copy of the License at\n\n\n# \n\n\n#  http:\n//www.apache.org/licenses/LICENSE-2.0\n\n\n#\n\n\n# Unless required by applicable law or agreed to in writing,\n\n\n# software distributed under the License is distributed on an\n\n\n# \nAS IS\n BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n\n\n# KIND, either express or implied.  See the License for the\n\n\n# specific language governing permissions and limitations\n\n\n# under the License.\n\n\n#\n\n\npkg\n.\nname\n: \nlibs/my_drivers/senseair\n\n\npkg\n.\ndeps\n:\n    \n-\n \n@apache-mynewt-core/hw/hal\n\n\n\n\n\n\n[user@IsMyLaptop:~/src/air_quality]$ cat libs/my_drivers/senseair/include/senseair/senseair.h\n\n\n\n\n\n/*\n\n\n * Licensed to the Apache Software Foundation (ASF) under one\n\n\n * or more contributor license agreements.  See the NOTICE file\n\n\n * distributed with this work for additional information\n\n\n * regarding copyright ownership.  The ASF licenses this file\n\n\n * to you under the Apache License, Version 2.0 (the\n\n\n * \nLicense\n); you may not use this file except in compliance\n\n\n * with the License.  You may obtain a copy of the License at\n\n\n * \n\n\n *  http://www.apache.org/licenses/LICENSE-2.0\n\n\n *\n\n\n * Unless required by applicable law or agreed to in writing,\n\n\n * software distributed under the License is distributed on an\n\n\n * \nAS IS\n BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n\n\n * KIND, either express or implied.  See the License for the\n\n\n * specific language governing permissions and limitations\n\n\n * under the License.\n\n\n*/\n\n\n#ifndef _SENSEAIR_H_\n\n\n#define _SENSEAIR_H_\n\n\n\nvoid\n \nsenseair_init\n(\nvoid\n);\n\n\n#endif \n/* _SENSEAIR_H_ */\n\n\n\n\n\n\n[user@IsMyLaptop:~/src/air_quality]$ cat libs/my_drivers/senseair/src/senseair.c\n\n\n\n\n\n/**\n\n\n * Licensed to the Apache Software Foundation (ASF) under one\n\n\n * or more contributor license agreements.  See the NOTICE file\n\n\n * distributed with this work for additional information\n\n\n * regarding copyright ownership.  The ASF licenses this file\n\n\n * to you under the Apache License, Version 2.0 (the\n\n\n * \nLicense\n); you may not use this file except in compliance\n\n\n * with the License.  You may obtain a copy of the License at\n\n\n * \n\n\n *  http://www.apache.org/licenses/LICENSE-2.0\n\n\n *\n\n\n * Unless required by applicable law or agreed to in writing,\n\n\n * software distributed under the License is distributed on an\n\n\n * \nAS IS\n BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n\n\n * KIND, either express or implied.  See the License for the\n\n\n * specific language governing permissions and limitations\n\n\n * under the License.\n\n\n */\n\n\n\nvoid\n\n\nsenseair_init\n(\nvoid\n)\n{\n}\n\n\n\n\n\nAnd add dependency to this package in my project yml file.\n\n\nHere's from apps/air_quality/pkg.yml\n\n\npkg.name: apps/air_quality\npkg.type: app\npkg.description: Air quality sensor test\npkg.keywords:\n\npkg.deps:\n    - \n@apache-mynewt-core/libs/console/full\n\n    - \n@apache-mynewt-core/libs/newtmgr\n\n    - \n@apache-mynewt-core/libs/os\n\n    - \n@apache-mynewt-core/libs/shell\n\n    - \n@apache-mynewt-core/sys/config\n\n    - \n@apache-mynewt-core/sys/log\n\n    - \n@apache-mynewt-core/sys/stats\n\n    - \n@apache-mynewt-core/libs/baselibc\n\n    - libs/my_drivers/senseair\n\n\n\n\n\nAnd add a call to your main() to initialize this driver.\n\n\n    [user@IsMyLaptop:~/src/air_quality]$ diff project/blinky/src/main.c project/air_quality/src/main.c\n    28a29\n    \n #include \nsenseair/senseair.h\n\n    190a192\n    \n senseair_init();\n    [user@IsMyLaptop:~/src/air_quality\n\n\n\n\n\nAnd then build it to make sure all goes well.\n\n\n[user@IsMyLaptop:~/src/air_quality]$ newt build air_q\nCompiling senseair.c\nArchiving senseair.a\nLinking air_quality.elf\nApp successfully built: /Users/user/src/air_quality/bin/air_q/apps/air_quality/air_quality.elf\n\n\n\n\n\nAll looks good.\n\n\nAdd CLI commands for testing drivers\n\n\nWhile developing the driver, you want to issue operations from console asking it to do stuff. The way to do this is to register your command handler with shell. Whenever your custom command is issued, you can respond to it.\n\n\nThe way you do this is first adding a dependency to shell package for your senseair driver. So you change libs/my_drivers/senseair/pkg.yml to have the following:\n\n\npkg.name: libs/my_drivers/senseair\npkg.deps:\n    - \n@apache-mynewt-core/hw/hal\n\n    - \n@apache-mynewt-core/libs/shell\n\n\n\n\n\n\nAnd then register your shell command in \nsenseair_init()\n.\n\n\n[user@IsMyLaptop:~/src/air_quality]$ cat libs/my_drivers/senseair/src/senseair.c\n ....\n\n\n\n\n\n#include \nshell/shell.h\n\n\n#include \nconsole/console.h\n\n\n\nstatic\n \nint\n \nsenseair_shell_func\n(\nint\n \nargc\n, \nchar\n \n**argv\n);\n\nstatic\n \nstruct\n \nshell_cmd\n \nsenseair_cmd\n \n=\n {\n    .\nsc_cmd\n \n=\n \nsenseair\n,\n    .\nsc_cmd_func\n \n=\n \nsenseair_shell_func\n,\n};\n\n\nvoid\n\n\nsenseair_init\n(\nvoid\n)\n{\n    \nint\n \nrc\n;\n\n    \nrc\n \n=\n \nshell_cmd_register\n(\nsenseair_cmd\n);\n    \nassert\n(\nrc\n \n==\n \n0\n);\n}\n\n\nstatic\n \nint\n\n\nsenseair_shell_func\n(\nint\n \nargc\n, \nchar\n \n**argv\n)\n{\n    \nconsole_printf\n(\nYay! Somebody called!\\n\n);\n    \nreturn\n \n0\n;\n}\n\n\n\n\n\nThen you build this, download to target, and start minicom on your console port.\n\n\n    [user@IsMyLaptop:~]$ minicom -D /dev/tty.usbserial-AH02MIE2\n\n\n    Welcome to minicom 2.7\n\n    OPTIONS: \n    Compiled on Oct 12 2015, 07:48:30.\n    Port /dev/tty.usbserial-AH02MIE2, 13:44:40\n\n    Press CTRL-X Z for help on special keys\n\n    ?\n    141964:Unknown command ?\n    ?\n    143804:config   log     echo    ?       tasks   mempools \n    143806:stat     senseair \n    senseair\n    150644:Yay! Somebody called!\n\n\n\n\n\nNow that's great. You can connect the hardware to board and start developing code for the driver itself.\n\n\nUse of HAL for drivers\n\n\nThe sensor has a serial port connection, and that's how you are going to connect to it. Your original BSP, hw/bsp/stm32f3discovery, has only one UART set up (as specified in src/hal_bsp.c, include/hal/bsp.h). Therefore, you need to create your own bsp which has configuration for this added hardware.\n\n\nSo in the shell you make a copy of the original BSP, and then change the package file a little.\n\n\n[user@IsMyLaptop:~/src/air_quality]$ mkdir hw\n[user@IsMyLaptop:~/src/air_quality]$ mkdir hw/bsp\n\n[user@IsMyLaptop:~/src/air_quality]$ cp -R repos/mynewt_stm32f3/hw/bsp/stm32f3discovery hw/bsp/stm32f3discovery_with_senseair\n\n\n\n\n\nThen you modify the pkg.yml in the copied BSP to assign name for this package. And modify the dependency for MCU package to point to mynewt_stm32f3 repository.\n\n\n    [user@IsMyLaptop:~/src/air_quality]$ grep pkg.name hw/bsp/stm32f3discovery_with_senseair/pkg.yml\n    pkg.name: \nhw/bsp/stm32f3discovery_with_senseair\n\n    [user@IsMyLaptop:~/src/air_quality]$ tail -2 hw/bsp/stm32f3discovery_with_senseair/pkg.yml\npkg.deps:\n    - \n@mynewt_stm32f3/hw/mcu/stm/stm32f3xx\n\n\n\n\n\n\nAnd you want to use this BSP with my target. So you change the BSP in the target definition.\n\n\nHere's your new target.\n\n\n[user@IsMyLaptop:~/src/air_quality]$ newt target show air_q\ntargets/air_q\n    app=apps/air_quality\n    bsp=hw/bsp/stm32f3discovery_with_senseair\n    build_profile=debug\n\n\n\n\n\nYou add the 2nd serial port to my new BSP. Go to hw/bsp/stm32f3discovery_with_senseair directory to do this.\n\n\nModify the include/hal/bsp.h to increase UART_CNT to 2, and add a definition of the 2nd logical UART. You will use this in your sensor driver.\n\n\nstatic\n \nconst\n \nstruct\n \nstm32f3_uart_cfg\n \nuart_cfg\n[\nUART_CNT\n] \n=\n {\n    [\n0\n] \n=\n {\n        .\nsuc_uart\n \n=\n \nUSART1\n,\n        .\nsuc_rcc_cmd\n \n=\n \nRCC_APB2PeriphClockCmd\n,\n        .\nsuc_rcc_dev\n \n=\n \nRCC_APB2Periph_USART1\n,\n        .\nsuc_pin_tx\n \n=\n \n9\n,\n        .\nsuc_pin_rx\n \n=\n \n10\n,\n        .\nsuc_pin_rts\n \n=\n \n12\n,\n        .\nsuc_pin_cts\n \n=\n \n11\n,\n        .\nsuc_pin_af\n \n=\n \nGPIO_AF_7\n,\n        .\nsuc_irqn\n \n=\n \nUSART1_IRQn\n\n    },\n    [\n1\n] \n=\n {\n        .\nsuc_uart\n \n=\n \nUSART2\n,\n        .\nsuc_rcc_cmd\n \n=\n \nRCC_APB1PeriphClockCmd\n,\n        .\nsuc_rcc_dev\n \n=\n \nRCC_APB1Periph_USART2\n,\n        .\nsuc_pin_tx\n \n=\n \n19\n, \n/* PB3 */\n\n        .\nsuc_pin_rx\n \n=\n \n20\n, \n/* PB4 */\n\n        .\nsuc_pin_rts\n \n=\n \n1\n,\n        .\nsuc_pin_cts\n \n=\n \n0\n,\n        .\nsuc_pin_af\n \n=\n \nGPIO_AF_7\n,\n        .\nsuc_irqn\n \n=\n \nUSART2_IRQn\n\n    }\n};\n\n\n\n\n\nWith this in place, you can refer to serial port where your SenseAir sensor is by a logical number. This makes the code more platform independent - you could connect this sensor to another board, like Olimex. You will also use the HAL UART abstraction to do the UART port setup and data transfer. That way you don't need to have any platform dependent pieces within your little driver.\n\n\nYou will now see what the driver code ends up looking like. Here's the header file, filled in from stub you created earlier.\n\n\n/*\n\n\n * Licensed to the Apache Software Foundation (ASF) under one\n\n\n * or more contributor license agreements.  See the NOTICE file\n\n\n * distributed with this work for additional information\n\n\n * regarding copyright ownership.  The ASF licenses this file\n\n\n * to you under the Apache License, Version 2.0 (the\n\n\n * \nLicense\n); you may not use this file except in compliance\n\n\n * with the License.  You may obtain a copy of the License at\n\n\n * \n\n\n *  http://www.apache.org/licenses/LICENSE-2.0\n\n\n *\n\n\n * Unless required by applicable law or agreed to in writing,\n\n\n * software distributed under the License is distributed on an\n\n\n * \nAS IS\n BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n\n\n * KIND, either express or implied.  See the License for the\n\n\n * specific language governing permissions and limitations\n\n\n * under the License.\n\n\n*/\n\n\n#ifndef _SENSEAIR_H_\n\n\n#define _SENSEAIR_H_\n\n\n\nenum\n \nsenseair_read_type\n {\n        \nSENSEAIR_CO2\n,\n        \nSENSEAIR_TEMPERATURE\n,\n        \nSENSEAIR_HUMIDITY\n\n};\n\n\nint\n \nsenseair_init\n(\nint\n \nuartno\n);\n\n\nint\n \nsenseair_read\n(\nenum\n \nsenseair_read_type\n);\n\n\n#endif \n/* _SENSEAIR_H_ */\n\n\n\n\n\n\nAs you can see, logical UART number has been added to the init routine. A 'read' function has been added, which is a blocking read. If you were making a commercial product, you would probably have a callback for reporting the results.\n\n\nAnd here is the source for the driver.\n\n\n/**\n\n\n * Licensed to the Apache Software Foundation (ASF) under one\n\n\n * or more contributor license agreements.  See the NOTICE file\n\n\n * distributed with this work for additional information\n\n\n * regarding copyright ownership.  The ASF licenses this file\n\n\n * to you under the Apache License, Version 2.0 (the\n\n\n * \nLicense\n); you may not use this file except in compliance\n\n\n * with the License.  You may obtain a copy of the License at\n\n\n *\n\n\n *  http://www.apache.org/licenses/LICENSE-2.0\n\n\n *\n\n\n * Unless required by applicable law or agreed to in writing,\n\n\n * software distributed under the License is distributed on an\n\n\n * \nAS IS\n BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n\n\n * KIND, either express or implied.  See the License for the\n\n\n * specific language governing permissions and limitations\n\n\n * under the License.\n\n\n */\n\n\n#include \nstring.h\n\n\n\n#include \nshell/shell.h\n\n\n#include \nconsole/console.h\n\n\n#include \nos/os.h\n\n\n\n#include \nhal/hal_uart.h\n\n\n\n#include \nsenseair/senseair.h\n\n\n\nstatic\n \nconst\n \nuint8_t\n \ncmd_read_co2\n[] \n=\n {\n    \n0xFE\n, \n0\nX44\n, \n0\nX00\n, \n0\nX08\n, \n0\nX02\n, \n0\nX9F\n, \n0\nX25\n\n};\n\nstatic\n \nconst\n \nuint8_t\n \ncmd_read_temp\n[] \n=\n {\n    \n0xFE\n, \n0\nX44\n, \n0\nX00\n, \n0\nX12\n, \n0\nX02\n, \n0\nX94\n, \n0\nX45\n\n};\n\nstatic\n \nconst\n \nuint8_t\n \ncmd_read_humidity\n[] \n=\n {\n    \n0xFE\n, \n0x44\n, \n0x00\n, \n0x14\n, \n0x02\n, \n0x97\n, \n0xE5\n\n};\n\n\nstatic\n \nint\n \nsenseair_shell_func\n(\nint\n \nargc\n, \nchar\n \n**argv\n);\n\nstatic\n \nstruct\n \nshell_cmd\n \nsenseair_cmd\n \n=\n {\n    .\nsc_cmd\n \n=\n \nsenseair\n,\n    .\nsc_cmd_func\n \n=\n \nsenseair_shell_func\n,\n};\n\n\nstruct\n \nsenseair\n { \n    \nint\n \nuart\n;\n    \nstruct\n \nos_sem\n \nsema\n;\n    \nconst\n \nuint8_t\n \n*tx_data\n;\n    \nint\n \ntx_off\n;\n    \nint\n \ntx_len\n;\n    \nuint8_t\n \nrx_data\n[\n32\n]; \n    \nint\n \nrx_off\n;\n    \nint\n \nvalue\n;\n} \nsenseair\n;\n\n\nstatic\n \nint\n\n\nsenseair_tx_char\n(\nvoid\n \n*arg\n)\n{\n    \nstruct\n \nsenseair\n \n*s\n \n=\n \nsenseair\n;\n    \nint\n \nrc\n;\n\n    \nif\n (\ns-\ntx_off\n \n=\n \ns-\ntx_len\n) {\n    \n/*\n\n\n         * Command tx finished.\n\n\n         */\n\n        \ns-\ntx_data\n \n=\n \nNULL\n;\n        \nreturn\n \n-\n1\n;\n    }\n\n    \nrc\n \n=\n \ns-\ntx_data\n[\ns-\ntx_off\n];\n    \ns-\ntx_off++\n;\n    \nreturn\n \nrc\n;\n}\n\n\n/*\n\n\n * CRC for modbus over serial port.\n\n\n */\n\n\nstatic\n \nconst\n \nuint16_t\n \nmb_crc_tbl\n[] \n=\n {\n    \n0x0000\n, \n0xcc01\n, \n0xd801\n, \n0x1400\n, \n0xf001\n, \n0x3c00\n, \n0x2800\n, \n0xe401\n,\n    \n0xa001\n, \n0x6c00\n, \n0x7800\n, \n0xb401\n, \n0x5000\n, \n0x9c01\n, \n0x8801\n, \n0x4400\n\n};\n\n\nstatic\n \nuint16_t\n\n\nmb_crc\n(\nconst\n \nuint8_t\n \n*data\n, \nint\n \nlen\n, \nuint16_t\n \ncrc\n)\n{\n    \nwhile\n (\nlen--\n \n \n0\n) {\n        \ncrc\n \n^=\n \n*data++\n;\n        \ncrc\n \n=\n (\ncrc\n \n \n4\n) \n^\n \nmb_crc_tbl\n[\ncrc\n \n \n0xf\n];\n        \ncrc\n \n=\n (\ncrc\n \n \n4\n) \n^\n \nmb_crc_tbl\n[\ncrc\n \n \n0xf\n];\n    }\n    \nreturn\n \ncrc\n;\n}\n\n\nstatic\n \nint\n\n\nmb_crc_check\n(\nconst\n \nvoid\n \n*pkt\n, \nint\n \nlen\n)\n{\n    \nuint16_t\n \ncrc\n, \ncmp\n;\n    \nuint8_t\n \n*bp\n \n=\n (\nuint8_t\n \n*\n)\npkt\n;\n\n    \nif\n (\nlen\n \n \nsizeof\n(\ncrc\n) \n+\n \n1\n) {\n        \nreturn\n \n-\n1\n;\n    }\n    \ncrc\n \n=\n \nmb_crc\n(\npkt\n, \nlen\n \n-\n \n2\n, \n0xffff\n);\n    \ncmp\n \n=\n \nbp\n[\nlen\n \n-\n \n2\n] \n|\n (\nbp\n[\nlen\n \n-\n \n1\n] \n \n8\n);\n    \nif\n (\ncrc\n \n!=\n \ncmp\n) {\n        \nreturn\n \n-\n1\n;\n    } \nelse\n {\n        \nreturn\n \n0\n;\n    }\n}\n\n\nstatic\n \nint\n\n\nsenseair_rx_char\n(\nvoid\n \n*arg\n, \nuint8_t\n \ndata\n)\n{\n    \nstruct\n \nsenseair\n \n*s\n \n=\n (\nstruct\n \nsenseair\n \n*\n)\narg\n;\n    \nint\n \nrc\n;\n\n    \nif\n (\ns-\nrx_off\n \n=\n \nsizeof\n(\ns-\nrx_data\n)) {\n        \ns-\nrx_off\n \n=\n \n0\n;\n    }\n    \ns-\nrx_data\n[\ns-\nrx_off\n] \n=\n \ndata\n;\n    \ns-\nrx_off++\n;\n\n    \nif\n (\ns-\nrx_off\n \n==\n \n7\n) {\n        \nrc\n \n=\n \nmb_crc_check\n(\ns-\nrx_data\n, \ns-\nrx_off\n);\n        \nif\n (\nrc\n \n==\n \n0\n) {\n            \ns-\nvalue\n \n=\n \ns-\nrx_data\n[\n3\n] \n*\n \n256\n \n+\n \ns-\nrx_data\n[\n4\n];\n            \nos_sem_release\n(\ns-\nsema\n);\n        }\n    }\n    \nreturn\n \n0\n;\n}\n\n\nvoid\n\n\nsenseair_tx\n(\nstruct\n \nsenseair\n \n*s\n, \nconst\n \nuint8_t\n \n*tx_data\n, \nint\n \ndata_len\n)\n{\n    \ns-\ntx_data\n \n=\n \ntx_data\n;\n    \ns-\ntx_len\n \n=\n \ndata_len\n;\n    \ns-\ntx_off\n \n=\n \n0\n;\n    \ns-\nrx_off\n \n=\n \n0\n;\n\n    \nhal_uart_start_tx\n(\ns-\nuart\n);\n}\n\n\nint\n\n\nsenseair_read\n(\nenum\n \nsenseair_read_type\n \ntype\n)\n{\n    \nstruct\n \nsenseair\n \n*s\n \n=\n \nsenseair\n;\n    \nconst\n \nuint8_t\n \n*cmd\n;\n    \nint\n \ncmd_len\n;\n    \nint\n \nrc\n;\n\n    \nif\n (\ns-\ntx_data\n) {\n        \n/*\n\n\n         * busy\n\n\n         */\n\n        \nreturn\n \n-\n1\n;\n    }\n    \nswitch\n (\ntype\n) {\n    \ncase\n \nSENSEAIR_CO2\n:\n        \ncmd\n \n=\n \ncmd_read_co2\n;\n        \ncmd_len\n \n=\n \nsizeof\n(\ncmd_read_co2\n);\n        \nbreak\n;\n    \ncase\n \nSENSEAIR_TEMPERATURE\n:\n        \ncmd\n \n=\n \ncmd_read_temp\n;\n        \ncmd_len\n \n=\n \nsizeof\n(\ncmd_read_temp\n);\n        \nbreak\n;\n    \ncase\n \nSENSEAIR_HUMIDITY\n:\n        \ncmd\n \n=\n \ncmd_read_humidity\n;\n        \ncmd_len\n \n=\n \nsizeof\n(\ncmd_read_humidity\n);\n        \nbreak\n;\n    \ndefault\n:\n\n        \nreturn\n \n-\n1\n;\n    }\n    \nsenseair_tx\n(\ns\n, \ncmd\n, \ncmd_len\n);\n    \nrc\n \n=\n \nos_sem_pend\n(\ns-\nsema\n, \nOS_TICKS_PER_SEC\n \n/\n \n2\n);\n    \nif\n (\nrc\n \n==\n \nOS_TIMEOUT\n) {\n        \n/*\n\n\n         * timeout\n\n\n         */\n\n        \nreturn\n \n-\n2\n;\n    }\n    \nreturn\n \ns-\nvalue\n;\n}\n\n\nstatic\n \nint\n\n\nsenseair_shell_func\n(\nint\n \nargc\n, \nchar\n \n**argv\n)\n{\n    \nint\n \nvalue\n;\n    \nenum\n \nsenseair_read_type\n \ntype\n;\n\n    \nif\n (\nargc\n \n \n2\n) {\n\nusage\n:\n        \nconsole_printf\n(\n%s \nco2|temp|humidity\n\\n\n, \nargv\n[\n0\n]);\n        \nreturn\n \n0\n;\n    }\n    \nif\n (\n!strcmp\n(\nargv\n[\n1\n], \nco2\n)) {\n        \ntype\n \n=\n \nSENSEAIR_CO2\n;\n    } \nelse\n \nif\n (\n!strcmp\n(\nargv\n[\n1\n], \ntemp\n)) {\n        \ntype\n \n=\n \nSENSEAIR_TEMPERATURE\n;\n    } \nelse\n \nif\n (\n!strcmp\n(\nargv\n[\n1\n], \nhumidity\n)) {\n        \n/*\n\n\n         * timeout\n\n\n         */\n\n        \nreturn\n \n-\n2\n;\n    }\n    \nreturn\n \ns-\nvalue\n;\n}\n\n\nstatic\n \nint\n\n\nsenseair_shell_func\n(\nint\n \nargc\n, \nchar\n \n**argv\n)\n{\n    \nint\n \nvalue\n;\n    \nenum\n \nsenseair_read_type\n \ntype\n;\n\n    \nif\n (\nargc\n \n \n2\n) {\n\nusage\n:\n        \nconsole_printf\n(\n%s \nco2|temp|humidity\n\\n\n, \nargv\n[\n0\n]);\n        \nreturn\n \n0\n;\n    }\n    \nif\n (\n!strcmp\n(\nargv\n[\n1\n], \nco2\n)) {\n        \ntype\n \n=\n \nSENSEAIR_CO2\n;\n    } \nelse\n \nif\n (\n!strcmp\n(\nargv\n[\n1\n], \ntemp\n)) {\n        \ntype\n \n=\n \nSENSEAIR_TEMPERATURE\n;\n    } \nelse\n \nif\n (\n!strcmp\n(\nargv\n[\n1\n], \nhumidity\n)) {\n        \ntype\n \n=\n \nSENSEAIR_HUMIDITY\n;\n    } \nelse\n {\n        \ngoto\n \nusage\n;\n    }\n    \nvalue\n \n=\n \nsenseair_read\n(\ntype\n);\n    \nif\n (\nvalue\n \n=\n \n0\n) {\n        \nconsole_printf\n(\nGot %d\\n\n, \nvalue\n);\n    } \nelse\n {\n        \nconsole_printf\n(\nError while reading: %d\\n\n, \nvalue\n);\n    }\n    \nreturn\n \n0\n;\n}\n\n\nint\n\n\nsenseair_init\n(\nint\n \nuartno\n)\n{\n    \nint\n \nrc\n;\n    \nstruct\n \nsenseair\n \n*s\n \n=\n \nsenseair\n;\n\n    \nrc\n \n=\n \nshell_cmd_register\n(\nsenseair_cmd\n);\n    \nif\n (\nrc\n) {\n        \nreturn\n \nrc\n;\n    }\n\n    \nrc\n \n=\n \nos_sem_init\n(\ns-\nsema\n, \n1\n);\n    \nif\n (\nrc\n) {\n        \nreturn\n \nrc\n;\n    }\n    \nrc\n \n=\n \nhal_uart_init_cbs\n(\nuartno\n, \nsenseair_tx_char\n, \nNULL\n,\n      \nsenseair_rx_char\n, \nsenseair\n);\n    \nif\n (\nrc\n) {\n        \nreturn\n \nrc\n;\n    }\n    \nrc\n \n=\n \nhal_uart_config\n(\nuartno\n, \n9600\n, \n8\n, \n1\n, \nHAL_UART_PARITY_NONE\n,\n      \nHAL_UART_FLOW_CTL_NONE\n);\n    \nif\n (\nrc\n) {\n        \nreturn\n \nrc\n;\n    }\n    \ns-\nuart\n \n=\n \nuartno\n;\n\n    \nreturn\n \n0\n;\n}\n\n\n\n\n\nAnd you modified your main() for senseair driver init.\n\n\nint\n\n\nmain\n(\nint\n \nargc\n, \nchar\n \n**argv\n)\n{\n    ....\n    \nsenseair_init\n(\n1\n);\n    ....\n    }\n\n\n\n\n\nYou can see from the code that you are using the HAL interface to open a UART port, and using OS semaphore as a way of blocking the task when waiting for read response to come back from the sensor.", 
            "title": "Adding an air-quality sensor"
        }, 
        {
            "location": "/os/tutorials/air_quality_sensor/#air-quality-sensor-project", 
            "text": "", 
            "title": "Air quality sensor project"
        }, 
        {
            "location": "/os/tutorials/air_quality_sensor/#setting-up-source-tree-for-stuff-you-need", 
            "text": "To start with, you need to create a new project under which you will do this development. So you type in:      $ mkdir $HOME/src\n    $ cd $HOME/src\n    $ newt new air_quality  Let's say you are using STM32F3discovery board as the platform. You know you need the board support package for that hardware. You can look up its location, add it your project, and fetch that along with the core OS components.  To make this happen, you'll need to modify the project.yml in your project's root directory.      [user@IsMyLaptop:~/src/air_quality]$ emacs project.yml  \n    [user@IsMyLaptop:~/src/air_quality]$ cat project.yml\n    project.name:  air_quality \n\n    project.repositories:\n        - apache-mynewt-core\n        - mynewt_stm32f3\n\n    # Use github s distribution mechanism for core ASF libraries.\n    # This provides mirroring automatically for us.\n    #\n    repository.apache-mynewt-core:\n        type: github\n        vers: 0-latest\n        user: apache\n        repo: incubator-mynewt-core\n\n    repository.mynewt_stm32f3:\n        type: github\n        vers: 0-latest\n        user: runtimeinc\n        repo: mynewt_stm32f3\n    [user@IsMyLaptop:~/src/air_quality]$ newt install\n    apache-mynewt-core\n    mynewt_stm32f3\n    [user@IsMyLaptop:~/src/air_quality]$ ls repos/\n    apache-mynewt-core  mynewt_stm32f3  Good. You want to make sure you have all the needed bits for supporting your board; so you decide to build the blinky project for the platform first.  Now create a target for it and build it. Easiest way to proceed is to copy the existing target for blinky, and modify it to build for STM32F3Discovery board.  [user@IsMyLaptop:~/src/air_quality]$ newt target copy my_blinky_sim blink_f3\nTarget successfully copied; targets/my_blinky_sim --  targets/blink_f3\n[user@IsMyLaptop:~/src/air_quality]$ newt target set blink_f3 bsp=@mynewt_stm32f3/hw/bsp/stm32f3discovery\nTarget targets/blink_f3 successfully set target.bsp to @mynewt_stm32f3/hw/bsp/stm32f3discovery\n[user@IsMyLaptop:~/src/air_quality]$ newt build blink_f3\nCompiling hal_bsp.c\n...\nLinking blinky.elf\nApp successfully built: /Users/user/src/air_quality/bin/blink_f3/apps/blinky/blinky.elf  Good.  You know that this platform uses bootloader, which means you have to create a target for that too.  [user@IsMyLaptop:~/src/air_quality]$ newt target create boot_f3\nTarget targets/boot_f3 successfully created\n[user@IsMyLaptop:~/src/air_quality]$ newt target show\n@apache-mynewt-core/targets/unittest\n    bsp=hw/bsp/native\n    build_profile=debug\n    compiler=compiler/sim\ntargets/blink_f3\n    app=apps/blinky\n    bsp=@mynewt_stm32f3/hw/bsp/stm32f3discovery\n    build_profile=debug\ntargets/boot_f3\ntargets/my_blinky_sim\n    app=apps/blinky\n    bsp=@apache-mynewt-core/hw/bsp/native\n    build_profile=debug\n[user@IsMyLaptop:~/src/air_quality]$ newt target set boot_f3 bsp=@mynewt_stm32f3/hw/bsp/stm32f3discovery\nTarget targets/boot_f3 successfully set target.bsp to @mynewt_stm32f3/hw/bsp/stm32f3discovery\n[user@IsMyLaptop:~/src/air_quality]$ newt target set boot_f3 app=@apache-mynewt-core/apps/boot\nTarget targets/boot_f3 successfully set target.app to @apache-mynewt-core/apps/boot\n[user@IsMyLaptop:~/src/air_quality]$ newt target set boot_f3 build_profile=optimized\nTarget targets/boot_f3 successfully set target.build_profile to optimized  And then build it, and load it onto the board.  newt build boot_f3\n....\nLinking boot.elf\nApp successfully built: /Users/user/src/air_quality/bin/boot_f3/apps/boot/boot.elf\n[user@IsMyLaptop:~/src/air_quality]$ newt load boot_f3  Next you must download the targets to board, and see that the LED actually blinks. You plug in the STM32F3 discovery board to your laptop, and say:  [user@IsMyLaptop:~/src/air_quality]$ newt load blink_f3\nDownloading /Users/user/src/air_quality/bin/blink_f3/apps/blinky/blinky.img to 0x08009000\nOpen On-Chip Debugger 0.9.0 (2015-05-28-12:05)\n....\nxPSR: 0x01000000 pc: 0x0800026c msp: 0x10002000\nauto erase enabled\nError: couldn t open /Users/user/src/air_quality/bin/blink_f3/apps/blinky/blinky.img\n\nError: exit status 1\n\nload - Load app image to target for  target-name .\n\nUsage:\n  newt load [flags]\n\nExamples:\n  newt load  target-name \n\n\nGlobal Flags:\n  -l, --loglevel string   Log level, defaults to WARN. (default  WARN )\n  -o, --outfile string    Filename to tee log output to\n  -q, --quiet             Be quiet; only display error output.\n  -s, --silent            Be silent; don t output anything.\n  -v, --verbose           Enable verbose output when executing commands.\nexit status 1  Ah. Forgot to create an image out of the blinky binary. Note that every time you want to build and load a new firmware image to target board, you need to run 'create-image' on it.  [user@IsMyLaptop:~/src/air_quality]$ newt create-image blink_f3 0.0.1\nApp image succesfully generated: /Users/user/src/air_quality/bin/blink_f3/apps/blinky/blinky.img\nBuild manifest: /Users/user/src/air_quality/bin/blink_f3/apps/blinky/manifest.json\n[user@IsMyLaptop:~/src/air_quality]$ newt load blink_f3 0.0.1  And it's blinking.  Shortcut for doing build/create-image/load/debug steps all in one is 'newt run' command. Check out the usage from command line help.", 
            "title": "Setting up source tree for stuff you need"
        }, 
        {
            "location": "/os/tutorials/air_quality_sensor/#create-test-project", 
            "text": "Now that you have your system setup, you can start creating your own stuff.\nFirst you want to create a project for yourself - you can start by getting project template from blinky, as it pretty much has what you want.      [user@IsMyLaptop:~/src/air_quality]$ mkdir apps/air_quality\n    [user@IsMyLaptop:~/src/air_quality]$ cp repos/apache-mynewt-core/apps/blinky/pkg.yml apps/air_quality/\n    [user@IsMyLaptop:~/src/air_quality]$ mkdir apps/air_quality/src\n    [user@IsMyLaptop:~/src/air_quality]$ cp repos/apache-mynewt-core/apps/blinky/src/main.c apps/air_quality/src/  Then you modify the apps/air_quality/pkg.yml for air_quality in order to change the  pkg.name  to be  apps/air_quality .\nYou also need to point the package dependencies to point to packages in apache-mynewt-core repository.\nSTM32F3discovery board has limited amount of memory, so you must also switch your libc to be baselibc, instead of the standard one.  [user@IsMyLaptop:~/src/air_quality]$ cat apps/air_quality/pkg.yml\npkg.name: apps/air_quality\npkg.type: app\npkg.description: Air quality sensor test\npkg.keywords:\n\npkg.deps:\n    -  @apache-mynewt-core/libs/console/full \n    -  @apache-mynewt-core/libs/newtmgr \n    -  @apache-mynewt-core/libs/os \n    -  @apache-mynewt-core/libs/shell \n    -  @apache-mynewt-core/sys/config \n    -  @apache-mynewt-core/sys/log \n    -  @apache-mynewt-core/sys/stats \n    -  @apache-mynewt-core/libs/baselibc   And create a target for it:  [user@IsMyLaptop:~/src/air_quality]$ newt target create air_q\nTarget targets/air_q successfully created\n[user@IsMyLaptop:~/src/air_quality]$ newt target set air_q bsp=@mynewt_stm32f3/hw/bsp/stm32f3discovery\nTarget targets/air_q successfully set target.bsp to @mynewt_stm32f3/hw/bsp/stm32f3discovery\n[user@IsMyLaptop:~/src/air_quality]$ newt target set air_q app=apps/air_quality \nTarget targets/air_q successfully set target.app to apps/air_quality\n[user@IsMyLaptop:~/src/air_quality]$ newt target set air_q build_profile=debug\nTarget targets/air_q successfully set target.build_profile to debug\n[user@IsMyLaptop:~/src/air_quality]$ newt build air_q\n ....\nLinking air_quality.elf\nApp successfully built: /Users/user/src/air_quality/bin/air_q/apps/air_quality/air_quality.elf", 
            "title": "Create test project"
        }, 
        {
            "location": "/os/tutorials/air_quality_sensor/#create-packages-for-drivers", 
            "text": "One of the sensors you want to enable is SenseAir K30, which will connect to the board over serial port.\nTo start development of the driver, you first need to create a package description for it, and add stubs for sources.  So you add few files. pkg.yml to describe the driver, and then header stub followed by source stub.  [user@IsMyLaptop:~/src/air_quality]$ cat libs/my_drivers/senseair/pkg.yml  #  # Licensed to the Apache Software Foundation (ASF) under one  # or more contributor license agreements.  See the NOTICE file  # distributed with this work for additional information  # regarding copyright ownership.  The ASF licenses this file  # to you under the Apache License, Version 2.0 (the  #  License ); you may not use this file except in compliance  # with the License.  You may obtain a copy of the License at  #   #  http: //www.apache.org/licenses/LICENSE-2.0  #  # Unless required by applicable law or agreed to in writing,  # software distributed under the License is distributed on an  #  AS IS  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  # KIND, either express or implied.  See the License for the  # specific language governing permissions and limitations  # under the License.  #  pkg . name :  libs/my_drivers/senseair  pkg . deps :\n     -   @apache-mynewt-core/hw/hal   [user@IsMyLaptop:~/src/air_quality]$ cat libs/my_drivers/senseair/include/senseair/senseair.h  /*   * Licensed to the Apache Software Foundation (ASF) under one   * or more contributor license agreements.  See the NOTICE file   * distributed with this work for additional information   * regarding copyright ownership.  The ASF licenses this file   * to you under the Apache License, Version 2.0 (the   *  License ); you may not use this file except in compliance   * with the License.  You may obtain a copy of the License at   *    *  http://www.apache.org/licenses/LICENSE-2.0   *   * Unless required by applicable law or agreed to in writing,   * software distributed under the License is distributed on an   *  AS IS  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY   * KIND, either express or implied.  See the License for the   * specific language governing permissions and limitations   * under the License.  */  #ifndef _SENSEAIR_H_  #define _SENSEAIR_H_  void   senseair_init ( void ); #endif  /* _SENSEAIR_H_ */   [user@IsMyLaptop:~/src/air_quality]$ cat libs/my_drivers/senseair/src/senseair.c  /**   * Licensed to the Apache Software Foundation (ASF) under one   * or more contributor license agreements.  See the NOTICE file   * distributed with this work for additional information   * regarding copyright ownership.  The ASF licenses this file   * to you under the Apache License, Version 2.0 (the   *  License ); you may not use this file except in compliance   * with the License.  You may obtain a copy of the License at   *    *  http://www.apache.org/licenses/LICENSE-2.0   *   * Unless required by applicable law or agreed to in writing,   * software distributed under the License is distributed on an   *  AS IS  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY   * KIND, either express or implied.  See the License for the   * specific language governing permissions and limitations   * under the License.   */  void  senseair_init ( void )\n{\n}  And add dependency to this package in my project yml file.  Here's from apps/air_quality/pkg.yml  pkg.name: apps/air_quality\npkg.type: app\npkg.description: Air quality sensor test\npkg.keywords:\n\npkg.deps:\n    -  @apache-mynewt-core/libs/console/full \n    -  @apache-mynewt-core/libs/newtmgr \n    -  @apache-mynewt-core/libs/os \n    -  @apache-mynewt-core/libs/shell \n    -  @apache-mynewt-core/sys/config \n    -  @apache-mynewt-core/sys/log \n    -  @apache-mynewt-core/sys/stats \n    -  @apache-mynewt-core/libs/baselibc \n    - libs/my_drivers/senseair  And add a call to your main() to initialize this driver.      [user@IsMyLaptop:~/src/air_quality]$ diff project/blinky/src/main.c project/air_quality/src/main.c\n    28a29\n      #include  senseair/senseair.h \n    190a192\n      senseair_init();\n    [user@IsMyLaptop:~/src/air_quality  And then build it to make sure all goes well.  [user@IsMyLaptop:~/src/air_quality]$ newt build air_q\nCompiling senseair.c\nArchiving senseair.a\nLinking air_quality.elf\nApp successfully built: /Users/user/src/air_quality/bin/air_q/apps/air_quality/air_quality.elf  All looks good.", 
            "title": "Create packages for drivers"
        }, 
        {
            "location": "/os/tutorials/air_quality_sensor/#add-cli-commands-for-testing-drivers", 
            "text": "While developing the driver, you want to issue operations from console asking it to do stuff. The way to do this is to register your command handler with shell. Whenever your custom command is issued, you can respond to it.  The way you do this is first adding a dependency to shell package for your senseair driver. So you change libs/my_drivers/senseair/pkg.yml to have the following:  pkg.name: libs/my_drivers/senseair\npkg.deps:\n    -  @apache-mynewt-core/hw/hal \n    -  @apache-mynewt-core/libs/shell   And then register your shell command in  senseair_init() .  [user@IsMyLaptop:~/src/air_quality]$ cat libs/my_drivers/senseair/src/senseair.c\n ....  #include  shell/shell.h  #include  console/console.h  static   int   senseair_shell_func ( int   argc ,  char   **argv ); static   struct   shell_cmd   senseair_cmd   =  {\n    . sc_cmd   =   senseair ,\n    . sc_cmd_func   =   senseair_shell_func ,\n}; void  senseair_init ( void )\n{\n     int   rc ;\n\n     rc   =   shell_cmd_register ( senseair_cmd );\n     assert ( rc   ==   0 );\n} static   int  senseair_shell_func ( int   argc ,  char   **argv )\n{\n     console_printf ( Yay! Somebody called!\\n );\n     return   0 ;\n}  Then you build this, download to target, and start minicom on your console port.      [user@IsMyLaptop:~]$ minicom -D /dev/tty.usbserial-AH02MIE2\n\n\n    Welcome to minicom 2.7\n\n    OPTIONS: \n    Compiled on Oct 12 2015, 07:48:30.\n    Port /dev/tty.usbserial-AH02MIE2, 13:44:40\n\n    Press CTRL-X Z for help on special keys\n\n    ?\n    141964:Unknown command ?\n    ?\n    143804:config   log     echo    ?       tasks   mempools \n    143806:stat     senseair \n    senseair\n    150644:Yay! Somebody called!  Now that's great. You can connect the hardware to board and start developing code for the driver itself.", 
            "title": "Add CLI commands for testing drivers"
        }, 
        {
            "location": "/os/tutorials/air_quality_sensor/#use-of-hal-for-drivers", 
            "text": "The sensor has a serial port connection, and that's how you are going to connect to it. Your original BSP, hw/bsp/stm32f3discovery, has only one UART set up (as specified in src/hal_bsp.c, include/hal/bsp.h). Therefore, you need to create your own bsp which has configuration for this added hardware.  So in the shell you make a copy of the original BSP, and then change the package file a little.  [user@IsMyLaptop:~/src/air_quality]$ mkdir hw\n[user@IsMyLaptop:~/src/air_quality]$ mkdir hw/bsp\n\n[user@IsMyLaptop:~/src/air_quality]$ cp -R repos/mynewt_stm32f3/hw/bsp/stm32f3discovery hw/bsp/stm32f3discovery_with_senseair  Then you modify the pkg.yml in the copied BSP to assign name for this package. And modify the dependency for MCU package to point to mynewt_stm32f3 repository.      [user@IsMyLaptop:~/src/air_quality]$ grep pkg.name hw/bsp/stm32f3discovery_with_senseair/pkg.yml\n    pkg.name:  hw/bsp/stm32f3discovery_with_senseair \n    [user@IsMyLaptop:~/src/air_quality]$ tail -2 hw/bsp/stm32f3discovery_with_senseair/pkg.yml\npkg.deps:\n    -  @mynewt_stm32f3/hw/mcu/stm/stm32f3xx   And you want to use this BSP with my target. So you change the BSP in the target definition.  Here's your new target.  [user@IsMyLaptop:~/src/air_quality]$ newt target show air_q\ntargets/air_q\n    app=apps/air_quality\n    bsp=hw/bsp/stm32f3discovery_with_senseair\n    build_profile=debug  You add the 2nd serial port to my new BSP. Go to hw/bsp/stm32f3discovery_with_senseair directory to do this.  Modify the include/hal/bsp.h to increase UART_CNT to 2, and add a definition of the 2nd logical UART. You will use this in your sensor driver.  static   const   struct   stm32f3_uart_cfg   uart_cfg [ UART_CNT ]  =  {\n    [ 0 ]  =  {\n        . suc_uart   =   USART1 ,\n        . suc_rcc_cmd   =   RCC_APB2PeriphClockCmd ,\n        . suc_rcc_dev   =   RCC_APB2Periph_USART1 ,\n        . suc_pin_tx   =   9 ,\n        . suc_pin_rx   =   10 ,\n        . suc_pin_rts   =   12 ,\n        . suc_pin_cts   =   11 ,\n        . suc_pin_af   =   GPIO_AF_7 ,\n        . suc_irqn   =   USART1_IRQn \n    },\n    [ 1 ]  =  {\n        . suc_uart   =   USART2 ,\n        . suc_rcc_cmd   =   RCC_APB1PeriphClockCmd ,\n        . suc_rcc_dev   =   RCC_APB1Periph_USART2 ,\n        . suc_pin_tx   =   19 ,  /* PB3 */ \n        . suc_pin_rx   =   20 ,  /* PB4 */ \n        . suc_pin_rts   =   1 ,\n        . suc_pin_cts   =   0 ,\n        . suc_pin_af   =   GPIO_AF_7 ,\n        . suc_irqn   =   USART2_IRQn \n    }\n};  With this in place, you can refer to serial port where your SenseAir sensor is by a logical number. This makes the code more platform independent - you could connect this sensor to another board, like Olimex. You will also use the HAL UART abstraction to do the UART port setup and data transfer. That way you don't need to have any platform dependent pieces within your little driver.  You will now see what the driver code ends up looking like. Here's the header file, filled in from stub you created earlier.  /*   * Licensed to the Apache Software Foundation (ASF) under one   * or more contributor license agreements.  See the NOTICE file   * distributed with this work for additional information   * regarding copyright ownership.  The ASF licenses this file   * to you under the Apache License, Version 2.0 (the   *  License ); you may not use this file except in compliance   * with the License.  You may obtain a copy of the License at   *    *  http://www.apache.org/licenses/LICENSE-2.0   *   * Unless required by applicable law or agreed to in writing,   * software distributed under the License is distributed on an   *  AS IS  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY   * KIND, either express or implied.  See the License for the   * specific language governing permissions and limitations   * under the License.  */  #ifndef _SENSEAIR_H_  #define _SENSEAIR_H_  enum   senseair_read_type  {\n         SENSEAIR_CO2 ,\n         SENSEAIR_TEMPERATURE ,\n         SENSEAIR_HUMIDITY \n}; int   senseair_init ( int   uartno ); int   senseair_read ( enum   senseair_read_type ); #endif  /* _SENSEAIR_H_ */   As you can see, logical UART number has been added to the init routine. A 'read' function has been added, which is a blocking read. If you were making a commercial product, you would probably have a callback for reporting the results.  And here is the source for the driver.  /**   * Licensed to the Apache Software Foundation (ASF) under one   * or more contributor license agreements.  See the NOTICE file   * distributed with this work for additional information   * regarding copyright ownership.  The ASF licenses this file   * to you under the Apache License, Version 2.0 (the   *  License ); you may not use this file except in compliance   * with the License.  You may obtain a copy of the License at   *   *  http://www.apache.org/licenses/LICENSE-2.0   *   * Unless required by applicable law or agreed to in writing,   * software distributed under the License is distributed on an   *  AS IS  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY   * KIND, either express or implied.  See the License for the   * specific language governing permissions and limitations   * under the License.   */  #include  string.h  #include  shell/shell.h  #include  console/console.h  #include  os/os.h  #include  hal/hal_uart.h  #include  senseair/senseair.h  static   const   uint8_t   cmd_read_co2 []  =  {\n     0xFE ,  0 X44 ,  0 X00 ,  0 X08 ,  0 X02 ,  0 X9F ,  0 X25 \n}; static   const   uint8_t   cmd_read_temp []  =  {\n     0xFE ,  0 X44 ,  0 X00 ,  0 X12 ,  0 X02 ,  0 X94 ,  0 X45 \n}; static   const   uint8_t   cmd_read_humidity []  =  {\n     0xFE ,  0x44 ,  0x00 ,  0x14 ,  0x02 ,  0x97 ,  0xE5 \n}; static   int   senseair_shell_func ( int   argc ,  char   **argv ); static   struct   shell_cmd   senseair_cmd   =  {\n    . sc_cmd   =   senseair ,\n    . sc_cmd_func   =   senseair_shell_func ,\n}; struct   senseair  { \n     int   uart ;\n     struct   os_sem   sema ;\n     const   uint8_t   *tx_data ;\n     int   tx_off ;\n     int   tx_len ;\n     uint8_t   rx_data [ 32 ]; \n     int   rx_off ;\n     int   value ;\n}  senseair ; static   int  senseair_tx_char ( void   *arg )\n{\n     struct   senseair   *s   =   senseair ;\n     int   rc ;\n\n     if  ( s- tx_off   =   s- tx_len ) {\n     /*           * Command tx finished.           */ \n         s- tx_data   =   NULL ;\n         return   - 1 ;\n    }\n\n     rc   =   s- tx_data [ s- tx_off ];\n     s- tx_off++ ;\n     return   rc ;\n} /*   * CRC for modbus over serial port.   */  static   const   uint16_t   mb_crc_tbl []  =  {\n     0x0000 ,  0xcc01 ,  0xd801 ,  0x1400 ,  0xf001 ,  0x3c00 ,  0x2800 ,  0xe401 ,\n     0xa001 ,  0x6c00 ,  0x7800 ,  0xb401 ,  0x5000 ,  0x9c01 ,  0x8801 ,  0x4400 \n}; static   uint16_t  mb_crc ( const   uint8_t   *data ,  int   len ,  uint16_t   crc )\n{\n     while  ( len--     0 ) {\n         crc   ^=   *data++ ;\n         crc   =  ( crc     4 )  ^   mb_crc_tbl [ crc     0xf ];\n         crc   =  ( crc     4 )  ^   mb_crc_tbl [ crc     0xf ];\n    }\n     return   crc ;\n} static   int  mb_crc_check ( const   void   *pkt ,  int   len )\n{\n     uint16_t   crc ,  cmp ;\n     uint8_t   *bp   =  ( uint8_t   * ) pkt ;\n\n     if  ( len     sizeof ( crc )  +   1 ) {\n         return   - 1 ;\n    }\n     crc   =   mb_crc ( pkt ,  len   -   2 ,  0xffff );\n     cmp   =   bp [ len   -   2 ]  |  ( bp [ len   -   1 ]    8 );\n     if  ( crc   !=   cmp ) {\n         return   - 1 ;\n    }  else  {\n         return   0 ;\n    }\n} static   int  senseair_rx_char ( void   *arg ,  uint8_t   data )\n{\n     struct   senseair   *s   =  ( struct   senseair   * ) arg ;\n     int   rc ;\n\n     if  ( s- rx_off   =   sizeof ( s- rx_data )) {\n         s- rx_off   =   0 ;\n    }\n     s- rx_data [ s- rx_off ]  =   data ;\n     s- rx_off++ ;\n\n     if  ( s- rx_off   ==   7 ) {\n         rc   =   mb_crc_check ( s- rx_data ,  s- rx_off );\n         if  ( rc   ==   0 ) {\n             s- value   =   s- rx_data [ 3 ]  *   256   +   s- rx_data [ 4 ];\n             os_sem_release ( s- sema );\n        }\n    }\n     return   0 ;\n} void  senseair_tx ( struct   senseair   *s ,  const   uint8_t   *tx_data ,  int   data_len )\n{\n     s- tx_data   =   tx_data ;\n     s- tx_len   =   data_len ;\n     s- tx_off   =   0 ;\n     s- rx_off   =   0 ;\n\n     hal_uart_start_tx ( s- uart );\n} int  senseair_read ( enum   senseair_read_type   type )\n{\n     struct   senseair   *s   =   senseair ;\n     const   uint8_t   *cmd ;\n     int   cmd_len ;\n     int   rc ;\n\n     if  ( s- tx_data ) {\n         /*           * busy           */ \n         return   - 1 ;\n    }\n     switch  ( type ) {\n     case   SENSEAIR_CO2 :\n         cmd   =   cmd_read_co2 ;\n         cmd_len   =   sizeof ( cmd_read_co2 );\n         break ;\n     case   SENSEAIR_TEMPERATURE :\n         cmd   =   cmd_read_temp ;\n         cmd_len   =   sizeof ( cmd_read_temp );\n         break ;\n     case   SENSEAIR_HUMIDITY :\n         cmd   =   cmd_read_humidity ;\n         cmd_len   =   sizeof ( cmd_read_humidity );\n         break ;\n     default : \n         return   - 1 ;\n    }\n     senseair_tx ( s ,  cmd ,  cmd_len );\n     rc   =   os_sem_pend ( s- sema ,  OS_TICKS_PER_SEC   /   2 );\n     if  ( rc   ==   OS_TIMEOUT ) {\n         /*           * timeout           */ \n         return   - 2 ;\n    }\n     return   s- value ;\n} static   int  senseair_shell_func ( int   argc ,  char   **argv )\n{\n     int   value ;\n     enum   senseair_read_type   type ;\n\n     if  ( argc     2 ) { usage :\n         console_printf ( %s  co2|temp|humidity \\n ,  argv [ 0 ]);\n         return   0 ;\n    }\n     if  ( !strcmp ( argv [ 1 ],  co2 )) {\n         type   =   SENSEAIR_CO2 ;\n    }  else   if  ( !strcmp ( argv [ 1 ],  temp )) {\n         type   =   SENSEAIR_TEMPERATURE ;\n    }  else   if  ( !strcmp ( argv [ 1 ],  humidity )) {\n         /*           * timeout           */ \n         return   - 2 ;\n    }\n     return   s- value ;\n} static   int  senseair_shell_func ( int   argc ,  char   **argv )\n{\n     int   value ;\n     enum   senseair_read_type   type ;\n\n     if  ( argc     2 ) { usage :\n         console_printf ( %s  co2|temp|humidity \\n ,  argv [ 0 ]);\n         return   0 ;\n    }\n     if  ( !strcmp ( argv [ 1 ],  co2 )) {\n         type   =   SENSEAIR_CO2 ;\n    }  else   if  ( !strcmp ( argv [ 1 ],  temp )) {\n         type   =   SENSEAIR_TEMPERATURE ;\n    }  else   if  ( !strcmp ( argv [ 1 ],  humidity )) {\n         type   =   SENSEAIR_HUMIDITY ;\n    }  else  {\n         goto   usage ;\n    }\n     value   =   senseair_read ( type );\n     if  ( value   =   0 ) {\n         console_printf ( Got %d\\n ,  value );\n    }  else  {\n         console_printf ( Error while reading: %d\\n ,  value );\n    }\n     return   0 ;\n} int  senseair_init ( int   uartno )\n{\n     int   rc ;\n     struct   senseair   *s   =   senseair ;\n\n     rc   =   shell_cmd_register ( senseair_cmd );\n     if  ( rc ) {\n         return   rc ;\n    }\n\n     rc   =   os_sem_init ( s- sema ,  1 );\n     if  ( rc ) {\n         return   rc ;\n    }\n     rc   =   hal_uart_init_cbs ( uartno ,  senseair_tx_char ,  NULL ,\n       senseair_rx_char ,  senseair );\n     if  ( rc ) {\n         return   rc ;\n    }\n     rc   =   hal_uart_config ( uartno ,  9600 ,  8 ,  1 ,  HAL_UART_PARITY_NONE ,\n       HAL_UART_FLOW_CTL_NONE );\n     if  ( rc ) {\n         return   rc ;\n    }\n     s- uart   =   uartno ;\n\n     return   0 ;\n}  And you modified your main() for senseair driver init.  int  main ( int   argc ,  char   **argv )\n{\n    ....\n     senseair_init ( 1 );\n    ....\n    }  You can see from the code that you are using the HAL interface to open a UART port, and using OS semaphore as a way of blocking the task when waiting for read response to come back from the sensor.", 
            "title": "Use of HAL for drivers"
        }, 
        {
            "location": "/os/tutorials/how_to_edit_docs/", 
            "text": "How to Edit Docs\n\n\nObjective\n\n\nLearn the process of editing docs by adding some content to a test document.\n\n\nMarkdown, MkDocs, Mou\n\n\nThe Mynewt documentation you see on the Apache incubator website is a bunch of HTML files generated using MkDocs which is a simple static site generation tool geared towards building project documentation. You can read about it at \nhttp://www.mkdocs.org\n. Documentation source files are written in Markdown, and configured with a single YAML configuration file. Markdown is a lightweight markup language with plain text formatting syntax designed so that it can be converted to HTML and many other formats using a tool (which in our case is MkDocs).\n\n\nYou do not need to install MkDocs unless you want to actually render your documentation in HTML in order to preview it before pushing your content to the remote repository. Typically, using a Markdown editor such as \nMou\n is enough to check how it will look after the document has gone through MkDocs. Go ahead and download \nMou\n. If you are on a Windows machine, download the \neditor of your choice\n.\n\n\nCurrently someone in the project is designated to use MkDocs to generate the HTML pages periodically after changes have been reviewed and accepted into the master branch.\n\n\nAccess to the Apache repo\n\n\nGet an account on Apache. You do not need a committer account to view the website or clone the repository but you need it to push changes to it.\n\n\nIf you are not a committer, you may follow the proposed non-committer workflow to share your work. The direct link to the proposed workflow is \nhttps://git-wip-us.apache.org/docs/workflow.html\n. You will find the steps described in more detail later in this tutorial.\n\n\nMaking a local copy\n\n\n\n\nCopy the document source files into a local directory and look at the contents of the copied directory to get an idea of the directory structure. Use http instead of https if you are a non-committer.\n\n\n\n\n        \n$\n \ngit\n \nclone\n \nhttps\n:\n//git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git\n\n        \nCloning\n \ninto\n \nincubator-mynewt-site\n...\n        \nremote\n: \nCounting\n \nobjects\n: \n330\n, \ndone\n.\n        \nremote\n: \nCompressing\n \nobjects\n: \n100\n%\n (\n263\n/\n263\n), \ndone\n.\n        \nremote\n: \nTotal\n \n330\n (\ndelta\n \n120\n), \nreused\n \n0\n (\ndelta\n \n0\n)\n        \nReceiving\n \nobjects\n: \n100\n%\n (\n330\n/\n330\n), \n4.34\n \nMiB\n \n|\n \n830.00\n \nKiB/s\n, \ndone\n.\n        \nResolving\n \ndeltas\n: \n100\n%\n (\n120\n/\n120\n), \ndone\n.\n        \nChecking\n \nconnectivity\n... \ndone\n.\n        \n$\n \nls\n\n        \nincubator-mynewt-site\n\n        \n$\n \nls\n \nincubator-mynewt-site/\n\n        \ndocs\n        \nimages\n      \nmkdocs\n.\nyml\n\n\n\n\n\n\n\n\nCreate a new branch to work on your documentation and move to that branch.\n\n\n\n\n        \n$\n \ngit\n \ncheckout\n \n-b\n \nyour-branch-name\n\n\n\n\n\n\nFile to be edited\n\n\nThe file you will edit is named try_markdown.md. It is in the incubator-mynewt-site/docs/os/tutorials/ directory.\n\n\nEditing an existing page\n\n\n\n\n\n\nOpen the application Mou.\n\n\n\n\n\n\nOpen the file incubator-mynewt-site/docs/os/tutorials/try_markdown.md in Mou.\n\n\n\n\n\n\nEdit the last item on the list.\n\n\n\n\n\n\nSave and quit the application.\n\n\n\n\n\n\nAdding a new page\n\n\nIf you create a new file somewhere in the \ndocs\n subdirectory to add a new page, you have to add a line in the \nmkdocs.yml\n file at the correct level. For example, if you add a new module named \"Ethernet\" by creating a new file named \nethernet.md\n in the \nmodules\n subdirectory, you have to insert the following line under \nModules:\n in the \nmkdocs.yml\n file.\n\n\n        \n-\n \nEthernet\n:\n \nmodules/ethernet\n.\nmd\n\n\n\n\n\n\nPushing changes to remote as a committer\n\n\nIf you are not a committer yet, skip this section and proceed to the \nnext section\n.\n\n\n\n\nCheck whether your remote git repository is set up. If you see the remote location as shown below you can skip the next step.\n\n\n\n\n        \n$\n \ngit\n \nremote\n \n-v\n\n        \norigin\n  \nhttps\n:\n//git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git (fetch)\n\n        \norigin\n  \nhttps\n:\n//git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git (push)\n\n\n\n\n\n\n\n\nIf, however, you do not see your remote repository, then set it up as follows.\n\n\n\n\n        \n$\n \ngit\n \nremote\n \nadd\n \norigin\n \nhttps\n:\n//git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git \n\n\n\n\n\n\n\n\nFirst check the git status. It will show you that the \ntry_markdown.md\n document has been modified. So you will stage a commit, and then commit the change. Finally, you will push the changes to the remote repository. \n\n\n\n\nDuring staging below using \ngit add\n, we use the \n-A\n option indicating you want to stage all your modifications. Instead, you can choose to specify only the files that you want to. The commit message (specified after \n-m\n) should summarize what your changes are about.\n\n\n        \n$\n \ngit\n \nstatus\n\n        \n$\n \ngit\n \nadd\n \n-A\n \n        \n$\n \ngit\n \ncommit\n \n-m\n \nMy first doc change as a trial run\n\n        \n$\n \ngit\n \npush\n \n-u\n \norigin\n \nyour-branch-name\n\n\n\n\n\n\n\n\n\n\nYou can see the changed Markdown file if you traverse the tree on the git repository \n https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git\n.\n\n\n\n\n\n\nA commit notification automatically goes out to the commits@mynewt.incubator.apache.org mailing list. The \"upstream\" manager pulls the notified changes, reviews it, and merges it to the master branch if all is well. Otherwise you get an email for further changes.\n\n\n\n\n\n\nSharing changes as a non-committer\n\n\nWe suggest you follow the proposed non-committer workflow at Apache to share your work. The direct link to the proposed workflow is \nhttps://git-wip-us.apache.org/docs/workflow.html\n. \n\n\n\n\nAssuming you have made changes to the example file, you will first commit your changes.\n\n\n\n\n        \n$\n \ngit\n \nadd\n \n-A\n \n        \n$\n \ngit\n \ncommit\n \n-m\n \nMy first doc change as a trial run\n\n\n\n\n\n\n\n\nOnce you're ready to share your changes with the rest of the project team, you can use the git format-patch command to produce a patch file (or a nice set of patches in the future) and email the patch file to dev@mynewt.incubator.apache.org. Later on you may attach multiple files in your email to the mailing list as part of an existing thread or a new one. Remember to summarize the issue you have tackled and your work if the commit message is not detailed enough.\n\n\n\n\nIf there is a JIRA ticket associated with your work you should post your patch files to the ticket.\n\n\n        \n$\n \ngit\n \nformat-patch\n \norigin/trunk\n\n\n\n\n\n\n\n\nAlternatively, you can use the mirror on github.com to submit a pull request. The mirror is located at \nhttps://github.com/apache/incubator-mynewt-site\n. It is up to you to decide whether to create a fork or a branch to work in and submit pull requests from. Remember you cannot push changes to the master on the github mirror, so you have to create a fork or a branch first. Your pull request will be reviewed by a committer for docs and merged into the master branch when the changes are understood and accepted. \n\n\n\n\nConversion to HTML\n\n\nThe conversion of the Markdown files to HTML for the website happens manually and statically using MkDocs. You cannot see automatic and immediate rendering in HTML upon making a change in the Markdown file. You can choose to stop here and proceed to changing other Markdown files in your branch.\n\n\nLocal preview of HTML files\n\n\nHowever, you have the option to download MkDocs and do a local conversion yourself to preview the pages using the built-in devserver that comes with MkDocs. But first you will have to install MkDocs for that. In order to install MkDocs you'll need Python installed on your system, as well as the Python package manager, pip. You can check if you have them already (usually you will).\n\n\n        \n$\n \npython\n \n--version\n\n        \nPython\n \n2.7.2\n\n        \n$\n \npip\n \n--version\n\n        \npip\n \n1.5.2\n\n        \n$\n \npip\n \ninstall\n \nmkdocs\n\n\n\n\n\n\nYou will then run the built-in webserver from the root of the documentation directory using the command \nmkdocs serve\n. The root directory for documentation is \nincubator-mynewt-site\n or the directory with the \nmkdocs.yml\n file.\n\n\n        \n$\n \nls\n\n        \ndocs\n        \nimages\n      \nmkdocs\n.\nyml\n\n        \n$\n \nmkdocs\n \nserve\n\n\n\n\n\n\nThen go to \nhttp://127.0.0.1:8000\n to preview your pages and see how they will look on the website! Remember that the Myself website itself will not be updated.\n\n\nFor more information on MkDocs go to \nhttp://www.mkdocs.org\n.", 
            "title": "Edit Docs"
        }, 
        {
            "location": "/os/tutorials/how_to_edit_docs/#how-to-edit-docs", 
            "text": "", 
            "title": "How to Edit Docs"
        }, 
        {
            "location": "/os/tutorials/how_to_edit_docs/#objective", 
            "text": "Learn the process of editing docs by adding some content to a test document.", 
            "title": "Objective"
        }, 
        {
            "location": "/os/tutorials/how_to_edit_docs/#markdown-mkdocs-mou", 
            "text": "The Mynewt documentation you see on the Apache incubator website is a bunch of HTML files generated using MkDocs which is a simple static site generation tool geared towards building project documentation. You can read about it at  http://www.mkdocs.org . Documentation source files are written in Markdown, and configured with a single YAML configuration file. Markdown is a lightweight markup language with plain text formatting syntax designed so that it can be converted to HTML and many other formats using a tool (which in our case is MkDocs).  You do not need to install MkDocs unless you want to actually render your documentation in HTML in order to preview it before pushing your content to the remote repository. Typically, using a Markdown editor such as  Mou  is enough to check how it will look after the document has gone through MkDocs. Go ahead and download  Mou . If you are on a Windows machine, download the  editor of your choice .  Currently someone in the project is designated to use MkDocs to generate the HTML pages periodically after changes have been reviewed and accepted into the master branch.", 
            "title": "Markdown, MkDocs, Mou"
        }, 
        {
            "location": "/os/tutorials/how_to_edit_docs/#access-to-the-apache-repo", 
            "text": "Get an account on Apache. You do not need a committer account to view the website or clone the repository but you need it to push changes to it.  If you are not a committer, you may follow the proposed non-committer workflow to share your work. The direct link to the proposed workflow is  https://git-wip-us.apache.org/docs/workflow.html . You will find the steps described in more detail later in this tutorial.", 
            "title": "Access to the Apache repo"
        }, 
        {
            "location": "/os/tutorials/how_to_edit_docs/#making-a-local-copy", 
            "text": "Copy the document source files into a local directory and look at the contents of the copied directory to get an idea of the directory structure. Use http instead of https if you are a non-committer.            $   git   clone   https : //git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git \n         Cloning   into   incubator-mynewt-site ...\n         remote :  Counting   objects :  330 ,  done .\n         remote :  Compressing   objects :  100 %  ( 263 / 263 ),  done .\n         remote :  Total   330  ( delta   120 ),  reused   0  ( delta   0 )\n         Receiving   objects :  100 %  ( 330 / 330 ),  4.34   MiB   |   830.00   KiB/s ,  done .\n         Resolving   deltas :  100 %  ( 120 / 120 ),  done .\n         Checking   connectivity ...  done .\n         $   ls \n         incubator-mynewt-site \n         $   ls   incubator-mynewt-site/ \n         docs          images        mkdocs . yml    Create a new branch to work on your documentation and move to that branch.            $   git   checkout   -b   your-branch-name", 
            "title": "Making a local copy"
        }, 
        {
            "location": "/os/tutorials/how_to_edit_docs/#file-to-be-edited", 
            "text": "The file you will edit is named try_markdown.md. It is in the incubator-mynewt-site/docs/os/tutorials/ directory.", 
            "title": "File to be edited"
        }, 
        {
            "location": "/os/tutorials/how_to_edit_docs/#editing-an-existing-page", 
            "text": "Open the application Mou.    Open the file incubator-mynewt-site/docs/os/tutorials/try_markdown.md in Mou.    Edit the last item on the list.    Save and quit the application.", 
            "title": "Editing an existing page"
        }, 
        {
            "location": "/os/tutorials/how_to_edit_docs/#adding-a-new-page", 
            "text": "If you create a new file somewhere in the  docs  subdirectory to add a new page, you have to add a line in the  mkdocs.yml  file at the correct level. For example, if you add a new module named \"Ethernet\" by creating a new file named  ethernet.md  in the  modules  subdirectory, you have to insert the following line under  Modules:  in the  mkdocs.yml  file.           -   Ethernet :   modules/ethernet . md", 
            "title": "Adding a new page"
        }, 
        {
            "location": "/os/tutorials/how_to_edit_docs/#pushing-changes-to-remote-as-a-committer", 
            "text": "If you are not a committer yet, skip this section and proceed to the  next section .   Check whether your remote git repository is set up. If you see the remote location as shown below you can skip the next step.            $   git   remote   -v \n         origin    https : //git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git (fetch) \n         origin    https : //git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git (push)    If, however, you do not see your remote repository, then set it up as follows.            $   git   remote   add   origin   https : //git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git     First check the git status. It will show you that the  try_markdown.md  document has been modified. So you will stage a commit, and then commit the change. Finally, you will push the changes to the remote repository.    During staging below using  git add , we use the  -A  option indicating you want to stage all your modifications. Instead, you can choose to specify only the files that you want to. The commit message (specified after  -m ) should summarize what your changes are about.           $   git   status \n         $   git   add   -A  \n         $   git   commit   -m   My first doc change as a trial run \n         $   git   push   -u   origin   your-branch-name     You can see the changed Markdown file if you traverse the tree on the git repository   https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git .    A commit notification automatically goes out to the commits@mynewt.incubator.apache.org mailing list. The \"upstream\" manager pulls the notified changes, reviews it, and merges it to the master branch if all is well. Otherwise you get an email for further changes.", 
            "title": "Pushing changes to remote as a committer"
        }, 
        {
            "location": "/os/tutorials/how_to_edit_docs/#sharing-changes-as-a-non-committer", 
            "text": "We suggest you follow the proposed non-committer workflow at Apache to share your work. The direct link to the proposed workflow is  https://git-wip-us.apache.org/docs/workflow.html .    Assuming you have made changes to the example file, you will first commit your changes.            $   git   add   -A  \n         $   git   commit   -m   My first doc change as a trial run    Once you're ready to share your changes with the rest of the project team, you can use the git format-patch command to produce a patch file (or a nice set of patches in the future) and email the patch file to dev@mynewt.incubator.apache.org. Later on you may attach multiple files in your email to the mailing list as part of an existing thread or a new one. Remember to summarize the issue you have tackled and your work if the commit message is not detailed enough.   If there is a JIRA ticket associated with your work you should post your patch files to the ticket.           $   git   format-patch   origin/trunk    Alternatively, you can use the mirror on github.com to submit a pull request. The mirror is located at  https://github.com/apache/incubator-mynewt-site . It is up to you to decide whether to create a fork or a branch to work in and submit pull requests from. Remember you cannot push changes to the master on the github mirror, so you have to create a fork or a branch first. Your pull request will be reviewed by a committer for docs and merged into the master branch when the changes are understood and accepted.", 
            "title": "Sharing changes as a non-committer"
        }, 
        {
            "location": "/os/tutorials/how_to_edit_docs/#conversion-to-html", 
            "text": "The conversion of the Markdown files to HTML for the website happens manually and statically using MkDocs. You cannot see automatic and immediate rendering in HTML upon making a change in the Markdown file. You can choose to stop here and proceed to changing other Markdown files in your branch.", 
            "title": "Conversion to HTML"
        }, 
        {
            "location": "/os/tutorials/how_to_edit_docs/#local-preview-of-html-files", 
            "text": "However, you have the option to download MkDocs and do a local conversion yourself to preview the pages using the built-in devserver that comes with MkDocs. But first you will have to install MkDocs for that. In order to install MkDocs you'll need Python installed on your system, as well as the Python package manager, pip. You can check if you have them already (usually you will).           $   python   --version \n         Python   2.7.2 \n         $   pip   --version \n         pip   1.5.2 \n         $   pip   install   mkdocs   You will then run the built-in webserver from the root of the documentation directory using the command  mkdocs serve . The root directory for documentation is  incubator-mynewt-site  or the directory with the  mkdocs.yml  file.           $   ls \n         docs          images        mkdocs . yml \n         $   mkdocs   serve   Then go to  http://127.0.0.1:8000  to preview your pages and see how they will look on the website! Remember that the Myself website itself will not be updated.  For more information on MkDocs go to  http://www.mkdocs.org .", 
            "title": "Local preview of HTML files"
        }, 
        {
            "location": "/os/core_os/mynewt_os/", 
            "text": "Mynewt Core OS\n\n\nThe Mynewt Core OS is a multitasking, preemptive real-time operating system combining a scheduler with typical RTOS features such as mutexes, semaphores, memory pools, etc. The Mynewt Core OS also provides a number of useful utilities such as a task watchdog, networking stack memory buffers and time management API. Each of these features is described in detail in its own section of the manual.\n\n\nA multitasking, preemptive operating system is one in which a number of different tasks can be instantiated and assigned a priority, with higher priority tasks running before lower priority tasks. Furthermore, if a lower priority task is running and a higher priority task wants to run, the lower priority task is halted and the higher priority task is allowed to run. In other words, the lower priority task is preempted by the higher priority task.\n\n\nWhy use an OS?\n\n\nYou may ask yourself \"why do I need a multitasking preemptive OS\"? The answer may indeed be that you do not. Some applications are simple and only require a polling loop. Others are more complex and may require that certain jobs are executed in a timely manner or before other jobs are executed. If you have a simple polling loop, you cannot move on to service a job until the current job is done being serviced. With the Mynewt OS, the application developer need not worry about certain jobs taking too long or not executing in a timely fashion; the OS provides mechanisms to deal with these situations. Another benefit of using an OS is that it helps shield application developers from other application code being written; the developer does not have to worry (or has to worry less) about other application code behaving badly and causing undesirable behavior or preventing their code from executing properly. Other benefits of using an OS (and the Mynewt OS in particular) is that it also provides features that the developer would otherwise need to create on his/her own. \n\n\nCore OS Features\n\n\n\n\n\n\nScheduler/context switching\n\n\nTime\n\n\nTasks\n\n\nEvent queues/callouts\n\n\nSemaphores\n\n\nMutexes\n\n\nMemory pools\n\n\nHeap\n\n\nMbufs\n\n\nSanity\n\n\nCallouts\n\n\nPorting OS to other platforms\n\n\n\n\nBasic OS Application Creation\n\n\nCreating an application using the Mynewt Core OS is a relatively simple task: once you have installed the basic Newt Tool structure (build structure) for your application and created your BSP (Board Support Package), the developer initializes the OS by calling \nos_init()\n, performs application specific initializations, and then starts the os by calling \nos_start()\n. \n\n\nThe \nos_init()\n API performs two basic functions: calls architecture and bsp specific setup and initializes the idle task of the OS. This is required before the OS is started. The OS start API initializes the OS time tick interrupt and starts the highest priority task running (i.e starts the scheduler). Note that \nos_start()\n never returns; once called the device is either running in an application task context or in idle task context.\n\n\nInitializing application modules and tasks can get somewhat complicated with RTOS's similar to Mynewt. Care must be taken that the API provided by a task are initialized prior to being called by another (higher priority) task. \n\n\nFor example, take a simple application with two tasks (tasks 1 and 2, with task 1 higher priority than task 2). Task 2 provides an API which has a semaphore lock and this semaphore is initialized by task 2 when the task handler for task 2 is called. Task 1 is expected to call this API.\n\n\nConsider the sequence of events when the OS is started. The scheduler starts running and picks the highest priority task (task 1 in this case). The task handler function for task 1 is called and will keep running until it yields execution. Before yielding, code in the task 1 handler function calls the API provided by task 2. The semaphore being accessed in the task 2 API has yet to be initialized since the task 2 handler function has not had a chance to run! This will lead to undesirable behavior and will need to be addressed by the application developer. Note that the Mynewt OS does guard against internal API being called before the OS has started (they will return error) but it does not safeguard application defined objects from access prior to initialization.\n\n\nExample\n\n\nOne way to avoid initialization issues like the one described above is to perform task initializations prior to starting the OS. The code example shown below illustrates this concept. The application initializes the OS, calls an application specific \"task initialization\" function, and then starts the OS. The application task initialization function is responsible for initializing all the data objects that each task exposes to the other tasks. The tasks themselves are also initialized at this time (by calling \nos_task_init()\n). \n\n\nIn the example, each task works in a ping-pong like fashion: task 1 wakes up, adds a token to semaphore 1 and then waits for a token from semaphore 2. Task 2 waits for a token on semaphore 1 and once it gets it, adds a token to semaphore 2. Notice that the semaphores are initialized by the application specific task initialization functions and not inside the task handler functions. If task 2 (being lower in priority than task 1) had called os_sem_init() for task2_sem inside task2_handler(), task 1 would have called os_sem_pend() using task2_sem before task2_sem was initialized.\n\n\n/* Task 1 handler function */\nvoid\ntask1_handler(void *arg)\n{\n    while (1) {\n        /* Release semaphore to task 2 */\n        os_sem_release(\ntask1_sem);\n\n        /* Wait for semaphore from task 2 */\n        os_sem_pend(\ntask2_sem, OS_TIMEOUT_NEVER);\n    }\n}\n\n/* Task 2 handler function */\nvoid\ntask2_handler(void *arg)\n{\n    struct os_task *t;\n\n    while (1) {\n        /* Wait for semaphore from task1 */\n        os_sem_pend(\ntask1_sem, OS_TIMEOUT_NEVER);\n\n        /* Release task2 semaphore */\n        os_sem_release(\ntask2_sem);\n    }\n}\n\n\n/* Initialize task 1 exposed data objects */\nvoid\ntask1_init(void)\n{\n    /* Initialize task1 semaphore */\n    os_sem_init(\ntask1_sem, 0);\n}\n\n/* Initialize task 2 exposed data objects */\nvoid\ntask2_init(void)\n{\n    /* Initialize task1 semaphore */\n    os_sem_init(\ntask2_sem, 0);\n}\n\n/**\n * init_app_tasks\n *  \n * Called by main.c after os_init(). This function performs initializations \n * that are required before tasks are running. \n *  \n * @return int 0 success; error otherwise.\n */\nstatic int\ninit_app_tasks(void)\n{\n    /*\n     * Initialize tasks 1 and 2. Note that the task handlers are not called yet; they will\n     * be called when the OS is started.\n     */\n    os_task_init(\ntask1, \ntask1\n, task1_handler, NULL, TASK1_PRIO, \n                 OS_WAIT_FOREVER, task1_stack, TASK1_STACK_SIZE);\n\n    os_task_init(\ntask2, \ntask2\n, task2_handler, NULL, TASK2_PRIO, \n                 OS_WAIT_FOREVER, task2_stack, TASK2_STACK_SIZE);\n\n    /* Call task specific initialization functions. */\n    task1_init();\n    task2_init();\n\n    return 0;\n}\n\n/**\n * main\n *  \n * The main function for the application. This function initializes the os, calls \n * the application specific task initialization function. then starts the \n * OS. We should not return from os start! \n */\nint\nmain(void)\n{\n    int i;\n    int rc;\n    uint32_t seed;\n\n    /* Initialize OS */\n    os_init();\n\n    /* Initialize application specific tasks */\n    init_app_tasks();\n\n    /* Start the OS */\n    os_start();\n\n    /* os start should never return. If it does, this should be an error */\n    assert(0);\n\n    return rc;\n}\n\n\n\n\n\nOS Functions\n\n\nThe functions available at the OS level are:\n\n\n\n\nos_init\n\n\nos_start\n\n\nos_started", 
            "title": "toc"
        }, 
        {
            "location": "/os/core_os/mynewt_os/#mynewt-core-os", 
            "text": "The Mynewt Core OS is a multitasking, preemptive real-time operating system combining a scheduler with typical RTOS features such as mutexes, semaphores, memory pools, etc. The Mynewt Core OS also provides a number of useful utilities such as a task watchdog, networking stack memory buffers and time management API. Each of these features is described in detail in its own section of the manual.  A multitasking, preemptive operating system is one in which a number of different tasks can be instantiated and assigned a priority, with higher priority tasks running before lower priority tasks. Furthermore, if a lower priority task is running and a higher priority task wants to run, the lower priority task is halted and the higher priority task is allowed to run. In other words, the lower priority task is preempted by the higher priority task.", 
            "title": "Mynewt Core OS"
        }, 
        {
            "location": "/os/core_os/mynewt_os/#why-use-an-os", 
            "text": "You may ask yourself \"why do I need a multitasking preemptive OS\"? The answer may indeed be that you do not. Some applications are simple and only require a polling loop. Others are more complex and may require that certain jobs are executed in a timely manner or before other jobs are executed. If you have a simple polling loop, you cannot move on to service a job until the current job is done being serviced. With the Mynewt OS, the application developer need not worry about certain jobs taking too long or not executing in a timely fashion; the OS provides mechanisms to deal with these situations. Another benefit of using an OS is that it helps shield application developers from other application code being written; the developer does not have to worry (or has to worry less) about other application code behaving badly and causing undesirable behavior or preventing their code from executing properly. Other benefits of using an OS (and the Mynewt OS in particular) is that it also provides features that the developer would otherwise need to create on his/her own.", 
            "title": "Why use an OS?"
        }, 
        {
            "location": "/os/core_os/mynewt_os/#core-os-features", 
            "text": "Scheduler/context switching  Time  Tasks  Event queues/callouts  Semaphores  Mutexes  Memory pools  Heap  Mbufs  Sanity  Callouts  Porting OS to other platforms", 
            "title": "Core OS Features"
        }, 
        {
            "location": "/os/core_os/mynewt_os/#basic-os-application-creation", 
            "text": "Creating an application using the Mynewt Core OS is a relatively simple task: once you have installed the basic Newt Tool structure (build structure) for your application and created your BSP (Board Support Package), the developer initializes the OS by calling  os_init() , performs application specific initializations, and then starts the os by calling  os_start() .   The  os_init()  API performs two basic functions: calls architecture and bsp specific setup and initializes the idle task of the OS. This is required before the OS is started. The OS start API initializes the OS time tick interrupt and starts the highest priority task running (i.e starts the scheduler). Note that  os_start()  never returns; once called the device is either running in an application task context or in idle task context.  Initializing application modules and tasks can get somewhat complicated with RTOS's similar to Mynewt. Care must be taken that the API provided by a task are initialized prior to being called by another (higher priority) task.   For example, take a simple application with two tasks (tasks 1 and 2, with task 1 higher priority than task 2). Task 2 provides an API which has a semaphore lock and this semaphore is initialized by task 2 when the task handler for task 2 is called. Task 1 is expected to call this API.  Consider the sequence of events when the OS is started. The scheduler starts running and picks the highest priority task (task 1 in this case). The task handler function for task 1 is called and will keep running until it yields execution. Before yielding, code in the task 1 handler function calls the API provided by task 2. The semaphore being accessed in the task 2 API has yet to be initialized since the task 2 handler function has not had a chance to run! This will lead to undesirable behavior and will need to be addressed by the application developer. Note that the Mynewt OS does guard against internal API being called before the OS has started (they will return error) but it does not safeguard application defined objects from access prior to initialization.", 
            "title": "Basic OS Application Creation"
        }, 
        {
            "location": "/os/core_os/mynewt_os/#example", 
            "text": "One way to avoid initialization issues like the one described above is to perform task initializations prior to starting the OS. The code example shown below illustrates this concept. The application initializes the OS, calls an application specific \"task initialization\" function, and then starts the OS. The application task initialization function is responsible for initializing all the data objects that each task exposes to the other tasks. The tasks themselves are also initialized at this time (by calling  os_task_init() ).   In the example, each task works in a ping-pong like fashion: task 1 wakes up, adds a token to semaphore 1 and then waits for a token from semaphore 2. Task 2 waits for a token on semaphore 1 and once it gets it, adds a token to semaphore 2. Notice that the semaphores are initialized by the application specific task initialization functions and not inside the task handler functions. If task 2 (being lower in priority than task 1) had called os_sem_init() for task2_sem inside task2_handler(), task 1 would have called os_sem_pend() using task2_sem before task2_sem was initialized.  /* Task 1 handler function */\nvoid\ntask1_handler(void *arg)\n{\n    while (1) {\n        /* Release semaphore to task 2 */\n        os_sem_release( task1_sem);\n\n        /* Wait for semaphore from task 2 */\n        os_sem_pend( task2_sem, OS_TIMEOUT_NEVER);\n    }\n}\n\n/* Task 2 handler function */\nvoid\ntask2_handler(void *arg)\n{\n    struct os_task *t;\n\n    while (1) {\n        /* Wait for semaphore from task1 */\n        os_sem_pend( task1_sem, OS_TIMEOUT_NEVER);\n\n        /* Release task2 semaphore */\n        os_sem_release( task2_sem);\n    }\n}\n\n\n/* Initialize task 1 exposed data objects */\nvoid\ntask1_init(void)\n{\n    /* Initialize task1 semaphore */\n    os_sem_init( task1_sem, 0);\n}\n\n/* Initialize task 2 exposed data objects */\nvoid\ntask2_init(void)\n{\n    /* Initialize task1 semaphore */\n    os_sem_init( task2_sem, 0);\n}\n\n/**\n * init_app_tasks\n *  \n * Called by main.c after os_init(). This function performs initializations \n * that are required before tasks are running. \n *  \n * @return int 0 success; error otherwise.\n */\nstatic int\ninit_app_tasks(void)\n{\n    /*\n     * Initialize tasks 1 and 2. Note that the task handlers are not called yet; they will\n     * be called when the OS is started.\n     */\n    os_task_init( task1,  task1 , task1_handler, NULL, TASK1_PRIO, \n                 OS_WAIT_FOREVER, task1_stack, TASK1_STACK_SIZE);\n\n    os_task_init( task2,  task2 , task2_handler, NULL, TASK2_PRIO, \n                 OS_WAIT_FOREVER, task2_stack, TASK2_STACK_SIZE);\n\n    /* Call task specific initialization functions. */\n    task1_init();\n    task2_init();\n\n    return 0;\n}\n\n/**\n * main\n *  \n * The main function for the application. This function initializes the os, calls \n * the application specific task initialization function. then starts the \n * OS. We should not return from os start! \n */\nint\nmain(void)\n{\n    int i;\n    int rc;\n    uint32_t seed;\n\n    /* Initialize OS */\n    os_init();\n\n    /* Initialize application specific tasks */\n    init_app_tasks();\n\n    /* Start the OS */\n    os_start();\n\n    /* os start should never return. If it does, this should be an error */\n    assert(0);\n\n    return rc;\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mynewt_os/#os-functions", 
            "text": "The functions available at the OS level are:   os_init  os_start  os_started", 
            "title": "OS Functions"
        }, 
        {
            "location": "/os/core_os/os_init/", 
            "text": "os_init\n\n\nvoid os_init(void)\n\n\n\n\n\nInitializes the OS. Must be called before the OS is started (i.e. os_start() is called).\n\n\n\n\nArguments\n\n\nNone\n\n\n\n\nReturned values\n\n\nNone\n\n\n\n\nNotes\n\n\nThe call to os_init performs architecture and bsp initializations and initializes the idle task.\n\n\nThis function does not start the OS, the OS time tick interrupt, or the scheduler.", 
            "title": "os_init"
        }, 
        {
            "location": "/os/core_os/os_init/#os_init", 
            "text": "void os_init(void)  Initializes the OS. Must be called before the OS is started (i.e. os_start() is called).", 
            "title": "os_init"
        }, 
        {
            "location": "/os/core_os/os_init/#arguments", 
            "text": "None", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/os_init/#returned-values", 
            "text": "None", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/os_init/#notes", 
            "text": "The call to os_init performs architecture and bsp initializations and initializes the idle task.  This function does not start the OS, the OS time tick interrupt, or the scheduler.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/os_start/", 
            "text": "os_start\n\n\nvoid os_start(void)\n\n\n\n\n\nStarts the OS by initializing and enabling the OS time tick and starting the scheduler.\n\n\nThis function does not return.\n\n\n\n\nArguments\n\n\nNone\n\n\n\n\nReturned values\n\n\nNone (does not return).\n\n\n\n\nNotes\n\n\nOnce os_start has been called, context is switched to the highest priority task that was initialized prior to calling os_start.", 
            "title": "os_start"
        }, 
        {
            "location": "/os/core_os/os_start/#os_start", 
            "text": "void os_start(void)  Starts the OS by initializing and enabling the OS time tick and starting the scheduler.  This function does not return.", 
            "title": "os_start"
        }, 
        {
            "location": "/os/core_os/os_start/#arguments", 
            "text": "None", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/os_start/#returned-values", 
            "text": "None (does not return).", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/os_start/#notes", 
            "text": "Once os_start has been called, context is switched to the highest priority task that was initialized prior to calling os_start.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/os_started/", 
            "text": "os_started\n\n\nint os_started(void)\n\n\n\n\n\nReturns 'true' (1) if the os has been started; 0 otherwise.\n\n\n\n\nArguments\n\n\nNone\n\n\n\n\nReturned values\n\n\nInteger value with 0 meaning the OS has not been started and 1 indicating the OS has been started (i.e. os_start() has been called).", 
            "title": "os_started"
        }, 
        {
            "location": "/os/core_os/os_started/#os_started", 
            "text": "int os_started(void)  Returns 'true' (1) if the os has been started; 0 otherwise.", 
            "title": "os_started"
        }, 
        {
            "location": "/os/core_os/os_started/#arguments", 
            "text": "None", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/os_started/#returned-values", 
            "text": "Integer value with 0 meaning the OS has not been started and 1 indicating the OS has been started (i.e. os_start() has been called).", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/context_switch/context_switch/", 
            "text": "Scheduler/Context Switching\n\n\nScheduler's job is to maintain the list of tasks and decide which one should be running next.\n\n\nDescription\n\n\nTask states can be \nrunning\n, \nready to run\n or \nsleeping\n.\n\n\nWhen task is \nrunning\n, CPU is executing in that task's context. The program counter (PC) is pointing to instructions task wants to execute and stack pointer (SP) is pointing to task's stack.\n\n\nTask which is \nready to run\n wants to get on the CPU to do its work.\n\n\nTask which is \nsleeping\n has no more work to do. It's waiting for someone else to wake it up.\n\n\nScheduler algorithm is simple: from among the tasks which are ready to run, pick the the one with highest priority (lowest numeric value in task's t_prio field), and make its state \nrunning\n.\n\n\nTasks which are either \nrunning\n or \nready to run\n are kept in linked list \ng_os_run_list\n. This list is ordered by priority.\n\n\nTasks which are \nsleeping\n are kept in linked list \ng_os_sleep_list\n.\n\n\nScheduler has a CPU architecture specific component; this code is responsible for swapping in the task which should be \nrunning\n. This process is called context switch. During context switching the state of the CPU (e.g. registers) for the currently \nrunning\n task is stored and the new task is swapped in.\n\n\nList of Functions\n\n\nThe functions available in context_switch are:\n\n\n\n\nos_sched\n\n\nos_arch_ctx_sw\n\n\nos_sched_ctx_sw_hook\n\n\nos_sched_get_current_task\n\n\nos_sched_insert\n\n\nos_sched_next_task\n\n\nos_sched_os_timer_exp\n\n\nos_sched_resort\n\n\nos_sched_set_current_task\n\n\nos_sched_sleep\n\n\nos_sched_wakeup", 
            "title": "toc"
        }, 
        {
            "location": "/os/core_os/context_switch/context_switch/#schedulercontext-switching", 
            "text": "Scheduler's job is to maintain the list of tasks and decide which one should be running next.", 
            "title": "Scheduler/Context Switching"
        }, 
        {
            "location": "/os/core_os/context_switch/context_switch/#description", 
            "text": "Task states can be  running ,  ready to run  or  sleeping .  When task is  running , CPU is executing in that task's context. The program counter (PC) is pointing to instructions task wants to execute and stack pointer (SP) is pointing to task's stack.  Task which is  ready to run  wants to get on the CPU to do its work.  Task which is  sleeping  has no more work to do. It's waiting for someone else to wake it up.  Scheduler algorithm is simple: from among the tasks which are ready to run, pick the the one with highest priority (lowest numeric value in task's t_prio field), and make its state  running .  Tasks which are either  running  or  ready to run  are kept in linked list  g_os_run_list . This list is ordered by priority.  Tasks which are  sleeping  are kept in linked list  g_os_sleep_list .  Scheduler has a CPU architecture specific component; this code is responsible for swapping in the task which should be  running . This process is called context switch. During context switching the state of the CPU (e.g. registers) for the currently  running  task is stored and the new task is swapped in.", 
            "title": "Description"
        }, 
        {
            "location": "/os/core_os/context_switch/context_switch/#list-of-functions", 
            "text": "The functions available in context_switch are:   os_sched  os_arch_ctx_sw  os_sched_ctx_sw_hook  os_sched_get_current_task  os_sched_insert  os_sched_next_task  os_sched_os_timer_exp  os_sched_resort  os_sched_set_current_task  os_sched_sleep  os_sched_wakeup", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched/", 
            "text": "os_sched \n\n\nvoid\n \nos_sched\n(\nstruct\n \nos_task\n \n*\nnext_t\n)\n\n\n\n\n\nPerforms context switch if needed. If \nnext_t\n is set, that task will be made \nrunning\n. If \nnext_t\n is NULL, highest priority \nready to run\n is swapped in. This function can be called when new tasks were made \nready to run\n or if the current task is moved to \nsleeping\n state.\n\n\nThis function will call the architecture specific routine to swap in the new task.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnext_t\n\n\nPointer to task which must run next (optional)\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nInterrupts must be disabled when calling this.\n\n\nExample\n\n\n\n\nos_error_t\n\n\nos_mutex_release\n(\nstruct\n \nos_mutex\n \n*mu\n)\n{\n    ...\n    \nOS_EXIT_CRITICAL\n(\nsr\n);\n\n    \n/* Re-schedule if needed */\n\n    \nif\n (\nresched\n) {\n        \nos_sched\n(\nrdy\n);\n    }\n\n    \nreturn\n \nOS_OK\n;\n\n}", 
            "title": "os_sched"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched/#os_sched", 
            "text": "void   os_sched ( struct   os_task   * next_t )  Performs context switch if needed. If  next_t  is set, that task will be made  running . If  next_t  is NULL, highest priority  ready to run  is swapped in. This function can be called when new tasks were made  ready to run  or if the current task is moved to  sleeping  state.  This function will call the architecture specific routine to swap in the new task.", 
            "title": " os_sched "
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched/#arguments", 
            "text": "Arguments  Description      next_t  Pointer to task which must run next (optional)", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched/#notes", 
            "text": "Interrupts must be disabled when calling this.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched/#example", 
            "text": "os_error_t  os_mutex_release ( struct   os_mutex   *mu )\n{\n    ...\n     OS_EXIT_CRITICAL ( sr );\n\n     /* Re-schedule if needed */ \n     if  ( resched ) {\n         os_sched ( rdy );\n    }\n\n     return   OS_OK ;\n\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/context_switch/os_arch_ctx_sw/", 
            "text": "os_arch_ctx_sw \n\n\nvoid os_arch_ctx_sw(struct os_task *next_t)\n\n\nChange the state of task pointed by \nnext_t\n to be \nrunning\n.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnext_t\n\n\nPointer to task which must run next\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nThis would get called from another task's context.\n\n\nExample\n\n\n\n\nvoid\n\n    \nos_sched\n(\nstruct\n \nos_task\n \n*\nnext_t\n)\n    {\n        \nos_sr_t\n \nsr\n;\n\n        \nOS_ENTER_CRITICAL\n(\nsr\n);\n\n        \nif\n (\n!\nnext_t\n) {\n            \nnext_t\n \n=\n \nos_sched_next_task\n();\n        }\n\n        \nif\n (\nnext_t\n \n!=\n \ng_current_task\n) {\n            \nos_arch_ctx_sw\n(\nnext_t\n);\n        }\n\n        \nOS_EXIT_CRITICAL\n(\nsr\n);\n    }", 
            "title": "os_arch_ctx_sw"
        }, 
        {
            "location": "/os/core_os/context_switch/os_arch_ctx_sw/#os_arch_ctx_sw", 
            "text": "void os_arch_ctx_sw(struct os_task *next_t)  Change the state of task pointed by  next_t  to be  running .", 
            "title": " os_arch_ctx_sw "
        }, 
        {
            "location": "/os/core_os/context_switch/os_arch_ctx_sw/#arguments", 
            "text": "Arguments  Description      next_t  Pointer to task which must run next", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/context_switch/os_arch_ctx_sw/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/context_switch/os_arch_ctx_sw/#notes", 
            "text": "This would get called from another task's context.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/context_switch/os_arch_ctx_sw/#example", 
            "text": "void \n     os_sched ( struct   os_task   * next_t )\n    {\n         os_sr_t   sr ;\n\n         OS_ENTER_CRITICAL ( sr );\n\n         if  ( ! next_t ) {\n             next_t   =   os_sched_next_task ();\n        }\n\n         if  ( next_t   !=   g_current_task ) {\n             os_arch_ctx_sw ( next_t );\n        }\n\n         OS_EXIT_CRITICAL ( sr );\n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_ctx_sw_hook/", 
            "text": "os_sched_ctx_sw_hook \n\n\nvoid\n \nos_sched_ctx_sw_hook\n(\nstruct\n \nos_task\n \n*\nnext_t\n)\n\n\n\n\n\nPerforms task accounting when context switching.\n\n\nThis function must be called from the architecture specific context switching routine \nos_arch_ctx_sw()\n before resuming execution of the \nrunning\n task.\n\n\nArguments\n\n\nN/A\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nExample\n\n\n\n\nvoid\n\n\nos_arch_ctx_sw\n(\nstruct\n \nos_task\n \n*t\n)\n{\n    \nos_sched_ctx_sw_hook\n(\nt\n);\n\n    \n/* Set PendSV interrupt pending bit to force context switch */\n\n    \nSCB-\nICSR\n \n=\n \nSCB_ICSR_PENDSVSET_Msk\n;\n}", 
            "title": "os_sched_ctx_sw_hook"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_ctx_sw_hook/#os_sched_ctx_sw_hook", 
            "text": "void   os_sched_ctx_sw_hook ( struct   os_task   * next_t )  Performs task accounting when context switching.  This function must be called from the architecture specific context switching routine  os_arch_ctx_sw()  before resuming execution of the  running  task.", 
            "title": " os_sched_ctx_sw_hook "
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_ctx_sw_hook/#arguments", 
            "text": "N/A", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_ctx_sw_hook/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_ctx_sw_hook/#notes", 
            "text": "", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_ctx_sw_hook/#example", 
            "text": "void  os_arch_ctx_sw ( struct   os_task   *t )\n{\n     os_sched_ctx_sw_hook ( t );\n\n     /* Set PendSV interrupt pending bit to force context switch */ \n     SCB- ICSR   =   SCB_ICSR_PENDSVSET_Msk ;\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_get_current_task/", 
            "text": "os_sched_get_current_task \n\n\nstruct\n \nos_task\n \n*os_sched_get_current_task\n(\nvoid\n)\n\n\n\n\n\nReturns the pointer to task which is currently \nrunning\n.\n\n\nArguments\n\n\nN/A\n\n\nReturned values\n\n\nSee description.\n\n\nNotes\n\n\nExample\n\n\n\n\nvoid\n\n\nos_time_delay\n(\nint32_t\n \nosticks\n)\n{\n    \nos_sr_t\n \nsr\n;\n\n    \nif\n (\nosticks\n \n \n0\n) {\n        \nOS_ENTER_CRITICAL\n(\nsr\n);\n        \nos_sched_sleep\n(\nos_sched_get_current_task\n(), (\nos_time_t\n)\nosticks\n);\n        \nOS_EXIT_CRITICAL\n(\nsr\n);\n        \nos_sched\n(\nNULL\n);\n    }\n}", 
            "title": "os_sched_get_current_task"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_get_current_task/#os_sched_get_current_task", 
            "text": "struct   os_task   *os_sched_get_current_task ( void )  Returns the pointer to task which is currently  running .", 
            "title": " os_sched_get_current_task "
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_get_current_task/#arguments", 
            "text": "N/A", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_get_current_task/#returned-values", 
            "text": "See description.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_get_current_task/#notes", 
            "text": "", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_get_current_task/#example", 
            "text": "void  os_time_delay ( int32_t   osticks )\n{\n     os_sr_t   sr ;\n\n     if  ( osticks     0 ) {\n         OS_ENTER_CRITICAL ( sr );\n         os_sched_sleep ( os_sched_get_current_task (), ( os_time_t ) osticks );\n         OS_EXIT_CRITICAL ( sr );\n         os_sched ( NULL );\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_insert/", 
            "text": "os_sched_insert \n\n\nos_error_t\n\n\nos_sched_insert\n(\nstruct\n \nos_task\n \n*t\n)\n\n\n\n\n\nInsert task into scheduler's \nready to run\n list.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt\n\n\nPointer to task\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns OS_EINVAL if task state is not \nREADY\n.\nReturns 0 on success.\n\n\nNotes\n\n\nYou probably don't need to call this.", 
            "title": "os_sched_insert"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_insert/#os_sched_insert", 
            "text": "os_error_t  os_sched_insert ( struct   os_task   *t )  Insert task into scheduler's  ready to run  list.", 
            "title": " os_sched_insert "
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_insert/#arguments", 
            "text": "Arguments  Description      t  Pointer to task", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_insert/#returned-values", 
            "text": "Returns OS_EINVAL if task state is not  READY .\nReturns 0 on success.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_insert/#notes", 
            "text": "You probably don't need to call this.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_next_task/", 
            "text": "os_sched_next_task \n\n\nstruct\n \nos_task\n \n*os_sched_next_task\n(\nvoid\n)\n\n\n\n\n\nReturns the pointer to highest priority task from the list which are \nready to run\n.\n\n\nArguments\n\n\nN/A\n\n\nReturned values\n\n\nSee description.\n\n\nNotes\n\n\nShould be called with interrupts disabled.", 
            "title": "os_sched_next_task"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_next_task/#os_sched_next_task", 
            "text": "struct   os_task   *os_sched_next_task ( void )  Returns the pointer to highest priority task from the list which are  ready to run .", 
            "title": " os_sched_next_task "
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_next_task/#arguments", 
            "text": "N/A", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_next_task/#returned-values", 
            "text": "See description.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_next_task/#notes", 
            "text": "Should be called with interrupts disabled.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_os_timer_exp/", 
            "text": "os_sched_os_timer_exp \n\n\nvoid\n \nos_sched_os_timer_exp\n(\nvoid\n)\n\n\n\n\n\nInform scheduler that OS time has moved forward, and it should inspect tasks which are \nsleeping\n to check whether they should be moved to \ng_run_list\n or not.\n\n\nThis function should be called from code which handles moving OS time forward. After calling it, the highest priority task which is \nready to run\n might've changed, so call to \nos_sched()\n should be done.\n\n\nArguments\n\n\nN/A\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nExample\n\n\n\n\nvoid\n\n\ntimer_handler\n(\nvoid\n)\n{\n    \nos_time_tick\n();\n    \nos_callout_tick\n();\n    \nos_sched_os_timer_exp\n();\n    \nos_sched\n(\nNULL\n);\n}", 
            "title": "os_sched_os_timer_exp"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_os_timer_exp/#os_sched_os_timer_exp", 
            "text": "void   os_sched_os_timer_exp ( void )  Inform scheduler that OS time has moved forward, and it should inspect tasks which are  sleeping  to check whether they should be moved to  g_run_list  or not.  This function should be called from code which handles moving OS time forward. After calling it, the highest priority task which is  ready to run  might've changed, so call to  os_sched()  should be done.", 
            "title": " os_sched_os_timer_exp "
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_os_timer_exp/#arguments", 
            "text": "N/A", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_os_timer_exp/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_os_timer_exp/#notes", 
            "text": "", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_os_timer_exp/#example", 
            "text": "void  timer_handler ( void )\n{\n     os_time_tick ();\n     os_callout_tick ();\n     os_sched_os_timer_exp ();\n     os_sched ( NULL );\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_resort/", 
            "text": "os_sched_resort \n\n\nvoid\n \nos_sched_resort\n(\nstruct\n \nos_task\n \n*t\n)\n\n\n\n\n\nInform scheduler that the priority of the task \nt\n has changed (e.g. in order to avoid priority inversion), and the \nready to run\n list should be re-sorted.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt\n\n\nPointer to a task whose priority has changed\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nt\n must be \nready to run\n before calling this.\n\n\nExample\n\n\n\n\nos_error_t\n\n\nos_mutex_pend\n(\nstruct\n \nos_mutex\n \n*mu\n, \nuint32_t\n \ntimeout\n)\n{\n    ....\n        \n/* Change priority of owner if needed */\n\n    \nif\n (\nmu-\nmu_owner-\nt_prio\n \n \ncurrent-\nt_prio\n) {\n        \nmu-\nmu_owner-\nt_prio\n \n=\n \ncurrent-\nt_prio\n;\n        \nos_sched_resort\n(\nmu-\nmu_owner\n);\n    }\n    ....\n}", 
            "title": "os_sched_resort"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_resort/#os_sched_resort", 
            "text": "void   os_sched_resort ( struct   os_task   *t )  Inform scheduler that the priority of the task  t  has changed (e.g. in order to avoid priority inversion), and the  ready to run  list should be re-sorted.", 
            "title": " os_sched_resort "
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_resort/#arguments", 
            "text": "Arguments  Description      t  Pointer to a task whose priority has changed", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_resort/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_resort/#notes", 
            "text": "t  must be  ready to run  before calling this.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_resort/#example", 
            "text": "os_error_t  os_mutex_pend ( struct   os_mutex   *mu ,  uint32_t   timeout )\n{\n    ....\n         /* Change priority of owner if needed */ \n     if  ( mu- mu_owner- t_prio     current- t_prio ) {\n         mu- mu_owner- t_prio   =   current- t_prio ;\n         os_sched_resort ( mu- mu_owner );\n    }\n    ....\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_set_current_task/", 
            "text": "os_sched_set_current_task \n\n\nvoid\n \n\nos_sched_set_current_task\n(\nstruct\n \nos_task\n \n*t\n)\n\n\n\n\n\nSets the currently running task to 't'.\n\n\nThis is called from architecture specific context switching code to update scheduler state. Call is made when state of the task 't' is made \nrunning\n.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt\n\n\nPointer to a task\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nThis function simply sets the global variable holding the currently running task. It does not perform a context switch or change the os run or sleep list.", 
            "title": "os_sched_set_current_task"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_set_current_task/#os_sched_set_current_task", 
            "text": "void   os_sched_set_current_task ( struct   os_task   *t )  Sets the currently running task to 't'.  This is called from architecture specific context switching code to update scheduler state. Call is made when state of the task 't' is made  running .", 
            "title": " os_sched_set_current_task "
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_set_current_task/#arguments", 
            "text": "Arguments  Description      t  Pointer to a task", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_set_current_task/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_set_current_task/#notes", 
            "text": "This function simply sets the global variable holding the currently running task. It does not perform a context switch or change the os run or sleep list.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_sleep/", 
            "text": "os_sched_sleep \n\n\nint\n\n\nos_sched_sleep\n(\nstruct\n \nos_task\n \n*t\n, \nos_time_t\n \nnticks\n)\n\n\n\n\n\nTask 't' state is changed from \nready to run\n to \nsleeping\n. Sleep time will be specified in \nnticks\n.\n\n\nTask will be woken up after sleep timer expires, unless there are other signals causing  it to wake up.\n\n\nIf \nnticks\n is set to \nOS_TIMEOUT_NEVER\n, task never wakes up with a sleep timer.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt\n\n\nPointer to task\n\n\n\n\n\n\nnticks\n\n\nNumber of ticks to sleep in OS ticks\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns 0 on success.\n\n\nNotes\n\n\nMust be called with interrupts disabled.\n\n\nExample\n\n\n\n\nstruct\n \nos_event\n \n*\n\n\nos_eventq_get\n(\nstruct\n \nos_eventq\n \n*evq\n)\n{\n    \nstruct\n \nos_event\n \n*ev\n;\n    \nos_sr_t\n \nsr\n;\n\n    \nOS_ENTER_CRITICAL\n(\nsr\n);\n\npull_one\n:\n    \nev\n \n=\n \nSTAILQ_FIRST\n(\nevq-\nevq_list\n);\n    \nif\n (\nev\n) {\n        \nSTAILQ_REMOVE\n(\nevq-\nevq_list\n, \nev\n, \nos_event\n, \nev_next\n);\n        \nev-\nev_queued\n \n=\n \n0\n;\n    } \nelse\n {\n        \nevq-\nevq_task\n \n=\n \nos_sched_get_current_task\n();\n        \nos_sched_sleep\n(\nevq-\nevq_task\n, \nOS_TIMEOUT_NEVER\n);\n        \nOS_EXIT_CRITICAL\n(\nsr\n);\n\n        \nos_sched\n(\nNULL\n);\n\n        \nOS_ENTER_CRITICAL\n(\nsr\n);\n        \nevq-\nevq_task\n \n=\n \nNULL\n;\n        \ngoto\n \npull_one\n;\n    }\n    \nOS_EXIT_CRITICAL\n(\nsr\n);\n\n    \nreturn\n (\nev\n);\n}", 
            "title": "os_sched_sleep"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_sleep/#os_sched_sleep", 
            "text": "int  os_sched_sleep ( struct   os_task   *t ,  os_time_t   nticks )  Task 't' state is changed from  ready to run  to  sleeping . Sleep time will be specified in  nticks .  Task will be woken up after sleep timer expires, unless there are other signals causing  it to wake up.  If  nticks  is set to  OS_TIMEOUT_NEVER , task never wakes up with a sleep timer.", 
            "title": " os_sched_sleep "
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_sleep/#arguments", 
            "text": "Arguments  Description      t  Pointer to task    nticks  Number of ticks to sleep in OS ticks", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_sleep/#returned-values", 
            "text": "Returns 0 on success.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_sleep/#notes", 
            "text": "Must be called with interrupts disabled.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_sleep/#example", 
            "text": "struct   os_event   *  os_eventq_get ( struct   os_eventq   *evq )\n{\n     struct   os_event   *ev ;\n     os_sr_t   sr ;\n\n     OS_ENTER_CRITICAL ( sr ); pull_one :\n     ev   =   STAILQ_FIRST ( evq- evq_list );\n     if  ( ev ) {\n         STAILQ_REMOVE ( evq- evq_list ,  ev ,  os_event ,  ev_next );\n         ev- ev_queued   =   0 ;\n    }  else  {\n         evq- evq_task   =   os_sched_get_current_task ();\n         os_sched_sleep ( evq- evq_task ,  OS_TIMEOUT_NEVER );\n         OS_EXIT_CRITICAL ( sr );\n\n         os_sched ( NULL );\n\n         OS_ENTER_CRITICAL ( sr );\n         evq- evq_task   =   NULL ;\n         goto   pull_one ;\n    }\n     OS_EXIT_CRITICAL ( sr );\n\n     return  ( ev );\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_wakeup/", 
            "text": "os_sched_wakeup \n\n\nint\n\n\nos_sched_wakeup\n(\nstruct\n \nos_task\n \n*t\n)\n\n\n\n\n\nCalled to make task \nready to run\n. If task is \nsleeping\n, it is woken up.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt\n\n\nPointer to task\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns 0 on success.\n\n\nNotes\n\n\nExample\n\n\n\n\nvoid\n\n\nos_eventq_put\n(\nstruct\n \nos_eventq\n \n*evq\n, \nstruct\n \nos_event\n \n*ev\n)\n{\n    ....\n        \n/* If task waiting on event, wake it up. */\n\n    \nresched\n \n=\n \n0\n;\n    \nif\n (\nevq-\nevq_task\n) {\n        \nos_sched_wakeup\n(\nevq-\nevq_task\n);\n        \nevq-\nevq_task\n \n=\n \nNULL\n;\n        \nresched\n \n=\n \n1\n;\n    }\n    ....\n}", 
            "title": "os_sched_wakeup"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_wakeup/#os_sched_wakeup", 
            "text": "int  os_sched_wakeup ( struct   os_task   *t )  Called to make task  ready to run . If task is  sleeping , it is woken up.", 
            "title": " os_sched_wakeup "
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_wakeup/#arguments", 
            "text": "Arguments  Description      t  Pointer to task", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_wakeup/#returned-values", 
            "text": "Returns 0 on success.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_wakeup/#notes", 
            "text": "", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/context_switch/os_sched_wakeup/#example", 
            "text": "void  os_eventq_put ( struct   os_eventq   *evq ,  struct   os_event   *ev )\n{\n    ....\n         /* If task waiting on event, wake it up. */ \n     resched   =   0 ;\n     if  ( evq- evq_task ) {\n         os_sched_wakeup ( evq- evq_task );\n         evq- evq_task   =   NULL ;\n         resched   =   1 ;\n    }\n    ....\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/time/os_time/", 
            "text": "OS_Time\n\n\nThe system time for the Mynewt OS.\n\n\nDescription\n\n\nThe Mynewt OS contains an incrementing time that drives the OS scheduler and time delays. The time is a fixed size (e.g. 32 bits) and will eventually wrap back to zero. The time to wrap from zero back to zero is called the \nOS time epoch\n. \n\n\nThe frequency of the OS time tick is specified in the architecture-specific OS code \nos_arch.h\n and is named \nOS_TICKS_PER_SEC\n.\n\n\nThe Mynewt OS also provides APIs for setting and retrieving the wallclock time (also known as local time or time-of-day in other operating systems).\n\n\nData Structures\n\n\nTime is stored in Mynewt as an \nos_time_t\n value. \n\n\nWallclock time is represented using the \nstruct os_timeval\n and \nstruct os_timezone\n tuple.\n\n\nstruct os_timeval\n represents the number of seconds elapsed since 00:00:00 Jan 1, 1970 UTC.\n\n\nstruct os_timeval {\n    int64_t tv_sec;  /\n seconds since Jan 1 1970 UTC \n/\n    int32_t tv_usec; /\n fractional seconds \n/\n};\n\n\nstruct os_timeval tv = { 1457400000, 0 };  /\n 01:20:00 Mar 8 2016 UTC \n/\n\n\n\nstruct os_timezone\n is used to specify the offset of local time from UTC and whether daylight savings is in effect. Note that \ntz_minuteswest\n is a positive number if the local time is \nbehind\n UTC and a negative number if the local time is \nahead\n of UTC.\n\n\nstruct os_timezone {\n    int16_t tz_minuteswest;\n    int16_t tz_dsttime;\n};\n\n\n/\n Pacific Standard Time is 08:00 hours west of UTC \n/\nstruct os_timezone PST = { 480, 0 };\nstruct os_timezone PDT = { 480, 1 };\n\n\n/\n Indian Standard Time is 05:30 hours east of UTC \n/\nstruct os_timezone IST = { -330, 0 };\n\n\n\nList of Functions\n\n\nThe functions available in time are:\n\n\n\n\nos_time_delay\n\n\nos_time_get\n\n\nos_time_tick\n\n\nos_settimeofday\n\n\nos_gettimeofday\n\n\n\n\nList of Macros\n\n\nSeveral macros help with the evalution of times with respect to each other.\n\n\n\n\nOS_TIME_TICK_LT(t1,t2)\n -- evaluates to true if t1 is before t2 in time.\n\n\nOS_TIME_TICK_GT(t1,t2)\n -- evaluates to true if t1 is after t2 in time \n\n\nOS_TIME_TICK_GEQ(t1,t2)\n -- evaluates to true if t1 is on or after t2 in time.\n\n\n\n\nNOTE:  For all of these macros the calculations are done modulo 'os_time_t'.  \n\n\nEnsure that comparison of OS time always uses the macros above (to compensate for the possible wrap of OS time).\n\n\nThe following macros help adding or subtracting time when represented as \nstruct os_timeval\n. All parameters to the following macros are pointers to \nstruct os_timeval\n.\n\n\n\n\nos_timeradd(tvp, uvp, vvp)\n --  Add \nuvp\n to \ntvp\n and store result in \nvvp\n.\n\n\nos_timersub(tvp, uvp, vvp)\n -- Subtract \nuvp\n from \ntvp\n and store result in \nvvp\n.\n\n\n\n\nSpecial Notes\n\n\nIts important to understand how quickly the time wraps especially when doing time comparison using the macros above (or by any other means). \n\n\nFor example, if a tick is 1 millisecond and \nos_time_t\n is 32-bits the OS time will wrap back to zero in about 49.7 days or stated another way, the OS time epoch is 49.7 days.\n\n\nIf two times are more than 1/2 the OS time epoch apart, any time comparison will be incorrect.  Ensure at design time that comparisons will not occur between times that are more than half the OS time epoch.", 
            "title": "toc"
        }, 
        {
            "location": "/os/core_os/time/os_time/#os_time", 
            "text": "The system time for the Mynewt OS.", 
            "title": "OS_Time"
        }, 
        {
            "location": "/os/core_os/time/os_time/#description", 
            "text": "The Mynewt OS contains an incrementing time that drives the OS scheduler and time delays. The time is a fixed size (e.g. 32 bits) and will eventually wrap back to zero. The time to wrap from zero back to zero is called the  OS time epoch .   The frequency of the OS time tick is specified in the architecture-specific OS code  os_arch.h  and is named  OS_TICKS_PER_SEC .  The Mynewt OS also provides APIs for setting and retrieving the wallclock time (also known as local time or time-of-day in other operating systems).", 
            "title": "Description"
        }, 
        {
            "location": "/os/core_os/time/os_time/#data-structures", 
            "text": "Time is stored in Mynewt as an  os_time_t  value.   Wallclock time is represented using the  struct os_timeval  and  struct os_timezone  tuple.  struct os_timeval  represents the number of seconds elapsed since 00:00:00 Jan 1, 1970 UTC. \nstruct os_timeval {\n    int64_t tv_sec;  /  seconds since Jan 1 1970 UTC  /\n    int32_t tv_usec; /  fractional seconds  /\n};  struct os_timeval tv = { 1457400000, 0 };  /  01:20:00 Mar 8 2016 UTC  /  struct os_timezone  is used to specify the offset of local time from UTC and whether daylight savings is in effect. Note that  tz_minuteswest  is a positive number if the local time is  behind  UTC and a negative number if the local time is  ahead  of UTC. \nstruct os_timezone {\n    int16_t tz_minuteswest;\n    int16_t tz_dsttime;\n};  /  Pacific Standard Time is 08:00 hours west of UTC  /\nstruct os_timezone PST = { 480, 0 };\nstruct os_timezone PDT = { 480, 1 };  /  Indian Standard Time is 05:30 hours east of UTC  /\nstruct os_timezone IST = { -330, 0 };", 
            "title": "Data Structures"
        }, 
        {
            "location": "/os/core_os/time/os_time/#list-of-functions", 
            "text": "The functions available in time are:   os_time_delay  os_time_get  os_time_tick  os_settimeofday  os_gettimeofday", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/core_os/time/os_time/#list-of-macros", 
            "text": "Several macros help with the evalution of times with respect to each other.   OS_TIME_TICK_LT(t1,t2)  -- evaluates to true if t1 is before t2 in time.  OS_TIME_TICK_GT(t1,t2)  -- evaluates to true if t1 is after t2 in time   OS_TIME_TICK_GEQ(t1,t2)  -- evaluates to true if t1 is on or after t2 in time.   NOTE:  For all of these macros the calculations are done modulo 'os_time_t'.    Ensure that comparison of OS time always uses the macros above (to compensate for the possible wrap of OS time).  The following macros help adding or subtracting time when represented as  struct os_timeval . All parameters to the following macros are pointers to  struct os_timeval .   os_timeradd(tvp, uvp, vvp)  --  Add  uvp  to  tvp  and store result in  vvp .  os_timersub(tvp, uvp, vvp)  -- Subtract  uvp  from  tvp  and store result in  vvp .", 
            "title": "List of Macros"
        }, 
        {
            "location": "/os/core_os/time/os_time/#special-notes", 
            "text": "Its important to understand how quickly the time wraps especially when doing time comparison using the macros above (or by any other means).   For example, if a tick is 1 millisecond and  os_time_t  is 32-bits the OS time will wrap back to zero in about 49.7 days or stated another way, the OS time epoch is 49.7 days.  If two times are more than 1/2 the OS time epoch apart, any time comparison will be incorrect.  Ensure at design time that comparisons will not occur between times that are more than half the OS time epoch.", 
            "title": "Special Notes"
        }, 
        {
            "location": "/os/core_os/time/os_time_delay/", 
            "text": "os_time_delay\n\n\nvoid\n \nos_time_delay\n(\nint32_t\n \nticks\n) \n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nticks\n\n\nNumber of ticks to delay. Less than or equal to zero means no delay\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nPassing \nOS_TIMEOUT_NEVER\n to this function will not block indefinitely but will return immediately.  Passing delays larger than 1/2 the OS time epoch should be avoided; behavior is unpredictable.\n\n\nExample\n\n\n\n\n    \n/* delay 3 seconds */\n\n    \nint32_t\n \ndelay\n \n=\n \nOS_TICKS_PER_SEC\n \n*\n \n3\n;\n    \nos_time_delay\n(\ndelay\n);", 
            "title": "os_time_delay"
        }, 
        {
            "location": "/os/core_os/time/os_time_delay/#os_time_delay", 
            "text": "void   os_time_delay ( int32_t   ticks )", 
            "title": "os_time_delay"
        }, 
        {
            "location": "/os/core_os/time/os_time_delay/#arguments", 
            "text": "Arguments  Description      ticks  Number of ticks to delay. Less than or equal to zero means no delay", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/time/os_time_delay/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/time/os_time_delay/#notes", 
            "text": "Passing  OS_TIMEOUT_NEVER  to this function will not block indefinitely but will return immediately.  Passing delays larger than 1/2 the OS time epoch should be avoided; behavior is unpredictable.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/time/os_time_delay/#example", 
            "text": "/* delay 3 seconds */ \n     int32_t   delay   =   OS_TICKS_PER_SEC   *   3 ;\n     os_time_delay ( delay );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/time/os_time_get/", 
            "text": "os_time_get\n\n\nos_time_t\n \nos_time_get\n(\nvoid\n) \n\n\n\n\n\nArguments\n\n\nN/A\n\n\nReturned values\n\n\nThe current value of the OS time\n\n\nNotes\n\n\nSee the \nSpecial Notes\n on OS time epoch and comparison\n\n\nExample\n\n\n\n\n   \nos_time_t\n \nnow\n \n=\n \nos_time_get\n();", 
            "title": "os_time_get"
        }, 
        {
            "location": "/os/core_os/time/os_time_get/#os_time_get", 
            "text": "os_time_t   os_time_get ( void )", 
            "title": "os_time_get"
        }, 
        {
            "location": "/os/core_os/time/os_time_get/#arguments", 
            "text": "N/A", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/time/os_time_get/#returned-values", 
            "text": "The current value of the OS time", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/time/os_time_get/#notes", 
            "text": "See the  Special Notes  on OS time epoch and comparison", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/time/os_time_get/#example", 
            "text": "os_time_t   now   =   os_time_get ();", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/time/os_time_tick/", 
            "text": "os_time_tick\n\n\nvoid\n \nos_time_tick\n(\nvoid\n) \n\n\n\n\n\nIncrements the OS time tick for the system.  Typically, this is called in one place by the architecture specific OS code (\nlibs/os/arch\n) \ntimer_handler\n which is in turn called by the BSP specific code assigned to drive the OS timer tick. See \nPorting Mynewt OS\n for details.\n\n\nArguments\n\n\nN/A\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nCalled for every single tick by the architecture specific functions.\n\n\nExample\n\n\n\n\n   \nos_time_tick\n();", 
            "title": "os_time_tick"
        }, 
        {
            "location": "/os/core_os/time/os_time_tick/#os_time_tick", 
            "text": "void   os_time_tick ( void )   Increments the OS time tick for the system.  Typically, this is called in one place by the architecture specific OS code ( libs/os/arch )  timer_handler  which is in turn called by the BSP specific code assigned to drive the OS timer tick. See  Porting Mynewt OS  for details.", 
            "title": "os_time_tick"
        }, 
        {
            "location": "/os/core_os/time/os_time_tick/#arguments", 
            "text": "N/A", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/time/os_time_tick/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/time/os_time_tick/#notes", 
            "text": "Called for every single tick by the architecture specific functions.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/time/os_time_tick/#example", 
            "text": "os_time_tick ();", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/time/os_gettimeofday/", 
            "text": "os_gettimeofday\n\n\nint\n \nos_gettimeofday\n(\nstruct\n \nos_timeval\n \n*utctime\n, \nstruct\n \nos_timezone\n \n*timezone\n); \n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nutctime\n\n\nUTC time corresponding to wallclock time\n\n\n\n\n\n\ntimezone\n\n\nTimezone to convert UTC time to wallclock time\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns 0 on success and non-zero on failure.\n\n\nNotes\n\n\nutctime\n or \ntimezone\n may be NULL.\n\n\nThe function is a no-op if both \nutctime\n and \ntimezone\n are NULL.\n\n\nExample\n\n\n\n\n    \n/*\n\n\n     * Display wallclock time on the console.\n\n\n     */\n\n    \nint\n \nrc\n;\n    \nstruct\n \nos_timeval\n \nutc\n;\n    \nstruct\n \nos_timezone\n \ntz\n;\n    \nchar\n \nbuf\n[\nDATETIME_BUFSIZE\n];\n\n    \nrc\n \n=\n \nos_gettimeofday\n(\nutc\n, \ntz\n);\n    \nif\n (\nrc\n \n==\n \n0\n) {\n        \nformat_datetime\n(\nutc\n, \ntz\n, \nbuf\n, \nsizeof\n(\nbuf\n));\n        \nconsole_printf\n(\n%s\\n\n, \nbuf\n);\n    }", 
            "title": "os_gettimeofday"
        }, 
        {
            "location": "/os/core_os/time/os_gettimeofday/#os_gettimeofday", 
            "text": "int   os_gettimeofday ( struct   os_timeval   *utctime ,  struct   os_timezone   *timezone );", 
            "title": "os_gettimeofday"
        }, 
        {
            "location": "/os/core_os/time/os_gettimeofday/#arguments", 
            "text": "Arguments  Description      utctime  UTC time corresponding to wallclock time    timezone  Timezone to convert UTC time to wallclock time", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/time/os_gettimeofday/#returned-values", 
            "text": "Returns 0 on success and non-zero on failure.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/time/os_gettimeofday/#notes", 
            "text": "utctime  or  timezone  may be NULL.  The function is a no-op if both  utctime  and  timezone  are NULL.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/time/os_gettimeofday/#example", 
            "text": "/*       * Display wallclock time on the console.       */ \n     int   rc ;\n     struct   os_timeval   utc ;\n     struct   os_timezone   tz ;\n     char   buf [ DATETIME_BUFSIZE ];\n\n     rc   =   os_gettimeofday ( utc ,  tz );\n     if  ( rc   ==   0 ) {\n         format_datetime ( utc ,  tz ,  buf ,  sizeof ( buf ));\n         console_printf ( %s\\n ,  buf );\n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/time/os_settimeofday/", 
            "text": "os_settimeofday\n\n\nint\n \nos_settimeofday\n(\nstruct\n \nos_timeval\n \n*utctime\n, \nstruct\n \nos_timezone\n \n*timezone\n);\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nutctime\n\n\nUTC time corresponding to the wallclock time\n\n\n\n\n\n\ntimezone\n\n\nTimezone associated with the wallclock time\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns 0 on success and non-zero on failure.\n\n\nNotes\n\n\nutctime\n may be NULL if only the timezone needs to be changed. This is useful when adjusting the \ntimezone\n to account for daylight savings.\n\n\ntimezone\n may be NULL if only the UTC time needs to be changed. This is useful when synchronizing Mynewt's time with an external time source like NTP.\n\n\nThe function is a no-op if both \nutctime\n and \ntimezone\n are NULL.\n\n\nExample\n\n\n\n\n    \nint\n \nrc\n;\n    \nparse_datetime\n(\ndatestr\n, \nutctime\n, \ntz\n);\n    \nrc\n \n=\n \nos_settimeofday\n(\nutctime\n, \ntz\n);\n    \nif\n (\nrc\n \n==\n \n0\n) {\n        \n/* success */\n\n    }", 
            "title": "os_settimeofday"
        }, 
        {
            "location": "/os/core_os/time/os_settimeofday/#os_settimeofday", 
            "text": "int   os_settimeofday ( struct   os_timeval   *utctime ,  struct   os_timezone   *timezone );", 
            "title": "os_settimeofday"
        }, 
        {
            "location": "/os/core_os/time/os_settimeofday/#arguments", 
            "text": "Arguments  Description      utctime  UTC time corresponding to the wallclock time    timezone  Timezone associated with the wallclock time", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/time/os_settimeofday/#returned-values", 
            "text": "Returns 0 on success and non-zero on failure.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/time/os_settimeofday/#notes", 
            "text": "utctime  may be NULL if only the timezone needs to be changed. This is useful when adjusting the  timezone  to account for daylight savings.  timezone  may be NULL if only the UTC time needs to be changed. This is useful when synchronizing Mynewt's time with an external time source like NTP.  The function is a no-op if both  utctime  and  timezone  are NULL.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/time/os_settimeofday/#example", 
            "text": "int   rc ;\n     parse_datetime ( datestr ,  utctime ,  tz );\n     rc   =   os_settimeofday ( utctime ,  tz );\n     if  ( rc   ==   0 ) {\n         /* success */ \n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/task/task/", 
            "text": "Task\n\n\nA task, along with the scheduler, forms the basis of the Mynewt OS. A task \nconsists of two basic elements: a task stack and a task function. The task \nfunction is basically a forever loop, waiting for some \"event\" to wake it up. \nThere are two methods used to signal a task that it has work to do: event queues \nand semaphores (see the appropriate manual sections for descriptions of these \nfeatures).\n\n\nThe Mynewt OS is a multi-tasking, preemptive OS. Every task is assigned a task \npriority (from 0 to 255), with 0 being the highest priority task. If a higher \npriority task than the current task wants to run, the scheduler preempts the \ncurrently running task and switches context to the higher priority task. This is \njust a fancy way of saying that the processor stack pointer now points to the \nstack of the higher priority task and the task resumes execution where it left \noff.\n\n\nTasks run to completion unless they are preempted by a higher priority task. The \ndeveloper must insure that tasks eventually \"sleep\"; otherwise lower priority \ntasks will never get a chance to run (actually, any task lower in priority than \nthe task that never sleeps). A task will be put to sleep in the following cases: \nit puts itself to sleep using \nos_time_delay()\n, it waits on an event queue \nwhich is empty or attempts to obtain a mutex or a semaphore that is currently \nowned by another task.\n\n\nNote that other sections of the manual describe these OS features in more \ndetail.\n\n\nDescription\n\n\nIn order to create a task two data structures need to be defined: the task \nobject (struct os_task) and its associated stack. Determining the stack size can \nbe a bit tricky; generally developers should not declare large local variables \non the stack so that task stacks can be of limited size. However, all \napplications are different and the developer must choose the stack size \naccordingly. NOTE: be careful when declaring your stack! The stack is in units \nof \nos_stack_t\n sized elements (generally 32-bits). Looking at the example given \nbelow and assuming \nos_stack_t\n is defined to be a 32-bit unsigned value, \n\"my_task_stack\" will use 256 bytes. \n\n\nA task must also have an associated \"task function\". This is the function that \nwill be called when the task is first run. This task function should never \nreturn!\n\n\nIn order to inform the Mynewt OS of the new task and to have it added to the \nscheduler, the \nos_task_init()\n function is called. Once \nos_task_init()\n is \ncalled, the task is made ready to run and is added to the active task list. Note \nthat a task can be initialized (started) before or after the os has started \n(i.e. before \nos_start()\n is called) but must be initialized after the os has \nbeen initialized (i.e. 'os_init' has been called). In most of the examples and \ncurrent Mynewt projects, the os is initialized, tasks are initialized, and the \nthe os is started. Once the os has started, the highest priority task will be \nthe first task set to run.\n\n\nInformation about a task can be obtained using the \nos_task_info_get_next()\n \nAPI. Developers can walk the list of tasks to obtain information on all created \ntasks. This information is of type \nos_task_info\n and is described below.\n\n\nThe following is a very simple example showing a single application task. This \ntask simply toggles an LED at a one second interval.\n\n\n/* Create a simple \nproject\n with a task that blinks a LED every second */\n\n\n\n/* Define task stack and task object */\n\n\n#define MY_TASK_PRI         (OS_TASK_PRI_HIGHEST) \n\n\n#define MY_STACK_SIZE       (64) \n\n\nstruct\n \nos_task\n \nmy_task\n; \n\nos_stack_t\n \nmy_task_stack\n[\nMY_STACK_SIZE\n]; \n\n\n/* This is the task function */\n\n\nvoid\n \nmy_task_func\n(\nvoid\n \n*arg\n) {\n    \n/* Set the led pin as an output */\n\n    \nhal_gpio_init_out\n(\nLED_BLINK_PIN\n, \n1\n);\n\n    \n/* The task is a forever loop that does not return */\n\n    \nwhile\n (\n1\n) {\n        \n/* Wait one second */\n \n        \nos_time_delay\n(\n1000\n);\n\n        \n/* Toggle the LED */\n \n        \nhal_gpio_toggle\n(\nLED_BLINK_PIN\n);\n    }\n}\n\n\n/* This is the main function for the project */\n\n\nint\n \nmain\n(\nvoid\n) {\n    \nint\n \nrc\n;\n\n    \n/* Initialize OS */\n\n    \nos_init\n();\n\n    \n/* Initialize the task */\n\n    \nos_task_init\n(\nmy_task\n, \nmy_task\n, \nmy_task_func\n, \nNULL\n, \nMY_TASK_PRIO\n, \n                 \nOS_WAIT_FOREVER\n, \nmy_task_stack\n, \nMY_STACK_SIZE\n);\n\n    \n/* Start the OS */\n\n    \nos_start\n();\n\n    \n/* os start should never return. If it does, this should be an error */\n\n    \nassert\n(\n0\n);\n\n    \nreturn\n \nrc\n;\n}\n\n\n\n\n\nData structures\n\n\n/* The highest and lowest task priorities */\n\n\n#define OS_TASK_PRI_HIGHEST         (0)\n\n\n#define OS_TASK_PRI_LOWEST          (0xff)\n\n\n\n/* Task states */\n\n\ntypedef\n \nenum\n \nos_task_state\n {\n    \nOS_TASK_READY\n \n=\n \n1\n, \n    \nOS_TASK_SLEEP\n \n=\n \n2\n\n} \nos_task_state_t\n;\n\n\n/* Task flags */\n\n\n#define OS_TASK_FLAG_NO_TIMEOUT     (0x0001U)\n\n\n#define OS_TASK_FLAG_SEM_WAIT       (0x0002U)\n\n\n#define OS_TASK_FLAG_MUTEX_WAIT     (0x0004U)\n\n\n\ntypedef\n \nvoid\n (\n*\nos_task_func_t\n)(\nvoid\n \n*\n);\n\n\n#define OS_TASK_MAX_NAME_LEN (32)\n\n\n\n\n\n\n\n\nstruct\n \nos_task\n {\n    \nos_stack_t\n \n*t_stackptr\n;\n    \nos_stack_t\n \n*t_stacktop\n;\n\n    \nuint16_t\n \nt_stacksize\n;\n    \nuint16_t\n \nt_flags\n;\n\n    \nuint8_t\n \nt_taskid\n;\n    \nuint8_t\n \nt_prio\n;\n    \nuint8_t\n \nt_state\n;\n    \nuint8_t\n \nt_pad\n;\n\n    \nchar\n \n*t_name\n;\n    \nos_task_func_t\n \nt_func\n;\n    \nvoid\n \n*t_arg\n;\n\n    \nvoid\n \n*t_obj\n;\n\n    \nstruct\n \nos_sanity_check\n \nt_sanity_check\n; \n\n    \nos_time_t\n \nt_next_wakeup\n;\n    \nos_time_t\n \nt_run_time\n;\n    \nuint32_t\n \nt_ctx_sw_cnt\n;\n\n    \n/* Global list of all tasks, irrespective of run or sleep lists */\n\n    \nSTAILQ_ENTRY\n(\nos_task\n) \nt_os_task_list\n;\n\n    \n/* Used to chain task to either the run or sleep list */\n \n    \nTAILQ_ENTRY\n(\nos_task\n) \nt_os_list\n;\n\n    \n/* Used to chain task to an object such as a semaphore or mutex */\n\n    \nSLIST_ENTRY\n(\nos_task\n) \nt_obj_list\n;\n};\n\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt_stackptr\n\n\nCurrent stack pointer\n\n\n\n\n\n\nt_stacktop\n\n\nThe address of the top of the task stack. The stack grows downward\n\n\n\n\n\n\nt_stacksize\n\n\nThe size of the stack, in units of os_stack_t (not bytes!)\n\n\n\n\n\n\nt_flags\n\n\nTask flags (see flag definitions)\n\n\n\n\n\n\nt_taskid\n\n\nA numeric id assigned to each task\n\n\n\n\n\n\nt_prio\n\n\nThe priority of the task. The lower the number, the higher the priority\n\n\n\n\n\n\nt_state\n\n\nThe task state (see state definitions)\n\n\n\n\n\n\nt_pad\n\n\npadding (for alignment)\n\n\n\n\n\n\nt_name\n\n\nName of task\n\n\n\n\n\n\nt_func\n\n\nPointer to task function\n\n\n\n\n\n\nt_obj\n\n\nGeneric object used by mutexes and semaphores when the task is waiting on a mutex or semaphore\n\n\n\n\n\n\nt_sanity_check\n\n\nSanity task data structure\n\n\n\n\n\n\nt_next_wakeup\n\n\nOS time when task is next scheduled to wake up\n\n\n\n\n\n\nt_run_time\n\n\nThe amount of os time ticks this task has been running\n\n\n\n\n\n\nt_ctx_sw_cnt\n\n\nThe number of times that this task has been run\n\n\n\n\n\n\nt_os_task_list\n\n\nList pointer for global task list. All tasks are placed on this list\n\n\n\n\n\n\nt_os_list\n\n\nList pointer used by either the active task list or the sleeping task list\n\n\n\n\n\n\nt_obj_list\n\n\nList pointer for tasks waiting on a semaphore or mutex\n\n\n\n\n\n\n\n\n\n\nstruct\n \nos_task_info\n {\n    \nuint8_t\n \noti_prio\n;\n    \nuint8_t\n \noti_taskid\n;\n    \nuint8_t\n \noti_state\n;\n    \nuint8_t\n \noti_flags\n;\n    \nuint16_t\n \noti_stkusage\n;\n    \nuint16_t\n \noti_stksize\n;\n    \nuint32_t\n \noti_cswcnt\n;\n    \nuint32_t\n \noti_runtime\n;\n    \nos_time_t\n \noti_last_checkin\n;\n    \nos_time_t\n \noti_next_checkin\n;\n\n    \nchar\n \noti_name\n[\nOS_TASK_MAX_NAME_LEN\n];\n};\n\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noti_prio\n\n\nTask priority\n\n\n\n\n\n\noti_taskid\n\n\nTask id\n\n\n\n\n\n\noti_state\n\n\nTask state\n\n\n\n\n\n\noti_flags\n\n\nTask flags\n\n\n\n\n\n\noti_stkusage\n\n\nAmount of stack used by the task (in os_stack_t units)\n\n\n\n\n\n\noti_stksize\n\n\nThe size of the stack (in os_stack_t units)\n\n\n\n\n\n\noti_cswcnt\n\n\nThe context switch count\n\n\n\n\n\n\noti_runtime\n\n\nThe amount of time that the task has run (in os time ticks)\n\n\n\n\n\n\noti_last_checkin\n\n\nThe time (os time) at which this task last checked in to the sanity task\n\n\n\n\n\n\noti_next_checkin\n\n\nThe time (os time) at which this task last checked in to the sanity task\n\n\n\n\n\n\noti_name\n\n\nName of the task\n\n\n\n\n\n\n\n\n\n\nList of Functions\n\n\nThe functions available in task are:\n\n\n\n\nos_task_init\n\n\nos_task_count\n\n\nos_task_info_get_next", 
            "title": "toc"
        }, 
        {
            "location": "/os/core_os/task/task/#task", 
            "text": "A task, along with the scheduler, forms the basis of the Mynewt OS. A task \nconsists of two basic elements: a task stack and a task function. The task \nfunction is basically a forever loop, waiting for some \"event\" to wake it up. \nThere are two methods used to signal a task that it has work to do: event queues \nand semaphores (see the appropriate manual sections for descriptions of these \nfeatures).  The Mynewt OS is a multi-tasking, preemptive OS. Every task is assigned a task \npriority (from 0 to 255), with 0 being the highest priority task. If a higher \npriority task than the current task wants to run, the scheduler preempts the \ncurrently running task and switches context to the higher priority task. This is \njust a fancy way of saying that the processor stack pointer now points to the \nstack of the higher priority task and the task resumes execution where it left \noff.  Tasks run to completion unless they are preempted by a higher priority task. The \ndeveloper must insure that tasks eventually \"sleep\"; otherwise lower priority \ntasks will never get a chance to run (actually, any task lower in priority than \nthe task that never sleeps). A task will be put to sleep in the following cases: \nit puts itself to sleep using  os_time_delay() , it waits on an event queue \nwhich is empty or attempts to obtain a mutex or a semaphore that is currently \nowned by another task.  Note that other sections of the manual describe these OS features in more \ndetail.", 
            "title": "Task"
        }, 
        {
            "location": "/os/core_os/task/task/#description", 
            "text": "In order to create a task two data structures need to be defined: the task \nobject (struct os_task) and its associated stack. Determining the stack size can \nbe a bit tricky; generally developers should not declare large local variables \non the stack so that task stacks can be of limited size. However, all \napplications are different and the developer must choose the stack size \naccordingly. NOTE: be careful when declaring your stack! The stack is in units \nof  os_stack_t  sized elements (generally 32-bits). Looking at the example given \nbelow and assuming  os_stack_t  is defined to be a 32-bit unsigned value, \n\"my_task_stack\" will use 256 bytes.   A task must also have an associated \"task function\". This is the function that \nwill be called when the task is first run. This task function should never \nreturn!  In order to inform the Mynewt OS of the new task and to have it added to the \nscheduler, the  os_task_init()  function is called. Once  os_task_init()  is \ncalled, the task is made ready to run and is added to the active task list. Note \nthat a task can be initialized (started) before or after the os has started \n(i.e. before  os_start()  is called) but must be initialized after the os has \nbeen initialized (i.e. 'os_init' has been called). In most of the examples and \ncurrent Mynewt projects, the os is initialized, tasks are initialized, and the \nthe os is started. Once the os has started, the highest priority task will be \nthe first task set to run.  Information about a task can be obtained using the  os_task_info_get_next()  \nAPI. Developers can walk the list of tasks to obtain information on all created \ntasks. This information is of type  os_task_info  and is described below.  The following is a very simple example showing a single application task. This \ntask simply toggles an LED at a one second interval.  /* Create a simple  project  with a task that blinks a LED every second */  /* Define task stack and task object */  #define MY_TASK_PRI         (OS_TASK_PRI_HIGHEST)   #define MY_STACK_SIZE       (64)   struct   os_task   my_task ;  os_stack_t   my_task_stack [ MY_STACK_SIZE ];  /* This is the task function */  void   my_task_func ( void   *arg ) {\n     /* Set the led pin as an output */ \n     hal_gpio_init_out ( LED_BLINK_PIN ,  1 );\n\n     /* The task is a forever loop that does not return */ \n     while  ( 1 ) {\n         /* Wait one second */  \n         os_time_delay ( 1000 );\n\n         /* Toggle the LED */  \n         hal_gpio_toggle ( LED_BLINK_PIN );\n    }\n} /* This is the main function for the project */  int   main ( void ) {\n     int   rc ;\n\n     /* Initialize OS */ \n     os_init ();\n\n     /* Initialize the task */ \n     os_task_init ( my_task ,  my_task ,  my_task_func ,  NULL ,  MY_TASK_PRIO , \n                  OS_WAIT_FOREVER ,  my_task_stack ,  MY_STACK_SIZE );\n\n     /* Start the OS */ \n     os_start ();\n\n     /* os start should never return. If it does, this should be an error */ \n     assert ( 0 );\n\n     return   rc ;\n}", 
            "title": "Description"
        }, 
        {
            "location": "/os/core_os/task/task/#data-structures", 
            "text": "/* The highest and lowest task priorities */  #define OS_TASK_PRI_HIGHEST         (0)  #define OS_TASK_PRI_LOWEST          (0xff)  /* Task states */  typedef   enum   os_task_state  {\n     OS_TASK_READY   =   1 , \n     OS_TASK_SLEEP   =   2 \n}  os_task_state_t ; /* Task flags */  #define OS_TASK_FLAG_NO_TIMEOUT     (0x0001U)  #define OS_TASK_FLAG_SEM_WAIT       (0x0002U)  #define OS_TASK_FLAG_MUTEX_WAIT     (0x0004U)  typedef   void  ( * os_task_func_t )( void   * ); #define OS_TASK_MAX_NAME_LEN (32)    struct   os_task  {\n     os_stack_t   *t_stackptr ;\n     os_stack_t   *t_stacktop ;\n\n     uint16_t   t_stacksize ;\n     uint16_t   t_flags ;\n\n     uint8_t   t_taskid ;\n     uint8_t   t_prio ;\n     uint8_t   t_state ;\n     uint8_t   t_pad ;\n\n     char   *t_name ;\n     os_task_func_t   t_func ;\n     void   *t_arg ;\n\n     void   *t_obj ;\n\n     struct   os_sanity_check   t_sanity_check ; \n\n     os_time_t   t_next_wakeup ;\n     os_time_t   t_run_time ;\n     uint32_t   t_ctx_sw_cnt ;\n\n     /* Global list of all tasks, irrespective of run or sleep lists */ \n     STAILQ_ENTRY ( os_task )  t_os_task_list ;\n\n     /* Used to chain task to either the run or sleep list */  \n     TAILQ_ENTRY ( os_task )  t_os_list ;\n\n     /* Used to chain task to an object such as a semaphore or mutex */ \n     SLIST_ENTRY ( os_task )  t_obj_list ;\n};     Element  Description      t_stackptr  Current stack pointer    t_stacktop  The address of the top of the task stack. The stack grows downward    t_stacksize  The size of the stack, in units of os_stack_t (not bytes!)    t_flags  Task flags (see flag definitions)    t_taskid  A numeric id assigned to each task    t_prio  The priority of the task. The lower the number, the higher the priority    t_state  The task state (see state definitions)    t_pad  padding (for alignment)    t_name  Name of task    t_func  Pointer to task function    t_obj  Generic object used by mutexes and semaphores when the task is waiting on a mutex or semaphore    t_sanity_check  Sanity task data structure    t_next_wakeup  OS time when task is next scheduled to wake up    t_run_time  The amount of os time ticks this task has been running    t_ctx_sw_cnt  The number of times that this task has been run    t_os_task_list  List pointer for global task list. All tasks are placed on this list    t_os_list  List pointer used by either the active task list or the sleeping task list    t_obj_list  List pointer for tasks waiting on a semaphore or mutex      struct   os_task_info  {\n     uint8_t   oti_prio ;\n     uint8_t   oti_taskid ;\n     uint8_t   oti_state ;\n     uint8_t   oti_flags ;\n     uint16_t   oti_stkusage ;\n     uint16_t   oti_stksize ;\n     uint32_t   oti_cswcnt ;\n     uint32_t   oti_runtime ;\n     os_time_t   oti_last_checkin ;\n     os_time_t   oti_next_checkin ;\n\n     char   oti_name [ OS_TASK_MAX_NAME_LEN ];\n};     Element  Description      oti_prio  Task priority    oti_taskid  Task id    oti_state  Task state    oti_flags  Task flags    oti_stkusage  Amount of stack used by the task (in os_stack_t units)    oti_stksize  The size of the stack (in os_stack_t units)    oti_cswcnt  The context switch count    oti_runtime  The amount of time that the task has run (in os time ticks)    oti_last_checkin  The time (os time) at which this task last checked in to the sanity task    oti_next_checkin  The time (os time) at which this task last checked in to the sanity task    oti_name  Name of the task", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/core_os/task/task/#list-of-functions", 
            "text": "The functions available in task are:   os_task_init  os_task_count  os_task_info_get_next", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/core_os/task/os_task_count/", 
            "text": "os_task_count\n\n\nuint8_t\n \nos_task_count\n(\nvoid\n);\n\n\n\n\n\nReturns the number of tasks that have been created. \n\n\n\n\nArguments\n\n\nNone\n\n\n\n\nReturned values\n\n\nunsigned 8-bit integer representing number of tasks created\n\n\n\n\nExample\n\n\n    \nuint8_t\n \nnum_tasks\n;\n\n    \nnum_tasks\n \n=\n \nos_task_count\n();", 
            "title": "os_task_count"
        }, 
        {
            "location": "/os/core_os/task/os_task_count/#os_task_count", 
            "text": "uint8_t   os_task_count ( void );  Returns the number of tasks that have been created.", 
            "title": " os_task_count"
        }, 
        {
            "location": "/os/core_os/task/os_task_count/#arguments", 
            "text": "None", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/task/os_task_count/#returned-values", 
            "text": "unsigned 8-bit integer representing number of tasks created", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/task/os_task_count/#example", 
            "text": "uint8_t   num_tasks ;\n\n     num_tasks   =   os_task_count ();", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/task/os_task_info_get_next/", 
            "text": "os_task_info_get_next\n\n\nstruct\n \nos_task\n \n*os_task_info_get_next\n(\nconst\n \nstruct\n \nos_task\n \n*prev\n, \nstruct\n \nos_task_info\n \n*oti\n);\n\n\n\n\n\nPopulates the os task info structure pointed to by \noti\n with task information. \nThe task populating the \noti\n structure is either the first task on the task \nlist if \nprev\n is NULL, or the next task in the task list (the next pointer of \n\nprev\n).\n\n\nIf there are no tasks initialized, NULL is returned. Otherwise, the task \nstructure used to populate \noti\n is returned.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprev\n\n\nPointer to previous task in task list. If NULL, use first task on list\n\n\n\n\n\n\noti\n\n\nPointer to \nos_task_info\n structure where task information will be stored\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns a pointer to the os task structure that was used to populate the task \ninformation structure. NULL means that no tasks were created.\n\n\n\n\nExample\n\n\nvoid\n \n\nget_task_info\n(\nvoid\n)\n{\n    \nstruct\n \nos_task\n \n*prev_task\n; \n    \nstruct\n \nos_task_info\n \noti\n; \n\n    \nconsole_printf\n(\nTasks: \\n\n);\n    \nprev_task\n \n=\n \nNULL\n;\n    \nwhile\n (\n1\n) {\n        \nprev_task\n \n=\n \nos_task_info_get_next\n(\nprev_task\n, \noti\n);\n        \nif\n (\nprev_task\n \n==\n \nNULL\n) {\n            \nbreak\n;\n        }\n\n        \nconsole_printf\n(\n  %s (prio: %u, tid: %u, lcheck: %lu, ncheck: %lu, \n\n                \nflags: 0x%x, ssize: %u, susage: %u, cswcnt: %lu, \n\n                \ntot_run_time: %lums)\\n\n,\n                \noti\n.\noti_name\n, \noti\n.\noti_prio\n, \noti\n.\noti_taskid\n, \n                (\nunsigned\n \nlong\n)\noti\n.\noti_last_checkin\n,\n                (\nunsigned\n \nlong\n)\noti\n.\noti_next_checkin\n, \noti\n.\noti_flags\n,\n                \noti\n.\noti_stksize\n, \noti\n.\noti_stkusage\n, (\nunsigned\n \nlong\n)\noti\n.\noti_cswcnt\n,\n                (\nunsigned\n \nlong\n)\noti\n.\noti_runtime\n);\n\n    }\n}", 
            "title": "os_task_info_get_next"
        }, 
        {
            "location": "/os/core_os/task/os_task_info_get_next/#os_task_info_get_next", 
            "text": "struct   os_task   *os_task_info_get_next ( const   struct   os_task   *prev ,  struct   os_task_info   *oti );  Populates the os task info structure pointed to by  oti  with task information. \nThe task populating the  oti  structure is either the first task on the task \nlist if  prev  is NULL, or the next task in the task list (the next pointer of  prev ).  If there are no tasks initialized, NULL is returned. Otherwise, the task \nstructure used to populate  oti  is returned.", 
            "title": " os_task_info_get_next"
        }, 
        {
            "location": "/os/core_os/task/os_task_info_get_next/#arguments", 
            "text": "Arguments  Description      prev  Pointer to previous task in task list. If NULL, use first task on list    oti  Pointer to  os_task_info  structure where task information will be stored", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/task/os_task_info_get_next/#returned-values", 
            "text": "Returns a pointer to the os task structure that was used to populate the task \ninformation structure. NULL means that no tasks were created.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/task/os_task_info_get_next/#example", 
            "text": "void   get_task_info ( void )\n{\n     struct   os_task   *prev_task ; \n     struct   os_task_info   oti ; \n\n     console_printf ( Tasks: \\n );\n     prev_task   =   NULL ;\n     while  ( 1 ) {\n         prev_task   =   os_task_info_get_next ( prev_task ,  oti );\n         if  ( prev_task   ==   NULL ) {\n             break ;\n        }\n\n         console_printf (   %s (prio: %u, tid: %u, lcheck: %lu, ncheck: %lu,  \n                 flags: 0x%x, ssize: %u, susage: %u, cswcnt: %lu,  \n                 tot_run_time: %lums)\\n ,\n                 oti . oti_name ,  oti . oti_prio ,  oti . oti_taskid , \n                ( unsigned   long ) oti . oti_last_checkin ,\n                ( unsigned   long ) oti . oti_next_checkin ,  oti . oti_flags ,\n                 oti . oti_stksize ,  oti . oti_stkusage , ( unsigned   long ) oti . oti_cswcnt ,\n                ( unsigned   long ) oti . oti_runtime );\n\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/task/os_task_init/", 
            "text": "os_task_init\n\n\nint\n \nos_task_init\n(\nstruct\n \nos_task\n \n*t\n, \nchar\n \n*name\n, \nos_task_func_t\n \nfunc\n, \nvoid\n \n*arg\n, \n                 \nuint8_t\n \nprio\n, \nos_time_t\n \nsanity_itvl\n, \nos_stack_t\n \n*stack_bottom\n, \n                 \nuint16_t\n \nstack_size\n)\n\n\n\n\n\nCalled to create a task. This adds the task object to the list of ready to run \ntasks.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt\n\n\nPointer to task\n\n\n\n\n\n\nname\n\n\nTask name\n\n\n\n\n\n\nfunc\n\n\nTask function\n\n\n\n\n\n\narg\n\n\nGeneric argument to pass to task\n\n\n\n\n\n\nprio\n\n\nPriority of task\n\n\n\n\n\n\nsanity_itvl\n\n\nThe interval at which the sanity task will check to see if this task is sill alive\n\n\n\n\n\n\nstack_bottom\n\n\nPointer to bottom of stack.\n\n\n\n\n\n\nstack_size\n\n\nThe size of the stack. NOTE: this is not in bytes! It is the number of \nos_stack_t\n elements allocated (generally 32-bits each)\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_OK: task initialization successful.\n\n\nAll other error codes indicate an internal error.\n\n\n\n\nExample\n\n\n    \n/* Create the task */\n \n    \nint\n \nrc\n;\n\n    \nos_stack_t\n \nmy_task_stack\n[\nMY_STACK_SIZE\n];\n\n    \nrc\n \n=\n \nos_task_init\n(\nmy_task\n, \nmy_task\n, \nmy_task_func\n, \nNULL\n, \nMY_TASK_PRIO\n, \n                      \nOS_WAIT_FOREVER\n, \nmy_task_stack\n, \nMY_STACK_SIZE\n);\n    \nassert\n(\nrc\n \n==\n \nOS_OK\n);", 
            "title": "os_task_init"
        }, 
        {
            "location": "/os/core_os/task/os_task_init/#os_task_init", 
            "text": "int   os_task_init ( struct   os_task   *t ,  char   *name ,  os_task_func_t   func ,  void   *arg , \n                  uint8_t   prio ,  os_time_t   sanity_itvl ,  os_stack_t   *stack_bottom , \n                  uint16_t   stack_size )  Called to create a task. This adds the task object to the list of ready to run \ntasks.", 
            "title": " os_task_init"
        }, 
        {
            "location": "/os/core_os/task/os_task_init/#arguments", 
            "text": "Arguments  Description      t  Pointer to task    name  Task name    func  Task function    arg  Generic argument to pass to task    prio  Priority of task    sanity_itvl  The interval at which the sanity task will check to see if this task is sill alive    stack_bottom  Pointer to bottom of stack.    stack_size  The size of the stack. NOTE: this is not in bytes! It is the number of  os_stack_t  elements allocated (generally 32-bits each)", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/task/os_task_init/#returned-values", 
            "text": "OS_OK: task initialization successful.  All other error codes indicate an internal error.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/task/os_task_init/#example", 
            "text": "/* Create the task */  \n     int   rc ;\n\n     os_stack_t   my_task_stack [ MY_STACK_SIZE ];\n\n     rc   =   os_task_init ( my_task ,  my_task ,  my_task_func ,  NULL ,  MY_TASK_PRIO , \n                       OS_WAIT_FOREVER ,  my_task_stack ,  MY_STACK_SIZE );\n     assert ( rc   ==   OS_OK );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/event_queue/event_queue/", 
            "text": "Event Queues\n\n\nEvent queue is a way of serializing events arring to a task. This makes it easy to queue processing to happen inside task's context. This would be done either from an interrupt handler, or from another task.\n\n\nEvents arrive in a form of a data structure \nstruct os_event\n.\n\n\nDescription\n\n\nEvents are in form of a data structure \nstruct os_event\n, and they are queued to data structure \nstruct os_eventq\n.\n\n\nQueue must be initialized before trying to add events to it. This is done using \nos_eventq_init()\n.\n\n\nCommon way of using event queues is to have a task loop while calling \nos_eventq_get()\n, waiting for work to do.\nOther tasks (or interrupts) then call \nos_eventq_put()\n to wake it up. Once event has been queued task waiting on that queue is woken up, and will get a pointer to queued event structure.\nProcessing task would then act according to event type.\n\n\nWhen \nos_event\n is queued, it should not be freed until processing task is done with it.\n\n\nIt is assumed that there is only one task consuming events from an event queue. Only one task should be sleeping on a particular \nos_eventq\n at a time.\n\n\nNote that os_callout subsystem assumes that event queue is used as the wakeup mechanism.\n\n\nData structures\n\n\nstruct\n \nos_event\n {\n    \nuint8_t\n \nev_queued\n;\n    \nuint8_t\n \nev_type\n;\n    \nvoid\n \n*ev_arg\n;\n    \nSTAILQ_ENTRY\n(\nos_event\n) \nev_next\n;\n};\n\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nev_queued\n\n\nInternal field, which tells whether event is linked into an \nos_eventq\n already\n\n\n\n\n\n\nev_type\n\n\nType of an event. This should be unique, as it should be used by processing task to figure out what the event means\n\n\n\n\n\n\nev_arg\n\n\nCan be used further as input to task processing this event\n\n\n\n\n\n\nev_next\n\n\nLinkage attaching this event to an event queue\n\n\n\n\n\n\n\n\nstruct\n \nos_eventq\n {\n    \nstruct\n \nos_task\n \n*evq_task\n;\n    \nSTAILQ_HEAD\n(, \nos_event\n) \nevq_list\n;\n};\n\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nevq_task\n\n\nPointer to task if there is task sleeping on \nos_eventq_get()\n\n\n\n\n\n\nevq_list\n\n\nQueue head for list of events in this queue\n\n\n\n\n\n\n\n\nList of Functions\n\n\nThe functions available in event queue feature are:\n\n\n\n\nos_eventq_get\n\n\nos_eventq_init\n\n\nos_eventq_put\n\n\nos_eventq_remove", 
            "title": "toc"
        }, 
        {
            "location": "/os/core_os/event_queue/event_queue/#event-queues", 
            "text": "Event queue is a way of serializing events arring to a task. This makes it easy to queue processing to happen inside task's context. This would be done either from an interrupt handler, or from another task.  Events arrive in a form of a data structure  struct os_event .", 
            "title": "Event Queues"
        }, 
        {
            "location": "/os/core_os/event_queue/event_queue/#description", 
            "text": "Events are in form of a data structure  struct os_event , and they are queued to data structure  struct os_eventq .  Queue must be initialized before trying to add events to it. This is done using  os_eventq_init() .  Common way of using event queues is to have a task loop while calling  os_eventq_get() , waiting for work to do.\nOther tasks (or interrupts) then call  os_eventq_put()  to wake it up. Once event has been queued task waiting on that queue is woken up, and will get a pointer to queued event structure.\nProcessing task would then act according to event type.  When  os_event  is queued, it should not be freed until processing task is done with it.  It is assumed that there is only one task consuming events from an event queue. Only one task should be sleeping on a particular  os_eventq  at a time.  Note that os_callout subsystem assumes that event queue is used as the wakeup mechanism.", 
            "title": "Description"
        }, 
        {
            "location": "/os/core_os/event_queue/event_queue/#data-structures", 
            "text": "struct   os_event  {\n     uint8_t   ev_queued ;\n     uint8_t   ev_type ;\n     void   *ev_arg ;\n     STAILQ_ENTRY ( os_event )  ev_next ;\n};     Element  Description      ev_queued  Internal field, which tells whether event is linked into an  os_eventq  already    ev_type  Type of an event. This should be unique, as it should be used by processing task to figure out what the event means    ev_arg  Can be used further as input to task processing this event    ev_next  Linkage attaching this event to an event queue     struct   os_eventq  {\n     struct   os_task   *evq_task ;\n     STAILQ_HEAD (,  os_event )  evq_list ;\n};     Element  Description      evq_task  Pointer to task if there is task sleeping on  os_eventq_get()    evq_list  Queue head for list of events in this queue", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/core_os/event_queue/event_queue/#list-of-functions", 
            "text": "The functions available in event queue feature are:   os_eventq_get  os_eventq_init  os_eventq_put  os_eventq_remove", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_get/", 
            "text": "os_eventq_get\n\n\nvoid\n\n\nos_eventq_get\n(\nstruct\n \nos_eventq\n \n*evq\n)\n\n\n\n\n\nFetches the first event from a queue. Task will sleep until something gets queued.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nevq\n\n\nQueue to wait on\n\n\n\n\n\n\n\n\nReturned values\n\n\nWill return with a pointer to first \nstruct event\n which is in the queue.\n\n\nNotes\n\n\nExample\n\n\nMain loop of an example task.\n\n\n    \nwhile\n (\n1\n) {\n        \nev\n \n=\n \nos_eventq_get\n(\ntask1_evq\n);\n        \nassert\n(\nev\n);\n        \nif\n (\nev-\nev_type\n \n==\n \nCONS_EV_TYPE\n) {\n            \n/* XXX do stuff */\n\n        }\n    }", 
            "title": "os_eventq_get"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_get/#os_eventq_get", 
            "text": "void  os_eventq_get ( struct   os_eventq   *evq )  Fetches the first event from a queue. Task will sleep until something gets queued.", 
            "title": " os_eventq_get"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_get/#arguments", 
            "text": "Arguments  Description      evq  Queue to wait on", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_get/#returned-values", 
            "text": "Will return with a pointer to first  struct event  which is in the queue.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_get/#notes", 
            "text": "", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_get/#example", 
            "text": "Main loop of an example task.       while  ( 1 ) {\n         ev   =   os_eventq_get ( task1_evq );\n         assert ( ev );\n         if  ( ev- ev_type   ==   CONS_EV_TYPE ) {\n             /* XXX do stuff */ \n        }\n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_init/", 
            "text": "os_eventq_init\n\n\n   \nvoid\n\n    \nos_eventq_init\n(\nstruct\n \nos_eventq\n \n*evq\n)\n\n\n\n\n\nInitializes \nstruct os_eventq\n, making it ready for use.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nevq\n\n\nPointer to event queue getting initialized\n\n\n\n\n\n\n\n\nReturned values\n\n\nNone\n\n\nNotes\n\n\nUsually done at subsystem init time; before OS has been started, and before interrupts generating events have been enabled.\n\n\nExample\n\n\n\nThis initializes event queue used by newtmgr task.\n\n\nstruct\n \nos_eventq\n \ng_nmgr_evq\n;\n\n\nint\n\n\nnmgr_task_init\n(\nuint8_t\n \nprio\n, \nos_stack_t\n \n*stack_ptr\n, \nuint16_t\n \nstack_len\n)\n{\n    \n/* variable declarations here */\n\n\n    \nos_eventq_init\n(\ng_nmgr_evq\n);\n\n    \n/* initialization continues here */\n\n}", 
            "title": "os_eventq_init"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_init/#os_eventq_init", 
            "text": "void \n     os_eventq_init ( struct   os_eventq   *evq )  Initializes  struct os_eventq , making it ready for use.", 
            "title": " os_eventq_init"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_init/#arguments", 
            "text": "Arguments  Description      evq  Pointer to event queue getting initialized", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_init/#returned-values", 
            "text": "None", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_init/#notes", 
            "text": "Usually done at subsystem init time; before OS has been started, and before interrupts generating events have been enabled.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_init/#example", 
            "text": "This initializes event queue used by newtmgr task.  struct   os_eventq   g_nmgr_evq ; int  nmgr_task_init ( uint8_t   prio ,  os_stack_t   *stack_ptr ,  uint16_t   stack_len )\n{\n     /* variable declarations here */ \n\n     os_eventq_init ( g_nmgr_evq );\n\n     /* initialization continues here */ \n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_put/", 
            "text": "os_eventq_put\n\n\nvoid\n\n\nos_eventq_put\n(\nstruct\n \nos_eventq\n \n*evq\n, \nstruct\n \nos_event\n \n*ev\n)\n\n\n\n\n\nQueues an event to tail of the event queue.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nevq\n\n\nQueue where event is being placed\n\n\n\n\n\n\nev\n\n\nEvent which is being queued\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nExample\n\n\n\nThis is used to pass info about an event to a task handling it.\n\n\n    \n/* Get an event structure off the queue */\n\n    \nev\n \n=\n (\nstruct\n \nos_event\n \n*\n)\nos_memblock_get\n(\ng_hci_os_event_pool\n);\n    \nif\n (\n!ev\n) {\n        \nerr\n \n=\n \nos_memblock_put\n(\ng_hci_cmd_pool\n, \nhci_ev\n);\n        \nassert\n(\nerr\n \n==\n \nOS_OK\n);\n        \nreturn\n \n-\n1\n;\n    }\n\n    \n/* Fill out the event and post to Link Layer */\n\n    \nev-\nev_queued\n \n=\n \n0\n;\n    \nev-\nev_type\n \n=\n \nBLE_HOST_HCI_EVENT_CTLR_EVENT\n;\n    \nev-\nev_arg\n \n=\n \nhci_ev\n;\n    \nos_eventq_put\n(\nble_hs_evq\n, \nev\n);", 
            "title": "os_eventq_put"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_put/#os_eventq_put", 
            "text": "void  os_eventq_put ( struct   os_eventq   *evq ,  struct   os_event   *ev )  Queues an event to tail of the event queue.", 
            "title": " os_eventq_put"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_put/#arguments", 
            "text": "Arguments  Description      evq  Queue where event is being placed    ev  Event which is being queued", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_put/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_put/#example", 
            "text": "This is used to pass info about an event to a task handling it.       /* Get an event structure off the queue */ \n     ev   =  ( struct   os_event   * ) os_memblock_get ( g_hci_os_event_pool );\n     if  ( !ev ) {\n         err   =   os_memblock_put ( g_hci_cmd_pool ,  hci_ev );\n         assert ( err   ==   OS_OK );\n         return   - 1 ;\n    }\n\n     /* Fill out the event and post to Link Layer */ \n     ev- ev_queued   =   0 ;\n     ev- ev_type   =   BLE_HOST_HCI_EVENT_CTLR_EVENT ;\n     ev- ev_arg   =   hci_ev ;\n     os_eventq_put ( ble_hs_evq ,  ev );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_remove/", 
            "text": "os_eventq_remove\n\n\nvoid\n\n\nos_eventq_remove\n(\nstruct\n \nos_eventq\n \n*evq\n, \nstruct\n \nos_event\n \n*ev\n)\n\n\n\n\n\nRemoves an event which has been placed in a queue.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nevq\n\n\nQueue where event is being removed from\n\n\n\n\n\n\nev\n\n\nEvent which is being removed\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nExample\n\n\n\nThis is from os_callout_stop(). User wants to stop a callout from getting passed to a task. If the event has already been queued, then remove it before it is seen.\n\n\n    \nif\n (\nc-\nc_evq\n) {\n        \nos_eventq_remove\n(\nc-\nc_evq\n, \nc-\nc_ev\n);\n    }", 
            "title": "os_eventq_remove"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_remove/#os_eventq_remove", 
            "text": "void  os_eventq_remove ( struct   os_eventq   *evq ,  struct   os_event   *ev )  Removes an event which has been placed in a queue.", 
            "title": " os_eventq_remove"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_remove/#arguments", 
            "text": "Arguments  Description      evq  Queue where event is being removed from    ev  Event which is being removed", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_remove/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_remove/#notes", 
            "text": "", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/event_queue/os_eventq_remove/#example", 
            "text": "This is from os_callout_stop(). User wants to stop a callout from getting passed to a task. If the event has already been queued, then remove it before it is seen.       if  ( c- c_evq ) {\n         os_eventq_remove ( c- c_evq ,  c- c_ev );\n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/semaphore/semaphore/", 
            "text": "Semaphore\n\n\nA semaphore is a structure used for gaining exclusive access (much like a mutex), synchronizing task operations and/or use in a \"producer/consumer\" roles. Semaphores like the ones used by the myNewt OS are called \"counting\" semaphores as they are allowed to have more than one token (explained below).\n\n\nDescription\n\n\nA semaphore is a fairly simple construct consisting of a queue for waiting tasks and the number of tokens currently owned by the semaphore. A semaphore can be obtained as long as there are tokens in the semaphore. Any task can add tokens to the semaphore and any task can request the semaphore, thereby removing tokens. When creating the semaphore, the initial number of tokens can be set as well.\n\n\nWhen used for exclusive access to a shared resource the semaphore only needs a single token. In this case, a single task \"creates\" the semaphore by calling \nos_sem_init\n with a value of one (1) for the token. When a task desires exclusive access to the shared resource it requests the semaphore by calling \nos_sem_pend\n. If there is a token the requesting task will acquire the semaphore and continue operation. If no tokens are available the task will be put to sleep until there is a token. A common \"problem\" with using a semaphore for exclusive access is called \npriority inversion\n. Consider the following scenario: a high and low priority task both share a resource which is locked using a semaphore. If the low priority task obtains the semaphore and then the high priority task requests the semaphore, the high priority task is now blocked until the low priority task releases the semaphore. Now suppose that there are tasks between the low priority task and the high priority task that want to run. These tasks will preempt the low priority task which owns the semaphore. Thus, the high priority task is blocked waiting for the low priority task to finish using the semaphore but the low priority task cannot run since other tasks are running. Thus, the high priority tasks is \"inverted\" in priority; in effect running at a much lower priority as normally it would preempt the other (lower priority) tasks. If this is an issue a mutex should be used instead of a semaphore.\n\n\nSemaphores can also be used for task synchronization. A simple example of this would be the following. A task creates a semaphore and initializes it with no tokens. The task then waits on the semaphore, and since there are no tokens, the task is put to sleep. When other tasks want to wake up the sleeping task they simply add a token by calling \nos_sem_release\n. This will cause the sleeping task to wake up (instantly if no other higher priority tasks want to run).\n\n\nThe other common use of a counting semaphore is in what is commonly called a \"producer/consumer\" relationship. The producer adds tokens (by calling \nos_sem_release\n) and the consumer consumes them by calling \nos_sem_pend\n. In this relationship, the producer has work for the consumer to do. Each token added to the semaphore will cause the consumer to do whatever work is required. A simple example could be the following: every time a button is pressed there is some work to do (ring a bell). Each button press causes the producer to add a token. Each token consumed rings the bell. There will exactly the same number of bell rings as there are button presses. In other words, each call to \nos_sem_pend\n subtracts exactly one token and each call to \nos_sem_release\n adds exactly one token.\n\n\nData structures\n\n\nstruct\n \nos_sem\n\n{\n    \nSLIST_HEAD\n(, \nos_task\n) \nsem_head\n;     \n/* chain of waiting tasks */\n\n    \nuint16_t\n    \n_pad\n;\n    \nuint16_t\n    \nsem_tokens\n;             \n/* # of tokens */\n\n};\n\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsem_head\n\n\nQueue head for list of tasks waiting on semaphore\n\n\n\n\n\n\n_pad\n\n\nPadding for alignment\n\n\n\n\n\n\nsem_tokens\n\n\nCurrent number of tokens\n\n\n\n\n\n\n\n\nList of Functions\n\n\nThe functions available in semaphore are:\n\n\n\n\nos_sem_init\n\n\nos_sem_pend\n\n\nos_sem_release", 
            "title": "toc"
        }, 
        {
            "location": "/os/core_os/semaphore/semaphore/#semaphore", 
            "text": "A semaphore is a structure used for gaining exclusive access (much like a mutex), synchronizing task operations and/or use in a \"producer/consumer\" roles. Semaphores like the ones used by the myNewt OS are called \"counting\" semaphores as they are allowed to have more than one token (explained below).", 
            "title": "Semaphore"
        }, 
        {
            "location": "/os/core_os/semaphore/semaphore/#description", 
            "text": "A semaphore is a fairly simple construct consisting of a queue for waiting tasks and the number of tokens currently owned by the semaphore. A semaphore can be obtained as long as there are tokens in the semaphore. Any task can add tokens to the semaphore and any task can request the semaphore, thereby removing tokens. When creating the semaphore, the initial number of tokens can be set as well.  When used for exclusive access to a shared resource the semaphore only needs a single token. In this case, a single task \"creates\" the semaphore by calling  os_sem_init  with a value of one (1) for the token. When a task desires exclusive access to the shared resource it requests the semaphore by calling  os_sem_pend . If there is a token the requesting task will acquire the semaphore and continue operation. If no tokens are available the task will be put to sleep until there is a token. A common \"problem\" with using a semaphore for exclusive access is called  priority inversion . Consider the following scenario: a high and low priority task both share a resource which is locked using a semaphore. If the low priority task obtains the semaphore and then the high priority task requests the semaphore, the high priority task is now blocked until the low priority task releases the semaphore. Now suppose that there are tasks between the low priority task and the high priority task that want to run. These tasks will preempt the low priority task which owns the semaphore. Thus, the high priority task is blocked waiting for the low priority task to finish using the semaphore but the low priority task cannot run since other tasks are running. Thus, the high priority tasks is \"inverted\" in priority; in effect running at a much lower priority as normally it would preempt the other (lower priority) tasks. If this is an issue a mutex should be used instead of a semaphore.  Semaphores can also be used for task synchronization. A simple example of this would be the following. A task creates a semaphore and initializes it with no tokens. The task then waits on the semaphore, and since there are no tokens, the task is put to sleep. When other tasks want to wake up the sleeping task they simply add a token by calling  os_sem_release . This will cause the sleeping task to wake up (instantly if no other higher priority tasks want to run).  The other common use of a counting semaphore is in what is commonly called a \"producer/consumer\" relationship. The producer adds tokens (by calling  os_sem_release ) and the consumer consumes them by calling  os_sem_pend . In this relationship, the producer has work for the consumer to do. Each token added to the semaphore will cause the consumer to do whatever work is required. A simple example could be the following: every time a button is pressed there is some work to do (ring a bell). Each button press causes the producer to add a token. Each token consumed rings the bell. There will exactly the same number of bell rings as there are button presses. In other words, each call to  os_sem_pend  subtracts exactly one token and each call to  os_sem_release  adds exactly one token.", 
            "title": "Description"
        }, 
        {
            "location": "/os/core_os/semaphore/semaphore/#data-structures", 
            "text": "struct   os_sem \n{\n     SLIST_HEAD (,  os_task )  sem_head ;      /* chain of waiting tasks */ \n     uint16_t      _pad ;\n     uint16_t      sem_tokens ;              /* # of tokens */ \n};     Element  Description      sem_head  Queue head for list of tasks waiting on semaphore    _pad  Padding for alignment    sem_tokens  Current number of tokens", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/core_os/semaphore/semaphore/#list-of-functions", 
            "text": "The functions available in semaphore are:   os_sem_init  os_sem_pend  os_sem_release", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_init/", 
            "text": "os_sem_init\n\n\nos_error_t\n \nos_sem_init\n(\nstruct\n \nos_sem\n \n*sem\n, \nuint16_t\n \ntokens\n)    \n\n\n\n\n\nInitialize a semaphore with a given number of tokens. Should be called before the semaphore is used.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*sem\n\n\nPointer to semaphore\n\n\n\n\n\n\ntokens\n\n\nInitial number of tokens allocated to semaphore\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_INVALID_PARM: returned when *sem is NULL on entry.\n\n\nOS_OK: semaphore initialized successfully.\n\n\nNotes\n\n\n\n\nExample\n\n\nThe following example shows how to initialize a semaphore used for exclusive access.\n\n\nstruct\n \nos_mutex\n \ng_os_sem\n;\n\nos_error_t\n \nerr\n;\n\n\nerr\n \n=\n \nos_sem_init\n(\ng_os_sem\n, \n1\n);\n\nassert\n(\nerr\n \n==\n \nOS_OK\n);", 
            "title": "os_sem_init"
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_init/#os_sem_init", 
            "text": "os_error_t   os_sem_init ( struct   os_sem   *sem ,  uint16_t   tokens )      Initialize a semaphore with a given number of tokens. Should be called before the semaphore is used.", 
            "title": " os_sem_init"
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_init/#arguments", 
            "text": "Arguments  Description      *sem  Pointer to semaphore    tokens  Initial number of tokens allocated to semaphore", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_init/#returned-values", 
            "text": "OS_INVALID_PARM: returned when *sem is NULL on entry.  OS_OK: semaphore initialized successfully.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_init/#notes", 
            "text": "", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_init/#example", 
            "text": "The following example shows how to initialize a semaphore used for exclusive access.  struct   os_mutex   g_os_sem ; os_error_t   err ; err   =   os_sem_init ( g_os_sem ,  1 ); assert ( err   ==   OS_OK );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_pend/", 
            "text": "os_sem_pend \n\n\nos_error_t\n \nos_sem_pend\n(\nstruct\n \nos_sem\n \n*sem\n, \nuint32_t\n \ntimeout\n)\n\n\n\n\n\nWait for a semaphore for a given amount of time.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*sem\n\n\nPointer to semaphore\n\n\n\n\n\n\ntimeout\n\n\nAmount of time, in os ticks, to wait for semaphore. A value of 0 means no wait. A value of 0xFFFFFFFF means wait forever.\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_INVALID_PARM: returned when *sem is NULL on entry.\n\n\nOS_OK: semaphore acquired successfully.\n\n\nOS_TIMEOUT: the semaphore was not available within the timeout specified.\n\n\nOS_NOT_STARTED: Attempt to release a semaphore before os started.\n\n\nNotes\n\n\nIf a timeout of 0 is used and the function returns OS_TIMEOUT, the semaphore was not available and was not acquired. No release of the semaphore should occur and the calling task does not own the semaphore.\n\n\nExample\n\n\nstruct\n \nos_sem\n \ng_os_sem\n;\n\nos_error_t\n \nerr\n;\n\n\nerr\n \n=\n \nos_sem_pend\n(\ng_os_sem\n, \nOS_TIMEOUT_NEVER\n);\n\nassert\n(\nerr\n \n==\n \nOS_OK\n);\n\n\n/* Perform operations requiring semaphore lock */\n\n\n\nerr\n \n=\n \nos_sem_release\n(\ng_os_sem\n);\n\nassert\n(\nerr\n \n==\n \nOS_OK\n);", 
            "title": "os_sem_pend"
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_pend/#os_sem_pend", 
            "text": "os_error_t   os_sem_pend ( struct   os_sem   *sem ,  uint32_t   timeout )  Wait for a semaphore for a given amount of time.", 
            "title": " os_sem_pend "
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_pend/#arguments", 
            "text": "Arguments  Description      *sem  Pointer to semaphore    timeout  Amount of time, in os ticks, to wait for semaphore. A value of 0 means no wait. A value of 0xFFFFFFFF means wait forever.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_pend/#returned-values", 
            "text": "OS_INVALID_PARM: returned when *sem is NULL on entry.  OS_OK: semaphore acquired successfully.  OS_TIMEOUT: the semaphore was not available within the timeout specified.  OS_NOT_STARTED: Attempt to release a semaphore before os started.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_pend/#notes", 
            "text": "If a timeout of 0 is used and the function returns OS_TIMEOUT, the semaphore was not available and was not acquired. No release of the semaphore should occur and the calling task does not own the semaphore.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_pend/#example", 
            "text": "struct   os_sem   g_os_sem ; os_error_t   err ; err   =   os_sem_pend ( g_os_sem ,  OS_TIMEOUT_NEVER ); assert ( err   ==   OS_OK ); /* Perform operations requiring semaphore lock */  err   =   os_sem_release ( g_os_sem ); assert ( err   ==   OS_OK );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_release/", 
            "text": "os_sem_release \n\n\nos_error_t\n \nos_sem_release\n(\nstruct\n \nos_sem\n \n*sem\n)\n\n\n\n\n\nRelease a semaphore that you are holding. This adds a token to the semaphore.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*sem\n\n\nPointer to semaphore\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_NOT_STARTED: Called before os has been started.\n\n\nOS_INVALID_PARM: returned when *sem is NULL on entry.\n\n\nOS_OK: semaphore released successfully.\n\n\nNotes\n\n\nExample\n\n\nstruct\n \nos_sem\n \ng_os_sem\n;\n\nos_error_t\n \nerr\n;\n\n\nerr\n \n=\n \nos_sem_pend\n(\ng_os_sem\n, \nOS_TIMEOUT_NEVER\n);\n\nassert\n(\nerr\n \n==\n \nOS_OK\n);\n\n\n/* Perform operations requiring semaphore lock */\n\n\n\nerr\n \n=\n \nos_sem_release\n(\ng_os_sem\n);\n\nassert\n(\nerr\n \n==\n \nOS_OK\n);", 
            "title": "os_sem_release"
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_release/#os_sem_release", 
            "text": "os_error_t   os_sem_release ( struct   os_sem   *sem )  Release a semaphore that you are holding. This adds a token to the semaphore.", 
            "title": " os_sem_release "
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_release/#arguments", 
            "text": "Arguments  Description      *sem  Pointer to semaphore", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_release/#returned-values", 
            "text": "OS_NOT_STARTED: Called before os has been started.  OS_INVALID_PARM: returned when *sem is NULL on entry.  OS_OK: semaphore released successfully.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_release/#notes", 
            "text": "", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/semaphore/os_sem_release/#example", 
            "text": "struct   os_sem   g_os_sem ; os_error_t   err ; err   =   os_sem_pend ( g_os_sem ,  OS_TIMEOUT_NEVER ); assert ( err   ==   OS_OK ); /* Perform operations requiring semaphore lock */  err   =   os_sem_release ( g_os_sem ); assert ( err   ==   OS_OK );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mutex/mutex/", 
            "text": "Mutex\n\n\nMutex is short for \"mutual exclusion\"; a mutex provides mutually exclusive access to a shared resource. A mutex provides \npriority inheritance\n in order to prevent \npriority inversion\n. Priority inversion occurs when a higher priority task is waiting on a resource owned by a lower priority task. Using a mutex, the lower priority task will inherit the highest priority of any task waiting on the mutex. \n\n\nDescription\n\n\nThe first order of business when using a mutex is to declare the mutex globally. The mutex needs to be initialized before it is used (see the examples). It is generally a good idea to initialize the mutex before tasks start running in order to avoid a task possibly using the mutex before it is initialized.\n\n\nWhen a task wants exclusive access to a shared resource it needs to obtain the mutex by calling \nos_mutex_pend\n. If the mutex is currently owned by a different task (a lower priority task), the requesting task will be put to sleep and the owners priority will be elevated to the priority of the requesting task. Note that multiple tasks can request ownership and the current owner is elevated to the highest priority of any task waitin on the mutex. When the task is done using the shared resource, it needs to release the mutex by called \nos_mutex_release\n. There needs to be one release per call to pend. Note that nested calls to \nos_mutex_pend\n are allowed but there needs to be one release per pend.\n\n\nThe following example will illustrate how priority inheritance works. In this example, the task number is the same as its priority. Remember that the lower the number, the higher the priority (i.e. priority 0 is higher priority than priority 1). Suppose that task 5 gets ownership of a mutex but is preempted by task 4. Task 4 attempts to gain ownership of the mutex but cannot as it is owned by task 5. Task 4 is put to sleep and task 5 is temporarily raised to priority 4. Before task 5 can release the mutex, task 3 runs and attempts to acquire the mutex. At this point, both task 3 and task 4 are waiting on the mutex (sleeping). Task 5 now runs at priority 3 (the highest priority of all the tasks waiting on the mutex). When task 5 finally releases the mutex it will be preempted as two higher priority tasks are waiting for it. \n\n\nNote that when multiple tasks are waiting on a mutex owned by another task, once the mutex is released the highest priority task waiting on the mutex is run. \n\n\nData structures\n\n\nstruct\n \nos_mutex\n\n{\n    \nSLIST_HEAD\n(, \nos_task\n) \nmu_head\n;\n    \nuint8_t\n     \n_pad\n;\n    \nuint8_t\n     \nmu_prio\n;\n    \nuint16_t\n    \nmu_level\n;\n    \nstruct\n \nos_task\n \n*mu_owner\n;\n};\n\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmu_head\n\n\nQueue head for list of tasks waiting on mutex\n\n\n\n\n\n\n_pad\n\n\nPadding\n\n\n\n\n\n\nmu_prio\n\n\nDefault priority of owner of mutex. Used to reset priority of task when mutex released\n\n\n\n\n\n\nmu_level\n\n\nCall nesting level (for nested calls)\n\n\n\n\n\n\nmu_owner\n\n\nPointer to task structure which owns mutex\n\n\n\n\n\n\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_mutex_init\n\n\nos_mutex_pend\n\n\nos_mutex_release", 
            "title": "toc"
        }, 
        {
            "location": "/os/core_os/mutex/mutex/#mutex", 
            "text": "Mutex is short for \"mutual exclusion\"; a mutex provides mutually exclusive access to a shared resource. A mutex provides  priority inheritance  in order to prevent  priority inversion . Priority inversion occurs when a higher priority task is waiting on a resource owned by a lower priority task. Using a mutex, the lower priority task will inherit the highest priority of any task waiting on the mutex.", 
            "title": "Mutex"
        }, 
        {
            "location": "/os/core_os/mutex/mutex/#description", 
            "text": "The first order of business when using a mutex is to declare the mutex globally. The mutex needs to be initialized before it is used (see the examples). It is generally a good idea to initialize the mutex before tasks start running in order to avoid a task possibly using the mutex before it is initialized.  When a task wants exclusive access to a shared resource it needs to obtain the mutex by calling  os_mutex_pend . If the mutex is currently owned by a different task (a lower priority task), the requesting task will be put to sleep and the owners priority will be elevated to the priority of the requesting task. Note that multiple tasks can request ownership and the current owner is elevated to the highest priority of any task waitin on the mutex. When the task is done using the shared resource, it needs to release the mutex by called  os_mutex_release . There needs to be one release per call to pend. Note that nested calls to  os_mutex_pend  are allowed but there needs to be one release per pend.  The following example will illustrate how priority inheritance works. In this example, the task number is the same as its priority. Remember that the lower the number, the higher the priority (i.e. priority 0 is higher priority than priority 1). Suppose that task 5 gets ownership of a mutex but is preempted by task 4. Task 4 attempts to gain ownership of the mutex but cannot as it is owned by task 5. Task 4 is put to sleep and task 5 is temporarily raised to priority 4. Before task 5 can release the mutex, task 3 runs and attempts to acquire the mutex. At this point, both task 3 and task 4 are waiting on the mutex (sleeping). Task 5 now runs at priority 3 (the highest priority of all the tasks waiting on the mutex). When task 5 finally releases the mutex it will be preempted as two higher priority tasks are waiting for it.   Note that when multiple tasks are waiting on a mutex owned by another task, once the mutex is released the highest priority task waiting on the mutex is run.", 
            "title": "Description"
        }, 
        {
            "location": "/os/core_os/mutex/mutex/#data-structures", 
            "text": "struct   os_mutex \n{\n     SLIST_HEAD (,  os_task )  mu_head ;\n     uint8_t       _pad ;\n     uint8_t       mu_prio ;\n     uint16_t      mu_level ;\n     struct   os_task   *mu_owner ;\n};     Element  Description      mu_head  Queue head for list of tasks waiting on mutex    _pad  Padding    mu_prio  Default priority of owner of mutex. Used to reset priority of task when mutex released    mu_level  Call nesting level (for nested calls)    mu_owner  Pointer to task structure which owns mutex", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/core_os/mutex/mutex/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_mutex_init  os_mutex_pend  os_mutex_release", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/core_os/mutex/os_mutex_pend/", 
            "text": "os_mutex_pend \n\n\nos_error_t\n \nos_mutex_pend\n(\nstruct\n \nos_mutex\n \n*mu\n, \nuint32_t\n \ntimeout\n) \n\n\n\n\n\nAcquire ownership of a mutex.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*mu\n\n\nPointer to mutex\n\n\n\n\n\n\ntimeout\n\n\nTimeout, in os ticks. A value of 0 means no timeout. A value of 0xFFFFFFFF means to wait forever.\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_INVALID_PARM: returned when *mu is NULL on entry.\n\n\nOS_OK: mutex was successfully acquired.\n\n\nOS_TIMEOUT: the mutex was not available within the timeout specified.\n\n\nOS_NOT_STARTED: Attempt to release a mutex before the os has been started.\n\n\nNotes\n\n\nIf the mutex is owned by another task and the timeout is 0 the function returns immediately with the error code OS_TIMEOUT. The calling task \ndoes not\n own the mutex when this occurs.\n\n\nExample\n\n\nstruct\n \nos_mutex\n \ng_mutex1\n;\n\nos_error_t\n \nerr\n;\n\n\nerr\n \n=\n \nos_mutex_pend\n(\ng_mutex1\n, \n0\n);\n\nassert\n(\nerr\n \n==\n \nOS_OK\n);\n\n\n/* Perform operations requiring exclusive access */\n\n\n\nerr\n \n=\n \nos_mutex_release\n(\ng_mutex1\n);\n\nassert\n(\nerr\n \n==\n \nOS_OK\n);", 
            "title": "os_mutex_init"
        }, 
        {
            "location": "/os/core_os/mutex/os_mutex_pend/#os_mutex_pend", 
            "text": "os_error_t   os_mutex_pend ( struct   os_mutex   *mu ,  uint32_t   timeout )   Acquire ownership of a mutex.", 
            "title": "os_mutex_pend "
        }, 
        {
            "location": "/os/core_os/mutex/os_mutex_pend/#arguments", 
            "text": "Arguments  Description      *mu  Pointer to mutex    timeout  Timeout, in os ticks. A value of 0 means no timeout. A value of 0xFFFFFFFF means to wait forever.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mutex/os_mutex_pend/#returned-values", 
            "text": "OS_INVALID_PARM: returned when *mu is NULL on entry.  OS_OK: mutex was successfully acquired.  OS_TIMEOUT: the mutex was not available within the timeout specified.  OS_NOT_STARTED: Attempt to release a mutex before the os has been started.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mutex/os_mutex_pend/#notes", 
            "text": "If the mutex is owned by another task and the timeout is 0 the function returns immediately with the error code OS_TIMEOUT. The calling task  does not  own the mutex when this occurs.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/mutex/os_mutex_pend/#example", 
            "text": "struct   os_mutex   g_mutex1 ; os_error_t   err ; err   =   os_mutex_pend ( g_mutex1 ,  0 ); assert ( err   ==   OS_OK ); /* Perform operations requiring exclusive access */  err   =   os_mutex_release ( g_mutex1 ); assert ( err   ==   OS_OK );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mutex/os_mutex_release/", 
            "text": "os_mutex_release\n\n\nos_error_t\n \nos_mutex_release\n(\nstruct\n \nos_mutex\n \n*mu\n)\n\n\n\n\n\nRelease ownership of a mutex\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*mu\n\n\nPointer to mutex\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_INVALID_PARM: returned when *mu is NULL on entry.\n\n\nOS_OK: mutex initialized successfully.\n\n\nOS_BAD_MUTEX: The mutex was not owned by the task attempting to release it.\n\n\nOS_NOT_STARTED: Attempt to release a mutex before the os has been started.\n\n\nExample\n\n\nstruct\n \nos_mutex\n \ng_mutex1\n;\n\nos_error_t\n \nerr\n;\n\n\nerr\n \n=\n \nos_mutex_pend\n(\ng_mutex1\n, \n0\n);\n\nassert\n(\nerr\n \n==\n \nOS_OK\n);\n\n\n/* Perform operations requiring exclusive access */\n\n\n\nerr\n \n=\n \nos_mutex_release\n(\ng_mutex1\n);\n\nassert\n(\nerr\n \n==\n \nOS_OK\n);", 
            "title": "os_mutex_release"
        }, 
        {
            "location": "/os/core_os/mutex/os_mutex_release/#os_mutex_release", 
            "text": "os_error_t   os_mutex_release ( struct   os_mutex   *mu )  Release ownership of a mutex", 
            "title": "os_mutex_release"
        }, 
        {
            "location": "/os/core_os/mutex/os_mutex_release/#arguments", 
            "text": "Arguments  Description      *mu  Pointer to mutex", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mutex/os_mutex_release/#returned-values", 
            "text": "OS_INVALID_PARM: returned when *mu is NULL on entry.  OS_OK: mutex initialized successfully.  OS_BAD_MUTEX: The mutex was not owned by the task attempting to release it.  OS_NOT_STARTED: Attempt to release a mutex before the os has been started.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mutex/os_mutex_release/#example", 
            "text": "struct   os_mutex   g_mutex1 ; os_error_t   err ; err   =   os_mutex_pend ( g_mutex1 ,  0 ); assert ( err   ==   OS_OK ); /* Perform operations requiring exclusive access */  err   =   os_mutex_release ( g_mutex1 ); assert ( err   ==   OS_OK );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/memory_pool/memory_pool/", 
            "text": "Memory Pools\n\n\nA memory pool is a collection of fixed sized elements called memory blocks. Generally, memory pools are used when the developer wants to allocate a certain amount of memory to a given feature. Unlike the heap, where a code module is at the mercy of other code modules to insure there is sufficient memory, memory pools can insure sufficient memory allocation.\n\n\nDescription\n\n\nIn order to create a memory pool the developer needs to do a few things. The first task is to define the memory pool itself. This is a data structure which contains information about the pool itself (i.e. number of blocks, size of the blocks, etc).\n\n\nstruct\n \nos_mempool\n \nmy_pool\n;\n\n\n\n\n\n\nThe next order of business is to allocate the memory used by the memory pool. This memory can either be statically allocated (i.e. a global variable) or dynamically allocated (i.e. from the heap). When determining the amount of memory required for the memory pool, simply multiplying the number of blocks by the size of each block is not sufficient as the OS may have alignment requirements. The alignment size definition is named \nOS_ALIGNMENT\n and can be found in os_arch.h as it is architecture specific. The memory block alignment is usually for efficiency but may be due to other reasons. Generally, blocks are aligned on 32-bit boundaries. Note that memory blocks must also be of sufficient size to hold a list pointer as this is needed to chain memory blocks on the free list.\n\n\nIn order to simplify this for the user two macros have been provided: \nOS_MEMPOOL_BYTES(n, blksize)\n and \nOS_MEMPOOL_SIZE(n, blksize)\n. The first macro returns the number of bytes needed for the memory pool while the second returns the number of \nos_membuf_t\n elements required by the memory pool. The \nos_membuf_t\n type is used to guarantee that the memory buffer used by the memory pool is aligned on the correct boundary. \n\n\nHere are some examples. Note that if a custom malloc implementation is used it must guarantee that the memory buffer used by the pool is allocated on the correct boundary (i.e. OS_ALIGNMENT).\n\n\nvoid\n \n*my_memory_buffer\n;\n\nmy_memory_buffer\n \n=\n \nmalloc\n(\nOS_MEMPOOL_BYTES\n(\nNUM_BLOCKS\n, \nBLOCK_SIZE\n));\n\n\n\n\n\nos_membuf_t\n \nmy_memory_buffer\n[\nOS_MEMPOOL_SIZE\n(\nNUM_BLOCKS\n, \nBLOCK_SIZE\n)];\n\n\n\n\n\n\nNow that the memory pool has been defined as well as the memory required for the memory blocks which make up the pool the user needs to initialize the memory pool by calling \nos_mempool_init\n.\n\n\nos_mempool_init\n(\nmy_pool\n, \nNUM_BLOCKS\n, \nBLOCK_SIZE\n, \nmy_memory_buffer\n,\n                         \nMyPool\n);\n\n\n\n\n\n\nOnce the memory pool has been initialized the developer can allocate memory blocks from the pool by calling \nos_memblock_get\n. When the memory block is no longer needed the memory can be freed by calling \nos_memblock_put\n. \n\n\nData structures\n\n\nstruct\n \nos_mempool\n {\n    \nint\n \nmp_block_size\n;\n    \nint\n \nmp_num_blocks\n;\n    \nint\n \nmp_num_free\n;\n    \nuint32_t\n \nmp_membuf_addr\n;\n    \nSTAILQ_ENTRY\n(\nos_mempool\n) \nmp_list\n;    \n    \nSLIST_HEAD\n(,\nos_memblock\n);\n    \nchar\n \n*name\n;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmp_block_size\n\n\nSize of the memory blocks, in bytes. This is not the actual  number of bytes used by each block; it is the requested size of each block. The actual memory block size will be aligned to OS_ALIGNMENT bytes\n\n\n\n\n\n\nmp_num_blocks\n\n\nNumber of memory blocks in the pool\n\n\n\n\n\n\nmp_num_free\n\n\nNumber of free blocks left\n\n\n\n\n\n\nmp_membuf_addr\n\n\nThe address of the memory block. This is used to check that a valid memory block is being freed.\n\n\n\n\n\n\nmp_list\n\n\nList pointer to chain memory pools so they can be displayed by newt tools\n\n\n\n\n\n\nSLIST_HEAD(,os_memblock)\n\n\nList pointer to chain free memory blocks\n\n\n\n\n\n\nname\n\n\nName for the memory block\n\n\n\n\n\n\n\n\nList of Functions\n\n\nThe functions available in mem_pool are:\n\n\n\n\nos_memblock_get\n\n\nos_mempool_init\n\n\nos_memblock_put\n\n\nOS_MEMPOOL_BYTES\n\n\nOS_MEMPOOL_SIZE", 
            "title": "toc"
        }, 
        {
            "location": "/os/core_os/memory_pool/memory_pool/#memory-pools", 
            "text": "A memory pool is a collection of fixed sized elements called memory blocks. Generally, memory pools are used when the developer wants to allocate a certain amount of memory to a given feature. Unlike the heap, where a code module is at the mercy of other code modules to insure there is sufficient memory, memory pools can insure sufficient memory allocation.", 
            "title": "Memory Pools"
        }, 
        {
            "location": "/os/core_os/memory_pool/memory_pool/#description", 
            "text": "In order to create a memory pool the developer needs to do a few things. The first task is to define the memory pool itself. This is a data structure which contains information about the pool itself (i.e. number of blocks, size of the blocks, etc).  struct   os_mempool   my_pool ;  \nThe next order of business is to allocate the memory used by the memory pool. This memory can either be statically allocated (i.e. a global variable) or dynamically allocated (i.e. from the heap). When determining the amount of memory required for the memory pool, simply multiplying the number of blocks by the size of each block is not sufficient as the OS may have alignment requirements. The alignment size definition is named  OS_ALIGNMENT  and can be found in os_arch.h as it is architecture specific. The memory block alignment is usually for efficiency but may be due to other reasons. Generally, blocks are aligned on 32-bit boundaries. Note that memory blocks must also be of sufficient size to hold a list pointer as this is needed to chain memory blocks on the free list.  In order to simplify this for the user two macros have been provided:  OS_MEMPOOL_BYTES(n, blksize)  and  OS_MEMPOOL_SIZE(n, blksize) . The first macro returns the number of bytes needed for the memory pool while the second returns the number of  os_membuf_t  elements required by the memory pool. The  os_membuf_t  type is used to guarantee that the memory buffer used by the memory pool is aligned on the correct boundary.   Here are some examples. Note that if a custom malloc implementation is used it must guarantee that the memory buffer used by the pool is allocated on the correct boundary (i.e. OS_ALIGNMENT).  void   *my_memory_buffer ; my_memory_buffer   =   malloc ( OS_MEMPOOL_BYTES ( NUM_BLOCKS ,  BLOCK_SIZE ));  os_membuf_t   my_memory_buffer [ OS_MEMPOOL_SIZE ( NUM_BLOCKS ,  BLOCK_SIZE )];  \nNow that the memory pool has been defined as well as the memory required for the memory blocks which make up the pool the user needs to initialize the memory pool by calling  os_mempool_init .  os_mempool_init ( my_pool ,  NUM_BLOCKS ,  BLOCK_SIZE ,  my_memory_buffer ,\n                          MyPool );  \nOnce the memory pool has been initialized the developer can allocate memory blocks from the pool by calling  os_memblock_get . When the memory block is no longer needed the memory can be freed by calling  os_memblock_put .", 
            "title": "Description"
        }, 
        {
            "location": "/os/core_os/memory_pool/memory_pool/#data-structures", 
            "text": "struct   os_mempool  {\n     int   mp_block_size ;\n     int   mp_num_blocks ;\n     int   mp_num_free ;\n     uint32_t   mp_membuf_addr ;\n     STAILQ_ENTRY ( os_mempool )  mp_list ;    \n     SLIST_HEAD (, os_memblock );\n     char   *name ;\n};      Element  Description      mp_block_size  Size of the memory blocks, in bytes. This is not the actual  number of bytes used by each block; it is the requested size of each block. The actual memory block size will be aligned to OS_ALIGNMENT bytes    mp_num_blocks  Number of memory blocks in the pool    mp_num_free  Number of free blocks left    mp_membuf_addr  The address of the memory block. This is used to check that a valid memory block is being freed.    mp_list  List pointer to chain memory pools so they can be displayed by newt tools    SLIST_HEAD(,os_memblock)  List pointer to chain free memory blocks    name  Name for the memory block", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/core_os/memory_pool/memory_pool/#list-of-functions", 
            "text": "The functions available in mem_pool are:   os_memblock_get  os_mempool_init  os_memblock_put  OS_MEMPOOL_BYTES  OS_MEMPOOL_SIZE", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_memblock_get/", 
            "text": "os_memblock_get\n\n\nvoid\n \n*os_memblock_get\n(\nstruct\n \nos_mempool\n \n*mp\n)\n\n\n\n\n\nAllocate an element from the memory pool. If succesful, you'll get a pointer to allocated element. If there are no elements available, you'll get NULL as response.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmp\n\n\nPool where element is getting allocated from\n\n\n\n\n\n\n\n\nReturned values\n\n\nNULL: no elements available.\n\n: pointer to allocated element.\n\n\nNotes\n\n\nExample\n\n\n\n\n    \nstruct\n \nnffs_file\n \n*file\n;\n\n    \nfile\n \n=\n \nos_memblock_get\n(\nnffs_file_pool\n);\n    \nif\n (\nfile\n \n!=\n \nNULL\n) {\n        \nmemset\n(\nfile\n, \n0\n, \nsizeof\n \n*file\n);\n    }", 
            "title": "os_memblock_get"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_memblock_get/#os_memblock_get", 
            "text": "void   *os_memblock_get ( struct   os_mempool   *mp )  Allocate an element from the memory pool. If succesful, you'll get a pointer to allocated element. If there are no elements available, you'll get NULL as response.", 
            "title": " os_memblock_get"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_memblock_get/#arguments", 
            "text": "Arguments  Description      mp  Pool where element is getting allocated from", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_memblock_get/#returned-values", 
            "text": "NULL: no elements available. : pointer to allocated element.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_memblock_get/#notes", 
            "text": "", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_memblock_get/#example", 
            "text": "struct   nffs_file   *file ;\n\n     file   =   os_memblock_get ( nffs_file_pool );\n     if  ( file   !=   NULL ) {\n         memset ( file ,  0 ,  sizeof   *file );\n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_mempool_init/", 
            "text": "os_mempool_init\n\n\nos_error_t\n \nos_mempool_init\n(\nstruct\n \nos_mempool\n \n*mp\n, \nint\n \nblocks\n, \nint\n \nblock_size\n, \nvoid\n \n*membuf\n, \nchar\n \n*name\n)\n\n\n\n\n\nInitializes the memory pool. Memory pointed to by \nmembuf\n is divided into \nblocks\n number of elements of size OS_ALIGN(\nblock_size\n). The \nname\n is optional, and names the memory pool.\n\n\nIt is assumed that the amount of memory pointed by \nmembuf\n has at least \nOS_MEMPOOL_BYTES(blocks, block_size)\n number of bytes.\n\n\nname\n is not copied, so caller should make sure that the memory does not get reused.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmp\n\n\nMemory pool being initialized\n\n\n\n\n\n\nblocks\n\n\nNumber of elements in the pool\n\n\n\n\n\n\nblock_size\n\n\nMinimum size of an individual element in pool\n\n\n\n\n\n\nmembuf\n\n\nBacking store for the memory pool elements\n\n\n\n\n\n\nname\n\n\nName of the memory pool\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_OK: operation was successful.\n\nOS_INVALID_PARAM: invalid parameters. Block count or block size was negative, or membuf or mp was NULL.\n\nOS_MEM_NOT_ALIGNED: membuf was not aligned on correct byte boundary.\n\n\nNotes\n\n\nNote that os_mempool_init() does not allocate backing storage; \nmembuf\n has to be allocated by the caller.\n\n\nIt's recommended that you use \nOS_MEMPOOL_BYTES()\n or \nOS_MEMPOOL_SIZE()\n to figure out how much memory to allocate for the pool.\n\n\nExample\n\n\n\n\n    \nvoid\n \n*nffs_file_mem\n;\n\n    \nnffs_file_mem\n \n=\n \nmalloc\n(\nOS_MEMPOOL_BYTES\n(\nnffs_config\n.\nnc_num_files\n, \nsizeof\n (\nstruct\n \nnffs_file\n)));\n\n    \nrc\n \n=\n \nos_mempool_init\n(\nnffs_file_pool\n, \nnffs_config\n.\nnc_num_files\n,\n                         \nsizeof\n (\nstruct\n \nnffs_file\n), \nnffs_file_mem\n,\n                         \nnffs_file_pool\n);\n    \nif\n (\nrc\n \n!=\n \n0\n) {\n        \n/* Memory pool initialization failure */\n\n    }", 
            "title": "os_mempool_init"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_mempool_init/#os_mempool_init", 
            "text": "os_error_t   os_mempool_init ( struct   os_mempool   *mp ,  int   blocks ,  int   block_size ,  void   *membuf ,  char   *name )  Initializes the memory pool. Memory pointed to by  membuf  is divided into  blocks  number of elements of size OS_ALIGN( block_size ). The  name  is optional, and names the memory pool.  It is assumed that the amount of memory pointed by  membuf  has at least  OS_MEMPOOL_BYTES(blocks, block_size)  number of bytes.  name  is not copied, so caller should make sure that the memory does not get reused.", 
            "title": " os_mempool_init"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_mempool_init/#arguments", 
            "text": "Arguments  Description      mp  Memory pool being initialized    blocks  Number of elements in the pool    block_size  Minimum size of an individual element in pool    membuf  Backing store for the memory pool elements    name  Name of the memory pool", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_mempool_init/#returned-values", 
            "text": "OS_OK: operation was successful. \nOS_INVALID_PARAM: invalid parameters. Block count or block size was negative, or membuf or mp was NULL. \nOS_MEM_NOT_ALIGNED: membuf was not aligned on correct byte boundary.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_mempool_init/#notes", 
            "text": "Note that os_mempool_init() does not allocate backing storage;  membuf  has to be allocated by the caller.  It's recommended that you use  OS_MEMPOOL_BYTES()  or  OS_MEMPOOL_SIZE()  to figure out how much memory to allocate for the pool.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_mempool_init/#example", 
            "text": "void   *nffs_file_mem ;\n\n     nffs_file_mem   =   malloc ( OS_MEMPOOL_BYTES ( nffs_config . nc_num_files ,  sizeof  ( struct   nffs_file )));\n\n     rc   =   os_mempool_init ( nffs_file_pool ,  nffs_config . nc_num_files ,\n                          sizeof  ( struct   nffs_file ),  nffs_file_mem ,\n                          nffs_file_pool );\n     if  ( rc   !=   0 ) {\n         /* Memory pool initialization failure */ \n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_memblock_put/", 
            "text": "os_memblock_put\n\n\nos_error_t\n \nos_memblock_put\n(\nstruct\n \nos_mempool\n \n*mp\n, \nvoid\n \n*block_addr\n)\n\n\n\n\n\nReleases previously allocated element back to the pool.  \n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmp\n\n\nPointer to memory pool from which block was allocated\n\n\n\n\n\n\nblock_addr\n\n\nPointer to element getting freed\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_OK: operation was a success:\n\nOS_INVALID_PARAM: If either mp or block_addr were NULL, or the block being freed was outside the range of the memory buffer or not on a true block size boundary.\n\n\n\n\nExample\n\n\n\n\n    \nif\n (\nfile\n \n!=\n \nNULL\n) {\n        \nrc\n \n=\n \nos_memblock_put\n(\nnffs_file_pool\n, \nfile\n);\n        \nif\n (\nrc\n \n!=\n \n0\n) {\n            \n/* Error freeing memory block */\n\n        }\n    }", 
            "title": "os_memblock_put"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_memblock_put/#os_memblock_put", 
            "text": "os_error_t   os_memblock_put ( struct   os_mempool   *mp ,  void   *block_addr )  Releases previously allocated element back to the pool.", 
            "title": "os_memblock_put"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_memblock_put/#arguments", 
            "text": "Arguments  Description      mp  Pointer to memory pool from which block was allocated    block_addr  Pointer to element getting freed", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_memblock_put/#returned-values", 
            "text": "OS_OK: operation was a success: \nOS_INVALID_PARAM: If either mp or block_addr were NULL, or the block being freed was outside the range of the memory buffer or not on a true block size boundary.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/memory_pool/os_memblock_put/#example", 
            "text": "if  ( file   !=   NULL ) {\n         rc   =   os_memblock_put ( nffs_file_pool ,  file );\n         if  ( rc   !=   0 ) {\n             /* Error freeing memory block */ \n        }\n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/memory_pool/OS_MEMPOOL_BYTES/", 
            "text": "OS_MEMPOOL_BYTES\n\n\nOS_MEMPOOL_BYTES\n(\nn\n,\nblksize\n)\n\n\n\n\n\nCalculates how many bytes of memory is used by \nn\n number of elements, when individual element size is \nblksize\n bytes.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nNumber of elements\n\n\n\n\n\n\nblksize\n\n\nSize of an element is number of bytes\n\n\n\n\n\n\n\n\nReturned values\n\n\nThe number of bytes used by the memory pool.\n\n\n\n\nNotes\n\n\nOS_MEMPOOL_BYTES is a macro and not a function.\n\n\n\n\nExample\n\n\nHere we allocate memory to be used as a pool.\n\n\n    \nvoid\n \n*nffs_file_mem\n;\n\n    \nnffs_file_mem\n \n=\n \nmalloc\n(\nOS_MEMPOOL_BYTES\n(\nnffs_config\n.\nnc_num_files\n, \nsizeof\n (\nstruct\n \nnffs_file\n)));\n    \nif\n (\nnffs_file_mem\n \n==\n \nNULL\n) {\n        \nreturn\n \nFS_ENOMEM\n;\n    }", 
            "title": "OS_MEMPOOL_BYTES"
        }, 
        {
            "location": "/os/core_os/memory_pool/OS_MEMPOOL_BYTES/#os_mempool_bytes", 
            "text": "OS_MEMPOOL_BYTES ( n , blksize )  Calculates how many bytes of memory is used by  n  number of elements, when individual element size is  blksize  bytes.", 
            "title": "OS_MEMPOOL_BYTES"
        }, 
        {
            "location": "/os/core_os/memory_pool/OS_MEMPOOL_BYTES/#arguments", 
            "text": "Arguments  Description      n  Number of elements    blksize  Size of an element is number of bytes", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/memory_pool/OS_MEMPOOL_BYTES/#returned-values", 
            "text": "The number of bytes used by the memory pool.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/memory_pool/OS_MEMPOOL_BYTES/#notes", 
            "text": "OS_MEMPOOL_BYTES is a macro and not a function.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/memory_pool/OS_MEMPOOL_BYTES/#example", 
            "text": "Here we allocate memory to be used as a pool.       void   *nffs_file_mem ;\n\n     nffs_file_mem   =   malloc ( OS_MEMPOOL_BYTES ( nffs_config . nc_num_files ,  sizeof  ( struct   nffs_file )));\n     if  ( nffs_file_mem   ==   NULL ) {\n         return   FS_ENOMEM ;\n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/memory_pool/OS_MEMPOOL_SIZE/", 
            "text": "OS_MEMPOOL_SIZE\n\n\nOS_MEMPOOL_SIZE\n(\nn\n,\nblksize\n)\n\n\n\n\n\nCalculates the number of os_membuf_t elements used by \nn\n blocks of size \nblksize\n bytes.\n\n\nNote that os_membuf_t is used so that memory blocks are aligned on OS_ALIGNMENT boundaries.\n\n\nThe \nblksize\n variable is the minimum number of bytes required for each block; the actual block size is padded so that each block is aligned on OS_ALIGNMENT boundaries.  \n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nNumber of elements\n\n\n\n\n\n\nblksize\n\n\nSize of an element is number of bytes\n\n\n\n\n\n\n\n\nReturned values\n\n\nThe number of os_membuf_t elements used by the memory pool. Note that os_membuf_t is defined to be a unsigned, 32-bit integer when OS_ALIGNMENT is 4 and an unsigned, 64-bit integer when OS_ALIGNMENT is 8.\n\n\n\n\nNotes\n\n\nOS_MEMPOOL_SIZE is a macro and not a function.\n\n\n\n\nExample\n\n\nHere we define a memory buffer to be used by a memory pool using OS_MEMPOOL_SIZE\n\n\n#define NUM_BLOCKS      (16)\n\n\n#define BLOCK_SIZE      (32)\n\n\n\nos_membuf_t\n \nmy_pool_memory\n[\nOS_MEMPOOL_SIZE\n(\nNUM_BLOCKS\n, \nBLOCK_SIZE\n)]", 
            "title": "OS_MEMPOOL_SIZE"
        }, 
        {
            "location": "/os/core_os/memory_pool/OS_MEMPOOL_SIZE/#os_mempool_size", 
            "text": "OS_MEMPOOL_SIZE ( n , blksize )  Calculates the number of os_membuf_t elements used by  n  blocks of size  blksize  bytes.  Note that os_membuf_t is used so that memory blocks are aligned on OS_ALIGNMENT boundaries.  The  blksize  variable is the minimum number of bytes required for each block; the actual block size is padded so that each block is aligned on OS_ALIGNMENT boundaries.", 
            "title": "OS_MEMPOOL_SIZE"
        }, 
        {
            "location": "/os/core_os/memory_pool/OS_MEMPOOL_SIZE/#arguments", 
            "text": "Arguments  Description      n  Number of elements    blksize  Size of an element is number of bytes", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/memory_pool/OS_MEMPOOL_SIZE/#returned-values", 
            "text": "The number of os_membuf_t elements used by the memory pool. Note that os_membuf_t is defined to be a unsigned, 32-bit integer when OS_ALIGNMENT is 4 and an unsigned, 64-bit integer when OS_ALIGNMENT is 8.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/memory_pool/OS_MEMPOOL_SIZE/#notes", 
            "text": "OS_MEMPOOL_SIZE is a macro and not a function.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/memory_pool/OS_MEMPOOL_SIZE/#example", 
            "text": "Here we define a memory buffer to be used by a memory pool using OS_MEMPOOL_SIZE  #define NUM_BLOCKS      (16)  #define BLOCK_SIZE      (32)  os_membuf_t   my_pool_memory [ OS_MEMPOOL_SIZE ( NUM_BLOCKS ,  BLOCK_SIZE )]", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/heap/heap/", 
            "text": "Heap\n\n\nAPI for doing dynamic memory allocation.\n\n\nDescription\n\n\nThis provides malloc()/free() functionality with locking.  The shared resource heap needs to be protected from concurrent access when OS has been started. \nos_malloc()\n function grabs a mutex before calling \nmalloc()\n.\n\n\nData structures\n\n\nN/A\n\n\nList of Functions\n\n\nThe functions available in heap are:\n\n\n\n\nos_free\n\n\nos_malloc\n\n\nos_realloc", 
            "title": "toc"
        }, 
        {
            "location": "/os/core_os/heap/heap/#heap", 
            "text": "API for doing dynamic memory allocation.", 
            "title": "Heap"
        }, 
        {
            "location": "/os/core_os/heap/heap/#description", 
            "text": "This provides malloc()/free() functionality with locking.  The shared resource heap needs to be protected from concurrent access when OS has been started.  os_malloc()  function grabs a mutex before calling  malloc() .", 
            "title": "Description"
        }, 
        {
            "location": "/os/core_os/heap/heap/#data-structures", 
            "text": "N/A", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/core_os/heap/heap/#list-of-functions", 
            "text": "The functions available in heap are:   os_free  os_malloc  os_realloc", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/core_os/heap/os_free/", 
            "text": "os_free\n\n\nvoid\n \nos_free\n(\nvoid\n \n*mem\n)\n\n\n\n\n\nFrees previously allocated memory back to the heap.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmem\n\n\nPointer to memory being released\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nCalls C-library \nfree()\n behind the covers.\n\n\nExample\n\n\n\n\n   \nos_free\n(\ninfo\n);", 
            "title": "os_free"
        }, 
        {
            "location": "/os/core_os/heap/os_free/#os_free", 
            "text": "void   os_free ( void   *mem )  Frees previously allocated memory back to the heap.", 
            "title": "os_free"
        }, 
        {
            "location": "/os/core_os/heap/os_free/#arguments", 
            "text": "Arguments  Description      mem  Pointer to memory being released", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/heap/os_free/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/heap/os_free/#notes", 
            "text": "Calls C-library  free()  behind the covers.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/heap/os_free/#example", 
            "text": "os_free ( info );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/heap/os_malloc/", 
            "text": "os_malloc\n\n\nvoid\n \n*os_malloc\n(\nsize_t\n \nsize\n)\n\n\n\n\n\nAllocates \nsize\n number of bytes from heap and returns a pointer to it.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsize\n\n\nNumber of bytes to allocate\n\n\n\n\n\n\n\n\nReturned values\n\n\n: pointer to memory allocated from heap.\nNULL: not enough memory available.\n\n\nNotes\n\n\nos_malloc()\n calls \nmalloc()\n, which is provided by C-library. The heap must be set up during platform initialization.\nDepending on which C-library you use, you might have to do the heap setup differently. Most often \nmalloc()\n implementation will maintain a list of allocated and then freed memory blocks. If user asks for memory which cannot be satisfied from free list, they'll call platform's \nsbrk()\n, which then tries to grow the heap.\n\n\nExample\n\n\n\n\n    \ninfo\n \n=\n (\nstruct\n \nos_task_info\n \n*\n) \nos_malloc\n(\n            \nsizeof\n(\nstruct\n \nos_task_info\n) \n*\n \ntcount\n);\n    \nif\n (\n!info\n) {\n        \nrc\n \n=\n \n-\n1\n;\n        \ngoto\n \nerr\n;\n    }", 
            "title": "os_malloc"
        }, 
        {
            "location": "/os/core_os/heap/os_malloc/#os_malloc", 
            "text": "void   *os_malloc ( size_t   size )  Allocates  size  number of bytes from heap and returns a pointer to it.", 
            "title": " os_malloc"
        }, 
        {
            "location": "/os/core_os/heap/os_malloc/#arguments", 
            "text": "Arguments  Description      size  Number of bytes to allocate", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/heap/os_malloc/#returned-values", 
            "text": ": pointer to memory allocated from heap.\nNULL: not enough memory available.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/heap/os_malloc/#notes", 
            "text": "os_malloc()  calls  malloc() , which is provided by C-library. The heap must be set up during platform initialization.\nDepending on which C-library you use, you might have to do the heap setup differently. Most often  malloc()  implementation will maintain a list of allocated and then freed memory blocks. If user asks for memory which cannot be satisfied from free list, they'll call platform's  sbrk() , which then tries to grow the heap.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/heap/os_malloc/#example", 
            "text": "info   =  ( struct   os_task_info   * )  os_malloc (\n             sizeof ( struct   os_task_info )  *   tcount );\n     if  ( !info ) {\n         rc   =   - 1 ;\n         goto   err ;\n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/heap/os_realloc/", 
            "text": "os_realloc\n\n\nvoid\n \n*os_realloc\n(\nvoid\n \n*ptr\n, \nsize_t\n \nsize\n)\n\n\n\n\n\nTries to resize previously allocated memory block, and returns pointer to resized memory.\nptr can be NULL, in which case the call is similar to calling \nos_malloc()\n.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nptr\n\n\nPointer to previously allocated memory\n\n\n\n\n\n\nsize\n\n\nNew size to adjust the memory block to\n\n\n\n\n\n\n\n\nReturned values\n\n\nNULL: size adjustment was not successful. \n\nptr: pointer to new start of memory block\n\n\nNotes\n\n\nExample\n\n\n\n\nInsert\n \nthe\n \ncode\n \nsnippet\n \nhere", 
            "title": "os_realloc"
        }, 
        {
            "location": "/os/core_os/heap/os_realloc/#os_realloc", 
            "text": "void   *os_realloc ( void   *ptr ,  size_t   size )  Tries to resize previously allocated memory block, and returns pointer to resized memory.\nptr can be NULL, in which case the call is similar to calling  os_malloc() .", 
            "title": "os_realloc"
        }, 
        {
            "location": "/os/core_os/heap/os_realloc/#arguments", 
            "text": "Arguments  Description      ptr  Pointer to previously allocated memory    size  New size to adjust the memory block to", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/heap/os_realloc/#returned-values", 
            "text": "NULL: size adjustment was not successful.  \nptr: pointer to new start of memory block", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/heap/os_realloc/#notes", 
            "text": "", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/heap/os_realloc/#example", 
            "text": "Insert   the   code   snippet   here", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/mbuf/", 
            "text": "Mbufs\n\n\nThe mbuf (short for memory buffer) is a common concept in networking stacks. The mbuf is used to hold packet data as it traverses the stack. The mbuf also generally stores header information or other networking stack information that is carried around with the packet. The mbuf and its associated library of functions were developed to make common networking stack operations (like stripping and adding protocol headers) efficient and as copy-free as possible.\n\n\nIn its simplest form, an mbuf is a memory block with some space reserved for internal information and a pointer which is used to \"chain\" memory blocks together in order to create a \"packet\". This is a very important aspect of the mbuf: the ability to chain mbufs together to create larger \"packets\" (chains of mbufs).\n\n\nWhy use mbufs?\n\n\nThe main reason is to conserve memory. Consider a networking protocol that generally sends small packets but occasionally sends large ones. The Bluetooth Low Energy (BLE) protocol is one such example. A flat buffer would need to be sized so that the maximum packet size could be contained by the buffer. With the mbuf, a number of mbufs can be chained together so that the occasional large packet can be handled while leaving more packet buffers available to the networking stack for smaller packets.\n\n\nPacket Header mbuf\n\n\nNot all mbufs are created equal. The first mbuf in a chain of mbufs is a special mbuf called a \"packet header mbuf\". The reason that this mbuf is special is that it contains the length of all the data contained by the chain of mbufs (the packet length, in other words). The packet header mbuf may also contain a user defined structure (called a \"user header\") so that networking protocol specific information can be conveyed to various layers of the networking stack. Any mbufs that are part of the packet (i.e. in the mbuf chain but not the first one) are \"normal\" (i.e. non-packet header) mbufs. A normal mbuf does not have any packet header or user packet header structures in them; they only contain the basic mbuf header (\nstruct os_mbuf\n). Figure 1 illustrates these two types of mbufs. Note that the numbers/text in parentheses denote the size of the structures/elements (in bytes) and that MBLEN is the memory block length of the memory pool used by the mbuf pool.\n\n\n\n\nNormal mbuf\n\n\nNow let's take a deeper dive into the mbuf structure. Figure 2 illustrates a normal mbuf and breaks out the various fields in the \nos_mbuf\n structure. \n\n\n\n\nThe \nom_data\n field is a pointer to where the data starts inside the data buffer. Typically, mbufs that are allocated from the mbuf pool (discussed later) have their om_data pointer set to the start of the data buffer but there are cases where this may not be desirable (added a protocol header to a packet, for example). \n\n\nThe \nom_flags\n field is a set of flags used internally by the mbuf library. Currently, no flags have been defined. \n\n\nThe \nom_pkthdr_len\n field is the total length of all packet headers in the mbuf. For normal mbufs this is set to 0 as there is no packet or user packet headers. For packet header mbufs, this would be set to the length of the packet header structure (16) plus the size of the user packet header (if any). Note that it is this field which differentiates packet header mbufs from normal mbufs (i.e. if \nom_pkthdr_len\n is zero, this is a normal mbuf; otherwise it is a packet header mbuf). \n\n\nThe \nom_len\n field contains the amount of user data in the data buffer. When initially allocated, this field is 0 as there is no user data in the mbuf. \n\n\nThe \nomp_pool\n field is a pointer to the pool from which this mbuf has been allocated. This is used internally by the mbuf library. \n\n\nThe \nomp_next\n field is a linked list element which is used to chain mbufs.\n\n\n\n\nFigure 2 also shows a normal mbuf with actual values in the \nos_mbuf\n structure. This mbuf starts at address 0x1000 and is 256 bytes in total length. In this example, the user has copied 33 bytes into the data buffer starting at address 0x1010 (this is where om_data points). Note that the packet header length in this mbuf is 0 as it is not a packet header mbuf.\n\n\n\n\nFigure 3 illustrates the packet header mbuf along with some chained mbufs (i.e a \"packet\"). In this example, the user header structure is defined to be 8 bytes. Note that in figure 3 we show a number of different mbufs with varying \nom_data\n pointers and lengths since we want to show various examples of valid mbufs. For all the mbufs (both packet header and normal ones) the total length of the memory block is 128 bytes.\n\n\n\n\nMbuf pools\n\n\nMbufs are collected into \"mbuf pools\" much like memory blocks. The mbuf pool itself contains a pointer to a memory pool. The memory blocks in this memory pool are the actual mbufs; both normal and packet header mbufs. Thus, the memory block (and corresponding memory pool) must be sized correctly. In other words, the memory blocks which make up the memory pool used by the mbuf pool must be at least: sizeof(struct os_mbuf) + sizeof(struct os_mbuf_pkthdr) + sizeof(struct user_defined_header) + desired minimum data buffer length. For example, if the developer wants mbufs to contain at least 64 bytes of user data and they have a user header of 12 bytes, the size of the memory block would be (at least): 64 + 12 + 16 + 8, or 100 bytes. Yes, this is a fair amount of overhead. However, the flexibility provided by the mbuf library usually outweighs overhead concerns.\n\n\nCreate mbuf pool\n\n\nCreating an mbuf pool is fairly simple: create a memory pool and then create the mbuf pool using that memory pool. Once the developer has determined the size of the user data needed per mbuf (this is based on the application/networking stack and is outside the scope of this discussion) and the size of the user header (if any), the memory blocks can be sized. In the example shown below, the application requires 64 bytes of user data per mbuf and also allocates a user header (called struct user_hdr). Note that we do not show the user header data structure as there really is no need; all we need to do is to account for it when creating the memory pool. In the example, we use the macro \nMBUF_PKTHDR_OVERHEAD\n to denote the amount of packet header overhead per mbuf and \nMBUF_MEMBLOCK_OVERHEAD\n to denote the total amount of overhead required per memory block. The macro \nMBUF_BUF_SIZE\n is used to denote the amount of payload that the application requires (aligned on a 32-bit boundary in this case). All this leads to the total memory block size required, denoted by the macro \nMBUF_MEMBLOCK_OVERHEAD\n.\n\n\n#define MBUF_PKTHDR_OVERHEAD    sizeof(struct os_mbuf_pkthdr) + sizeof(struct user_hdr)\n\n\n#define MBUF_MEMBLOCK_OVERHEAD  sizeof(struct os_mbuf) + MBUF_PKTHDR_OVERHEAD\n\n\n\n#define MBUF_NUM_MBUFS      (32)\n\n\n#define MBUF_PAYLOAD_SIZE   (64)\n\n\n#define MBUF_BUF_SIZE       OS_ALIGN(MBUF_PAYLOAD_SIZE, 4)\n\n\n#define MBUF_MEMBLOCK_SIZE  (MBUF_BUF_SIZE + MBUF_MEMBLOCK_OVERHEAD)\n\n\n#define MBUF_MEMPOOL_SIZE   OS_MEMPOOL_SIZE(MBUF_NUM_MBUFS, MBUF_MEMBLOCK_SIZE)\n\n\n\nstruct\n \nos_mbuf_pool\n \ng_mbuf_pool\n; \n\nstruct\n \nos_mempool\n \ng_mbuf_mempool\n;\n\nos_membuf_t\n \ng_mbuf_buffer\n[\nMBUF_MEMPOOL_SIZE\n];\n\n\nvoid\n\n\ncreate_mbuf_pool\n(\nvoid\n)\n{\n    \nint\n \nrc\n;\n\n    \nrc\n \n=\n \nos_mempool_init\n(\ng_mbuf_mempool\n, \nMBUF_NUM_MBUFS\n, \n                          \nMBUF_MEMBLOCK_SIZE\n, \ng_mbuf_buffer\n[\n0\n], \nmbuf_pool\n);\n    \nassert\n(\nrc\n \n==\n \n0\n);\n\n    \nrc\n \n=\n \nos_mbuf_pool_init\n(\ng_mbuf_pool\n, \ng_mbuf_mempool\n, \nMBUF_MEMBLOCK_SIZE\n, \n                           \nMBUF_NUM_MBUFS\n);\n    \nassert\n(\nrc\n \n==\n \n0\n);\n}\n\n\n\n\n\nUsing mbufs\n\n\nThe following examples illustrate typical mbuf usage. There are two basic mbuf allocation API: \nos_mbuf_get()\n and \nos_mbuf_get_pkthdr()\n. The first API obtains a normal mbuf whereas the latter obtains a packet header mbuf. Typically, application developers use \nos_mbuf_get_pkthdr()\n and rarely, if ever, need to call \nos_mbuf_get()\n as the rest of the mbuf API (e.g. \nos_mbuf_append()\n, \nos_mbuf_copyinto()\n, etc.) typically deal with allocating and chaining mbufs. It is recommended to use the provided API to copy data into/out of mbuf chains and/or manipulate mbufs.\n\n\nIn \nexample1\n, the developer creates a packet and then sends the packet to a networking interface. The code sample also provides an example of copying data out of an mbuf as well as use of the \"pullup\" api (another very common mbuf api).\n\n\nvoid\n\n\nmbuf_usage_example1\n(\nuint8_t\n \n*mydata\n, \nint\n \nmydata_length\n)\n{\n    \nint\n \nrc\n;\n    \nstruct\n \nos_mbuf\n \n*om\n;\n\n    \n/* get a packet header mbuf */\n\n    \nom\n \n=\n \nos_mbuf_get_pkthdr\n(\ng_mbuf_pool\n, \nsizeof\n(\nstruct\n \nuser_hdr\n));\n    \nif\n (\nom\n) {\n        \n/* \n\n\n         * Copy user data into mbuf. NOTE: if mydata_length is greater than the\n\n\n         * mbuf payload size (64 bytes using above example), mbufs are allocated\n\n\n         * and chained together to accommodate the total packet length.\n\n\n         */\n\n        \nrc\n \n=\n \nos_mbuf_copyinto\n(\nom\n, \n0\n, \nmydata\n, \nlen\n);\n        \nif\n (\nrc\n) {\n            \n/* Error! Could not allocate enough mbufs for total packet length */\n\n            \nreturn\n \n-\n1\n;\n        }\n\n        \n/* Send packet to networking interface */\n\n        \nsend_pkt\n(\nom\n);\n    }\n}\n\n\n\n\n\nIn \nexample2\n we show use of the pullup api as this illustrates some of the typical pitfalls developers encounter when using mbufs. The first pitfall is one of alignment/padding. Depending on the processor and/or compiler, the sizeof() a structure may vary. Thus, the size of \nmy_protocol_header\n may be different inside the packet data of the mbuf than the size of the structure on the stack or as a global variable, for instance. While some networking protcols may align protocol information on convenient processor boundaries many others try to conserve bytes \"on the air\" (i.e inside the packet data). Typical methods used to deal with this are \"packing\" the structure (i.e. force compiler to not pad) or creating protocol headers that do not require padding. \nexample2\n assumes that one of these methods was used when defining the \nmy_protocol_header\n structure.\n\n\nAnother common pitfall occurs around endianness. A network protocol may be little endian or big endian; it all depends on the protocol specification. Processors also have an endianness; this means that the developer has to be careful that the processor endianness and the protocol endianness are handled correctly. In \nexample2\n, some common networking functions are used: \nntohs()\n and \nntohl()\n. These are shorthand for \"network order to host order, short\" and \"network order to host order, long\". Basically, these functions convert data of a certain size (i.e. 16 bits, 32 bits, etc) to the endianness of the host. Network byte order is big-endian (most significant byte first), so these functions convert big-endian byte order to host order (thus, the implementation of these functions is host dependent). Note that the BLE networking stack \"on the air\" format is least signigicant byte first (i.e. little endian), so a \"bletoh\" function would have to take little endian format and convert to host format.\n\n\nA long story short: the developer must take care when copying structure data to/from mbufs and flat buffers!\n\n\nA final note: these examples assume the same mbuf struture and definitions used in the first example. \n\n\nvoid\n\n\nmbuf_usage_example2\n(\nstruct\n \nmbuf\n \n*rxpkt\n)\n{\n    \nint\n \nrc\n;\n    \nuint8_t\n \npacket_data\n[\n16\n];\n    \nstruct\n \nmbuf\n \n*om\n;\n    \nstruct\n \nmy_protocol_header\n \n*phdr\n;\n\n    \n/* Make sure that \nmy_protocol_header\n bytes are contiguous in mbuf */\n\n    \nom\n \n=\n \nos_mbuf_pullup\n(\ng_mbuf_pool\n, \nsizeof\n(\nstruct\n \nmy_protocol_header\n));\n    \nif\n (\n!om\n) {\n        \n/* Not able to pull up data into contiguous area */\n\n        \nreturn\n \n-\n1\n;\n    }\n\n    \n/* \n\n\n     * Get the protocol information from the packet. In this example we presume that we\n\n\n     * are interested in protocol types that are equal to MY_PROTOCOL_TYPE, are not zero\n\n\n     * length, and have had some time in flight.\n\n\n     */\n\n    \nphdr\n \n=\n \nOS_MBUF_DATA\n(\nom\n, \nstruct\n \nmy_protocol_header\n \n*\n);\n    \ntype\n \n=\n \nntohs\n(\nphdr-\nprot_type\n);\n    \nlength\n \n=\n \nntohs\n(\nphdr-\nprot_length\n);\n    \ntime_in_flight\n \n=\n \nntohl\n(\nphdr-\nprot_tif\n);\n\n    \nif\n ((\ntype\n \n==\n \nMY_PROTOCOL_TYPE\n) \n (\nlength\n \n \n0\n) \n (\ntime_in_flight\n \n \n0\n)) {\n        \nrc\n \n=\n \nos_mbuf_copydata\n(\nrxpkt\n, \nsizeof\n(\nstruct\n \nmy_protocol_header\n), \n16\n, \npacket_data\n);\n        \nif\n (\n!rc\n) {\n            \n/* Success! Perform operations on packet data */\n\n            \n... \nuser\n \ncode\n \nhere\n ...\n\n        }\n    }\n\n    \n/* Free passed in packet (mbuf chain) since we dont need it anymore */\n\n    \nos_mbuf_free_chain\n(\nom\n);\n}\n\n\n\n\n\n\n\nData Structures\n\n\nstruct\n \nos_mbuf_pool\n {\n    \nuint16_t\n \nomp_databuf_len\n;\n    \nuint16_t\n \nomp_mbuf_count\n;\n    \nstruct\n \nos_mempool\n \n*omp_pool\n;\n    \nSTAILQ_ENTRY\n(\nos_mbuf_pool\n) \nomp_next\n;\n};\n\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nomp_databuf_len\n\n\nThe length, in bytes, of the \"data buffer\" of the mbuf. The data buffer of the mbuf is everything except the os_mbuf structure (which is present in all types of mbufs)\n\n\n\n\n\n\nomp_mbuf_count\n\n\nTotal number of mbufs in the pool when allocated. This is NOT the number of free mbufs in the pool!\n\n\n\n\n\n\nomp_pool\n\n\nThe memory pool from which the mbufs are allocated\n\n\n\n\n\n\nomp_next\n\n\nThis is a linked list pointer which chains memory pools. It is used by the system memory pool library\n\n\n\n\n\n\n\n\n\n\nstruct\n \nos_mbuf_pkthdr\n {\n    \nuint16_t\n \nomp_len\n;\n    \nuint16_t\n \nomp_flags\n;\n    \nSTAILQ_ENTRY\n(\nos_mbuf_pkthdr\n) \nomp_next\n;\n};\n\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nomp_len\n\n\nLength, in bytes, of the \"packet\". This is the sum of the user data in all the mbufs chained to the packet header mbuf (including the packet header mbuf)\n\n\n\n\n\n\nomp_flags\n\n\nPacket header flags.\n\n\n\n\n\n\nomp_next\n\n\nLinked list pointer to chain \"packets\". This can be used to add mbuf chains to a queue or linked list and is there for convenience.\n\n\n\n\n\n\n\n\n\n\nstruct\n \nos_mbuf\n {\n    \nuint8_t\n \n*om_data\n;\n    \nuint8_t\n \nom_flags\n;\n    \nuint8_t\n \nom_pkthdr_len\n;\n    \nuint16_t\n \nom_len\n;\n    \nstruct\n \nos_mbuf_pool\n \n*om_omp\n;\n    \nSLIST_ENTRY\n(\nos_mbuf\n) \nom_next\n;\n    \nuint8_t\n \nom_databuf\n[\n0\n];\n};\n\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nom_data\n\n\nPointer to start of user data in mbuf data buffer\n\n\n\n\n\n\nom_flags\n\n\nmbuf flags field. Currently all flags unused.\n\n\n\n\n\n\nom_pkthdr_len\n\n\nThe total length of all packet headers in the mbuf (mbuf packet header plus user packet header), in bytes\n\n\n\n\n\n\nom_len\n\n\nThe length of the user data contained in this mbuf, in bytes\n\n\n\n\n\n\nom_omp\n\n\nMemory pool pointer. This is the mbuf pool from which this mbuf was allocated.\n\n\n\n\n\n\nom_next\n\n\nPointer to next mbuf in packet chain\n\n\n\n\n\n\nom_databuf\n\n\nmbuf data buffer (accessor to start of mbuf data buffer). Note that the mbuf data buffer refers to the start of either the user data in normal mbufs or the start of the os mbuf packet header for packet header mbufs\n\n\n\n\n\n\n\n\nList of Functions/Macros\n\n\nThe functions/macros available in mbuf are:\n\n\n\n\nOS_MBUF_PKTHDR\n\n\nOS_MBUF_PKTHDR_TO_MBUF\n\n\nOS_MBUF_PKTLEN\n\n\nOS_MBUF_DATA\n\n\nOS_MBUF_USRHDR\n\n\nOS_MBUF_USRHDR_LEN\n\n\nOS_MBUF_LEADINGSPACE\n\n\nOS_MBUF_TRAILINGSPACE\n\n\nos_mbuf_adj\n\n\nos_mbuf_append\n\n\nos_mbuf_concat\n\n\nos_mbuf_copydata\n\n\nos_mbuf_copyinto\n\n\nos_mbuf_dup\n\n\nos_mbuf_extend\n\n\nos_mbuf_free_chain\n\n\nos_mbuf_get\n\n\nos_mbuf_get_pkthdr\n\n\nos_mbuf_memcmp\n\n\nos_mbuf_off\n\n\nos_mbuf_pool_init\n\n\nos_mbuf_prepend\n\n\nos_mbuf_pullup", 
            "title": "toc"
        }, 
        {
            "location": "/os/core_os/mbuf/mbuf/#mbufs", 
            "text": "The mbuf (short for memory buffer) is a common concept in networking stacks. The mbuf is used to hold packet data as it traverses the stack. The mbuf also generally stores header information or other networking stack information that is carried around with the packet. The mbuf and its associated library of functions were developed to make common networking stack operations (like stripping and adding protocol headers) efficient and as copy-free as possible.  In its simplest form, an mbuf is a memory block with some space reserved for internal information and a pointer which is used to \"chain\" memory blocks together in order to create a \"packet\". This is a very important aspect of the mbuf: the ability to chain mbufs together to create larger \"packets\" (chains of mbufs).", 
            "title": "Mbufs"
        }, 
        {
            "location": "/os/core_os/mbuf/mbuf/#why-use-mbufs", 
            "text": "The main reason is to conserve memory. Consider a networking protocol that generally sends small packets but occasionally sends large ones. The Bluetooth Low Energy (BLE) protocol is one such example. A flat buffer would need to be sized so that the maximum packet size could be contained by the buffer. With the mbuf, a number of mbufs can be chained together so that the occasional large packet can be handled while leaving more packet buffers available to the networking stack for smaller packets.", 
            "title": "Why use mbufs?"
        }, 
        {
            "location": "/os/core_os/mbuf/mbuf/#packet-header-mbuf", 
            "text": "Not all mbufs are created equal. The first mbuf in a chain of mbufs is a special mbuf called a \"packet header mbuf\". The reason that this mbuf is special is that it contains the length of all the data contained by the chain of mbufs (the packet length, in other words). The packet header mbuf may also contain a user defined structure (called a \"user header\") so that networking protocol specific information can be conveyed to various layers of the networking stack. Any mbufs that are part of the packet (i.e. in the mbuf chain but not the first one) are \"normal\" (i.e. non-packet header) mbufs. A normal mbuf does not have any packet header or user packet header structures in them; they only contain the basic mbuf header ( struct os_mbuf ). Figure 1 illustrates these two types of mbufs. Note that the numbers/text in parentheses denote the size of the structures/elements (in bytes) and that MBLEN is the memory block length of the memory pool used by the mbuf pool.", 
            "title": "Packet Header mbuf"
        }, 
        {
            "location": "/os/core_os/mbuf/mbuf/#normal-mbuf", 
            "text": "Now let's take a deeper dive into the mbuf structure. Figure 2 illustrates a normal mbuf and breaks out the various fields in the  os_mbuf  structure.    The  om_data  field is a pointer to where the data starts inside the data buffer. Typically, mbufs that are allocated from the mbuf pool (discussed later) have their om_data pointer set to the start of the data buffer but there are cases where this may not be desirable (added a protocol header to a packet, for example).   The  om_flags  field is a set of flags used internally by the mbuf library. Currently, no flags have been defined.   The  om_pkthdr_len  field is the total length of all packet headers in the mbuf. For normal mbufs this is set to 0 as there is no packet or user packet headers. For packet header mbufs, this would be set to the length of the packet header structure (16) plus the size of the user packet header (if any). Note that it is this field which differentiates packet header mbufs from normal mbufs (i.e. if  om_pkthdr_len  is zero, this is a normal mbuf; otherwise it is a packet header mbuf).   The  om_len  field contains the amount of user data in the data buffer. When initially allocated, this field is 0 as there is no user data in the mbuf.   The  omp_pool  field is a pointer to the pool from which this mbuf has been allocated. This is used internally by the mbuf library.   The  omp_next  field is a linked list element which is used to chain mbufs.   Figure 2 also shows a normal mbuf with actual values in the  os_mbuf  structure. This mbuf starts at address 0x1000 and is 256 bytes in total length. In this example, the user has copied 33 bytes into the data buffer starting at address 0x1010 (this is where om_data points). Note that the packet header length in this mbuf is 0 as it is not a packet header mbuf.   Figure 3 illustrates the packet header mbuf along with some chained mbufs (i.e a \"packet\"). In this example, the user header structure is defined to be 8 bytes. Note that in figure 3 we show a number of different mbufs with varying  om_data  pointers and lengths since we want to show various examples of valid mbufs. For all the mbufs (both packet header and normal ones) the total length of the memory block is 128 bytes.", 
            "title": "Normal mbuf"
        }, 
        {
            "location": "/os/core_os/mbuf/mbuf/#mbuf-pools", 
            "text": "Mbufs are collected into \"mbuf pools\" much like memory blocks. The mbuf pool itself contains a pointer to a memory pool. The memory blocks in this memory pool are the actual mbufs; both normal and packet header mbufs. Thus, the memory block (and corresponding memory pool) must be sized correctly. In other words, the memory blocks which make up the memory pool used by the mbuf pool must be at least: sizeof(struct os_mbuf) + sizeof(struct os_mbuf_pkthdr) + sizeof(struct user_defined_header) + desired minimum data buffer length. For example, if the developer wants mbufs to contain at least 64 bytes of user data and they have a user header of 12 bytes, the size of the memory block would be (at least): 64 + 12 + 16 + 8, or 100 bytes. Yes, this is a fair amount of overhead. However, the flexibility provided by the mbuf library usually outweighs overhead concerns.", 
            "title": "Mbuf pools"
        }, 
        {
            "location": "/os/core_os/mbuf/mbuf/#create-mbuf-pool", 
            "text": "Creating an mbuf pool is fairly simple: create a memory pool and then create the mbuf pool using that memory pool. Once the developer has determined the size of the user data needed per mbuf (this is based on the application/networking stack and is outside the scope of this discussion) and the size of the user header (if any), the memory blocks can be sized. In the example shown below, the application requires 64 bytes of user data per mbuf and also allocates a user header (called struct user_hdr). Note that we do not show the user header data structure as there really is no need; all we need to do is to account for it when creating the memory pool. In the example, we use the macro  MBUF_PKTHDR_OVERHEAD  to denote the amount of packet header overhead per mbuf and  MBUF_MEMBLOCK_OVERHEAD  to denote the total amount of overhead required per memory block. The macro  MBUF_BUF_SIZE  is used to denote the amount of payload that the application requires (aligned on a 32-bit boundary in this case). All this leads to the total memory block size required, denoted by the macro  MBUF_MEMBLOCK_OVERHEAD .  #define MBUF_PKTHDR_OVERHEAD    sizeof(struct os_mbuf_pkthdr) + sizeof(struct user_hdr)  #define MBUF_MEMBLOCK_OVERHEAD  sizeof(struct os_mbuf) + MBUF_PKTHDR_OVERHEAD  #define MBUF_NUM_MBUFS      (32)  #define MBUF_PAYLOAD_SIZE   (64)  #define MBUF_BUF_SIZE       OS_ALIGN(MBUF_PAYLOAD_SIZE, 4)  #define MBUF_MEMBLOCK_SIZE  (MBUF_BUF_SIZE + MBUF_MEMBLOCK_OVERHEAD)  #define MBUF_MEMPOOL_SIZE   OS_MEMPOOL_SIZE(MBUF_NUM_MBUFS, MBUF_MEMBLOCK_SIZE)  struct   os_mbuf_pool   g_mbuf_pool ;  struct   os_mempool   g_mbuf_mempool ; os_membuf_t   g_mbuf_buffer [ MBUF_MEMPOOL_SIZE ]; void  create_mbuf_pool ( void )\n{\n     int   rc ;\n\n     rc   =   os_mempool_init ( g_mbuf_mempool ,  MBUF_NUM_MBUFS , \n                           MBUF_MEMBLOCK_SIZE ,  g_mbuf_buffer [ 0 ],  mbuf_pool );\n     assert ( rc   ==   0 );\n\n     rc   =   os_mbuf_pool_init ( g_mbuf_pool ,  g_mbuf_mempool ,  MBUF_MEMBLOCK_SIZE , \n                            MBUF_NUM_MBUFS );\n     assert ( rc   ==   0 );\n}", 
            "title": "Create mbuf pool"
        }, 
        {
            "location": "/os/core_os/mbuf/mbuf/#using-mbufs", 
            "text": "The following examples illustrate typical mbuf usage. There are two basic mbuf allocation API:  os_mbuf_get()  and  os_mbuf_get_pkthdr() . The first API obtains a normal mbuf whereas the latter obtains a packet header mbuf. Typically, application developers use  os_mbuf_get_pkthdr()  and rarely, if ever, need to call  os_mbuf_get()  as the rest of the mbuf API (e.g.  os_mbuf_append() ,  os_mbuf_copyinto() , etc.) typically deal with allocating and chaining mbufs. It is recommended to use the provided API to copy data into/out of mbuf chains and/or manipulate mbufs.  In  example1 , the developer creates a packet and then sends the packet to a networking interface. The code sample also provides an example of copying data out of an mbuf as well as use of the \"pullup\" api (another very common mbuf api).  void  mbuf_usage_example1 ( uint8_t   *mydata ,  int   mydata_length )\n{\n     int   rc ;\n     struct   os_mbuf   *om ;\n\n     /* get a packet header mbuf */ \n     om   =   os_mbuf_get_pkthdr ( g_mbuf_pool ,  sizeof ( struct   user_hdr ));\n     if  ( om ) {\n         /*            * Copy user data into mbuf. NOTE: if mydata_length is greater than the           * mbuf payload size (64 bytes using above example), mbufs are allocated           * and chained together to accommodate the total packet length.           */ \n         rc   =   os_mbuf_copyinto ( om ,  0 ,  mydata ,  len );\n         if  ( rc ) {\n             /* Error! Could not allocate enough mbufs for total packet length */ \n             return   - 1 ;\n        }\n\n         /* Send packet to networking interface */ \n         send_pkt ( om );\n    }\n}  In  example2  we show use of the pullup api as this illustrates some of the typical pitfalls developers encounter when using mbufs. The first pitfall is one of alignment/padding. Depending on the processor and/or compiler, the sizeof() a structure may vary. Thus, the size of  my_protocol_header  may be different inside the packet data of the mbuf than the size of the structure on the stack or as a global variable, for instance. While some networking protcols may align protocol information on convenient processor boundaries many others try to conserve bytes \"on the air\" (i.e inside the packet data). Typical methods used to deal with this are \"packing\" the structure (i.e. force compiler to not pad) or creating protocol headers that do not require padding.  example2  assumes that one of these methods was used when defining the  my_protocol_header  structure.  Another common pitfall occurs around endianness. A network protocol may be little endian or big endian; it all depends on the protocol specification. Processors also have an endianness; this means that the developer has to be careful that the processor endianness and the protocol endianness are handled correctly. In  example2 , some common networking functions are used:  ntohs()  and  ntohl() . These are shorthand for \"network order to host order, short\" and \"network order to host order, long\". Basically, these functions convert data of a certain size (i.e. 16 bits, 32 bits, etc) to the endianness of the host. Network byte order is big-endian (most significant byte first), so these functions convert big-endian byte order to host order (thus, the implementation of these functions is host dependent). Note that the BLE networking stack \"on the air\" format is least signigicant byte first (i.e. little endian), so a \"bletoh\" function would have to take little endian format and convert to host format.  A long story short: the developer must take care when copying structure data to/from mbufs and flat buffers!  A final note: these examples assume the same mbuf struture and definitions used in the first example.   void  mbuf_usage_example2 ( struct   mbuf   *rxpkt )\n{\n     int   rc ;\n     uint8_t   packet_data [ 16 ];\n     struct   mbuf   *om ;\n     struct   my_protocol_header   *phdr ;\n\n     /* Make sure that  my_protocol_header  bytes are contiguous in mbuf */ \n     om   =   os_mbuf_pullup ( g_mbuf_pool ,  sizeof ( struct   my_protocol_header ));\n     if  ( !om ) {\n         /* Not able to pull up data into contiguous area */ \n         return   - 1 ;\n    }\n\n     /*        * Get the protocol information from the packet. In this example we presume that we       * are interested in protocol types that are equal to MY_PROTOCOL_TYPE, are not zero       * length, and have had some time in flight.       */ \n     phdr   =   OS_MBUF_DATA ( om ,  struct   my_protocol_header   * );\n     type   =   ntohs ( phdr- prot_type );\n     length   =   ntohs ( phdr- prot_length );\n     time_in_flight   =   ntohl ( phdr- prot_tif );\n\n     if  (( type   ==   MY_PROTOCOL_TYPE )   ( length     0 )   ( time_in_flight     0 )) {\n         rc   =   os_mbuf_copydata ( rxpkt ,  sizeof ( struct   my_protocol_header ),  16 ,  packet_data );\n         if  ( !rc ) {\n             /* Success! Perform operations on packet data */ \n             ...  user   code   here  ... \n        }\n    }\n\n     /* Free passed in packet (mbuf chain) since we dont need it anymore */ \n     os_mbuf_free_chain ( om );\n}", 
            "title": "Using mbufs"
        }, 
        {
            "location": "/os/core_os/mbuf/mbuf/#data-structures", 
            "text": "struct   os_mbuf_pool  {\n     uint16_t   omp_databuf_len ;\n     uint16_t   omp_mbuf_count ;\n     struct   os_mempool   *omp_pool ;\n     STAILQ_ENTRY ( os_mbuf_pool )  omp_next ;\n};     Element  Description      omp_databuf_len  The length, in bytes, of the \"data buffer\" of the mbuf. The data buffer of the mbuf is everything except the os_mbuf structure (which is present in all types of mbufs)    omp_mbuf_count  Total number of mbufs in the pool when allocated. This is NOT the number of free mbufs in the pool!    omp_pool  The memory pool from which the mbufs are allocated    omp_next  This is a linked list pointer which chains memory pools. It is used by the system memory pool library      struct   os_mbuf_pkthdr  {\n     uint16_t   omp_len ;\n     uint16_t   omp_flags ;\n     STAILQ_ENTRY ( os_mbuf_pkthdr )  omp_next ;\n};     Element  Description      omp_len  Length, in bytes, of the \"packet\". This is the sum of the user data in all the mbufs chained to the packet header mbuf (including the packet header mbuf)    omp_flags  Packet header flags.    omp_next  Linked list pointer to chain \"packets\". This can be used to add mbuf chains to a queue or linked list and is there for convenience.      struct   os_mbuf  {\n     uint8_t   *om_data ;\n     uint8_t   om_flags ;\n     uint8_t   om_pkthdr_len ;\n     uint16_t   om_len ;\n     struct   os_mbuf_pool   *om_omp ;\n     SLIST_ENTRY ( os_mbuf )  om_next ;\n     uint8_t   om_databuf [ 0 ];\n};     Element  Description      om_data  Pointer to start of user data in mbuf data buffer    om_flags  mbuf flags field. Currently all flags unused.    om_pkthdr_len  The total length of all packet headers in the mbuf (mbuf packet header plus user packet header), in bytes    om_len  The length of the user data contained in this mbuf, in bytes    om_omp  Memory pool pointer. This is the mbuf pool from which this mbuf was allocated.    om_next  Pointer to next mbuf in packet chain    om_databuf  mbuf data buffer (accessor to start of mbuf data buffer). Note that the mbuf data buffer refers to the start of either the user data in normal mbufs or the start of the os mbuf packet header for packet header mbufs", 
            "title": "Data Structures"
        }, 
        {
            "location": "/os/core_os/mbuf/mbuf/#list-of-functionsmacros", 
            "text": "The functions/macros available in mbuf are:   OS_MBUF_PKTHDR  OS_MBUF_PKTHDR_TO_MBUF  OS_MBUF_PKTLEN  OS_MBUF_DATA  OS_MBUF_USRHDR  OS_MBUF_USRHDR_LEN  OS_MBUF_LEADINGSPACE  OS_MBUF_TRAILINGSPACE  os_mbuf_adj  os_mbuf_append  os_mbuf_concat  os_mbuf_copydata  os_mbuf_copyinto  os_mbuf_dup  os_mbuf_extend  os_mbuf_free_chain  os_mbuf_get  os_mbuf_get_pkthdr  os_mbuf_memcmp  os_mbuf_off  os_mbuf_pool_init  os_mbuf_prepend  os_mbuf_pullup", 
            "title": "List of Functions/Macros"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_PKTHDR/", 
            "text": "OS_MBUF_PKTHDR\n\n\nOS_MBUF_PKTHDR\n(\n__om\n)\n\n\n\n\n\nMacro used to get a pointer to the os mbuf packet header of an mbuf.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n__om\n\n\nPointer to mbuf (struct os_mbuf *)\n\n\n\n\n\n\n\n\n\n\nExample\n\n\nint\n\n\ndoes_packet_have_data\n(\nstruct\n \nos_mbuf\n \n*om\n)\n{\n    \nstruct\n \nos_mbuf_pkthdr\n \n*hdr\n;\n\n    \nhdr\n \n=\n \nOS_MBUF_PKTHDR\n(\nom\n);\n    \nif\n (\nhdr-\nomp_len\n \n!=\n \n0\n) {\n        \n/* Packet has data in it */\n\n        \nreturn\n \nTRUE\n\n    } \nelse\n {\n        \n/* Packet has no data */\n\n        \nreturn\n \nFALSE\n;\n    }\n}", 
            "title": "OS_MBUF_PKTHDR"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_PKTHDR/#os_mbuf_pkthdr", 
            "text": "OS_MBUF_PKTHDR ( __om )  Macro used to get a pointer to the os mbuf packet header of an mbuf.", 
            "title": "OS_MBUF_PKTHDR"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_PKTHDR/#arguments", 
            "text": "Arguments  Description      __om  Pointer to mbuf (struct os_mbuf *)", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_PKTHDR/#example", 
            "text": "int  does_packet_have_data ( struct   os_mbuf   *om )\n{\n     struct   os_mbuf_pkthdr   *hdr ;\n\n     hdr   =   OS_MBUF_PKTHDR ( om );\n     if  ( hdr- omp_len   !=   0 ) {\n         /* Packet has data in it */ \n         return   TRUE \n    }  else  {\n         /* Packet has no data */ \n         return   FALSE ;\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_PKTHDR_TO_MBUF/", 
            "text": "OS_MBUF_PKTHDR_TO_MBUF\n\n\nOS_MBUF_PKTHDR_TO_MBUF\n(\n__hdr\n)\n\n\n\n\n\nMacro used to get a pointer to the mbuf given a pointer to the os mbuf packet header\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n__hdr\n\n\nPointer to os mbuf packet header (struct os_mbuf_pkthdr *)\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n    \nstruct\n \nos_mbuf\n \n*om\n;\n    \nstruct\n \nos_mbuf_pkthdr\n \n*hdr\n;\n\n    \nom\n \n=\n \nOS_MBUF_PKTHDR_TO_MBUF\n(\nhdr\n);\n    \nos_mbuf_free_chain\n(\nom\n);", 
            "title": "OS_MBUF_PKTHDR_TO_MBUF"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_PKTHDR_TO_MBUF/#os_mbuf_pkthdr_to_mbuf", 
            "text": "OS_MBUF_PKTHDR_TO_MBUF ( __hdr )  Macro used to get a pointer to the mbuf given a pointer to the os mbuf packet header", 
            "title": "OS_MBUF_PKTHDR_TO_MBUF"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_PKTHDR_TO_MBUF/#arguments", 
            "text": "Arguments  Description      __hdr  Pointer to os mbuf packet header (struct os_mbuf_pkthdr *)", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_PKTHDR_TO_MBUF/#example", 
            "text": "struct   os_mbuf   *om ;\n     struct   os_mbuf_pkthdr   *hdr ;\n\n     om   =   OS_MBUF_PKTHDR_TO_MBUF ( hdr );\n     os_mbuf_free_chain ( om );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_PKTLEN/", 
            "text": "OS_MBUF_PKTLEN\n\n\nOS_MBUF_PKTLEN\n(\n__om\n)\n\n\n\n\n\nMacro used to get the length of an entire mbuf chain.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n__om\n\n\nPointer to mbuf (struct os_mbuf *)\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n    \nuint16_t\n \npktlen\n;\n    \nstruct\n \nos_mbuf\n \n*om\n;\n\n    \n/* Check if there is any data in the mbuf chain */\n\n    \npktlen\n \n=\n \nOS_MBUF_PKTLEN\n(\nom\n);\n    \nif\n (\npktlen\n \n!=\n \n0\n) {\n        \n/* mbuf chain has data */\n\n    }", 
            "title": "OS_MBUF_PKTLEN"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_PKTLEN/#os_mbuf_pktlen", 
            "text": "OS_MBUF_PKTLEN ( __om )  Macro used to get the length of an entire mbuf chain.", 
            "title": "OS_MBUF_PKTLEN"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_PKTLEN/#arguments", 
            "text": "Arguments  Description      __om  Pointer to mbuf (struct os_mbuf *)", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_PKTLEN/#example", 
            "text": "uint16_t   pktlen ;\n     struct   os_mbuf   *om ;\n\n     /* Check if there is any data in the mbuf chain */ \n     pktlen   =   OS_MBUF_PKTLEN ( om );\n     if  ( pktlen   !=   0 ) {\n         /* mbuf chain has data */ \n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_DATA/", 
            "text": "OS_MBUF_DATA\n\n\nOS_MBUF_DATA\n(\n__om\n, \n__type\n)\n\n\n\n\n\nMacro used to cast the data pointer of an mbuf to a given type.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n__om\n\n\nPointer to mbuf (struct os_mbuf *)\n\n\n\n\n\n\n__type\n\n\nType to cast\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n    \nstruct\n \nos_mbuf\n \n*om\n\n    \nuint8_t\n \n*rxbuf\n;\n\n    \nrxbuf\n \n=\n \nOS_MBUF_DATA\n(\nom\n, \nuint8_t\n \n*\n);", 
            "title": "OS_MBUF_DATA"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_DATA/#os_mbuf_data", 
            "text": "OS_MBUF_DATA ( __om ,  __type )  Macro used to cast the data pointer of an mbuf to a given type.", 
            "title": "OS_MBUF_DATA"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_DATA/#arguments", 
            "text": "Arguments  Description      __om  Pointer to mbuf (struct os_mbuf *)    __type  Type to cast", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_DATA/#example", 
            "text": "struct   os_mbuf   *om \n     uint8_t   *rxbuf ;\n\n     rxbuf   =   OS_MBUF_DATA ( om ,  uint8_t   * );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_USRHDR/", 
            "text": "OS_MBUF_USRHDR\n\n\nOS_MBUF_USRHDR\n(\n__om\n)\n\n\n\n\n\nMacro used to get a pointer to the user packet header of an mbuf.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n__om\n\n\nPointer to mbuf (struct os_mbuf *). Must be head of chain (i.e. a packet header mbuf)\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n    \nstruct\n \nos_mbuf\n \n*om\n\n    \nstruct\n \nuser_header\n \n*hdr\n;\n\n    \nhdr\n \n=\n \nOS_MBUF_USRHDR\n(\nom\n);", 
            "title": "OS_MBUF_USRHDR"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_USRHDR/#os_mbuf_usrhdr", 
            "text": "OS_MBUF_USRHDR ( __om )  Macro used to get a pointer to the user packet header of an mbuf.", 
            "title": "OS_MBUF_USRHDR"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_USRHDR/#arguments", 
            "text": "Arguments  Description      __om  Pointer to mbuf (struct os_mbuf *). Must be head of chain (i.e. a packet header mbuf)", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_USRHDR/#example", 
            "text": "struct   os_mbuf   *om \n     struct   user_header   *hdr ;\n\n     hdr   =   OS_MBUF_USRHDR ( om );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_USRHDR_LEN/", 
            "text": "OS_MBUF_USRHDR_LEN\n\n\nOS_MBUF_USRHDR_LEN\n(\n__om\n)\n\n\n\n\n\nMacro used to retrieve the length of the user packet header in an mbuf.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n__om\n\n\nPointer to mbuf (struct os_mbuf *). Must be head of chain (i.e. a packet header mbuf)\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n    \nuint16_t\n \nuser_length\n;\n    \nstruct\n \nos_mbuf\n \n*om\n\n    \nstruct\n \nuser_header\n \n*hdr\n;\n\n    \nuser_length\n  \n=\n \nOS_MBUF_USRHDR_LEN\n(\nom\n);", 
            "title": "OS_MBUF_USRHDR_LEN"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_USRHDR_LEN/#os_mbuf_usrhdr_len", 
            "text": "OS_MBUF_USRHDR_LEN ( __om )  Macro used to retrieve the length of the user packet header in an mbuf.", 
            "title": "OS_MBUF_USRHDR_LEN"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_USRHDR_LEN/#arguments", 
            "text": "Arguments  Description      __om  Pointer to mbuf (struct os_mbuf *). Must be head of chain (i.e. a packet header mbuf)", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_USRHDR_LEN/#example", 
            "text": "uint16_t   user_length ;\n     struct   os_mbuf   *om \n     struct   user_header   *hdr ;\n\n     user_length    =   OS_MBUF_USRHDR_LEN ( om );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_LEADINGSPACE/", 
            "text": "OS_MBUF_LEADINGSPACE\n\n\nOS_MBUF_LEADINGSPACE\n(\n__om\n)\n\n\n\n\n\nMacro used to get the amount of leading space in an mbuf (in bytes).\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n__om\n\n\nPointer to mbuf (struct os_mbuf *)\n\n\n\n\n\n\n\n\n\n\nNotes\n\n\nThis macro works on both normal mbufs and packet header mbufs. The amount of leading space is the number of bytes between the current om_data pointer of the mbuf and the start of the mbuf user data buffer.\n\n\n\n\nExample\n\n\n    \nuint8_t\n \n*dptr\n;\n    \nuint16_t\n \nspace\n;\n    \nstruct\n \nos_mbuf\n \n*om\n;\n    \nstruct\n \nmy_data_struct\n \nmy_data\n;\n\n    \n/* Copy data from \nmy_data\n into the start of an mbuf but only if there is enough room */\n\n    \nspace\n \n=\n \nOS_MBUF_LEADINGSPACE\n(\nom\n);\n    \nif\n (\nspace\n \n=\n \nsizeof\n(\nstruct\n \nmy_data_struct\n)) {\n        \ndptr\n \n=\n \nom-\nom_data\n \n-\n \nsizeof\n(\nstruct\n \nmy_data_struct\n);\n        \nmemcpy\n(\ndptr\n, \nmy_data\n, \nsizeof\n(\nstruct\n \nmy_data_struct\n));\n    }", 
            "title": "OS_MBUF_LEADINGSPACE"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_LEADINGSPACE/#os_mbuf_leadingspace", 
            "text": "OS_MBUF_LEADINGSPACE ( __om )  Macro used to get the amount of leading space in an mbuf (in bytes).", 
            "title": "OS_MBUF_LEADINGSPACE"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_LEADINGSPACE/#arguments", 
            "text": "Arguments  Description      __om  Pointer to mbuf (struct os_mbuf *)", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_LEADINGSPACE/#notes", 
            "text": "This macro works on both normal mbufs and packet header mbufs. The amount of leading space is the number of bytes between the current om_data pointer of the mbuf and the start of the mbuf user data buffer.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_LEADINGSPACE/#example", 
            "text": "uint8_t   *dptr ;\n     uint16_t   space ;\n     struct   os_mbuf   *om ;\n     struct   my_data_struct   my_data ;\n\n     /* Copy data from  my_data  into the start of an mbuf but only if there is enough room */ \n     space   =   OS_MBUF_LEADINGSPACE ( om );\n     if  ( space   =   sizeof ( struct   my_data_struct )) {\n         dptr   =   om- om_data   -   sizeof ( struct   my_data_struct );\n         memcpy ( dptr ,  my_data ,  sizeof ( struct   my_data_struct ));\n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_TRAILINGSPACE/", 
            "text": "OS_MBUF_TRAILINGSPACE\n\n\nOS_MBUF_TRAILINGSPACE\n(\n__om\n)\n\n\n\n\n\nMacro used to get the amount of trailing space in an mbuf (in bytes).\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n__om\n\n\nPointer to mbuf (struct os_mbuf *)\n\n\n\n\n\n\n\n\n\n\nNotes\n\n\nThis macro works on both normal mbufs and packet header mbufs. The amount of trailing space is the number of bytes between the current om_data pointer of the mbuf and the end of the mbuf.\n\n\n\n\nExample\n\n\n    \nuint16_t\n \nspace\n;\n    \nstruct\n \nos_mbuf\n \n*om\n;\n    \nstruct\n \nmy_data_struct\n \nmy_data\n;\n\n    \n/* Copy data from \nmy_data\n to the end of an mbuf but only if there is enough room */\n\n    \nspace\n \n=\n \nOS_MBUF_TRAILINGSPACE\n(\nom\n);\n    \nif\n (\nspace\n \n=\n \nsizeof\n(\nstruct\n \nmy_data_struct\n)) {\n        \nmemcpy\n(\nom-\nom_data\n, \nmy_data\n, \nsizeof\n(\nstruct\n \nmy_data_struct\n));\n    }", 
            "title": "OS_MBUF_TRAILINGSPACE"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_TRAILINGSPACE/#os_mbuf_trailingspace", 
            "text": "OS_MBUF_TRAILINGSPACE ( __om )  Macro used to get the amount of trailing space in an mbuf (in bytes).", 
            "title": "OS_MBUF_TRAILINGSPACE"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_TRAILINGSPACE/#arguments", 
            "text": "Arguments  Description      __om  Pointer to mbuf (struct os_mbuf *)", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_TRAILINGSPACE/#notes", 
            "text": "This macro works on both normal mbufs and packet header mbufs. The amount of trailing space is the number of bytes between the current om_data pointer of the mbuf and the end of the mbuf.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/mbuf/OS_MBUF_TRAILINGSPACE/#example", 
            "text": "uint16_t   space ;\n     struct   os_mbuf   *om ;\n     struct   my_data_struct   my_data ;\n\n     /* Copy data from  my_data  to the end of an mbuf but only if there is enough room */ \n     space   =   OS_MBUF_TRAILINGSPACE ( om );\n     if  ( space   =   sizeof ( struct   my_data_struct )) {\n         memcpy ( om- om_data ,  my_data ,  sizeof ( struct   my_data_struct ));\n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_adj/", 
            "text": "os_mbuf_adj\n\n\nvoid\n \nos_mbuf_adj\n(\nstruct\n \nos_mbuf\n \n*mp\n, \nint\n \nreq_len\n);\n\n\n\n\n\nTrims \nreq_len\n bytes from either the head (if positive) or tail (if negative) of an mbuf chain. Adjusts the packet length of the mbuf chain if \nmp\n points to a packet header mbuf. When trimming from the head, no mbufs are freed. When trimming from the tail, any mbufs of zero length left at the end of the chain are freed.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmp\n\n\nPointer to mbuf. Can be head of a chain of mbufs, a single mbuf or a packet header mbuf\n\n\n\n\n\n\nreq_len\n\n\nNumber of bytes to trim from head or tail of mbuf\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nNone\n\n\nNotes\n\n\nExample\n\n\n    \nuint16_t\n \npktlen\n;\n    \nstruct\n \nos_mbuf\n \n*om\n;\n    \nstruct\n \nmy_pkt_header\n \nhdr\n;\n\n    \n/* Get mbuf chain length */\n\n    \npktlen\n \n=\n \nOS_MBUF_PKTLEN\n(\nom\n);\n\n    \n/* Strip header from mbuf chain */\n\n    \nos_mbuf_adj\n(\nom\n, \nsizeof\n(\nstruct\n \nmy_pkt_header\n));\n    \npktlen\n \n-=\n \nsizeof\n(\nstruct\n \nmy_pkt_header\n);\n\n    \n/* New packet length should be old packet length minus stripped header */\n\n    \nassert\n(\npktlen\n \n==\n \nOS_MBUF_PKTLEN\n(\nom\n));", 
            "title": "os_mbuf_adj"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_adj/#os_mbuf_adj", 
            "text": "void   os_mbuf_adj ( struct   os_mbuf   *mp ,  int   req_len );  Trims  req_len  bytes from either the head (if positive) or tail (if negative) of an mbuf chain. Adjusts the packet length of the mbuf chain if  mp  points to a packet header mbuf. When trimming from the head, no mbufs are freed. When trimming from the tail, any mbufs of zero length left at the end of the chain are freed.", 
            "title": " os_mbuf_adj"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_adj/#arguments", 
            "text": "Arguments  Description      mp  Pointer to mbuf. Can be head of a chain of mbufs, a single mbuf or a packet header mbuf    req_len  Number of bytes to trim from head or tail of mbuf", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_adj/#returned-values", 
            "text": "None", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_adj/#notes", 
            "text": "", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_adj/#example", 
            "text": "uint16_t   pktlen ;\n     struct   os_mbuf   *om ;\n     struct   my_pkt_header   hdr ;\n\n     /* Get mbuf chain length */ \n     pktlen   =   OS_MBUF_PKTLEN ( om );\n\n     /* Strip header from mbuf chain */ \n     os_mbuf_adj ( om ,  sizeof ( struct   my_pkt_header ));\n     pktlen   -=   sizeof ( struct   my_pkt_header );\n\n     /* New packet length should be old packet length minus stripped header */ \n     assert ( pktlen   ==   OS_MBUF_PKTLEN ( om ));", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_append/", 
            "text": "os_mbuf_append\n\n\nint\n \nos_mbuf_append\n(\nstruct\n \nos_mbuf\n \n*om\n, \nconst\n \nvoid\n \n*data\n,  \nuint16_t\n \nlen\n)\n\n\n\n\n\nAppends a data buffer of length \nlen\n to the end of an mbuf chain, adjusting packet length if \nom\n is a packet header mbuf. If not enough trailing space exists at the end of the mbuf chain, mbufs are allocated to hold the data.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nom\n\n\nPointer to mbuf. Can be head of a chain of mbufs, a single mbuf or a packet header mbuf\n\n\n\n\n\n\ndata\n\n\nPointer to data buffer to copy from\n\n\n\n\n\n\nlen\n\n\nNumber of bytes to copy from data buffer to the end of the mbuf\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\n0: success\n\nOS_ENOMEM: Could not allocate enough mbufs to hold data.\n\nOS_EINVAL: \nom\n was NULL on entry.\n\n\n\n\nNotes\n\n\nIf not enough mbufs were available the packet header length of the mbuf may get adjusted even though the entire data buffer was not appended to the end of the mbuf.\n\n\n\n\nIf any mbufs are allocated, they are allocated from the same pool as \nom\n\n\n\n\nExample\n\n\n    \nint\n \nrc\n;\n    \nuint16_t\n \npktlen\n;\n    \nstruct\n \nos_mbuf\n \n*om\n;\n    \nstruct\n \nmy_data_struct\n \nmy_data\n;\n\n    \n/* Get initial packet length */\n\n    \npktlen\n \n=\n \nOS_MBUF_PKTLEN\n(\nom\n);\n\n    \n/* Append \nmy_data\n to end of mbuf, freeing mbuf if unable to append all the data */\n\n    \nrc\n \n=\n \nos_mbuf_append\n(\nom\n, \nmy_data\n, \nsizeof\n(\nstruct\n \nmy_pkt_header\n));\n    \nif\n (\nrc\n) {\n        \nos_mbuf_free_chain\n(\nom\n);\n    }\n    \npktlen\n \n+=\n \nsizeof\n(\nstruct\n \nmy_pkt_header\n);\n\n    \n/* New packet length should be initial packet length plus length of \nmy_data\n */\n\n    \nassert\n(\npktlen\n \n==\n \nOS_MBUF_PKTLEN\n(\nom\n));", 
            "title": "os_mbuf_append"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_append/#os_mbuf_append", 
            "text": "int   os_mbuf_append ( struct   os_mbuf   *om ,  const   void   *data ,   uint16_t   len )  Appends a data buffer of length  len  to the end of an mbuf chain, adjusting packet length if  om  is a packet header mbuf. If not enough trailing space exists at the end of the mbuf chain, mbufs are allocated to hold the data.", 
            "title": " os_mbuf_append"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_append/#arguments", 
            "text": "Arguments  Description      om  Pointer to mbuf. Can be head of a chain of mbufs, a single mbuf or a packet header mbuf    data  Pointer to data buffer to copy from    len  Number of bytes to copy from data buffer to the end of the mbuf", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_append/#returned-values", 
            "text": "0: success \nOS_ENOMEM: Could not allocate enough mbufs to hold data. \nOS_EINVAL:  om  was NULL on entry.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_append/#notes", 
            "text": "If not enough mbufs were available the packet header length of the mbuf may get adjusted even though the entire data buffer was not appended to the end of the mbuf.   If any mbufs are allocated, they are allocated from the same pool as  om", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_append/#example", 
            "text": "int   rc ;\n     uint16_t   pktlen ;\n     struct   os_mbuf   *om ;\n     struct   my_data_struct   my_data ;\n\n     /* Get initial packet length */ \n     pktlen   =   OS_MBUF_PKTLEN ( om );\n\n     /* Append  my_data  to end of mbuf, freeing mbuf if unable to append all the data */ \n     rc   =   os_mbuf_append ( om ,  my_data ,  sizeof ( struct   my_pkt_header ));\n     if  ( rc ) {\n         os_mbuf_free_chain ( om );\n    }\n     pktlen   +=   sizeof ( struct   my_pkt_header );\n\n     /* New packet length should be initial packet length plus length of  my_data  */ \n     assert ( pktlen   ==   OS_MBUF_PKTLEN ( om ));", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_concat/", 
            "text": "os_mbuf_concat\n\n\nvoid\n \nos_mbuf_concat\n(\nstruct\n \nos_mbuf\n \n*first\n, \nstruct\n \nos_mbuf\n \n*second\n)\n\n\n\n\n\nAttaches a second mbuf chain onto the end of the first. If the first chain contains a packet header, the header's length is updated.  If the second chain has a packet header, its header is cleared.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfirst\n\n\nPointer to first mbuf chain\n\n\n\n\n\n\nsecond\n\n\nPointer to second mbuf chain\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nNone\n\n\n\n\nNotes\n\n\nNo data is copied or moved nor are any mbufs freed.\n\n\n\n\nExample\n\n\n    \nuint16_t\n \npktlen1\n;\n    \nuint16_t\n \npktlen2\n;\n    \nstruct\n \nos_mbuf\n \n*pkt1\n;\n    \nstruct\n \nos_mbuf\n \n*pkt2\n;\n\n    \n/* Get initial packet lengths */\n\n    \npktlen1\n \n=\n \nOS_MBUF_PKTLEN\n(\npkt1\n);\n    \npktlen2\n \n=\n \nOS_MBUF_PKTLEN\n(\npkt2\n);\n\n    \n/*  Add pkt2 to end of pkt1 */\n\n    \nos_mbuf_concat\n(\npkt1\n, \npkt2\n);\n\n    \n/* New packet length should be sum of pkt1 and pkt2 */\n\n    \nassert\n((\npktlen1\n \n+\n \npktlen2\n) \n==\n \nOS_MBUF_PKTLEN\n(\npkt1\n));", 
            "title": "os_mbuf_concat"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_concat/#os_mbuf_concat", 
            "text": "void   os_mbuf_concat ( struct   os_mbuf   *first ,  struct   os_mbuf   *second )  Attaches a second mbuf chain onto the end of the first. If the first chain contains a packet header, the header's length is updated.  If the second chain has a packet header, its header is cleared.", 
            "title": " os_mbuf_concat"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_concat/#arguments", 
            "text": "Arguments  Description      first  Pointer to first mbuf chain    second  Pointer to second mbuf chain", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_concat/#returned-values", 
            "text": "None", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_concat/#notes", 
            "text": "No data is copied or moved nor are any mbufs freed.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_concat/#example", 
            "text": "uint16_t   pktlen1 ;\n     uint16_t   pktlen2 ;\n     struct   os_mbuf   *pkt1 ;\n     struct   os_mbuf   *pkt2 ;\n\n     /* Get initial packet lengths */ \n     pktlen1   =   OS_MBUF_PKTLEN ( pkt1 );\n     pktlen2   =   OS_MBUF_PKTLEN ( pkt2 );\n\n     /*  Add pkt2 to end of pkt1 */ \n     os_mbuf_concat ( pkt1 ,  pkt2 );\n\n     /* New packet length should be sum of pkt1 and pkt2 */ \n     assert (( pktlen1   +   pktlen2 )  ==   OS_MBUF_PKTLEN ( pkt1 ));", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_copydata/", 
            "text": "os_mbuf_copydata\n\n\nint\n \nos_mbuf_copydata\n(\nconst\n \nstruct\n \nos_mbuf\n \n*m\n, \nint\n \noff\n, \nint\n \nlen\n, \nvoid\n \n*dst\n)\n\n\n\n\n\nCopy data from an mbuf chain starting \noff\n bytes from the beginning, continuing for \nlen\n bytes, into the indicated buffer.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nm\n\n\nPointer to mbuf chain\n\n\n\n\n\n\noff\n\n\nStart copy offset, in bytes, from beginning of mbuf chain\n\n\n\n\n\n\nlen\n\n\nNumber of bytes to copy\n\n\n\n\n\n\ndst\n\n\nData buffer to copy into\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\n0: success.\n\n-1: The mbuf does not contain enough data\n\n\n\n\nExample\n\n\n    \nint\n \nrc\n;\n    \nstruct\n \nos_mbuf\n \n*om\n;\n    \nstruct\n \nmy_hdr_1\n \nmy_hdr1\n;    \n    \nstruct\n \nmy_hdr_2\n \nmy_hdr2\n;    \n\n    \n/* Header 1 and Header 2 are contiguous in packet at start. Retrieve them from the mbuf chain */\n    \n    \nrc\n \n=\n \nos_mbuf_copydata\n(\nom\n, \n0\n, \nsizeof\n(\nstruct\n \nmy_hdr_1\n), \nmy_hdr1\n);\n    \nif\n (\nrc\n) {\n        \n/* error! */\n\n        \nreturn\n \n-\n1\n;\n    }\n\n    \nrc\n \n=\n \nos_mbuf_copydata\n(\nom\n, \nsizeof\n(\nstruct\n \nmy_hdr_1\n), \nsizeof\n(\nstruct\n \nmy_hdr_2\n), \nmy_hdr2\n);\n    \nif\n (\nrc\n) {\n        \n/* error! */\n\n        \nreturn\n \n-\n1\n;\n    }", 
            "title": "os_mbuf_copydata"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_copydata/#os_mbuf_copydata", 
            "text": "int   os_mbuf_copydata ( const   struct   os_mbuf   *m ,  int   off ,  int   len ,  void   *dst )  Copy data from an mbuf chain starting  off  bytes from the beginning, continuing for  len  bytes, into the indicated buffer.", 
            "title": " os_mbuf_copydata"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_copydata/#arguments", 
            "text": "Arguments  Description      m  Pointer to mbuf chain    off  Start copy offset, in bytes, from beginning of mbuf chain    len  Number of bytes to copy    dst  Data buffer to copy into", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_copydata/#returned-values", 
            "text": "0: success. \n-1: The mbuf does not contain enough data", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_copydata/#example", 
            "text": "int   rc ;\n     struct   os_mbuf   *om ;\n     struct   my_hdr_1   my_hdr1 ;    \n     struct   my_hdr_2   my_hdr2 ;    \n\n     /* Header 1 and Header 2 are contiguous in packet at start. Retrieve them from the mbuf chain */     \n     rc   =   os_mbuf_copydata ( om ,  0 ,  sizeof ( struct   my_hdr_1 ),  my_hdr1 );\n     if  ( rc ) {\n         /* error! */ \n         return   - 1 ;\n    }\n\n     rc   =   os_mbuf_copydata ( om ,  sizeof ( struct   my_hdr_1 ),  sizeof ( struct   my_hdr_2 ),  my_hdr2 );\n     if  ( rc ) {\n         /* error! */ \n         return   - 1 ;\n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_copyinto/", 
            "text": "os_mbuf_copyinto\n\n\nint\n \nos_mbuf_copyinto\n(\nstruct\n \nos_mbuf\n \n*om\n, \nint\n \noff\n, \nconst\n \nvoid\n \n*src\n, \nint\n \nlen\n);\n\n\n\n\n\nCopies the contents of a flat buffer into an mbuf chain, starting at the specified destination offset.  If the mbuf is too small for the source data, it is extended as necessary.  If the destination mbuf contains a packet header, the header length is updated.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nom\n\n\nPointer to mbuf chain\n\n\n\n\n\n\noff\n\n\nStart copy offset, in bytes, from beginning of mbuf chain\n\n\n\n\n\n\nsrc\n\n\nAddress from which bytes are copied\n\n\n\n\n\n\nlen\n\n\nNumber of bytes to copy from src\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\n0: success.\n\nAll other values indicate an error.\n\n\n\n\nExample\n\n\n    \nint\n \nrc\n;\n    \nuint16_t\n \npktlen\n;\n    \nstruct\n \nos_mbuf\n \n*om\n;\n    \nstruct\n \nmy_data_struct\n \nmy_data\n;  \n\n    \n/* Get initial packet length */\n\n    \npktlen\n \n=\n \nOS_MBUF_PKTLEN\n(\nom\n);\n\n    \n/* Copy \nmy_data\n into mbuf */\n\n    \nrc\n \n=\n \nos_mbuf_copyinto\n(\nom\n, \n0\n, \nmy_data\n, \nsizeof\n(\nstruct\n \nmy_data_struct\n));\n    \nif\n (\nrc\n) {\n        \nos_mbuf_free_chain\n(\nom\n);\n        \nreturn\n;\n    }\n\n    \n/* Packet length should have increased by size of \nmy_data\n */\n\n    \npktlen\n \n+=\n \nsizeof\n(\nstruct\n \nmy_data_struct\n);\n    \nassert\n(\npktlen\n \n==\n \nOS_MBUF_PKTLEN\n(\nom\n));", 
            "title": "os_mbuf_copyinto"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_copyinto/#os_mbuf_copyinto", 
            "text": "int   os_mbuf_copyinto ( struct   os_mbuf   *om ,  int   off ,  const   void   *src ,  int   len );  Copies the contents of a flat buffer into an mbuf chain, starting at the specified destination offset.  If the mbuf is too small for the source data, it is extended as necessary.  If the destination mbuf contains a packet header, the header length is updated.", 
            "title": " os_mbuf_copyinto"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_copyinto/#arguments", 
            "text": "Arguments  Description      om  Pointer to mbuf chain    off  Start copy offset, in bytes, from beginning of mbuf chain    src  Address from which bytes are copied    len  Number of bytes to copy from src", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_copyinto/#returned-values", 
            "text": "0: success. \nAll other values indicate an error.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_copyinto/#example", 
            "text": "int   rc ;\n     uint16_t   pktlen ;\n     struct   os_mbuf   *om ;\n     struct   my_data_struct   my_data ;  \n\n     /* Get initial packet length */ \n     pktlen   =   OS_MBUF_PKTLEN ( om );\n\n     /* Copy  my_data  into mbuf */ \n     rc   =   os_mbuf_copyinto ( om ,  0 ,  my_data ,  sizeof ( struct   my_data_struct ));\n     if  ( rc ) {\n         os_mbuf_free_chain ( om );\n         return ;\n    }\n\n     /* Packet length should have increased by size of  my_data  */ \n     pktlen   +=   sizeof ( struct   my_data_struct );\n     assert ( pktlen   ==   OS_MBUF_PKTLEN ( om ));", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_dup/", 
            "text": "os_mbuf_dup\n\n\nstruct\n \nos_mbuf\n \n*os_mbuf_dup\n(\nstruct\n \nos_mbuf\n \n*om\n)\n\n\n\n\n\nDuplicate a chain of mbufs.  Return the start of the duplicated chain.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nom\n\n\nPointer to mbuf chain to duplicate\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nPointer to the duplicated chain or NULL if not enough mbufs were available to duplicate the chain.\n\n\n\n\nExample\n\n\n    \nstruct\n \nos_mbuf\n \n*om\n;\n    \nstruct\n \nos_mbuf\n \n*new_om\n;\n\n    \n/* Make a copy of om, returning -1 if not able to duplicate om */\n\n    \nnew_om\n \n=\n \nos_mbuf_dup\n(\nom\n);\n    \nif\n (\n!new_om\n) {\n        \nreturn\n \n-\n1\n;\n    }", 
            "title": "os_mbuf_dup"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_dup/#os_mbuf_dup", 
            "text": "struct   os_mbuf   *os_mbuf_dup ( struct   os_mbuf   *om )  Duplicate a chain of mbufs.  Return the start of the duplicated chain.", 
            "title": " os_mbuf_dup"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_dup/#arguments", 
            "text": "Arguments  Description      om  Pointer to mbuf chain to duplicate", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_dup/#returned-values", 
            "text": "Pointer to the duplicated chain or NULL if not enough mbufs were available to duplicate the chain.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_dup/#example", 
            "text": "struct   os_mbuf   *om ;\n     struct   os_mbuf   *new_om ;\n\n     /* Make a copy of om, returning -1 if not able to duplicate om */ \n     new_om   =   os_mbuf_dup ( om );\n     if  ( !new_om ) {\n         return   - 1 ;\n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_extend/", 
            "text": "os_mbuf_extend\n\n\nvoid\n \n*os_mbuf_extend\n(\nstruct\n \nos_mbuf\n \n*om\n, \nuint16_t\n \nlen\n);\n\n\n\n\n\nIncreases the length of an mbuf chain by the specified amount.  If there is not sufficient room in the last buffer, a new buffer is allocated and appended to the chain.  It is an error to request more data than can fit in a single buffer.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nom\n\n\nPointer to mbuf chain\n\n\n\n\n\n\nlen\n\n\nNumber of bytes to increase packet header\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nPointer to start of extended data. Caller is guaranteed that there are at least \nlen\n bytes from this pointer to the end of the mbuf.\n\n\nReturns NULL if extension fails due to insufficient mbufs or \nlen\n too large.\n\n\n\nExample\n\n\n    \nuint8_t\n \n*dptr\n;\n    \nstruct\n \nos_mbuf\n \n*om\n;\n    \nstruct\n \nmy_data_struct\n \nmy_data\n;  \n\n    \n/* Obtain enough room to add \nmy_data\n to an mbuf chain */\n\n    \ndptr\n \n=\n \nos_mbuf_extend\n(\nom\n, \nsizeof\n(\nstruct\n \nmy_data_struct\n));\n    \nif\n (\ndptr\n) {\n        \nmemcpy\n(\ndptr\n, \nmy_data\n, \nsizeof\n(\nstruct\n \nmy_data_struct\n));\n    }", 
            "title": "os_mbuf_extend"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_extend/#os_mbuf_extend", 
            "text": "void   *os_mbuf_extend ( struct   os_mbuf   *om ,  uint16_t   len );  Increases the length of an mbuf chain by the specified amount.  If there is not sufficient room in the last buffer, a new buffer is allocated and appended to the chain.  It is an error to request more data than can fit in a single buffer.", 
            "title": " os_mbuf_extend"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_extend/#arguments", 
            "text": "Arguments  Description      om  Pointer to mbuf chain    len  Number of bytes to increase packet header", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_extend/#returned-values", 
            "text": "Pointer to start of extended data. Caller is guaranteed that there are at least  len  bytes from this pointer to the end of the mbuf.  Returns NULL if extension fails due to insufficient mbufs or  len  too large.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_extend/#example", 
            "text": "uint8_t   *dptr ;\n     struct   os_mbuf   *om ;\n     struct   my_data_struct   my_data ;  \n\n     /* Obtain enough room to add  my_data  to an mbuf chain */ \n     dptr   =   os_mbuf_extend ( om ,  sizeof ( struct   my_data_struct ));\n     if  ( dptr ) {\n         memcpy ( dptr ,  my_data ,  sizeof ( struct   my_data_struct ));\n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_free_chain/", 
            "text": "os_mbuf_free_chain\n\n\nint\n \nos_mbuf_free_chain\n(\nstruct\n \nos_mbuf\n \n*om\n);\n\n\n\n\n\nFrees a chain of mbufs\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nom\n\n\nPointer to mbuf chain\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\n0: success\n\nAny other value indicates error\n\n\n\n\nNotes\n\n\nNote that for each mbuf in the chain, \nos_mbuf_free()\n is called.\n\n\n\n\nExample\n\n\n    \nint\n \nrc\n;\n    \nstruct\n \nos_mbuf\n \n*om\n;\n\n    \n/* Free mbuf chain */\n\n    \nrc\n \n=\n \nos_mbuf_free_chain\n(\nom\n);\n    \nassert\n(\nrc\n \n==\n \n0\n);", 
            "title": "os_mbuf_free_chain"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_free_chain/#os_mbuf_free_chain", 
            "text": "int   os_mbuf_free_chain ( struct   os_mbuf   *om );  Frees a chain of mbufs", 
            "title": " os_mbuf_free_chain"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_free_chain/#arguments", 
            "text": "Arguments  Description      om  Pointer to mbuf chain", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_free_chain/#returned-values", 
            "text": "0: success \nAny other value indicates error", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_free_chain/#notes", 
            "text": "Note that for each mbuf in the chain,  os_mbuf_free()  is called.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_free_chain/#example", 
            "text": "int   rc ;\n     struct   os_mbuf   *om ;\n\n     /* Free mbuf chain */ \n     rc   =   os_mbuf_free_chain ( om );\n     assert ( rc   ==   0 );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_get/", 
            "text": "os_mbuf_get\n\n\nstruct\n \nos_mbuf\n \n*os_mbuf_get\n(\nstruct\n \nos_mbuf_pool\n \n*omp\n, \nuint16_t\n \nleadingspace\n)\n\n\n\n\n\nGet an mbuf from the mbuf pool. The mbuf is allocated, and initialized prior to being returned. The \nleadingspace\n parameter allows the user to specify the amount of leading space in the allocated mbuf.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nom\n\n\nPointer to mbuf pool from which to allocate mbuf\n\n\n\n\n\n\nleadingspace\n\n\nAmount of leading space in allocated mbuf. Request cannot exceed the mbuf data buffer size.\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns a pointer to the allocated mbuf or NULL if there are no mbufs available or \nleadingspace\n was too large.\n\n\n\nNotes\n\n\nIn most typical applications, the application developer does not need to call \nos_mbuf_get()\n; the other API will do this automatically. However, this API is provided for convenience as mbufs can also be a simple way to allocate temporary chunks of memory.\n\n\n\n\nExample\n\n\n    \nstruct\n \nos_mbuf\n \n*om\n;\n\n    \n/* Get an mbuf */\n\n    \nom\n \n=\n \nos_mbuf_get\n(\ng_mbuf_pool\n, \n0\n);\n    \nif\n (\nom\n) {\n        \n/* we have allocated an mbuf from the pool */\n\n    }", 
            "title": "os_mbuf_get"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_get/#os_mbuf_get", 
            "text": "struct   os_mbuf   *os_mbuf_get ( struct   os_mbuf_pool   *omp ,  uint16_t   leadingspace )  Get an mbuf from the mbuf pool. The mbuf is allocated, and initialized prior to being returned. The  leadingspace  parameter allows the user to specify the amount of leading space in the allocated mbuf.", 
            "title": "os_mbuf_get"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_get/#arguments", 
            "text": "Arguments  Description      om  Pointer to mbuf pool from which to allocate mbuf    leadingspace  Amount of leading space in allocated mbuf. Request cannot exceed the mbuf data buffer size.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_get/#returned-values", 
            "text": "Returns a pointer to the allocated mbuf or NULL if there are no mbufs available or  leadingspace  was too large.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_get/#notes", 
            "text": "In most typical applications, the application developer does not need to call  os_mbuf_get() ; the other API will do this automatically. However, this API is provided for convenience as mbufs can also be a simple way to allocate temporary chunks of memory.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_get/#example", 
            "text": "struct   os_mbuf   *om ;\n\n     /* Get an mbuf */ \n     om   =   os_mbuf_get ( g_mbuf_pool ,  0 );\n     if  ( om ) {\n         /* we have allocated an mbuf from the pool */ \n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_get_pkthdr/", 
            "text": "os_mbuf_get_pkthdr\n\n\nstruct\n \nos_mbuf\n \n*os_mbuf_get_pkthdr\n(\nstruct\n \nos_mbuf_pool\n \n*omp\n, \nuint8_t\n \npkthdr_len\n);\n\n\n\n\n\nAllocates a packet header mbuf from the mbuf pool pointed to by \nomp\n. Adds a user header of length \npkthdr_len\n to packet header mbuf.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nom\n\n\nPointer to mbuf pool from which to allocate mbuf\n\n\n\n\n\n\npkthdr_len\n\n\nThe user header packet length to allocate for the packet header mbuf\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns a pointer to the allocated mbuf or NULL if there are no mbufs available or the user packet header was too large.\n\n\n\n\nNotes\n\n\nThe packet header mbuf returned will have its data pointer incremented by the sizeof(struct os_mbuf_pkthdr) as well as the amount of user header data (i.e. \npkthdr_len\n). In other words, the data pointer is offset from the start of the mbuf by: sizeof(struct os_mbuf) + sizeof(struct os_mbuf_pkthdr) + pkthdr_len. The \nom_pkthdr_len\n element in the allocated mbuf is set to: sizeof(struct os_mbuf_pkthdr) + pkthdr_len.\n\n\n\n\nExample\n\n\n    \nstruct\n \nos_mbuf\n \n*om\n;\n    \nstruct\n \nmy_user_header\n \nmy_hdr\n;\n\n    \n/* Get a packet header mbuf with a user header in it */\n\n    \nom\n \n=\n \nos_mbuf_get_pkthdr\n(\ng_mbuf_pool\n, \nsizeof\n(\nstruct\n \nmy_user_header\n));\n    \nif\n (\nom\n) {\n        \n/* Packet header mbuf was allocated */\n\n    }", 
            "title": "os_mbuf_get_pkthdr"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_get_pkthdr/#os_mbuf_get_pkthdr", 
            "text": "struct   os_mbuf   *os_mbuf_get_pkthdr ( struct   os_mbuf_pool   *omp ,  uint8_t   pkthdr_len );  Allocates a packet header mbuf from the mbuf pool pointed to by  omp . Adds a user header of length  pkthdr_len  to packet header mbuf.", 
            "title": "os_mbuf_get_pkthdr"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_get_pkthdr/#arguments", 
            "text": "Arguments  Description      om  Pointer to mbuf pool from which to allocate mbuf    pkthdr_len  The user header packet length to allocate for the packet header mbuf", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_get_pkthdr/#returned-values", 
            "text": "Returns a pointer to the allocated mbuf or NULL if there are no mbufs available or the user packet header was too large.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_get_pkthdr/#notes", 
            "text": "The packet header mbuf returned will have its data pointer incremented by the sizeof(struct os_mbuf_pkthdr) as well as the amount of user header data (i.e.  pkthdr_len ). In other words, the data pointer is offset from the start of the mbuf by: sizeof(struct os_mbuf) + sizeof(struct os_mbuf_pkthdr) + pkthdr_len. The  om_pkthdr_len  element in the allocated mbuf is set to: sizeof(struct os_mbuf_pkthdr) + pkthdr_len.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_get_pkthdr/#example", 
            "text": "struct   os_mbuf   *om ;\n     struct   my_user_header   my_hdr ;\n\n     /* Get a packet header mbuf with a user header in it */ \n     om   =   os_mbuf_get_pkthdr ( g_mbuf_pool ,  sizeof ( struct   my_user_header ));\n     if  ( om ) {\n         /* Packet header mbuf was allocated */ \n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_memcmp/", 
            "text": "os_mbuf_memcmp\n\n\nint\n \nos_mbuf_memcmp\n(\nconst\n \nstruct\n \nos_mbuf\n \n*om\n, \nint\n \noff\n, \nconst\n \nvoid\n \n*data\n, \nint\n \nlen\n)\n\n\n\n\n\nPerforms a memory compare of the specified region of an mbuf chain against a flat buffer.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nom\n\n\nPointer to mbuf\n\n\n\n\n\n\noff\n\n\nOffset, in bytes, from start of mbuf to start of comparison\n\n\n\n\n\n\ndata\n\n\nPointer to flat data buffer to compare\n\n\n\n\n\n\nlen\n\n\nNumber of bytes to compare\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nA value of zero means the memory regions are identical; all other values represent either an error or a value returned from memcmp. \n\n\n\n\nNotes\n\n\nThis function will compare bytes starting from \noff\n bytes from the start of the mbuf chain with a data buffer.\n\n\n\n\nExample\n\n\n    \nint\n \nrc\n;\n    \nstruct\n \nos_mbuf\n \n*om\n;\n    \nuint8_t\n \nmy_data_buffer\n[\n32\n];\n\n    \n/* Get a packet header mbuf with a user header in it */\n\n    \nrc\n \n=\n \nos_mbuf_memcmp\n(\nom\n, \n0\n, \nmy_data_buffer\n, \n32\n);\n    \nif\n (\n!rc\n) {\n        \n/* \nmy_data_buffer\n and the data from offset 0 in the mbuf chain are identical! */\n\n    }", 
            "title": "os_mbuf_memcmp"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_memcmp/#os_mbuf_memcmp", 
            "text": "int   os_mbuf_memcmp ( const   struct   os_mbuf   *om ,  int   off ,  const   void   *data ,  int   len )  Performs a memory compare of the specified region of an mbuf chain against a flat buffer.", 
            "title": "os_mbuf_memcmp"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_memcmp/#arguments", 
            "text": "Arguments  Description      om  Pointer to mbuf    off  Offset, in bytes, from start of mbuf to start of comparison    data  Pointer to flat data buffer to compare    len  Number of bytes to compare", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_memcmp/#returned-values", 
            "text": "A value of zero means the memory regions are identical; all other values represent either an error or a value returned from memcmp.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_memcmp/#notes", 
            "text": "This function will compare bytes starting from  off  bytes from the start of the mbuf chain with a data buffer.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_memcmp/#example", 
            "text": "int   rc ;\n     struct   os_mbuf   *om ;\n     uint8_t   my_data_buffer [ 32 ];\n\n     /* Get a packet header mbuf with a user header in it */ \n     rc   =   os_mbuf_memcmp ( om ,  0 ,  my_data_buffer ,  32 );\n     if  ( !rc ) {\n         /*  my_data_buffer  and the data from offset 0 in the mbuf chain are identical! */ \n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_off/", 
            "text": "os_mbuf_off\n\n\nstruct\n \nos_mbuf\n \n*os_mbuf_off\n(\nstruct\n \nos_mbuf\n \n*om\n, \nint\n \noff\n, \nint\n \n*out_off\n)\n\n\n\n\n\nGiven an offset in the packet (i.e. user data byte offset in the mbuf chain), return the mbuf and the offset in that mbuf where byte 'off' is located. Note that the offset is 'returned' in \nout_off\n.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nom\n\n\nPointer to mbuf\n\n\n\n\n\n\noff\n\n\nLocation in mbuf chain of desired byte offset\n\n\n\n\n\n\nout_off\n\n\nPointer to storage for the relative offset of the absolute location in the returned mbuf\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nNULL if the offset is not within the mbuf chain or \nom\n points to NULL.\n\n\n\n\nNotes\n\n\nThe user is allowed to call this function with the length of the mbuf chain but no greater. This allows the user to get the mbuf and offset (in that mbuf) where the next user data byte should be written.\n\n\nWhile this api is provided to the user, other API are expected to be used by the applciation developer (i.e. \nos_mbuf_append()\n or \nos_mbuf_copyinto()\n).\n\n\n\nExample\n\n\n    \nint\n \nrelative_offset\n;\n    \nuint16_t\n \npktlen\n;\n    \nstruct\n \nos_mbuf\n \n*om\n;\n    \nstruct\n \nos_mbuf\n \n*tmp\n;\n\n    \n/* Append a new line character to end of mbuf data */\n\n    \npktlen\n \n=\n \nOS_MBUF_PKTLEN\n(\nom\n);\n\n    \nrelative_offset\n \n=\n \n0\n;\n    \ntmp\n \n=\n \nos_mbuf_off\n(\nom\n, \npktlen\n, \nrelative_offset\n);\n    \nif\n (\ntmp\n) {\n        \n/* Offset found. */\n\n        \ntmp-\nom_data\n[\nrelative_offset\n] \n=\n \n\\n\n;\n    } \nelse\n {\n        \n/*\n\n\n         * This mbuf does not contain enough bytes so this is an invalid offset.\n\n\n         * In other words, the mbuf is less than 62 bytes in length.\n\n\n         */\n\n    }", 
            "title": "os_mbuf_off"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_off/#os_mbuf_off", 
            "text": "struct   os_mbuf   *os_mbuf_off ( struct   os_mbuf   *om ,  int   off ,  int   *out_off )  Given an offset in the packet (i.e. user data byte offset in the mbuf chain), return the mbuf and the offset in that mbuf where byte 'off' is located. Note that the offset is 'returned' in  out_off .", 
            "title": "os_mbuf_off"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_off/#arguments", 
            "text": "Arguments  Description      om  Pointer to mbuf    off  Location in mbuf chain of desired byte offset    out_off  Pointer to storage for the relative offset of the absolute location in the returned mbuf", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_off/#returned-values", 
            "text": "NULL if the offset is not within the mbuf chain or  om  points to NULL.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_off/#notes", 
            "text": "The user is allowed to call this function with the length of the mbuf chain but no greater. This allows the user to get the mbuf and offset (in that mbuf) where the next user data byte should be written.  While this api is provided to the user, other API are expected to be used by the applciation developer (i.e.  os_mbuf_append()  or  os_mbuf_copyinto() ).", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_off/#example", 
            "text": "int   relative_offset ;\n     uint16_t   pktlen ;\n     struct   os_mbuf   *om ;\n     struct   os_mbuf   *tmp ;\n\n     /* Append a new line character to end of mbuf data */ \n     pktlen   =   OS_MBUF_PKTLEN ( om );\n\n     relative_offset   =   0 ;\n     tmp   =   os_mbuf_off ( om ,  pktlen ,  relative_offset );\n     if  ( tmp ) {\n         /* Offset found. */ \n         tmp- om_data [ relative_offset ]  =   \\n ;\n    }  else  {\n         /*           * This mbuf does not contain enough bytes so this is an invalid offset.           * In other words, the mbuf is less than 62 bytes in length.           */ \n    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_pool_init/", 
            "text": "os_mbuf_pool_init\n\n\nint\n \nos_mbuf_pool_init\n(\nstruct\n \nos_mbuf_pool\n \n*omp\n, \nstruct\n \nos_mempool\n \n*mp\n, \nuint16_t\n \nbuf_len\n, \n                      \nuint16_t\n \nnbufs\n)\n\n\n\n\n\nInitialize an mbuf pool\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nomp\n\n\nPointer to mbuf pool to initialize\n\n\n\n\n\n\nmp\n\n\nPointer to memory pool used by mbuf pool\n\n\n\n\n\n\nbuf_len\n\n\nThe size of the memory blocks in the memory pool used by the mbuf pool\n\n\n\n\n\n\nnbufs\n\n\nThe number of mbufs in the pool\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\n0 on success; all other values indicate an error.\n\n\n\n\nNotes\n\n\nThe parameter \nbuf_len\n is the total size of the memory block. This must accommodate the os_mbuf structure, the os_mbuf_pkthdr structure, any user headers plus the desired amount of user data.\n\n\n\n\nExample\n\n\n#define MBUF_PKTHDR_OVERHEAD    sizeof(struct os_mbuf_pkthdr) + sizeof(struct user_hdr)\n\n\n#define MBUF_MEMBLOCK_OVERHEAD  sizeof(struct os_mbuf) + MBUF_PKTHDR_OVERHEAD\n\n\n\n#define MBUF_NUM_MBUFS      (32)\n\n\n#define MBUF_PAYLOAD_SIZE   (64)\n\n\n#define MBUF_BUF_SIZE       OS_ALIGN(MBUF_PAYLOAD_SIZE, 4)\n\n\n#define MBUF_MEMBLOCK_SIZE  (MBUF_BUF_SIZE + MBUF_MEMBLOCK_OVERHEAD)\n\n\n#define MBUF_MEMPOOL_SIZE   OS_MEMPOOL_SIZE(MBUF_NUM_MBUFS, MBUF_MEMBLOCK_SIZE)\n\n\n\nstruct\n \nos_mbuf_pool\n \ng_mbuf_pool\n; \n\nstruct\n \nos_mempool\n \ng_mbuf_mempool\n;\n\nos_membuf_t\n \ng_mbuf_buffer\n[\nMBUF_MEMPOOL_SIZE\n];\n\n\nvoid\n\n\ncreate_mbuf_pool\n(\nvoid\n)\n{\n    \nint\n \nrc\n;\n\n    \nrc\n \n=\n \nos_mempool_init\n(\ng_mbuf_mempool\n, \nMBUF_NUM_MBUFS\n, \n                          \nMBUF_MEMBLOCK_SIZE\n, \ng_mbuf_buffer\n[\n0\n], \nmbuf_pool\n);\n    \nassert\n(\nrc\n \n==\n \n0\n);\n\n    \nrc\n \n=\n \nos_mbuf_pool_init\n(\ng_mbuf_pool\n, \ng_mbuf_mempool\n, \nMBUF_MEMBLOCK_SIZE\n, \n                           \nMBUF_NUM_MBUFS\n);\n    \nassert\n(\nrc\n \n==\n \n0\n);\n}", 
            "title": "os_mbuf_pool_init"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_pool_init/#os_mbuf_pool_init", 
            "text": "int   os_mbuf_pool_init ( struct   os_mbuf_pool   *omp ,  struct   os_mempool   *mp ,  uint16_t   buf_len , \n                       uint16_t   nbufs )  Initialize an mbuf pool", 
            "title": "os_mbuf_pool_init"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_pool_init/#arguments", 
            "text": "Arguments  Description      omp  Pointer to mbuf pool to initialize    mp  Pointer to memory pool used by mbuf pool    buf_len  The size of the memory blocks in the memory pool used by the mbuf pool    nbufs  The number of mbufs in the pool", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_pool_init/#returned-values", 
            "text": "0 on success; all other values indicate an error.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_pool_init/#notes", 
            "text": "The parameter  buf_len  is the total size of the memory block. This must accommodate the os_mbuf structure, the os_mbuf_pkthdr structure, any user headers plus the desired amount of user data.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_pool_init/#example", 
            "text": "#define MBUF_PKTHDR_OVERHEAD    sizeof(struct os_mbuf_pkthdr) + sizeof(struct user_hdr)  #define MBUF_MEMBLOCK_OVERHEAD  sizeof(struct os_mbuf) + MBUF_PKTHDR_OVERHEAD  #define MBUF_NUM_MBUFS      (32)  #define MBUF_PAYLOAD_SIZE   (64)  #define MBUF_BUF_SIZE       OS_ALIGN(MBUF_PAYLOAD_SIZE, 4)  #define MBUF_MEMBLOCK_SIZE  (MBUF_BUF_SIZE + MBUF_MEMBLOCK_OVERHEAD)  #define MBUF_MEMPOOL_SIZE   OS_MEMPOOL_SIZE(MBUF_NUM_MBUFS, MBUF_MEMBLOCK_SIZE)  struct   os_mbuf_pool   g_mbuf_pool ;  struct   os_mempool   g_mbuf_mempool ; os_membuf_t   g_mbuf_buffer [ MBUF_MEMPOOL_SIZE ]; void  create_mbuf_pool ( void )\n{\n     int   rc ;\n\n     rc   =   os_mempool_init ( g_mbuf_mempool ,  MBUF_NUM_MBUFS , \n                           MBUF_MEMBLOCK_SIZE ,  g_mbuf_buffer [ 0 ],  mbuf_pool );\n     assert ( rc   ==   0 );\n\n     rc   =   os_mbuf_pool_init ( g_mbuf_pool ,  g_mbuf_mempool ,  MBUF_MEMBLOCK_SIZE , \n                            MBUF_NUM_MBUFS );\n     assert ( rc   ==   0 );\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_prepend/", 
            "text": "os_mbuf_prepend\n\n\nstruct\n \nos_mbuf\n \n*os_mbuf_prepend\n(\nstruct\n \nos_mbuf\n \n*om\n, \nint\n \nlen\n)\n\n\n\n\n\nIncreases the length of an mbuf chain by adding data to the front.  If there is insufficient room in the leading mbuf, additional mbufs are allocated and prepended as necessary.  If this function fails to allocate an mbuf, the entire chain is freed.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nom\n\n\nPointer to mbuf\n\n\n\n\n\n\nlen\n\n\nLength, in bytes, to prepend\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nPointer to mbuf at head of chain; NULL if not enough mbufs were available to accommodate \nlen\n.\n\n\n\n\nNotes\n\n\nIf \nom\n is a packet header mbuf, the total length of the packet is adjusted by \nlen\n. Note that the returned mbuf may not point to \nom\n if insufficient leading space was available in \nom\n.\n\n\n\n\nExample\n\n\n    \nuint16_t\n \npktlen\n;\n    \nstruct\n \nos_mbuf\n \n*om\n;\n    \nstruct\n \nos_mbuf\n \n*tmp\n;\n\n    \n/* Get initial packet length before prepend */\n\n    \npktlen\n \n=\n \nOS_MBUF_PKTLEN\n(\nom\n);\n\n    \ntmp\n \n=\n \nos_mbuf_prepend\n(\nom\n, \n32\n);\n    \nif\n (\n!tmp\n) {\n        \n/* Not able to prepend. The chain pointed to by *om has been freed */\n\n        \nreturn\n \n-\n1\n;\n    }\n\n    \n/* The packet length should equal the original length plus what we prepended */\n\n    \nassert\n((\npktlen\n \n+\n \n32\n) \n==\n \nOS_MBUF_PKTLEN\n(\ntmp\n));", 
            "title": "os_mbuf_prepend"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_prepend/#os_mbuf_prepend", 
            "text": "struct   os_mbuf   *os_mbuf_prepend ( struct   os_mbuf   *om ,  int   len )  Increases the length of an mbuf chain by adding data to the front.  If there is insufficient room in the leading mbuf, additional mbufs are allocated and prepended as necessary.  If this function fails to allocate an mbuf, the entire chain is freed.", 
            "title": "os_mbuf_prepend"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_prepend/#arguments", 
            "text": "Arguments  Description      om  Pointer to mbuf    len  Length, in bytes, to prepend", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_prepend/#returned-values", 
            "text": "Pointer to mbuf at head of chain; NULL if not enough mbufs were available to accommodate  len .", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_prepend/#notes", 
            "text": "If  om  is a packet header mbuf, the total length of the packet is adjusted by  len . Note that the returned mbuf may not point to  om  if insufficient leading space was available in  om .", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_prepend/#example", 
            "text": "uint16_t   pktlen ;\n     struct   os_mbuf   *om ;\n     struct   os_mbuf   *tmp ;\n\n     /* Get initial packet length before prepend */ \n     pktlen   =   OS_MBUF_PKTLEN ( om );\n\n     tmp   =   os_mbuf_prepend ( om ,  32 );\n     if  ( !tmp ) {\n         /* Not able to prepend. The chain pointed to by *om has been freed */ \n         return   - 1 ;\n    }\n\n     /* The packet length should equal the original length plus what we prepended */ \n     assert (( pktlen   +   32 )  ==   OS_MBUF_PKTLEN ( tmp ));", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_pullup/", 
            "text": "os_mbuf_pullup\n\n\nstruct\n \nos_mbuf\n \n*os_mbuf_pullup\n(\nstruct\n \nos_mbuf\n \n*om\n, \nuint16_t\n \nlen\n)\n\n\n\n\n\nRearrange an mbuf chain so that len bytes are contiguous, and in the data area of an mbuf (so that OS_MBUF_DATA() will  work on a structure of size len.)  Returns the resulting mbuf chain on success, free's it and returns NULL on failure.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nom\n\n\nPointer to mbuf\n\n\n\n\n\n\nlen\n\n\nLength, in bytes, to pullup (make contiguous in mbuf)\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nPointer to mbuf at head of chain; NULL if not enough mbufs were available to accommodate \nlen\n or if the requested pullup size was too large.\n\n\n\n\nNotes\n\n\nHopefully it is apparent to the user that you cannot pullup more bytes than the mbuf can accommodate. Pullup does not allocate more than one mbuf; the entire pullup length must be contained within a single mbuf.\n\n\nThe mbuf that is being pulled up into does not need to be a packet header mbuf; it can be a normal mbuf. The user should note that the maximum pullup length does depend on the type of mbuf being pulled up into (a packet header or normal mbuf).\n\n\n\n\nExample\n\n\n    \nstruct\n \nos_mbuf\n \n*om\n;\n    \nstruct\n \nos_mbuf\n \n*tmp\n;\n    \nstruct\n \nmy_header_struct\n \nmy_header\n;\n\n    \n/* Make sure \nmy_header\n is contiguous in the mbuf */\n\n    \ntmp\n \n=\n \nos_mbuf_pullup\n(\nom\n, \nsizeof\n(\nmy_header_struct\n));\n    \nif\n (\n!tmp\n) {\n        \n/* Pullup failed. The chain pointed to by *om has been freed */\n\n        \nreturn\n \n-\n1\n;\n    }\n\n    \n/* copy data from mbuf into header structure */\n\n    \nmemcpy\n(\nmy_header\n, \ntmp-\nom_data\n, \nsizeof\n(\nstruct\n \nmy_header_struct\n));", 
            "title": "os_mbuf_pullup"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_pullup/#os_mbuf_pullup", 
            "text": "struct   os_mbuf   *os_mbuf_pullup ( struct   os_mbuf   *om ,  uint16_t   len )  Rearrange an mbuf chain so that len bytes are contiguous, and in the data area of an mbuf (so that OS_MBUF_DATA() will  work on a structure of size len.)  Returns the resulting mbuf chain on success, free's it and returns NULL on failure.", 
            "title": "os_mbuf_pullup"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_pullup/#arguments", 
            "text": "Arguments  Description      om  Pointer to mbuf    len  Length, in bytes, to pullup (make contiguous in mbuf)", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_pullup/#returned-values", 
            "text": "Pointer to mbuf at head of chain; NULL if not enough mbufs were available to accommodate  len  or if the requested pullup size was too large.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_pullup/#notes", 
            "text": "Hopefully it is apparent to the user that you cannot pullup more bytes than the mbuf can accommodate. Pullup does not allocate more than one mbuf; the entire pullup length must be contained within a single mbuf.  The mbuf that is being pulled up into does not need to be a packet header mbuf; it can be a normal mbuf. The user should note that the maximum pullup length does depend on the type of mbuf being pulled up into (a packet header or normal mbuf).", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/mbuf/os_mbuf_pullup/#example", 
            "text": "struct   os_mbuf   *om ;\n     struct   os_mbuf   *tmp ;\n     struct   my_header_struct   my_header ;\n\n     /* Make sure  my_header  is contiguous in the mbuf */ \n     tmp   =   os_mbuf_pullup ( om ,  sizeof ( my_header_struct ));\n     if  ( !tmp ) {\n         /* Pullup failed. The chain pointed to by *om has been freed */ \n         return   - 1 ;\n    }\n\n     /* copy data from mbuf into header structure */ \n     memcpy ( my_header ,  tmp- om_data ,  sizeof ( struct   my_header_struct ));", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/msys/msys/", 
            "text": "Msys\n\n\nMsys stands for \"system mbufs\" and is a set of API built on top of the mbuf code. The basic idea behind msys is the following. The developer can create different size mbuf pools and register them with msys. The application then allocates mbufs using the msys API (as opposed to the mbuf API). The msys code will choose the mbuf pool with the smallest mbufs that can accommodate the requested size. \n\n\nLet us walk through an example where the user registers three mbuf pools with msys: one with 32 byte mbufs, one with 256 and one with 2048. If the user requests an mbuf with 10 bytes, the 32-byte mbuf pool is used. If the request is for 33 bytes the 256 byte mbuf pool is used. If an mbuf data size is requested that is larger than any of the pools (say, 4000 bytes) the largest pool is used. While this behaviour may not be optimal in all cases that is the currently implemented behaviour. All this means is that the user is not guaranteed that a single mbuf can hold the requested data.\n\n\nThe msys code will not allocate an mbuf from a larger pool if the chosen mbuf pool is empty. Similarly, the msys code will not chain together a number of smaller mbufs to accommodate the requested size. While this behaviour may change in future implementations the current code will simply return NULL. Using the above example, say the user requests 250 bytes. The msys code chooses the appropriate pool (i.e. the 256 byte mbuf pool) and attempts to allocate an mbuf from that pool. If that pool is empty, NULL is returned even though the 32 and 2048 byte pools are not empty.\n\n\nNote that no added descriptions on how to use the msys API are presented here (other than in the API descriptions themselves) as the msys API is used in exactly the same manner as the mbuf API. The only difference is that mbuf pools are added to msys by calling \nos_msys_register().\n\n\n  \n\n\nList of Functions\n\n\nThe functions available in msys are:\n\n\n\n\nos_msys_get\n\n\nos_msys_get_pkthdr\n\n\nos_msys_register\n\n\nos_msys_reset", 
            "title": "toc"
        }, 
        {
            "location": "/os/core_os/msys/msys/#msys", 
            "text": "Msys stands for \"system mbufs\" and is a set of API built on top of the mbuf code. The basic idea behind msys is the following. The developer can create different size mbuf pools and register them with msys. The application then allocates mbufs using the msys API (as opposed to the mbuf API). The msys code will choose the mbuf pool with the smallest mbufs that can accommodate the requested size.   Let us walk through an example where the user registers three mbuf pools with msys: one with 32 byte mbufs, one with 256 and one with 2048. If the user requests an mbuf with 10 bytes, the 32-byte mbuf pool is used. If the request is for 33 bytes the 256 byte mbuf pool is used. If an mbuf data size is requested that is larger than any of the pools (say, 4000 bytes) the largest pool is used. While this behaviour may not be optimal in all cases that is the currently implemented behaviour. All this means is that the user is not guaranteed that a single mbuf can hold the requested data.  The msys code will not allocate an mbuf from a larger pool if the chosen mbuf pool is empty. Similarly, the msys code will not chain together a number of smaller mbufs to accommodate the requested size. While this behaviour may change in future implementations the current code will simply return NULL. Using the above example, say the user requests 250 bytes. The msys code chooses the appropriate pool (i.e. the 256 byte mbuf pool) and attempts to allocate an mbuf from that pool. If that pool is empty, NULL is returned even though the 32 and 2048 byte pools are not empty.  Note that no added descriptions on how to use the msys API are presented here (other than in the API descriptions themselves) as the msys API is used in exactly the same manner as the mbuf API. The only difference is that mbuf pools are added to msys by calling  os_msys_register().", 
            "title": "Msys"
        }, 
        {
            "location": "/os/core_os/msys/msys/#list-of-functions", 
            "text": "The functions available in msys are:   os_msys_get  os_msys_get_pkthdr  os_msys_register  os_msys_reset", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_get/", 
            "text": "os_msys_get\n\n\nstruct\n \nos_mbuf\n \n*os_msys_get\n(\nuint16_t\n \ndsize\n, \nuint16_t\n \nleadingspace\n)\n\n\n\n\n\nRetrieve an mbuf from the system mbuf pools with \nleadingspace\n bytes available in the mbuf.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndsize\n\n\nMinimum requested size of mbuf. Actual mbuf allocated may not accommodate \ndsize\n\n\n\n\n\n\nleadingspace\n\n\nNumber of bytes for leading space in mbuf (space at start of mbuf)\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nPointer to mbuf or NULL if no mbufs were available.\n\n\n\n\nNotes\n\n\nAs described in the overview section, \nos_msys_get()\n may return an mbuf that is smaller than dsize, meaning that the mbuf user data buffer does not have enough contiguous space to hold \ndsize\n bytes.\n\n\nThis API will not return an mbuf from a larger mbuf pool if the appropriate msys mbuf pool is empty. See the overview for more information.\n\n\n\n\nExample\n\n\n    \nstruct\n \nos_mbuf\n \n*om\n;\n\n    \n/* Allocate an mbuf with hopefully at least 100 bytes in its user data buffer */\n\n    \nom\n \n=\n \nos_msys_get\n(\n100\n, \n0\n);\n    \nif\n (\n!om\n) {\n        \n/* No mbufs available. */\n\n        \nreturn\n \n-\n1\n;\n    }\n}", 
            "title": "os_msys_get"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_get/#os_msys_get", 
            "text": "struct   os_mbuf   *os_msys_get ( uint16_t   dsize ,  uint16_t   leadingspace )  Retrieve an mbuf from the system mbuf pools with  leadingspace  bytes available in the mbuf.", 
            "title": "os_msys_get"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_get/#arguments", 
            "text": "Arguments  Description      dsize  Minimum requested size of mbuf. Actual mbuf allocated may not accommodate  dsize    leadingspace  Number of bytes for leading space in mbuf (space at start of mbuf)", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_get/#returned-values", 
            "text": "Pointer to mbuf or NULL if no mbufs were available.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_get/#notes", 
            "text": "As described in the overview section,  os_msys_get()  may return an mbuf that is smaller than dsize, meaning that the mbuf user data buffer does not have enough contiguous space to hold  dsize  bytes.  This API will not return an mbuf from a larger mbuf pool if the appropriate msys mbuf pool is empty. See the overview for more information.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_get/#example", 
            "text": "struct   os_mbuf   *om ;\n\n     /* Allocate an mbuf with hopefully at least 100 bytes in its user data buffer */ \n     om   =   os_msys_get ( 100 ,  0 );\n     if  ( !om ) {\n         /* No mbufs available. */ \n         return   - 1 ;\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_get_pkthdr/", 
            "text": "os_msys_get_pkthdr\n\n\nstruct\n \nos_mbuf\n \n*os_msys_get_pkthdr\n(\nuint16_t\n \ndsize\n, \nuint16_t\n \nuser_hdr_len\n)\n\n\n\n\n\nRetrieve a packet header mbuf from the system mbuf pools with \nuser_hdr_len\n bytes available for the user header in the mbuf.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndsize\n\n\nMinimum requested size of mbuf. Actual mbuf allocated may not accommodate \ndsize\n\n\n\n\n\n\nuser_hdr_len\n\n\nSize, in of bytes, of user header in the mbuf\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nPointer to mbuf or NULL if no mbufs were available.\n\n\n\n\nNotes\n\n\nThe same notes apply to this API as to \nos_msys_get()\n.\n\n\n\n\nExample\n\n\n    \nstruct\n \nos_mbuf\n \n*om\n;\n    \nstruct\n \nmy_user_hdr_struct\n \nmy_usr_hdr\n;\n\n    \n/*\n\n\n     * Allocate an mbuf with hopefully at least 100 bytes in its user data buffer\n\n\n     * and that has a user header of size sizeof(struct my_user_hdr_struct)\n\n\n     */\n\n    \nom\n \n=\n \nos_msys_get_pkthdr\n(\n100\n, \nsizeof\n(\nstruct\n \nmy_user_hdr_struct\n));\n    \nif\n (\n!om\n) {\n        \n/* No mbufs available. */\n\n        \nreturn\n \n-\n1\n;\n    }\n}", 
            "title": "os_msys_get_pkthdr"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_get_pkthdr/#os_msys_get_pkthdr", 
            "text": "struct   os_mbuf   *os_msys_get_pkthdr ( uint16_t   dsize ,  uint16_t   user_hdr_len )  Retrieve a packet header mbuf from the system mbuf pools with  user_hdr_len  bytes available for the user header in the mbuf.", 
            "title": "os_msys_get_pkthdr"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_get_pkthdr/#arguments", 
            "text": "Arguments  Description      dsize  Minimum requested size of mbuf. Actual mbuf allocated may not accommodate  dsize    user_hdr_len  Size, in of bytes, of user header in the mbuf", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_get_pkthdr/#returned-values", 
            "text": "Pointer to mbuf or NULL if no mbufs were available.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_get_pkthdr/#notes", 
            "text": "The same notes apply to this API as to  os_msys_get() .", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_get_pkthdr/#example", 
            "text": "struct   os_mbuf   *om ;\n     struct   my_user_hdr_struct   my_usr_hdr ;\n\n     /*       * Allocate an mbuf with hopefully at least 100 bytes in its user data buffer       * and that has a user header of size sizeof(struct my_user_hdr_struct)       */ \n     om   =   os_msys_get_pkthdr ( 100 ,  sizeof ( struct   my_user_hdr_struct ));\n     if  ( !om ) {\n         /* No mbufs available. */ \n         return   - 1 ;\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_register/", 
            "text": "os_msys_register\n\n\nint\n \nos_msys_register\n(\nstruct\n \nos_mbuf_pool\n \n*new_pool\n) \n\n\n\n\n\nRegister an mbuf pool for use as a system mbuf pool. The pool should be initialized prior to registration.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnew_pool\n\n\nPointer to mbuf pool to add to system mbuf pools\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\n0 on success; all other values indicate an error.\n\n\n\n\nExample\n\n\n    \nrc\n \n=\n \nos_msys_register\n(\ng_mbuf_pool\n);\n    \nassert\n(\nrc\n \n==\n \n0\n);", 
            "title": "os_msys_register"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_register/#os_msys_register", 
            "text": "int   os_msys_register ( struct   os_mbuf_pool   *new_pool )   Register an mbuf pool for use as a system mbuf pool. The pool should be initialized prior to registration.", 
            "title": "os_msys_register"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_register/#arguments", 
            "text": "Arguments  Description      new_pool  Pointer to mbuf pool to add to system mbuf pools", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_register/#returned-values", 
            "text": "0 on success; all other values indicate an error.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_register/#example", 
            "text": "rc   =   os_msys_register ( g_mbuf_pool );\n     assert ( rc   ==   0 );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_reset/", 
            "text": "os_msys_reset\n\n\nvoid\n \nos_msys_reset\n(\nvoid\n) \n\n\n\n\n\nResets msys module. This de-registers all pools from msys but does nothing to the pools themselves (they still exist as mbuf pools).\n\n\n\n\nArguments\n\n\nNone\n\n\n\n\nReturned values\n\n\nNone\n\n\n\n\nExample\n\n\n    \nos_msys_reset\n();", 
            "title": "os_msys_reset"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_reset/#os_msys_reset", 
            "text": "void   os_msys_reset ( void )   Resets msys module. This de-registers all pools from msys but does nothing to the pools themselves (they still exist as mbuf pools).", 
            "title": "os_msys_reset"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_reset/#arguments", 
            "text": "None", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_reset/#returned-values", 
            "text": "None", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/msys/os_msys_reset/#example", 
            "text": "os_msys_reset ();", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mqueue/mqueue/", 
            "text": "Mqueue\n\n\nMqueue (Mbuf event queue) is a set of API built on top of the mbuf and event queue code. A typical networking stack operation is to put a packet on a queue and post an event to the task handling that queue. Mqueue was designed to provide a common API so that individual packages would not each have to create similar code.\n\n\nThe mqueue data structure consists of a queue head pointer (a \"stailq\" queue; a singly linked list with head structure having a pointer to the start and end of the list) and an os event structure. Packets (packet header mbufs) are added to the queue using the \nomp_next\n pointer in the \nos_mbuf_pkthdr\n structure of the mbuf. The event is used to post to the task an event of type OS_EVENT_T_MQUEUE_DATA. \n\n\n  \n\n\nUsing Mqueue\n\n\nThe following code sample will demonstrate how to use an mqueue. This is a simple example where packets are put on a \"receive queue\" and a task processes that \"receive queue\" by incrementing the total number of packet received and then freeing the packet. Not shown in the code example is a call my_task_rx_data_func. Presumably, some other code will call this API. \n\n\n\n\nuint32_t\n \npkts_rxd\n;\n\nstruct\n \nos_mqueue\n \nrxpkt_q\n;\n\nstruct\n \nos_eventq\n \nmy_task_evq\n;\n\n\nvoid\n\n\nprocess_rx_data_queue\n(\nvoid\n)\n{\n    \nstruct\n \nos_mbuf\n \n*om\n;\n\n    \n/* Drain all packets off queue and process them */\n\n    \nwhile\n ((\nom\n \n=\n \nos_mqueue_get\n(\nrxpkt_q\n)) \n!=\n \nNULL\n) {\n        \n++pkts_rxd\n;\n        \nos_mbuf_free_chain\n(\nom\n);\n    }\n}\n\n\nint\n\n\nmy_task_rx_data_func\n(\nstruct\n \nos_mbuf\n \n*om\n)\n{\n    \nint\n \nrc\n;\n\n    \nrc\n \n=\n \nos_mqueue_put\n(\nrxpkt_q\n, \nmy_task_evq\n, \nom\n);\n    \nif\n (\nrc\n \n!=\n \n0\n) {\n        \nreturn\n \n-\n1\n;\n    }\n\n    \nreturn\n \n0\n;\n}\n\n\nvoid\n\n\nmy_task_handler\n(\nvoid\n \n*arg\n)\n{\n    \nstruct\n \nos_event\n \n*ev\n;\n    \nstruct\n \nos_callout_func\n \n*cf\n;\n    \nint\n \nrc\n;\n\n    \n/* Initialize eventq */\n\n    \nos_eventq_init\n(\nmy_task_evq\n);\n\n    \n/* Initialize mqueue */\n\n    \nos_mqueue_init\n(\nrxpkt_q\n, \nNULL\n);\n\n    \nwhile\n (\n1\n) {\n        \nev\n \n=\n \nos_eventq_get\n(\nmy_task_evq\n);\n        \nswitch\n (\nev-\nev_type\n) {\n\n        \ncase\n \nOS_EVENT_T_MQUEUE_DATA\n:\n            \nprocess_rx_data_queue\n();\n            \nbreak\n;\n\n        \ndefault\n:\n\n            \nassert\n(\n0\n);\n            \nbreak\n;\n        }\n    }\n}\n\n\n\n\n\nData Structures\n\n\nstruct\n \nos_mqueue\n {\n    \nSTAILQ_HEAD\n(, \nos_mbuf_pkthdr\n) \nmq_head\n;\n    \nstruct\n \nos_event\n \nmq_ev\n;\n};\n\n\n\n\n\n\n\nList of Functions\n\n\nThe functions available in Mqueue are:\n\n\n\n\nos_mqueue_init\n\n\nos_mqueue_get\n\n\nos_mqueue_put", 
            "title": "toc"
        }, 
        {
            "location": "/os/core_os/mqueue/mqueue/#mqueue", 
            "text": "Mqueue (Mbuf event queue) is a set of API built on top of the mbuf and event queue code. A typical networking stack operation is to put a packet on a queue and post an event to the task handling that queue. Mqueue was designed to provide a common API so that individual packages would not each have to create similar code.  The mqueue data structure consists of a queue head pointer (a \"stailq\" queue; a singly linked list with head structure having a pointer to the start and end of the list) and an os event structure. Packets (packet header mbufs) are added to the queue using the  omp_next  pointer in the  os_mbuf_pkthdr  structure of the mbuf. The event is used to post to the task an event of type OS_EVENT_T_MQUEUE_DATA.", 
            "title": "Mqueue"
        }, 
        {
            "location": "/os/core_os/mqueue/mqueue/#using-mqueue", 
            "text": "The following code sample will demonstrate how to use an mqueue. This is a simple example where packets are put on a \"receive queue\" and a task processes that \"receive queue\" by incrementing the total number of packet received and then freeing the packet. Not shown in the code example is a call my_task_rx_data_func. Presumably, some other code will call this API.    uint32_t   pkts_rxd ; struct   os_mqueue   rxpkt_q ; struct   os_eventq   my_task_evq ; void  process_rx_data_queue ( void )\n{\n     struct   os_mbuf   *om ;\n\n     /* Drain all packets off queue and process them */ \n     while  (( om   =   os_mqueue_get ( rxpkt_q ))  !=   NULL ) {\n         ++pkts_rxd ;\n         os_mbuf_free_chain ( om );\n    }\n} int  my_task_rx_data_func ( struct   os_mbuf   *om )\n{\n     int   rc ;\n\n     rc   =   os_mqueue_put ( rxpkt_q ,  my_task_evq ,  om );\n     if  ( rc   !=   0 ) {\n         return   - 1 ;\n    }\n\n     return   0 ;\n} void  my_task_handler ( void   *arg )\n{\n     struct   os_event   *ev ;\n     struct   os_callout_func   *cf ;\n     int   rc ;\n\n     /* Initialize eventq */ \n     os_eventq_init ( my_task_evq );\n\n     /* Initialize mqueue */ \n     os_mqueue_init ( rxpkt_q ,  NULL );\n\n     while  ( 1 ) {\n         ev   =   os_eventq_get ( my_task_evq );\n         switch  ( ev- ev_type ) {\n\n         case   OS_EVENT_T_MQUEUE_DATA :\n             process_rx_data_queue ();\n             break ;\n\n         default : \n             assert ( 0 );\n             break ;\n        }\n    }\n}", 
            "title": "Using Mqueue"
        }, 
        {
            "location": "/os/core_os/mqueue/mqueue/#data-structures", 
            "text": "struct   os_mqueue  {\n     STAILQ_HEAD (,  os_mbuf_pkthdr )  mq_head ;\n     struct   os_event   mq_ev ;\n};", 
            "title": "Data Structures"
        }, 
        {
            "location": "/os/core_os/mqueue/mqueue/#list-of-functions", 
            "text": "The functions available in Mqueue are:   os_mqueue_init  os_mqueue_get  os_mqueue_put", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/core_os/mqueue/os_mqueue_init/", 
            "text": "os_mqueue_init\n\n\nint\n \nos_mqueue_init\n(\nstruct\n \nos_mqueue\n \n*mq\n, \nvoid\n \n*arg\n)\n\n\n\n\n\nInitializes an queue. Sets the event argument in the os event of the mqueue to \narg\n. Sets type of event to OS_EVENT_T_MQUEUE_DATA.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmq\n\n\nPointer to a mqueue structure\n\n\n\n\n\n\narg\n\n\nEvent argument\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\n0: success. All other values indicate an error\n\n\n\n\nExample\n\n\n/* Declare mqueue */\n\n\nstruct\n \nos_mqueue\n \nrxpkt_q\n;\n\n\n/* Initialize mqueue */\n\n\nos_mqueue_init\n(\nrxpkt_q\n, \nNULL\n);", 
            "title": "os_mqueue_init"
        }, 
        {
            "location": "/os/core_os/mqueue/os_mqueue_init/#os_mqueue_init", 
            "text": "int   os_mqueue_init ( struct   os_mqueue   *mq ,  void   *arg )  Initializes an queue. Sets the event argument in the os event of the mqueue to  arg . Sets type of event to OS_EVENT_T_MQUEUE_DATA.", 
            "title": "os_mqueue_init"
        }, 
        {
            "location": "/os/core_os/mqueue/os_mqueue_init/#arguments", 
            "text": "Arguments  Description      mq  Pointer to a mqueue structure    arg  Event argument", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mqueue/os_mqueue_init/#returned-values", 
            "text": "0: success. All other values indicate an error", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mqueue/os_mqueue_init/#example", 
            "text": "/* Declare mqueue */  struct   os_mqueue   rxpkt_q ; /* Initialize mqueue */  os_mqueue_init ( rxpkt_q ,  NULL );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mqueue/os_mqueue_get/", 
            "text": "os_mqueue_get\n\n\nstruct\n \nos_mbuf\n \n*os_mqueue_get\n(\nstruct\n \nos_mqueue\n \n*mq\n)\n\n\n\n\n\nRetrieves a packet off an Mqueue. Returns a pointer to the mbuf at the head of the mbuf chain. NULL if no packets are on the queue.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmq\n\n\nPointer to Mqueue structure\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nThe packet at the head of the queue or NULL if no packets are on the queue.\n\n\n\n\nExample\n\n\nuint32_t\n \npkts_rxd\n;\n\nstruct\n \nos_mqueue\n \nrxpkt_q\n;\n\n\nvoid\n\n\nprocess_rx_data_queue\n(\nvoid\n)\n{\n    \nstruct\n \nos_mbuf\n \n*om\n;\n\n    \n/* Drain all packets off queue and process them */\n\n    \nwhile\n ((\nom\n \n=\n \nos_mqueue_get\n(\nrxpkt_q\n)) \n!=\n \nNULL\n) {\n        \n++pkts_rxd\n;\n        \nos_mbuf_free_chain\n(\nom\n);\n    }\n}", 
            "title": "os_mqueue_get"
        }, 
        {
            "location": "/os/core_os/mqueue/os_mqueue_get/#os_mqueue_get", 
            "text": "struct   os_mbuf   *os_mqueue_get ( struct   os_mqueue   *mq )  Retrieves a packet off an Mqueue. Returns a pointer to the mbuf at the head of the mbuf chain. NULL if no packets are on the queue.", 
            "title": "os_mqueue_get"
        }, 
        {
            "location": "/os/core_os/mqueue/os_mqueue_get/#arguments", 
            "text": "Arguments  Description      mq  Pointer to Mqueue structure", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mqueue/os_mqueue_get/#returned-values", 
            "text": "The packet at the head of the queue or NULL if no packets are on the queue.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mqueue/os_mqueue_get/#example", 
            "text": "uint32_t   pkts_rxd ; struct   os_mqueue   rxpkt_q ; void  process_rx_data_queue ( void )\n{\n     struct   os_mbuf   *om ;\n\n     /* Drain all packets off queue and process them */ \n     while  (( om   =   os_mqueue_get ( rxpkt_q ))  !=   NULL ) {\n         ++pkts_rxd ;\n         os_mbuf_free_chain ( om );\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/mqueue/os_mqueue_put/", 
            "text": "os_mqueue_put\n\n\nint\n \nos_mqueue_put\n(\nstruct\n \nos_mqueue\n \n*mq\n, \nstruct\n \nos_eventq\n \n*evq\n, \nstruct\n \nos_mbuf\n \n*m\n)\n\n\n\n\n\nAdds a packet (i.e. packet header mbuf) to an mqueue. Post event to \nevq\n. \n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmq\n\n\nPointer to mqueue\n\n\n\n\n\n\nevq\n\n\nPointer to event queue where mqueue event should get posted\n\n\n\n\n\n\nm\n\n\nPointer to packet header mbuf\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\n0: success\n\n\nOS_EINVAL: the mbuf is not a packet header mbuf.\n\n\n\n\nExample\n\n\nint\n\n\nmy_task_rx_data_func\n(\nstruct\n \nos_mbuf\n \n*om\n)\n{\n    \nint\n \nrc\n;\n\n    \nrc\n \n=\n \nos_mqueue_put\n(\nrxpkt_q\n, \nmy_task_evq\n, \nom\n);\n    \nif\n (\nrc\n \n!=\n \n0\n) {\n        \nreturn\n \n-\n1\n;\n    }\n\n    \nreturn\n \n0\n;\n}", 
            "title": "os_mqueue_put"
        }, 
        {
            "location": "/os/core_os/mqueue/os_mqueue_put/#os_mqueue_put", 
            "text": "int   os_mqueue_put ( struct   os_mqueue   *mq ,  struct   os_eventq   *evq ,  struct   os_mbuf   *m )  Adds a packet (i.e. packet header mbuf) to an mqueue. Post event to  evq .", 
            "title": "os_mqueue_put"
        }, 
        {
            "location": "/os/core_os/mqueue/os_mqueue_put/#arguments", 
            "text": "Arguments  Description      mq  Pointer to mqueue    evq  Pointer to event queue where mqueue event should get posted    m  Pointer to packet header mbuf", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/mqueue/os_mqueue_put/#returned-values", 
            "text": "0: success  OS_EINVAL: the mbuf is not a packet header mbuf.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/mqueue/os_mqueue_put/#example", 
            "text": "int  my_task_rx_data_func ( struct   os_mbuf   *om )\n{\n     int   rc ;\n\n     rc   =   os_mqueue_put ( rxpkt_q ,  my_task_evq ,  om );\n     if  ( rc   !=   0 ) {\n         return   - 1 ;\n    }\n\n     return   0 ;\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/sanity/sanity/", 
            "text": "Sanity\n\n\nThe Sanity task is a software watchdog task, which runs periodically to check\nsystem state, and ensure that everything is still operating properly.\n\n\nIn a typical system design, there are multiple stages of watchdog: \n\n\n\n\n\n\nInternal Watchdog\n\n\n\n\n\n\nExternal Watchdog \n\n\n\n\n\n\nSanity Watchdog \n\n\n\n\n\n\nThe \nInternal Watchdog\n is typically an MCU watchdog, which is tickled in \nthe core of the OS.  The internal watchdog is tickled frequently, and is \nmeant to be an indicator the OS is running.\n\n\nThe \nExternal Watchdog\n is a watchdog that's typically run slower.  The \npurpose of an external watchdog is to provide the system with a hard reset\nwhen it has lost its mind.  \n\n\nThe \nSanity Watchdog\n is the least frequently run watchdog, and is meant as \nan application watchdog.  \n\n\nThis document is about the operation of the Mynewt Sanity Watchdog.\n\n\nDescription\n\n\nInitializing the Sanity Task\n\n\nThe Sanity Watchdog is a task in the Mynewt OS, which when enabled, runs \nevery \nsanity_seconds\n.  In order to enable the Sanity Watchdog task, \ncall the \nos_sanity_task_init()\n function.\n\n\nint\n \nos_sanity_task_init\n(\nint\n \nsanity_seconds\n);\n\n\n\n\n\nBy default, every operating system task provides the frequency it will \ncheck in with the sanity task, with the \nsanity_itvl\n parameter in the \n\nos_task_init()\n function:\n\n\nint\n \nos_task_init\n(\nstruct\n \nos_task\n \n*t\n, \nchar\n \n*name\n, \nos_task_func_t\n \nfunc\n, \n    \nvoid\n \n*arg\n, \nuint8_t\n \nprio\n, \nos_time_t\n \nsanity_itvl\n, \nos_stack_t\n \n*bottom\n,\n    \nuint16_t\n \nstack_size\n);\n\n\n\n\n\nsanity_itvl\n is the time in OS time ticks that the task being created \nmust register in with the sanity task.  \n\n\nChecking in with Sanity Task\n\n\nThe task must then register in with the sanity task every \nsanity_itvl\n \nseconds.  In order to do that, the task should call the \nos_sanity_task_checkin\n\nfunction, which will reset the sanity check associated with this task.\nHere is an example of a task that uses a callout to checkin with the \nsanity task every 50 seconds:\n\n\n#define TASK1_SANITY_CHECKIN_ITVL (50 * OS_TICKS_PER_SEC) \n\n\nstruct\n \nos_eventq\n \ntask1_evq\n;\n\n\nstatic\n \nvoid\n\n\ntask1\n(\nvoid\n \n*arg\n)\n{\n    \nstruct\n \nos_task\n \n*t\n;\n    \nstruct\n \nos_event\n \n*ev\n;\n    \nstruct\n \nos_callout\n \nc\n;\n\n    \n/* Get current OS task */\n\n    \nt\n \n=\n \nos_sched_get_current_task\n();\n\n    \n/* Initialize the event queue. */\n\n    \nos_eventq_init\n(\ntask1_evq\n);\n\n    \n/* Initialize the callout */\n\n    \nos_callout_init\n(\nc\n, \ntask1_evq\n, \nNULL\n);\n\n    \n/* reset the callout to checkin with the sanity task \n\n\n     * in 50 seconds to kick off timing.\n\n\n     */\n\n    \nos_callout_reset\n(\nc\n, \nTASK1_SANITY_CHECKIN_ITVL\n);\n\n    \nwhile\n (\n1\n) {\n        \nev\n \n=\n \nos_eventq_get\n(\ntask1_evq\n);\n\n        \n/* The sanity timer has reset */\n\n        \nif\n (\nev-\nev_arg\n \n==\n \nc\n) {\n            \nos_sanity_task_checkin\n(\nt\n);\n        } \nelse\n {\n            \n/* not expecting any other events */\n\n            \nassert\n(\n0\n);\n        }\n    }\n\n    \n/* Should never reach */\n\n    \nassert\n(\n0\n);\n}\n\n\n\n\n\nRegistering a Custom Sanity Check\n\n\nIf a particular task wants to further hook into the sanity framework to \nperform other checks during the sanity task's operation, it can do so by\nregistering a \nstruct os_sanity_check\n using the \nos_sanity_check_register\n\nfunction.\n\n\nstatic\n \nint\n \n\nmymodule_perform_sanity_check\n(\nstruct\n \nos_sanity_check\n \n*sc\n, \nvoid\n \n*arg\n)\n{\n    \n/* Perform your checking here.  In this case, we check if there \n\n\n     * are available buffers in mymodule, and return 0 (all good)\n\n\n     * if true, and -1 (error) if not.\n\n\n     */\n\n    \nif\n (\nmymodule_has_buffers\n()) {\n        \nreturn\n (\n0\n);\n    } \nelse\n {\n        \nreturn\n (\n-\n1\n);\n    }\n}\n\n\nstatic\n \nint\n \n\nmymodule_register_sanity_check\n(\nvoid\n)\n{\n    \nstruct\n \nos_sanity_check\n \nsc\n;\n\n    \nos_sanity_check_init\n(\nsc\n);\n    \n/* Only assert() if mymodule_perform_sanity_check() fails 50 \n\n\n     * times.  SANITY_TASK_INTERVAL is defined by the user, and \n\n\n     * is the frequency at which the sanity_task runs in seconds.\n\n\n     */\n\n    \nOS_SANITY_CHECK_SETFUNC\n(\nsc\n, \nmymodule_perform_sanity_check\n, \nNULL\n, \n        \n50\n \n*\n \nSANITY_TASK_INTERVAL\n);\n\n    \nrc\n \n=\n \nos_sanity_check_register\n(\nsc\n);\n    \nif\n (\nrc\n \n!=\n \n0\n) {\n        \ngoto\n \nerr\n;\n    } \n\n    \nreturn\n (\n0\n);\n\nerr\n:\n    \nreturn\n (\nrc\n);\n}\n\n\n\n\n\nIn the above example, every time the custom sanity check \n\nmymodule_perform_sanity_check\n returns successfully (0), \nthe sanity check is reset.  In the \nOS_SANITY_CHECK_SETFUNC\n macro,\nthe sanity checkin interval is specified as 50 * SANITY_TASK_INTERVAL \n(which is the interval at which the sanity task runs.)  This means \nthat the \nmymodule_perform_sanity_check()\n function needs to fail\n50 times consecutively before the sanity task will crash the system.\n\n\nTIP:\n  When checking things like memory buffers, which can be temporarily \nbe exhausted, it's a good idea to have the sanity check fail multiple \nconsecutive times before crashing the system.  This will avoid crashing\nfor temporary failures.\n\n\nData structures\n\n\nOS Sanity Check\n\n\nstruct\n \nos_sanity_check\n {\n    \nos_time_t\n \nsc_checkin_last\n;\n    \nos_time_t\n \nsc_checkin_itvl\n;\n    \nos_sanity_check_func_t\n \nsc_func\n;\n    \nvoid\n \n*sc_arg\n; \n\n    \nSLIST_ENTRY\n(\nos_sanity_check\n) \nsc_next\n;\n};\n\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsc_checkin_last\n\n\nThe last time this sanity check checked in with the sanity task, in OS time ticks.\n\n\n\n\n\n\nsc_checkin_itvl\n\n\nHow frequently the sanity check is supposed to check in with the sanity task, in OS time ticks.\n\n\n\n\n\n\nsc_func\n\n\nIf not \nNULL\n, call this function when running the sanity task.  If the function returns 0, reset the sanity check.\n\n\n\n\n\n\nsc_arg\n\n\nArgument to pass to \nsc_func\n when calling it.\n\n\n\n\n\n\nsc_next\n\n\nSanity checks are chained in the sanity task when \nos_sanity_check_register()\n is called.\n\n\n\n\n\n\n\n\nList of Functions\n\n\nThe functions available in sanity are:\n\n\n\n\nos_sanity_check_init\n\n\nos_sanity_check_register\n\n\nos_sanity_check_reset\n\n\nos_sanity_task_checkin\n\n\nos_sanity_task_init", 
            "title": "toc"
        }, 
        {
            "location": "/os/core_os/sanity/sanity/#sanity", 
            "text": "The Sanity task is a software watchdog task, which runs periodically to check\nsystem state, and ensure that everything is still operating properly.  In a typical system design, there are multiple stages of watchdog:     Internal Watchdog    External Watchdog     Sanity Watchdog     The  Internal Watchdog  is typically an MCU watchdog, which is tickled in \nthe core of the OS.  The internal watchdog is tickled frequently, and is \nmeant to be an indicator the OS is running.  The  External Watchdog  is a watchdog that's typically run slower.  The \npurpose of an external watchdog is to provide the system with a hard reset\nwhen it has lost its mind.    The  Sanity Watchdog  is the least frequently run watchdog, and is meant as \nan application watchdog.    This document is about the operation of the Mynewt Sanity Watchdog.", 
            "title": "Sanity"
        }, 
        {
            "location": "/os/core_os/sanity/sanity/#description", 
            "text": "", 
            "title": "Description"
        }, 
        {
            "location": "/os/core_os/sanity/sanity/#initializing-the-sanity-task", 
            "text": "The Sanity Watchdog is a task in the Mynewt OS, which when enabled, runs \nevery  sanity_seconds .  In order to enable the Sanity Watchdog task, \ncall the  os_sanity_task_init()  function.  int   os_sanity_task_init ( int   sanity_seconds );  By default, every operating system task provides the frequency it will \ncheck in with the sanity task, with the  sanity_itvl  parameter in the  os_task_init()  function:  int   os_task_init ( struct   os_task   *t ,  char   *name ,  os_task_func_t   func , \n     void   *arg ,  uint8_t   prio ,  os_time_t   sanity_itvl ,  os_stack_t   *bottom ,\n     uint16_t   stack_size );  sanity_itvl  is the time in OS time ticks that the task being created \nmust register in with the sanity task.", 
            "title": "Initializing the Sanity Task"
        }, 
        {
            "location": "/os/core_os/sanity/sanity/#checking-in-with-sanity-task", 
            "text": "The task must then register in with the sanity task every  sanity_itvl  \nseconds.  In order to do that, the task should call the  os_sanity_task_checkin \nfunction, which will reset the sanity check associated with this task.\nHere is an example of a task that uses a callout to checkin with the \nsanity task every 50 seconds:  #define TASK1_SANITY_CHECKIN_ITVL (50 * OS_TICKS_PER_SEC)   struct   os_eventq   task1_evq ; static   void  task1 ( void   *arg )\n{\n     struct   os_task   *t ;\n     struct   os_event   *ev ;\n     struct   os_callout   c ;\n\n     /* Get current OS task */ \n     t   =   os_sched_get_current_task ();\n\n     /* Initialize the event queue. */ \n     os_eventq_init ( task1_evq );\n\n     /* Initialize the callout */ \n     os_callout_init ( c ,  task1_evq ,  NULL );\n\n     /* reset the callout to checkin with the sanity task        * in 50 seconds to kick off timing.       */ \n     os_callout_reset ( c ,  TASK1_SANITY_CHECKIN_ITVL );\n\n     while  ( 1 ) {\n         ev   =   os_eventq_get ( task1_evq );\n\n         /* The sanity timer has reset */ \n         if  ( ev- ev_arg   ==   c ) {\n             os_sanity_task_checkin ( t );\n        }  else  {\n             /* not expecting any other events */ \n             assert ( 0 );\n        }\n    }\n\n     /* Should never reach */ \n     assert ( 0 );\n}", 
            "title": "Checking in with Sanity Task"
        }, 
        {
            "location": "/os/core_os/sanity/sanity/#registering-a-custom-sanity-check", 
            "text": "If a particular task wants to further hook into the sanity framework to \nperform other checks during the sanity task's operation, it can do so by\nregistering a  struct os_sanity_check  using the  os_sanity_check_register \nfunction.  static   int   mymodule_perform_sanity_check ( struct   os_sanity_check   *sc ,  void   *arg )\n{\n     /* Perform your checking here.  In this case, we check if there        * are available buffers in mymodule, and return 0 (all good)       * if true, and -1 (error) if not.       */ \n     if  ( mymodule_has_buffers ()) {\n         return  ( 0 );\n    }  else  {\n         return  ( - 1 );\n    }\n} static   int   mymodule_register_sanity_check ( void )\n{\n     struct   os_sanity_check   sc ;\n\n     os_sanity_check_init ( sc );\n     /* Only assert() if mymodule_perform_sanity_check() fails 50        * times.  SANITY_TASK_INTERVAL is defined by the user, and        * is the frequency at which the sanity_task runs in seconds.       */ \n     OS_SANITY_CHECK_SETFUNC ( sc ,  mymodule_perform_sanity_check ,  NULL , \n         50   *   SANITY_TASK_INTERVAL );\n\n     rc   =   os_sanity_check_register ( sc );\n     if  ( rc   !=   0 ) {\n         goto   err ;\n    } \n\n     return  ( 0 ); err :\n     return  ( rc );\n}  In the above example, every time the custom sanity check  mymodule_perform_sanity_check  returns successfully (0), \nthe sanity check is reset.  In the  OS_SANITY_CHECK_SETFUNC  macro,\nthe sanity checkin interval is specified as 50 * SANITY_TASK_INTERVAL \n(which is the interval at which the sanity task runs.)  This means \nthat the  mymodule_perform_sanity_check()  function needs to fail\n50 times consecutively before the sanity task will crash the system.  TIP:   When checking things like memory buffers, which can be temporarily \nbe exhausted, it's a good idea to have the sanity check fail multiple \nconsecutive times before crashing the system.  This will avoid crashing\nfor temporary failures.", 
            "title": "Registering a Custom Sanity Check"
        }, 
        {
            "location": "/os/core_os/sanity/sanity/#data-structures", 
            "text": "", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/core_os/sanity/sanity/#os-sanity-check", 
            "text": "struct   os_sanity_check  {\n     os_time_t   sc_checkin_last ;\n     os_time_t   sc_checkin_itvl ;\n     os_sanity_check_func_t   sc_func ;\n     void   *sc_arg ; \n\n     SLIST_ENTRY ( os_sanity_check )  sc_next ;\n};     Element  Description      sc_checkin_last  The last time this sanity check checked in with the sanity task, in OS time ticks.    sc_checkin_itvl  How frequently the sanity check is supposed to check in with the sanity task, in OS time ticks.    sc_func  If not  NULL , call this function when running the sanity task.  If the function returns 0, reset the sanity check.    sc_arg  Argument to pass to  sc_func  when calling it.    sc_next  Sanity checks are chained in the sanity task when  os_sanity_check_register()  is called.", 
            "title": "OS Sanity Check"
        }, 
        {
            "location": "/os/core_os/sanity/sanity/#list-of-functions", 
            "text": "The functions available in sanity are:   os_sanity_check_init  os_sanity_check_register  os_sanity_check_reset  os_sanity_task_checkin  os_sanity_task_init", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_check_init/", 
            "text": "os_sanity_check_init\n\n\nint\n \nos_sanity_check_init\n(\nstruct\n \nos_sanity_check\n \n*sc\n)\n\n\n\n\n\nInitialize the sanity check pointed to by \nsc\n.  Sets default values, and ensures\nmemory is cleared out.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsc\n\n\nPointer to sanity check\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_OK\n: sanity check initialization is successful \n\n\nAll other error codes indicate an error.\n\n\n\n\nExample\n\n\n    \nint\n \nrc\n;\n\n    \nrc\n \n=\n \nos_sanity_task_check_init\n(\nmy_sanity_check\n); \n    \nassert\n(\nrc\n \n==\n \nOS_OK\n);", 
            "title": "os_sanity_check_init"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_check_init/#os_sanity_check_init", 
            "text": "int   os_sanity_check_init ( struct   os_sanity_check   *sc )  Initialize the sanity check pointed to by  sc .  Sets default values, and ensures\nmemory is cleared out.", 
            "title": " os_sanity_check_init"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_check_init/#arguments", 
            "text": "Arguments  Description      sc  Pointer to sanity check", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_check_init/#returned-values", 
            "text": "OS_OK : sanity check initialization is successful   All other error codes indicate an error.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_check_init/#example", 
            "text": "int   rc ;\n\n     rc   =   os_sanity_task_check_init ( my_sanity_check ); \n     assert ( rc   ==   OS_OK );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_check_register/", 
            "text": "os_sanity_check_register\n\n\nint\n \nos_sanity_check_register\n(\nstruct\n \nos_sanity_check\n \n*sc\n)\n\n\n\n\n\nRegister the sanity check pointed to by \nsc\n with the sanity task.  After registration\nthe sanity task will check this sanity check with every run of the sanity task.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsc\n\n\nPointer to sanity check\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_OK\n: sanity check successfully registered\n\n\nAll other error codes indicate an error.\n\n\n\n\nExample\n\n\n    \nint\n \nrc\n;\n\n    \nrc\n \n=\n \nos_sanity_check_register\n(\nmy_sc\n); \n    \nassert\n(\nrc\n \n==\n \nOS_OK\n);", 
            "title": "os_sanity_check_register"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_check_register/#os_sanity_check_register", 
            "text": "int   os_sanity_check_register ( struct   os_sanity_check   *sc )  Register the sanity check pointed to by  sc  with the sanity task.  After registration\nthe sanity task will check this sanity check with every run of the sanity task.", 
            "title": " os_sanity_check_register"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_check_register/#arguments", 
            "text": "Arguments  Description      sc  Pointer to sanity check", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_check_register/#returned-values", 
            "text": "OS_OK : sanity check successfully registered  All other error codes indicate an error.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_check_register/#example", 
            "text": "int   rc ;\n\n     rc   =   os_sanity_check_register ( my_sc ); \n     assert ( rc   ==   OS_OK );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_check_reset/", 
            "text": "os_sanity_check_reset\n\n\nint\n \nos_sanity_check_reset\n(\nstruct\n \nos_sanity_check\n \n*sc\n)\n\n\n\n\n\nReset the sanity check pointed to by sc.  This tells the sanity task that \nthis sanity check is considered valid for another \nsc_checkin_itvl\n time \nticks.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsc\n\n\nPointer to sanity check\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_OK\n: sanity check reset successful\n\n\nAll other error codes indicate an error.\n\n\n\n\nExample\n\n\n    \nint\n \nrc\n;\n\n    \nrc\n \n=\n \nos_sanity_check_reset\n(\nmy_sc\n); \n    \nassert\n(\nrc\n \n==\n \nOS_OK\n);", 
            "title": "os_sanity_check_reset"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_check_reset/#os_sanity_check_reset", 
            "text": "int   os_sanity_check_reset ( struct   os_sanity_check   *sc )  Reset the sanity check pointed to by sc.  This tells the sanity task that \nthis sanity check is considered valid for another  sc_checkin_itvl  time \nticks.", 
            "title": " os_sanity_check_reset"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_check_reset/#arguments", 
            "text": "Arguments  Description      sc  Pointer to sanity check", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_check_reset/#returned-values", 
            "text": "OS_OK : sanity check reset successful  All other error codes indicate an error.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_check_reset/#example", 
            "text": "int   rc ;\n\n     rc   =   os_sanity_check_reset ( my_sc ); \n     assert ( rc   ==   OS_OK );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_task_checkin/", 
            "text": "os_sanity_task_checkin\n\n\nint\n \nos_sanity_task_checkin\n(\nstruct\n \nos_task\n \n*t\n)\n\n\n\n\n\nUsed by a task to check in to the sanity task. This informs the sanity task that \n\ntask\n is still alive and working normally.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt\n\n\nPointer to task\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_OK\n: sanity check-in successful\n\n\nAll other error codes indicate an error.\n\n\n\n\nExample\n\n\n    \nint\n \nrc\n;\n\n    \nrc\n \n=\n \nos_sanity_task_checkin\n(\nmy_task\n); \n    \nassert\n(\nrc\n \n==\n \nOS_OK\n);", 
            "title": "os_sanity_task_checkin"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_task_checkin/#os_sanity_task_checkin", 
            "text": "int   os_sanity_task_checkin ( struct   os_task   *t )  Used by a task to check in to the sanity task. This informs the sanity task that  task  is still alive and working normally.", 
            "title": " os_sanity_task_checkin"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_task_checkin/#arguments", 
            "text": "Arguments  Description      t  Pointer to task", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_task_checkin/#returned-values", 
            "text": "OS_OK : sanity check-in successful  All other error codes indicate an error.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_task_checkin/#example", 
            "text": "int   rc ;\n\n     rc   =   os_sanity_task_checkin ( my_task ); \n     assert ( rc   ==   OS_OK );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_task_init/", 
            "text": "os_sanity_task_init\n\n\nint\n \nos_sanity_task_init\n(\nint\n \nnum_secs\n);\n\n\n\n\n\nInitialize the os sanity task.  \nnum_secs\n is the number of seconds to wait\nin between runs of the sanity task.\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnum_secs\n\n\nNumber of seconds to wait in between running sanity checks.\n\n\n\n\n\n\n\n\n\n\nReturned values\n\n\nOS_OK\n: Sanity task was successfully created.\n\n\nAll other error codes indicate an error.\n\n\n\n\nExample\n\n\n/* Run sanity checks every 50 seconds */\n\n\n\n#define SANITY_TASK_INTERVAL (50)\n\n    \nint\n \nrc\n;\n\n    \nrc\n \n=\n \nos_sanity_task_init\n(\nSANITY_TASK_INTERVAL\n); \n    \nassert\n(\nrc\n \n==\n \nOS_OK\n);", 
            "title": "os_sanity_task_init"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_task_init/#os_sanity_task_init", 
            "text": "int   os_sanity_task_init ( int   num_secs );  Initialize the os sanity task.   num_secs  is the number of seconds to wait\nin between runs of the sanity task.", 
            "title": " os_sanity_task_init"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_task_init/#arguments", 
            "text": "Arguments  Description      num_secs  Number of seconds to wait in between running sanity checks.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_task_init/#returned-values", 
            "text": "OS_OK : Sanity task was successfully created.  All other error codes indicate an error.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/sanity/os_sanity_task_init/#example", 
            "text": "/* Run sanity checks every 50 seconds */  #define SANITY_TASK_INTERVAL (50) \n     int   rc ;\n\n     rc   =   os_sanity_task_init ( SANITY_TASK_INTERVAL ); \n     assert ( rc   ==   OS_OK );", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/callout/callout/", 
            "text": "Callout\n\n\nCallouts are MyNewt OS timers.\n\n\nDescription\n\n\nCallout is a way of setting up an OS timer. When the timer fires, it is delivered as an event to task's event queue.\n\n\nUser would initialize their callout structure using \nos_callout_init()\n, or \nos_callout_func_init()\n and then arm it with \nos_callout_reset()\n.\n\n\nIf user wants to cancel the timer before it expires, they can either use \nos_callout_reset()\n to arm it for later expiry, or stop it altogether by calling \nos_callout_stop()\n.\n\n\nThere are 2 different options for data structure to use. First is \nstruct os_callout\n, which is a bare-bones version. You would initialize this with \nos_callout_init()\n.\n\n\nSecond option is \nstruct os_callout_func\n. This you can use if you expect to have multiple different types of timers in your task, running concurrently. The structure contains a function pointer, and you would call that function from your task's event processing loop.\n\n\nTime unit when arming the timer is OS ticks. This rate of this ticker depends on the platform this is running on. You should use OS define \nOS_TICKS_PER_SEC\n to convert wallclock time to OS  ticks.\n\n\nCallout timer fires out just once. For periodic timer type of operation you need to rearm it once it fires.\n\n\nData structures\n\n\nstruct os_callout {\n    struct os_event c_ev;\n    struct os_eventq *c_evq;\n    uint32_t c_ticks;\n    TAILQ_ENTRY(os_callout) c_next;\n};\n\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nc_ev\n\n\nEvent structure of this callout\n\n\n\n\n\n\nc_evq\n\n\nEvent queue where this callout is placed on timer expiry\n\n\n\n\n\n\nc_ticks\n\n\nOS tick amount when timer fires\n\n\n\n\n\n\nc_next\n\n\nLinkage to other unexpired callouts\n\n\n\n\n\n\n\n\nstruct os_callout_func {\n    struct os_callout cf_c;\n    os_callout_func_t cf_func;\n    void *cf_arg;\n};\n\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncf_c\n\n\nstruct os_callout. See above\n\n\n\n\n\n\ncf_func\n\n\nFunction pointer which should be called by event queue processing\n\n\n\n\n\n\ncf_arg\n\n\nGeneric void * argument to that function\n\n\n\n\n\n\n\n\nList of Functions\n\n\nThe functions available in callout are:\n\n\n\n\nos_callout_func_init\n\n\nos_callout_init\n\n\nos_callout_queued\n\n\nos_callout_reset\n\n\nos_callout_stop", 
            "title": "toc"
        }, 
        {
            "location": "/os/core_os/callout/callout/#callout", 
            "text": "Callouts are MyNewt OS timers.", 
            "title": "Callout"
        }, 
        {
            "location": "/os/core_os/callout/callout/#description", 
            "text": "Callout is a way of setting up an OS timer. When the timer fires, it is delivered as an event to task's event queue.  User would initialize their callout structure using  os_callout_init() , or  os_callout_func_init()  and then arm it with  os_callout_reset() .  If user wants to cancel the timer before it expires, they can either use  os_callout_reset()  to arm it for later expiry, or stop it altogether by calling  os_callout_stop() .  There are 2 different options for data structure to use. First is  struct os_callout , which is a bare-bones version. You would initialize this with  os_callout_init() .  Second option is  struct os_callout_func . This you can use if you expect to have multiple different types of timers in your task, running concurrently. The structure contains a function pointer, and you would call that function from your task's event processing loop.  Time unit when arming the timer is OS ticks. This rate of this ticker depends on the platform this is running on. You should use OS define  OS_TICKS_PER_SEC  to convert wallclock time to OS  ticks.  Callout timer fires out just once. For periodic timer type of operation you need to rearm it once it fires.", 
            "title": "Description"
        }, 
        {
            "location": "/os/core_os/callout/callout/#data-structures", 
            "text": "struct os_callout {\n    struct os_event c_ev;\n    struct os_eventq *c_evq;\n    uint32_t c_ticks;\n    TAILQ_ENTRY(os_callout) c_next;\n};     Element  Description      c_ev  Event structure of this callout    c_evq  Event queue where this callout is placed on timer expiry    c_ticks  OS tick amount when timer fires    c_next  Linkage to other unexpired callouts     struct os_callout_func {\n    struct os_callout cf_c;\n    os_callout_func_t cf_func;\n    void *cf_arg;\n};     Element  Description      cf_c  struct os_callout. See above    cf_func  Function pointer which should be called by event queue processing    cf_arg  Generic void * argument to that function", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/core_os/callout/callout/#list-of-functions", 
            "text": "The functions available in callout are:   os_callout_func_init  os_callout_init  os_callout_queued  os_callout_reset  os_callout_stop", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_func_init/", 
            "text": "os_callout_func_init \n\n\nvoid os_callout_func_init(struct os_callout_func *cf, struct os_eventq *evq, os_callout_func_t timo_func, void *ev_arg)\n\n\n\n\n\nInitializes the given \nstruct os_callout_func\n. Data structure is filled in with elements given as argument.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncf\n\n\nPointer to os_callout_func being initialized\n\n\n\n\n\n\nevq\n\n\nEvent queue where this gets delivered to\n\n\n\n\n\n\ntimo_func\n\n\nTimeout function. Event processing should call this\n\n\n\n\n\n\nev_arg\n\n\nGeneric argument for the event\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nThe same notes as with \nos_callout_init()\n.\n\n\nExample\n\n\n\n\nstruct os_callout_func g_native_cputimer;\nstruct os_eventq g_native_cputime_evq;\nvoid native_cputimer_cb(void *arg);\n\n    /* Initialize the callout function */\n    os_callout_func_init(\ng_native_cputimer,\n                     \ng_native_cputime_evq,\n                     native_cputimer_cb,\n                     NULL);", 
            "title": "os_callout_func_init"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_func_init/#os_callout_func_init", 
            "text": "void os_callout_func_init(struct os_callout_func *cf, struct os_eventq *evq, os_callout_func_t timo_func, void *ev_arg)  Initializes the given  struct os_callout_func . Data structure is filled in with elements given as argument.", 
            "title": " os_callout_func_init "
        }, 
        {
            "location": "/os/core_os/callout/os_callout_func_init/#arguments", 
            "text": "Arguments  Description      cf  Pointer to os_callout_func being initialized    evq  Event queue where this gets delivered to    timo_func  Timeout function. Event processing should call this    ev_arg  Generic argument for the event", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_func_init/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_func_init/#notes", 
            "text": "The same notes as with  os_callout_init() .", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_func_init/#example", 
            "text": "struct os_callout_func g_native_cputimer;\nstruct os_eventq g_native_cputime_evq;\nvoid native_cputimer_cb(void *arg);\n\n    /* Initialize the callout function */\n    os_callout_func_init( g_native_cputimer,\n                      g_native_cputime_evq,\n                     native_cputimer_cb,\n                     NULL);", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_init/", 
            "text": "os_callout_init \n\n\nvoid os_callout_init(struct os_callout *c, struct os_eventq *evq, void *ev_arg)\n\n\n\n\n\nInitializes \nstruct os_callout\n. Event type will be set to \nOS_EVENT_T_TIMER\n.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nc\n\n\nPointer to os_callout to initialize\n\n\n\n\n\n\nevq\n\n\nEvent queue where this gets delivered to\n\n\n\n\n\n\nev_arg\n\n\nGeneric argument which is filled in for the event\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nBe careful not to call this if the callout is armed, because that will mess up the list of pending callouts.\nOr if the timer has already fired, it will mess up the event queue where the callout was delivered to.\n\n\nExample\n\n\n\n\nstruct os_eventq my_evq;\nstruct os_callout my_callouts[8];\n\n    for (i = 0; i \n 8; i++) {\n        os_callout_init(\nmy_callouts[i], \nmy_evq, (void *)i);\n}", 
            "title": "os_callout_init"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_init/#os_callout_init", 
            "text": "void os_callout_init(struct os_callout *c, struct os_eventq *evq, void *ev_arg)  Initializes  struct os_callout . Event type will be set to  OS_EVENT_T_TIMER .", 
            "title": "os_callout_init "
        }, 
        {
            "location": "/os/core_os/callout/os_callout_init/#arguments", 
            "text": "Arguments  Description      c  Pointer to os_callout to initialize    evq  Event queue where this gets delivered to    ev_arg  Generic argument which is filled in for the event", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_init/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_init/#notes", 
            "text": "Be careful not to call this if the callout is armed, because that will mess up the list of pending callouts.\nOr if the timer has already fired, it will mess up the event queue where the callout was delivered to.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_init/#example", 
            "text": "struct os_eventq my_evq;\nstruct os_callout my_callouts[8];\n\n    for (i = 0; i   8; i++) {\n        os_callout_init( my_callouts[i],  my_evq, (void *)i);\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_queued/", 
            "text": "os_callout_queued\n\n\nint os_callout_queued(struct os_callout *c)\n\n\n\n\n\nTells whether the callout has been armed or not.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nc\n\n\nPointer to callout being checked\n\n\n\n\n\n\n\n\nReturned values\n\n\n0: timer is not armed\nnon-zero: timer is armed", 
            "title": "os_callout_queued"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_queued/#os_callout_queued", 
            "text": "int os_callout_queued(struct os_callout *c)  Tells whether the callout has been armed or not.", 
            "title": "os_callout_queued"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_queued/#arguments", 
            "text": "Arguments  Description      c  Pointer to callout being checked", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_queued/#returned-values", 
            "text": "0: timer is not armed\nnon-zero: timer is armed", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_reset/", 
            "text": "os_callout_reset \n\n\nvoid os_callout_reset(struct os_callout *c, int32_t timo)\n\n\n\n\n\nResets the callout to happen \ntimo\n in OS ticks.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nc\n\n\nPointer to os_callout being reset\n\n\n\n\n\n\ntimo\n\n\nOS ticks the timer is being set to\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nNotes\n\n\nExample\n\n\n\n\n/* Re-start the timer (run every 50 msecs) */\nos_callout_reset(\ng_bletest_timer.cf_c, OS_TICKS_PER_SEC / 20);", 
            "title": "os_callout_reset"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_reset/#os_callout_reset", 
            "text": "void os_callout_reset(struct os_callout *c, int32_t timo)  Resets the callout to happen  timo  in OS ticks.", 
            "title": " os_callout_reset "
        }, 
        {
            "location": "/os/core_os/callout/os_callout_reset/#arguments", 
            "text": "Arguments  Description      c  Pointer to os_callout being reset    timo  OS ticks the timer is being set to", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_reset/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_reset/#notes", 
            "text": "", 
            "title": "Notes"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_reset/#example", 
            "text": "/* Re-start the timer (run every 50 msecs) */\nos_callout_reset( g_bletest_timer.cf_c, OS_TICKS_PER_SEC / 20);", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_stop/", 
            "text": "os_callout_stop \n\n\nvoid os_callout_stop(struct os_callout *c)\n\n\n\n\n\nDisarms a timer.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nc\n\n\nPointer to os_callout being stopped\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nExample\n\n\nstruct os_callout_func g_native_cputimer;\n\n     os_callout_stop(\ng_native_cputimer.cf_c);", 
            "title": "os_callout_stop"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_stop/#os_callout_stop", 
            "text": "void os_callout_stop(struct os_callout *c)  Disarms a timer.", 
            "title": " os_callout_stop "
        }, 
        {
            "location": "/os/core_os/callout/os_callout_stop/#arguments", 
            "text": "Arguments  Description      c  Pointer to os_callout being stopped", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_stop/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/core_os/callout/os_callout_stop/#example", 
            "text": "struct os_callout_func g_native_cputimer;\n\n     os_callout_stop( g_native_cputimer.cf_c);", 
            "title": "Example"
        }, 
        {
            "location": "/os/core_os/porting/port_os/", 
            "text": "Porting Mynewt OS\n\n\nThis chapter describes how to adapt the Mynewt OS to different platforms. \n\n\nDescription\n\n\nThe Mynewt OS is a complete multi-tasking environment with scheduler, time \ncontrol, buffer management, and synchronization objects. it also includes \nlibraries and services like console, command shell, image manager, \nbootloader, and file systems etc.\n\n\nThee majority of this software is platform independent and requires no\nintervention to run on your platform, but some of the components require \nsupport from the underlying platform. \n\n\nThe platform dependency of these components can fall into several categories:\n\n\n\n\nCPU Core Dependencies\n -- Specific code or \nconfiguration to operate the CPU core within your target platform\n\n\nMCU Dependencies\n -- Specific code or configuration to operate the MCU or \nSoC within your target platform\n\n\nBSP Dependencies\n -- Specific code or configuration to accommodate the \nspecific layout and functionality of your target platform \n\n\n\n\nBSP Dependency\n\n\nWith all of the functionality provided by the core, MCU, and MCU HAL (Hardware Abstraction Layer), there are still some things that must be specified for your particular system. This \nis provided in Mynewt to allow you the flexibility to design for the exact\nfunctionality, peripherals and features that you require in your product.  \n\n\nIn Mynewt, these settings/components are included in a Board Support Package \n(BSP).  The BSP contains the information specific to running Mynewt on a target \nplatform or hardware board.  Mynewt supports some common open source hardware as well\nas the development boards for some common MCUs.  These development systems\nmight be enough for you to get your prototype up and running, but when building\na product you are likely going to have your own board which is slightly different\nfrom those already supported by Mynewt.\n\n\nFor example, you might decide on your system that 16 Kilobytes of flash space\nin one flash device is reserved for a flash file system.  Or on your system \nyou may decide that GPIO pin 5 of the MCU is connected to the system LED. Or\nyou may decide that the OS Tick (the underlying time source for the OS) should\nrun slower than the defaults to conserve battery power.  These types of \nbehaviors are specified in the BSP.  \n\n\nThe information provided in the BSP (what you need to specify to get a \ncomplete executable) can vary depending on the MCU and its underlying core\narchitecture.  For example, some MCUs have dedicated pins for UART, SPI etc,\nso there is no configuration required in the BSP when using these peripherals.\nHowever some MCUs have a pin multiplexor that allows the UART to be mapped to\nseveral different pins.  For these MCUs, the BSP must specify if and where\nthe UART pins should appear to match the hardware layout of your system.\n\n\n\n\nIf your BSP is already supported my Mynewt, there is no additional BSP work involved in porting to your platform.  You need only to set the \nbsp\n attribute in your Mynewt target using the \nnewt command tool\n. \n\n\nIf your BSP is not yet supported by Mynewt, you can add support following the instructions on \nhow to add BSP support to Mynewt\n\n\n\n\nMCU Dependency\n\n\nSome OS code depends on the MCU or SoC that the system contains. For example, the MCU may specify the potential memory map of the system - where code and data can reside.\n\n\n\n\nIf your MCU is already supported my Mynewt, there is no additional MCU work involved in porting to your platform.  You need only to set the \narch\n attribute in your Mynewt target using the \nnewt command tool\n. \n\n\nIf your MCU is not yet supported by Mynewt, you can add support following the instructions on\nhow to add MCU support to Mynewt\n\n\n\n\nMCU HAL\n\n\nMynewt's architecture supports a hardware abstraction layer (HAL) for common on or off-chip MCU peripherals such as GPIO, UARTs, flash memory etc.  Even if your MCU is supported for the core OS, you may find that you need to implement the HAL functionality for a new peripheral.   For a description of the HAL abstraction and implementation information,\nsee the \nHAL API\n\n\nCPU Core Dependency\n\n\nSome OS code depends on the CPU core that your system is using.  For example, a given CPU core has a specific assembly language instruction set, and may require special cross compiler or compiler settings to use the appropriate instruction set.  \n\n\n\n\nIf your CPU architecture is already supported my Mynewt, there is no CPU core work involved in porting to your platform.  You need only to set the  \narch\n and \ncompiler\n attributes in your Mynewt target using the \nnewt command tool\n. \n\n\nIf your CPU architecture is not supported by Mynewt, you can add support following the instructions on \nhow to add CPU architecture support to Mynewt", 
            "title": "toc"
        }, 
        {
            "location": "/os/core_os/porting/port_os/#porting-mynewt-os", 
            "text": "This chapter describes how to adapt the Mynewt OS to different platforms.", 
            "title": "Porting Mynewt OS"
        }, 
        {
            "location": "/os/core_os/porting/port_os/#description", 
            "text": "The Mynewt OS is a complete multi-tasking environment with scheduler, time \ncontrol, buffer management, and synchronization objects. it also includes \nlibraries and services like console, command shell, image manager, \nbootloader, and file systems etc.  Thee majority of this software is platform independent and requires no\nintervention to run on your platform, but some of the components require \nsupport from the underlying platform.   The platform dependency of these components can fall into several categories:   CPU Core Dependencies  -- Specific code or \nconfiguration to operate the CPU core within your target platform  MCU Dependencies  -- Specific code or configuration to operate the MCU or \nSoC within your target platform  BSP Dependencies  -- Specific code or configuration to accommodate the \nspecific layout and functionality of your target platform", 
            "title": "Description"
        }, 
        {
            "location": "/os/core_os/porting/port_os/#bsp-dependency", 
            "text": "With all of the functionality provided by the core, MCU, and MCU HAL (Hardware Abstraction Layer), there are still some things that must be specified for your particular system. This \nis provided in Mynewt to allow you the flexibility to design for the exact\nfunctionality, peripherals and features that you require in your product.    In Mynewt, these settings/components are included in a Board Support Package \n(BSP).  The BSP contains the information specific to running Mynewt on a target \nplatform or hardware board.  Mynewt supports some common open source hardware as well\nas the development boards for some common MCUs.  These development systems\nmight be enough for you to get your prototype up and running, but when building\na product you are likely going to have your own board which is slightly different\nfrom those already supported by Mynewt.  For example, you might decide on your system that 16 Kilobytes of flash space\nin one flash device is reserved for a flash file system.  Or on your system \nyou may decide that GPIO pin 5 of the MCU is connected to the system LED. Or\nyou may decide that the OS Tick (the underlying time source for the OS) should\nrun slower than the defaults to conserve battery power.  These types of \nbehaviors are specified in the BSP.    The information provided in the BSP (what you need to specify to get a \ncomplete executable) can vary depending on the MCU and its underlying core\narchitecture.  For example, some MCUs have dedicated pins for UART, SPI etc,\nso there is no configuration required in the BSP when using these peripherals.\nHowever some MCUs have a pin multiplexor that allows the UART to be mapped to\nseveral different pins.  For these MCUs, the BSP must specify if and where\nthe UART pins should appear to match the hardware layout of your system.   If your BSP is already supported my Mynewt, there is no additional BSP work involved in porting to your platform.  You need only to set the  bsp  attribute in your Mynewt target using the  newt command tool .   If your BSP is not yet supported by Mynewt, you can add support following the instructions on  how to add BSP support to Mynewt", 
            "title": "BSP Dependency"
        }, 
        {
            "location": "/os/core_os/porting/port_os/#mcu-dependency", 
            "text": "Some OS code depends on the MCU or SoC that the system contains. For example, the MCU may specify the potential memory map of the system - where code and data can reside.   If your MCU is already supported my Mynewt, there is no additional MCU work involved in porting to your platform.  You need only to set the  arch  attribute in your Mynewt target using the  newt command tool .   If your MCU is not yet supported by Mynewt, you can add support following the instructions on how to add MCU support to Mynewt", 
            "title": "MCU Dependency"
        }, 
        {
            "location": "/os/core_os/porting/port_os/#mcu-hal", 
            "text": "Mynewt's architecture supports a hardware abstraction layer (HAL) for common on or off-chip MCU peripherals such as GPIO, UARTs, flash memory etc.  Even if your MCU is supported for the core OS, you may find that you need to implement the HAL functionality for a new peripheral.   For a description of the HAL abstraction and implementation information,\nsee the  HAL API", 
            "title": "MCU HAL"
        }, 
        {
            "location": "/os/core_os/porting/port_os/#cpu-core-dependency", 
            "text": "Some OS code depends on the CPU core that your system is using.  For example, a given CPU core has a specific assembly language instruction set, and may require special cross compiler or compiler settings to use the appropriate instruction set.     If your CPU architecture is already supported my Mynewt, there is no CPU core work involved in porting to your platform.  You need only to set the   arch  and  compiler  attributes in your Mynewt target using the  newt command tool .   If your CPU architecture is not supported by Mynewt, you can add support following the instructions on  how to add CPU architecture support to Mynewt", 
            "title": "CPU Core Dependency"
        }, 
        {
            "location": "/os/core_os/porting/port_bsp/", 
            "text": "Create a BSP for your Target\n\n\nIntroduction\n\n\nIf you are using a board or system not currently supported by Mynewt, you will need to create a BSP for the new target.   If another similar BSP exists it is recommended to copy that BSP as a starting point.  For example, if another BSP exists using the same MCU, start with a copy of that BSP.\n\n\nEither way, this document describes the steps necessary to create a new BSP from scratch.  \n\n\nKeep your Reference Documents handy\n\n\nTo build a proper BSP, you will typically need the following:\n\n\n\n\nThe datasheet for the MCU you have chosen\n\n\nThe schematic of your board\n\n\nThe information on the CPU core within your MCU if it is not included in your MCU documentation\n\n\nThis Mynewt documentation\n\n\n\n\nName your BSP\n\n\nSelect a name for your BSP.  For the remainder of this document, we'll assume the bsp is named \nmyboard\n. In general its best to select a name that describes the board/system you are creating.\n\n\nCreate a BSP directory\n\n\nCreate a directory \nhw/bsp/myboard\n using the name chosen above. Within this BSP directory, create the following subdirectories:\n\n\nSelect a name for your BSP.  For the remainder of this document, \nwell assume the bsp is named \nmyboard\n. In general its best to select a \nname that describes the board/system you are creating.\n\n\n\n\ninclude\n\n\ninclude/bsp\n\n\nsrc\n\n\n\n\nCreate a Target using Mynewt\n\n\nCreate a newt target for your test project for the BSP. To learn how to create a target, see this \nhowto\n \nTutorial\n. Once you are familiar with creating targets, move on below to create a target to use to test your BSP.\n\n\nIt is recommended that you use a simple \nproject\n like \nblinky\n to minimize time to get a working Mynewt system.  For this document, we will assume the \ntarget\n is called \nmyboard_blinky\n and uses project \nblinky\n.  \n\n\nSet the \nbsp\n of the project to \n/hw/bsp/myboard\n. While creating your target, you will need to specify your \narch\nand \ncompiler\n. If your platform requires an architecture or compiler that are not defined in Mynewt, you will need to add them first.  To add a CPU architecture see \nCPU Porting\n.\n\n\nWhen you are complete, your \ntarget\n may look similar to this.\n\n\n    \n$newt\n \ntarget\n \nshow\n \n        \nmyboard_blinky\n\n            \narch=cortex_m0\n\n            \nbsp=hw/bsp/myboard\n\n            \ncompiler=arm-none-eabi-m0\n\n            \ncompiler_def=debug\n\n            \nname=myboard_blinky\n\n            \nproject=blinky\n\n\n\n\n\n\nCreate Required Files For Compilation\n\n\nCreate the following files within the BSP directory tree. For now, they can be empty files. We will fill them out one at a time.\n\n\n\n\n\n\n\n\nFile Path Name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLICENSE\n\n\nA File to present the source license for your BSP\n\n\n\n\n\n\nREADME.md\n\n\nA markdown file to write documentation for your BSP\n\n\n\n\n\n\npkg.yml\n\n\nA package file to describe your BSP contents\n\n\n\n\n\n\ninclude/bsp/bsp.h\n\n\nA header file to include definitions required by system from the BSP\n\n\n\n\n\n\nsrc/os_bsp.c\n\n\nA C source file to provide functions required by the OS from your BSP\n\n\n\n\n\n\nsrc/sbrk.c\n\n\nA C source file to memory from your heap to the OS\n\n\n\n\n\n\nsrc/libc_stubs.c\n\n\nA C source file to provide stubs/methods required by libc\n\n\n\n\n\n\nmyboard.ld\n\n\nA linker script to provide the memory map for your linked code\n\n\n\n\n\n\n\n\nOptionally, create these files as necessary to provide all functionality from Mynewt.\n\n\n\n\n\n\n\n\nFile Path Name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmyboard_boot.ld\n\n\nA linker script to provide the memory map for your bootloader\n\n\n\n\n\n\nmyboard_download.sh\n\n\nA bash script to download code into your platform\n\n\n\n\n\n\nmyboard_debug.sh\n\n\nA bash script to intiate a gdb session with your platform\n\n\n\n\n\n\nsrc/hal_bsp.c\n\n\nA C source file to provide functions required by the HAL from your BSP\n\n\n\n\n\n\n\n\nFill Out your Package File\n\n\nEdit the package file to describe your BSP. \n\n\nThe package file must contain:\n\n\n    \npkg\n.\nname\n: \nhw/bsp/myboard\n\n    \npkg\n.\nlinkerscript\n: \nmyboard.ld\n\n\n\n\n\n\n\n\n\n\n\n\nAttribute\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npkg.name\n\n\nThe name of your bsp package\n\n\n\n\n\n\npkg.linkerscript\n\n\nThe linker script that controls the memory placement of the compiled code sections from the Mynewt OS and your applications.\n\n\n\n\n\n\n\n\nThe linker script is a key component of the BSP and specifies where each section of code and data are stored within your CPU which can vary with the BSP depending on your chosen memory layout.  For a tutorial on writing linker scripts, see \nCreate or Copy Linker Script(s)\n.\n\n\nThe package file typically contains:\n\n\n    \npkg\n.\nlinkerscript\n.\nbootloader\n.\nOVERWRITE\n: \nmyboard_boot.ld\n\n    \npkg\n.\ndownloadscript\n: \nmyboard_download.sh\n\n    \npkg\n.\ndebugscript\n: \nmyboard_debug.sh\n\n    \npkg\n.\ndeps\n: \n    \n-\n \nhw/mcu/mymcu/variant\n\n\n\n\n\n\nwhere \nmymcu/variant\n should be replaced with the specific MCU and variant used in your design.\n\n\nThe following table describes additional attributes relevant to the BSP \npkg.yml\n file.\n\n\n\n\n\n\n\n\nAttribute\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npkg.linkerscript.bootloader.OVERWRITE\n\n\nA special linker for creating a bootloader for Mynewt\n\n\n\n\n\n\npkg.downloadscript\n\n\nA script that can download a flash image into your target platform\n\n\n\n\n\n\npkg.debugscript\n\n\nA script that can run the GDB debugger on your board\n\n\n\n\n\n\npkg.deps\n\n\nAny dependencies on your BSP\n\n\n\n\n\n\n\n\nThe BSP will invariably depend upon an MCU ( in this sample it's \nhw/mcu/mymcu/variant\n) since the Mynewt OS runs on an MCU within your target.  If your MCU is not supported by Mynewt, see \nMCU Porting\n for details on how to create an MCU in Mynewt.\n\n\nThe package file may also contain:\n\n\n    \npkg\n.\ncflags\n: \n-D__MY_SPECIAL_BSP_OPTIONS_\n\n    \npkg\n.\ndeps\n:\n    \n-\n \nlibs/cmsis-core\n\n\n\n\n\n\n\n\n\n\n\n\nAttribute\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npkg.cflags\n\n\nAny specific compiler flags for your bsp\n\n\n\n\n\n\npkg.deps\n\n\nAny other libraries that may be required.  Some architectures (like ARM) have special libraries to make BSP creation easier.\n\n\n\n\n\n\n\n\nCreate or Copy Linker Script\n\n\nIt's probably best to start with a linker script from another BSP using the same MCU.  If this is not available, consult your MCU documentation and library samples to find a linker script to start with.\n\n\nTypically, a linker script has to specify the following sections for code:\n\n\n\n\n.text -- the location and alignment of the memory section to store your code\n\n\n.data -- the location and alignment of the memory section to store initialized data\n\n\n.bss -- the location and alignment of the memory section to store uninitialized data\n\n\n.heap -- the location and alignment of the memory section to provide system memory\n\n\n\n\nThe linker script should specify the location and size of the different memory regions in your BSP and map the code sections described above into these regions.  \n\n\nThe linker script should also include an ENTRY point. This is used by the debugger to know where to start the program counter when the target is debugged.\n\n\nThere may be additional requirements from the MCU or OS that you may find easiest to place in the linker script. Some specific variables that the OS and MCU depends on are :\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n__bss_start__\n\n\na variable located at the start of the BSS section\n\n\n\n\n\n\n__bss_end__\n\n\na variable located at the end of the BSS section\n\n\n\n\n\n\n__isr_vector\n\n\nSome CPUs map their interrupt vectors. They may need to be specified in the linker\n\n\n\n\n\n\n_user_heap_start\n\n\nthe start of the heap for unallocated memory\n\n\n\n\n\n\n_user_heap_end\n\n\nthe end of the heap for unallocated memory\n\n\n\n\n\n\n\n\nCreate an alternate linker script for the bootloader since it is typically linked to use different addresses to boot the main image.  \n\n\nAdd Functions and Defines\n\n\nAt this point, it will be possible to run the \nnewt\n tool to build your target. \n\n\nYou may run into complaints from the linker script that a few Mynewt specific functions are missing.  We will describe these below.\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nos_bsp_init()\n\n\ncode to initialize the bsp\n\n\n\n\n\n\nos_bsp_systick_init()\n\n\ncode to setup the system tick for the OS\n\n\n\n\n\n\n\n\nThere are also several libc definitions that can be stubbed in your first BSP. Examples are \n_write\n, \n_read\n, etc. that can be found in \nlibc_stubs.c\n. But you \nmust\n implement the following function to provide memory to the OS and system.\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n_sbrk\n\n\nReturns memory from heap (used by malloc)\n\n\n\n\n\n\n\n\n\n\nImplement \n_sbrk()\n\n\n\n\nsbrk()\n is required by libc to get memory from the heap for things like malloc. Although not strongly BSP dependent, this is currently in the BSP to allow  flexibility in providing system memory.  See other BSPs for providing \nsbrk\n functionality.\n\n\n\n\nImplement \nos_bsp_init()\n\n\n\n\nos_bsp_init\n should initialize anything required by the OS by the BSP. Typically this is a very small set.  \n\n\nNOTE: Currently we are making calls to \n_sbrk()\n and \nclose(0)\n from \nos_bsp_init\n to get around a linker issue where some of libc is not getting included.  Please include this in your \nos_bsp_init\n.\n\n\n    \n/*\n\n\n     * XXX these references are here to keep the functions in for libc to find.\n\n\n     */\n\n    \n_sbrk\n(\n0\n);\n    \n_close\n(\n0\n);\n\n\n\n\n\n\n\nOther Unresolved Defines or Functions\n\n\n\n\nThere may be other unresolved defines or functions that are required by the specific MCU within your BSP. Below lists some sample defines.\n\n\n\n\n\n\n\n\nUndefined Variable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCONSOLE_UART_PORT\n\n\nWhich communications port on your target runs the console\n\n\n\n\n\n\nLED_BLINK_PIN\n\n\nwhich pin on your target runs the blinky LED\n\n\n\n\n\n\n\n\nThe set of missing functionality depends upon the libraries and dependencies you have included in the project.  That's why its best to keep your first project pretty simple then add incrementally.  For example, if you include Newtron file system, you will need to define a file system map for your BSP.\n\n\nMissing functionality may take the form of \n#define\n items required to compile, or they may take the form of missing functions.  \n\n\n\n\ncmsis_nvic.h\n\n\n\n\nIf you are using an ARM cortex architecture, you need to define the number of interrupts supported by your system.  If you are not using ARM Cortex architecture this may not be required (but something else might be).\n\n\nAdd Debug Script\n\n\nThe debug script in the bsp directory allows the newt tool to automatically connect to the debugger, and create a debug session with the target.  This requires knowledge of your target debug interface. Most of the Mynewt BSP targets use \nopenocd\n to perform debugging.  This script typically creates an openocd connection to the target and then connects a gdb instance to this openocd connection.  There are several examples in existing BSPs to follow.\n\n\nThe script must take a single argument which is the name of the image file minus the '.elf' suffix.\n\n\nThe BSP is complete without this file, but newt will be unable to establish a debug session without it.\n\n\nAdd Download Script\n\n\nSimilar to the debug script, the download script is a hook for newt to download the image to the target system.  The download script also typically uses openocd interface to erase flash, and progam the code into the device.\n\n\nNOTE: The download script needs to command openocd to program the image into the appropriate location, which is typically called \nFLASH_OFFSET\n in  these scripts. This location has to match the linker script location of the image link address.  For example, if your linker links the code to be run at \n0xC000\n your download script should download the image to the same\naddress in the correct flash.  \n\n\nAdd License and Documentation\n\n\nThe \nLICENSE\n file is an ASCII text file that describes the source license for this\npackage.\n\n\nThe \nREADME.md\n is a \nmarkdown\n\n file that contains any documentation you \nwant to provide for the BSP.", 
            "title": "BSP Porting"
        }, 
        {
            "location": "/os/core_os/porting/port_bsp/#create-a-bsp-for-your-target", 
            "text": "", 
            "title": "Create a BSP for your Target"
        }, 
        {
            "location": "/os/core_os/porting/port_bsp/#introduction", 
            "text": "If you are using a board or system not currently supported by Mynewt, you will need to create a BSP for the new target.   If another similar BSP exists it is recommended to copy that BSP as a starting point.  For example, if another BSP exists using the same MCU, start with a copy of that BSP.  Either way, this document describes the steps necessary to create a new BSP from scratch.", 
            "title": "Introduction"
        }, 
        {
            "location": "/os/core_os/porting/port_bsp/#keep-your-reference-documents-handy", 
            "text": "To build a proper BSP, you will typically need the following:   The datasheet for the MCU you have chosen  The schematic of your board  The information on the CPU core within your MCU if it is not included in your MCU documentation  This Mynewt documentation", 
            "title": "Keep your Reference Documents handy"
        }, 
        {
            "location": "/os/core_os/porting/port_bsp/#name-your-bsp", 
            "text": "Select a name for your BSP.  For the remainder of this document, we'll assume the bsp is named  myboard . In general its best to select a name that describes the board/system you are creating.", 
            "title": "Name your BSP"
        }, 
        {
            "location": "/os/core_os/porting/port_bsp/#create-a-bsp-directory", 
            "text": "Create a directory  hw/bsp/myboard  using the name chosen above. Within this BSP directory, create the following subdirectories:  Select a name for your BSP.  For the remainder of this document, \nwell assume the bsp is named  myboard . In general its best to select a \nname that describes the board/system you are creating.   include  include/bsp  src", 
            "title": "Create a BSP directory"
        }, 
        {
            "location": "/os/core_os/porting/port_bsp/#create-a-target-using-mynewt", 
            "text": "Create a newt target for your test project for the BSP. To learn how to create a target, see this  howto   Tutorial . Once you are familiar with creating targets, move on below to create a target to use to test your BSP.  It is recommended that you use a simple  project  like  blinky  to minimize time to get a working Mynewt system.  For this document, we will assume the  target  is called  myboard_blinky  and uses project  blinky .    Set the  bsp  of the project to  /hw/bsp/myboard . While creating your target, you will need to specify your  arch and  compiler . If your platform requires an architecture or compiler that are not defined in Mynewt, you will need to add them first.  To add a CPU architecture see  CPU Porting .  When you are complete, your  target  may look similar to this.       $newt   target   show  \n         myboard_blinky \n             arch=cortex_m0 \n             bsp=hw/bsp/myboard \n             compiler=arm-none-eabi-m0 \n             compiler_def=debug \n             name=myboard_blinky \n             project=blinky", 
            "title": "Create a Target using Mynewt"
        }, 
        {
            "location": "/os/core_os/porting/port_bsp/#create-required-files-for-compilation", 
            "text": "Create the following files within the BSP directory tree. For now, they can be empty files. We will fill them out one at a time.     File Path Name  Description      LICENSE  A File to present the source license for your BSP    README.md  A markdown file to write documentation for your BSP    pkg.yml  A package file to describe your BSP contents    include/bsp/bsp.h  A header file to include definitions required by system from the BSP    src/os_bsp.c  A C source file to provide functions required by the OS from your BSP    src/sbrk.c  A C source file to memory from your heap to the OS    src/libc_stubs.c  A C source file to provide stubs/methods required by libc    myboard.ld  A linker script to provide the memory map for your linked code     Optionally, create these files as necessary to provide all functionality from Mynewt.     File Path Name  Description      myboard_boot.ld  A linker script to provide the memory map for your bootloader    myboard_download.sh  A bash script to download code into your platform    myboard_debug.sh  A bash script to intiate a gdb session with your platform    src/hal_bsp.c  A C source file to provide functions required by the HAL from your BSP", 
            "title": "Create Required Files For Compilation"
        }, 
        {
            "location": "/os/core_os/porting/port_bsp/#fill-out-your-package-file", 
            "text": "Edit the package file to describe your BSP.   The package file must contain:       pkg . name :  hw/bsp/myboard \n     pkg . linkerscript :  myboard.ld      Attribute  Description      pkg.name  The name of your bsp package    pkg.linkerscript  The linker script that controls the memory placement of the compiled code sections from the Mynewt OS and your applications.     The linker script is a key component of the BSP and specifies where each section of code and data are stored within your CPU which can vary with the BSP depending on your chosen memory layout.  For a tutorial on writing linker scripts, see  Create or Copy Linker Script(s) .  The package file typically contains:       pkg . linkerscript . bootloader . OVERWRITE :  myboard_boot.ld \n     pkg . downloadscript :  myboard_download.sh \n     pkg . debugscript :  myboard_debug.sh \n     pkg . deps : \n     -   hw/mcu/mymcu/variant   where  mymcu/variant  should be replaced with the specific MCU and variant used in your design.  The following table describes additional attributes relevant to the BSP  pkg.yml  file.     Attribute  Description      pkg.linkerscript.bootloader.OVERWRITE  A special linker for creating a bootloader for Mynewt    pkg.downloadscript  A script that can download a flash image into your target platform    pkg.debugscript  A script that can run the GDB debugger on your board    pkg.deps  Any dependencies on your BSP     The BSP will invariably depend upon an MCU ( in this sample it's  hw/mcu/mymcu/variant ) since the Mynewt OS runs on an MCU within your target.  If your MCU is not supported by Mynewt, see  MCU Porting  for details on how to create an MCU in Mynewt.  The package file may also contain:       pkg . cflags :  -D__MY_SPECIAL_BSP_OPTIONS_ \n     pkg . deps :\n     -   libs/cmsis-core      Attribute  Description      pkg.cflags  Any specific compiler flags for your bsp    pkg.deps  Any other libraries that may be required.  Some architectures (like ARM) have special libraries to make BSP creation easier.", 
            "title": "Fill Out your Package File"
        }, 
        {
            "location": "/os/core_os/porting/port_bsp/#create-or-copy-linker-script", 
            "text": "It's probably best to start with a linker script from another BSP using the same MCU.  If this is not available, consult your MCU documentation and library samples to find a linker script to start with.  Typically, a linker script has to specify the following sections for code:   .text -- the location and alignment of the memory section to store your code  .data -- the location and alignment of the memory section to store initialized data  .bss -- the location and alignment of the memory section to store uninitialized data  .heap -- the location and alignment of the memory section to provide system memory   The linker script should specify the location and size of the different memory regions in your BSP and map the code sections described above into these regions.    The linker script should also include an ENTRY point. This is used by the debugger to know where to start the program counter when the target is debugged.  There may be additional requirements from the MCU or OS that you may find easiest to place in the linker script. Some specific variables that the OS and MCU depends on are :     Variable  Description      __bss_start__  a variable located at the start of the BSS section    __bss_end__  a variable located at the end of the BSS section    __isr_vector  Some CPUs map their interrupt vectors. They may need to be specified in the linker    _user_heap_start  the start of the heap for unallocated memory    _user_heap_end  the end of the heap for unallocated memory     Create an alternate linker script for the bootloader since it is typically linked to use different addresses to boot the main image.", 
            "title": "Create or Copy Linker Script"
        }, 
        {
            "location": "/os/core_os/porting/port_bsp/#add-functions-and-defines", 
            "text": "At this point, it will be possible to run the  newt  tool to build your target.   You may run into complaints from the linker script that a few Mynewt specific functions are missing.  We will describe these below.     Function  Description      os_bsp_init()  code to initialize the bsp    os_bsp_systick_init()  code to setup the system tick for the OS     There are also several libc definitions that can be stubbed in your first BSP. Examples are  _write ,  _read , etc. that can be found in  libc_stubs.c . But you  must  implement the following function to provide memory to the OS and system.     Function  Description      _sbrk  Returns memory from heap (used by malloc)      Implement  _sbrk()   sbrk()  is required by libc to get memory from the heap for things like malloc. Although not strongly BSP dependent, this is currently in the BSP to allow  flexibility in providing system memory.  See other BSPs for providing  sbrk  functionality.   Implement  os_bsp_init()   os_bsp_init  should initialize anything required by the OS by the BSP. Typically this is a very small set.    NOTE: Currently we are making calls to  _sbrk()  and  close(0)  from  os_bsp_init  to get around a linker issue where some of libc is not getting included.  Please include this in your  os_bsp_init .       /*       * XXX these references are here to keep the functions in for libc to find.       */ \n     _sbrk ( 0 );\n     _close ( 0 );   Other Unresolved Defines or Functions   There may be other unresolved defines or functions that are required by the specific MCU within your BSP. Below lists some sample defines.     Undefined Variable  Description      CONSOLE_UART_PORT  Which communications port on your target runs the console    LED_BLINK_PIN  which pin on your target runs the blinky LED     The set of missing functionality depends upon the libraries and dependencies you have included in the project.  That's why its best to keep your first project pretty simple then add incrementally.  For example, if you include Newtron file system, you will need to define a file system map for your BSP.  Missing functionality may take the form of  #define  items required to compile, or they may take the form of missing functions.     cmsis_nvic.h   If you are using an ARM cortex architecture, you need to define the number of interrupts supported by your system.  If you are not using ARM Cortex architecture this may not be required (but something else might be).", 
            "title": "Add Functions and Defines"
        }, 
        {
            "location": "/os/core_os/porting/port_bsp/#add-debug-script", 
            "text": "The debug script in the bsp directory allows the newt tool to automatically connect to the debugger, and create a debug session with the target.  This requires knowledge of your target debug interface. Most of the Mynewt BSP targets use  openocd  to perform debugging.  This script typically creates an openocd connection to the target and then connects a gdb instance to this openocd connection.  There are several examples in existing BSPs to follow.  The script must take a single argument which is the name of the image file minus the '.elf' suffix.  The BSP is complete without this file, but newt will be unable to establish a debug session without it.", 
            "title": "Add Debug Script"
        }, 
        {
            "location": "/os/core_os/porting/port_bsp/#add-download-script", 
            "text": "Similar to the debug script, the download script is a hook for newt to download the image to the target system.  The download script also typically uses openocd interface to erase flash, and progam the code into the device.  NOTE: The download script needs to command openocd to program the image into the appropriate location, which is typically called  FLASH_OFFSET  in  these scripts. This location has to match the linker script location of the image link address.  For example, if your linker links the code to be run at  0xC000  your download script should download the image to the same\naddress in the correct flash.", 
            "title": "Add Download Script"
        }, 
        {
            "location": "/os/core_os/porting/port_bsp/#add-license-and-documentation", 
            "text": "The  LICENSE  file is an ASCII text file that describes the source license for this\npackage.  The  README.md  is a  markdown \n file that contains any documentation you \nwant to provide for the BSP.", 
            "title": "Add License and Documentation"
        }, 
        {
            "location": "/os/core_os/porting/port_mcu/", 
            "text": "Porting Mynewt to a new MCU\n\n\nPorting Mynewt to a new MCU is not a difficult task if the core CPU architectures is already supported.\n\n\nThe depth of work depends on the amount of HAL (Hardware Abstraction Layer) support you need and provide in your port.\n\n\nTo get started:\n\n\n\n\nCreate a \nhw/mcu/mymcu\n directory where \nmymcu\n is the MCU you are porting to. Replace the name \nmymcu\n with a description of the MCU you are using.\n\n\nCreate a \nhw/mcu/mymcu/variant\n directory where the variant is the specific variant of the part you are usuing.  Many MCU parts have variants with different capabilities (RAM, FLASH etc) or different pinouts.  Replace \nvariant\n with a description of the variant of the part you are using.\n\n\nCreate a \nhw/mcu/mymcu/variant/pkg.yml\n file.  Copy from another mcu and fill out the relevant information\n\n\nCreate  \nhw/mcu/mymcu/variant/include\n,\nhw/mcu/mymcu/variant/include/mcu\n, and \n\nhw/mcu/mymcu/variant/src\n directories to contain the code for your mcu.\n\n\n\n\nAt this point there are two main tasks to complete.\n\n\n\n\nImplement any OS-specific code required by the OS\n\n\nImplement the HAL functionality that you are looking for\n\n\n\n\nPlease contact the Mynewt development list for help and advice porting to new MCU.", 
            "title": "MCU Porting"
        }, 
        {
            "location": "/os/core_os/porting/port_mcu/#porting-mynewt-to-a-new-mcu", 
            "text": "Porting Mynewt to a new MCU is not a difficult task if the core CPU architectures is already supported.  The depth of work depends on the amount of HAL (Hardware Abstraction Layer) support you need and provide in your port.  To get started:   Create a  hw/mcu/mymcu  directory where  mymcu  is the MCU you are porting to. Replace the name  mymcu  with a description of the MCU you are using.  Create a  hw/mcu/mymcu/variant  directory where the variant is the specific variant of the part you are usuing.  Many MCU parts have variants with different capabilities (RAM, FLASH etc) or different pinouts.  Replace  variant  with a description of the variant of the part you are using.  Create a  hw/mcu/mymcu/variant/pkg.yml  file.  Copy from another mcu and fill out the relevant information  Create   hw/mcu/mymcu/variant/include , hw/mcu/mymcu/variant/include/mcu , and  hw/mcu/mymcu/variant/src  directories to contain the code for your mcu.   At this point there are two main tasks to complete.   Implement any OS-specific code required by the OS  Implement the HAL functionality that you are looking for   Please contact the Mynewt development list for help and advice porting to new MCU.", 
            "title": "Porting Mynewt to a new MCU"
        }, 
        {
            "location": "/os/core_os/porting/port_cpu/", 
            "text": "Porting Mynewt to a new CPU Architecture\n\n\nA new CPU architecture typically requires the following:\n\n\n\n\nA new compiler\n\n\nNew architecture-specific code for the OS\n\n\nHelper libraries to help others porting to the same architecture\n\n\n\n\nThese are discussed below:\n\n\nCreate A New Compiler\n\n\nNOTE: Newt does not automatically install the compilers require to build all platforms.  Its up to the user using their local machines package manager to install the compilers.  The step described here just registers the compiler with newt.  \n\n\nCreate a new directory (named after the compiler you are adding). Copy the \npkg.yml\n file from another compiler.  \n\n\nEdit the \npkg.yml\n file and change the configuration attributes to match your compiler.  Most are self-explanatory paths to different compiler and linker tools.  There are a few configuration attributes worth noting.\n\n\n\n\n\n\n\n\nConfiguration Attributes\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npkg.keywords\n\n\nSpecific keywords to help others search for this using newt\n\n\n\n\n\n\ncompiler.flags.default\n\n\ndefault compiler flags for this architecture\n\n\n\n\n\n\ncompiler.flags.optimized\n\n\nadditional flags when the newt tool builds an optimized image\n\n\n\n\n\n\ncompiler.flags.debug\n\n\nadditional flags when the newt tool builds a debug image\n\n\n\n\n\n\n\n\nImplement architecture-specific OS code\n\n\nThere are several architecture-specific code functions that are required when implementing a new architecture.  You can find examples in the \nsim\n architecture within Mynewt.\n\n\nWhen porting to a new CPU architecture, use the existing architectures as samples when writing your implementation.\n\n\nPlease contact the Mynewt development list for help and advice portingto new MCU.", 
            "title": "CPU Porting"
        }, 
        {
            "location": "/os/core_os/porting/port_cpu/#porting-mynewt-to-a-new-cpu-architecture", 
            "text": "A new CPU architecture typically requires the following:   A new compiler  New architecture-specific code for the OS  Helper libraries to help others porting to the same architecture   These are discussed below:", 
            "title": "Porting Mynewt to a new CPU Architecture"
        }, 
        {
            "location": "/os/core_os/porting/port_cpu/#create-a-new-compiler", 
            "text": "NOTE: Newt does not automatically install the compilers require to build all platforms.  Its up to the user using their local machines package manager to install the compilers.  The step described here just registers the compiler with newt.    Create a new directory (named after the compiler you are adding). Copy the  pkg.yml  file from another compiler.    Edit the  pkg.yml  file and change the configuration attributes to match your compiler.  Most are self-explanatory paths to different compiler and linker tools.  There are a few configuration attributes worth noting.     Configuration Attributes  Description      pkg.keywords  Specific keywords to help others search for this using newt    compiler.flags.default  default compiler flags for this architecture    compiler.flags.optimized  additional flags when the newt tool builds an optimized image    compiler.flags.debug  additional flags when the newt tool builds a debug image", 
            "title": "Create A New Compiler"
        }, 
        {
            "location": "/os/core_os/porting/port_cpu/#implement-architecture-specific-os-code", 
            "text": "There are several architecture-specific code functions that are required when implementing a new architecture.  You can find examples in the  sim  architecture within Mynewt.  When porting to a new CPU architecture, use the existing architectures as samples when writing your implementation.  Please contact the Mynewt development list for help and advice portingto new MCU.", 
            "title": "Implement architecture-specific OS code"
        }, 
        {
            "location": "/os/modules/console/console/", 
            "text": "Console\n\n\nThe console is an operating system window where users interact with system programs of the operating system or a console application by entering text input (typically from a keyboard) and reading text output (typically on the computer terminal or monitor). The text written on the console brings some information and is a sequence of characters sent by the OS or programs running on the OS. \n\n\nSupport is currently available for console access via the serial port on the hardware board.\n\n\nDescription\n\n\nIn the Mynewt OS, the console library comes in two versions:\n\n\n\n\nfull - containing the full implementation\n\n\nstub - containing stubs for the API\n\n\n\n\nBoth of these have \npkg.yml\n file which states that they provide the \nconsole\n API. If a pkg uses this API, it should list \nconsole\n as a requirement.\nFor example, the shell pkg is defined by the following pkg.yml file:\n\n\n    pkg.name: libs/shell \n    pkg.vers: 0.1\n    pkg.deps:\n        - libs/os\n        - libs/util\n    pkg.reqs:\n        - console\n    pkg.identities:\n        - SHELL \n\n\n\n\n\nThe project .yml file decides which version of the console pkg should be included. \nIf project requires the full console capability it lists dependency \nlibs/console/full\n in its pkg.yml file. On the other hand, a project may not have a physical console (e.g. a UART port to connect a terminal to) but may have a dependency on a pkg that has console capability. In that case you would use a console stub. \n\n\nAnother example would be the bootloader project where we want to keep the size of the image small. It includes the \nlibs/os\n pkg that can print out messages on a console (e.g. if there is a hard fault) and the \nlibs/util\n pkg that uses full console (but only if SHELL is present to provide a CLI). However, we do not want to use any console I/O capability in this particular bootloader project to keep the size small. We simply use the console stub instead, and the pkg.yml file for the project boot pkg looks like the following:\n\n\n    project.name: boot\n    project.identities: bootloader\n    project.pkgs:\n        - libs/os\n        - libs/bootutil\n        - libs/nffs\n        - libs/console/stub\n        - libs/util \n\n\n\n\n\nConsole has 2 modes for transmit; \nblocking mode\n and \nnon-blocking mode\n. Usually the \nnon-blocking mode\n is the active one; the output buffer is drained by getting TX completion interrupts from hardware, and more data is added based on these interrupts.\n\nBlocking mode\n is used when we don't want TX completion interrupts. It is used when system crashes, and we still want to output info related to that crash.\n\n\nConsole, by default, echoes everything it receives back. Terminal programs expect this, and is a way for the user to know that the console is connected and responsive. Whether echoing happens or not can be controlled programmatically.\n\n\nData structures\n\n\nN/A\n\n\nList of Functions\n\n\nThe functions available in console are:\n\n\n\n\nconsole_blocking_mode\n\n\nconsole_echo\n\n\nconsole_init\n\n\nconsole_is_init\n\n\nconsole_printf\n\n\nconsole_read\n\n\nconsole_write", 
            "title": "toc"
        }, 
        {
            "location": "/os/modules/console/console/#console", 
            "text": "The console is an operating system window where users interact with system programs of the operating system or a console application by entering text input (typically from a keyboard) and reading text output (typically on the computer terminal or monitor). The text written on the console brings some information and is a sequence of characters sent by the OS or programs running on the OS.   Support is currently available for console access via the serial port on the hardware board.", 
            "title": "Console"
        }, 
        {
            "location": "/os/modules/console/console/#description", 
            "text": "In the Mynewt OS, the console library comes in two versions:   full - containing the full implementation  stub - containing stubs for the API   Both of these have  pkg.yml  file which states that they provide the  console  API. If a pkg uses this API, it should list  console  as a requirement.\nFor example, the shell pkg is defined by the following pkg.yml file:      pkg.name: libs/shell \n    pkg.vers: 0.1\n    pkg.deps:\n        - libs/os\n        - libs/util\n    pkg.reqs:\n        - console\n    pkg.identities:\n        - SHELL   The project .yml file decides which version of the console pkg should be included. \nIf project requires the full console capability it lists dependency  libs/console/full  in its pkg.yml file. On the other hand, a project may not have a physical console (e.g. a UART port to connect a terminal to) but may have a dependency on a pkg that has console capability. In that case you would use a console stub.   Another example would be the bootloader project where we want to keep the size of the image small. It includes the  libs/os  pkg that can print out messages on a console (e.g. if there is a hard fault) and the  libs/util  pkg that uses full console (but only if SHELL is present to provide a CLI). However, we do not want to use any console I/O capability in this particular bootloader project to keep the size small. We simply use the console stub instead, and the pkg.yml file for the project boot pkg looks like the following:      project.name: boot\n    project.identities: bootloader\n    project.pkgs:\n        - libs/os\n        - libs/bootutil\n        - libs/nffs\n        - libs/console/stub\n        - libs/util   Console has 2 modes for transmit;  blocking mode  and  non-blocking mode . Usually the  non-blocking mode  is the active one; the output buffer is drained by getting TX completion interrupts from hardware, and more data is added based on these interrupts. Blocking mode  is used when we don't want TX completion interrupts. It is used when system crashes, and we still want to output info related to that crash.  Console, by default, echoes everything it receives back. Terminal programs expect this, and is a way for the user to know that the console is connected and responsive. Whether echoing happens or not can be controlled programmatically.", 
            "title": "Description"
        }, 
        {
            "location": "/os/modules/console/console/#data-structures", 
            "text": "N/A", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/modules/console/console/#list-of-functions", 
            "text": "The functions available in console are:   console_blocking_mode  console_echo  console_init  console_is_init  console_printf  console_read  console_write", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/modules/console/console_blocking_mode/", 
            "text": "console_blocking_mode \n\n\n   void\n   console_blocking_mode(void)\n\n\n\n\n\nCalls the \nconsole_blocking_tx\n function to flush the buffered console output (transmit) queue. The function \nOS_ENTER_CRITICAL()\n is called to disable interrupts and \nOS_EXIT_CRITICAL()\n is called to enable interrupts back again once the buffer is flushed.\n\n\nArguments\n\n\nNone\n\n\nReturned values\n\n\nN/A\n\n\nExample\n\n\nHere is an example of calling \nconsole_blocking_mode\n and printing crash information from an assert to help debug.\n\n\nvoid\n_assert_func(const char *file, int line, const char *func, const char *e)\n{\n    int sr;\n\n    OS_ENTER_CRITICAL(sr);\n    (void)sr;\n    os_die_line = line;\n    os_die_module = file;\n    console_blocking_mode();\n    console_printf(\nAssert %s; failed in %s:%d\\n\n, e ? e : \n, file, line);\n    system_reset();\n}", 
            "title": "console_blocking_mode"
        }, 
        {
            "location": "/os/modules/console/console_blocking_mode/#console_blocking_mode", 
            "text": "void\n   console_blocking_mode(void)  Calls the  console_blocking_tx  function to flush the buffered console output (transmit) queue. The function  OS_ENTER_CRITICAL()  is called to disable interrupts and  OS_EXIT_CRITICAL()  is called to enable interrupts back again once the buffer is flushed.", 
            "title": " console_blocking_mode "
        }, 
        {
            "location": "/os/modules/console/console_blocking_mode/#arguments", 
            "text": "None", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/console/console_blocking_mode/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/console/console_blocking_mode/#example", 
            "text": "Here is an example of calling  console_blocking_mode  and printing crash information from an assert to help debug.  void\n_assert_func(const char *file, int line, const char *func, const char *e)\n{\n    int sr;\n\n    OS_ENTER_CRITICAL(sr);\n    (void)sr;\n    os_die_line = line;\n    os_die_module = file;\n    console_blocking_mode();\n    console_printf( Assert %s; failed in %s:%d\\n , e ? e :  , file, line);\n    system_reset();\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/console/console_echo/", 
            "text": "console_echo \n\n\n   void console_echo(int on)\n\n\n\n\n\nControls whether echoing is on or off for the console. When echoing is on, all characters received are transmitted back.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\non\n\n\n1 turns on echoing, 0 turns it off\n\n\n\n\n\n\n\n\nReturned values\n\n\nNone\n\n\nNotes\n\n\nExample\n\n\nHere is an example where newtmgr protocol handler is controlling whether echoing is on or off. Newtmgr, the tool, turns echoing off when it's transmitting large chunks of data to target board.\n\n\nstatic int\nnmgr_def_console_echo(struct nmgr_jbuf *njb)\n{\n    int echo_on = 1;\n    int rc;\n    struct json_attr_t attrs[3] = {\n        [0] = {\n            .attribute = \necho\n,\n            .type = t_integer,\n            .addr.integer = \necho_on,\n            .nodefault = 1\n        },\n        [1] = {\n            .attribute = NULL\n        }\n    };\n\n    rc = json_read_object(\nnjb-\nnjb_buf, attrs);\n    if (rc) {\n        return OS_EINVAL;\n    }\n\n    if (echo_on) {\n        console_echo(1);\n    } else {\n        console_echo(0);\n    }\n    return (0);\n}", 
            "title": "console_echo"
        }, 
        {
            "location": "/os/modules/console/console_echo/#console_echo", 
            "text": "void console_echo(int on)  Controls whether echoing is on or off for the console. When echoing is on, all characters received are transmitted back.", 
            "title": " console_echo "
        }, 
        {
            "location": "/os/modules/console/console_echo/#arguments", 
            "text": "Arguments  Description      on  1 turns on echoing, 0 turns it off", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/console/console_echo/#returned-values", 
            "text": "None", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/console/console_echo/#notes", 
            "text": "", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/console/console_echo/#example", 
            "text": "Here is an example where newtmgr protocol handler is controlling whether echoing is on or off. Newtmgr, the tool, turns echoing off when it's transmitting large chunks of data to target board.  static int\nnmgr_def_console_echo(struct nmgr_jbuf *njb)\n{\n    int echo_on = 1;\n    int rc;\n    struct json_attr_t attrs[3] = {\n        [0] = {\n            .attribute =  echo ,\n            .type = t_integer,\n            .addr.integer =  echo_on,\n            .nodefault = 1\n        },\n        [1] = {\n            .attribute = NULL\n        }\n    };\n\n    rc = json_read_object( njb- njb_buf, attrs);\n    if (rc) {\n        return OS_EINVAL;\n    }\n\n    if (echo_on) {\n        console_echo(1);\n    } else {\n        console_echo(0);\n    }\n    return (0);\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/console/console_init/", 
            "text": "console_init \n\n\n   int\n   console_init(console_rx_cb rx_cb)\n\n\n\n\n\nInitializes console receive buffer and calls hal funtions \nhal_uart_init_cbs\n and \nhal_uart_config\n to initialize serial port connection and configure it (e.g. baud rate, flow control etc.)\n\n\nCaller registers a function pointer of \ntype void (*console_rx_cb)(int full_line)\n. This function will be called when console receives either a) full line of data or b) when RX buffer in console is full. Note that this function is most likely getting called from interrupt context.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrx_cb\n\n\nFunction pointer, which gets called input is received.\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns 0 on success.\nNon-zero if HAL UART function calls fail.\n\n\nExample\n\n\nint\nmain(int argc, char **argv)\n{\n    ....\n\n    /* Init tasks */\n    shell_task_init(SHELL_TASK_PRIO, shell_stack, SHELL_TASK_STACK_SIZE,\n                         SHELL_MAX_INPUT_LEN);\n    console_init(shell_console_rx_cb);\n\n    ....\n}", 
            "title": "console_init"
        }, 
        {
            "location": "/os/modules/console/console_init/#console_init", 
            "text": "int\n   console_init(console_rx_cb rx_cb)  Initializes console receive buffer and calls hal funtions  hal_uart_init_cbs  and  hal_uart_config  to initialize serial port connection and configure it (e.g. baud rate, flow control etc.)  Caller registers a function pointer of  type void (*console_rx_cb)(int full_line) . This function will be called when console receives either a) full line of data or b) when RX buffer in console is full. Note that this function is most likely getting called from interrupt context.", 
            "title": " console_init "
        }, 
        {
            "location": "/os/modules/console/console_init/#arguments", 
            "text": "Arguments  Description      rx_cb  Function pointer, which gets called input is received.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/console/console_init/#returned-values", 
            "text": "Returns 0 on success.\nNon-zero if HAL UART function calls fail.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/console/console_init/#example", 
            "text": "int\nmain(int argc, char **argv)\n{\n    ....\n\n    /* Init tasks */\n    shell_task_init(SHELL_TASK_PRIO, shell_stack, SHELL_TASK_STACK_SIZE,\n                         SHELL_MAX_INPUT_LEN);\n    console_init(shell_console_rx_cb);\n\n    ....\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/console/console_is_init/", 
            "text": "console_is_init \n\n\n   int console_is_init(void)\n\n\n\n\n\nReturns whether console has been initialized or not. I.e. whether \nconsole_init()\n has been called yet.\n\n\nArguments\n\n\nNone\n\n\nReturned values\n\n\nReturns 1 if console has been initialized. 0 if not.\n\n\nExample\n\n\nstatic int\nlog_console_append(struct log *log, void *buf, int len)\n{\n    ....\n\n    if (!console_is_init()) {\n        return (0);\n    }\n\n    /* print log entry to console */\n    ....\n}", 
            "title": "console_is_init"
        }, 
        {
            "location": "/os/modules/console/console_is_init/#console_is_init", 
            "text": "int console_is_init(void)  Returns whether console has been initialized or not. I.e. whether  console_init()  has been called yet.", 
            "title": " console_is_init "
        }, 
        {
            "location": "/os/modules/console/console_is_init/#arguments", 
            "text": "None", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/console/console_is_init/#returned-values", 
            "text": "Returns 1 if console has been initialized. 0 if not.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/console/console_is_init/#example", 
            "text": "static int\nlog_console_append(struct log *log, void *buf, int len)\n{\n    ....\n\n    if (!console_is_init()) {\n        return (0);\n    }\n\n    /* print log entry to console */\n    ....\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/console/console_printf/", 
            "text": "console_printf\n\n\n    void\n    console_printf(const char *fmt, ...)\n\n\n\n\n\nWrites a formatted message instead of raw output to the console. It first composes a C string containing text specified as arguments to the function or containing the elements in the variable argument list passed to it using snprintf or vsnprintf, respectively. It then uses function \nconsole_write\n to output the formatted data (messages) on the console.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfmt\n\n\nPointer to C string that contains a format string that follows the same specifications as format in printf. The string is printed to console.\n\n\n\n\n\n\n...\n\n\nDepending on the format string, the function may expect either a sequence of additional arguments to be used to replace a format specifier in the format string or a variable arguments list. va_list is a special type defined in \n in stdarg.h.\n\n\n\n\n\n\n\n\nReturned values\n\n\nNone\n\n\nNotes\n\n\nWhile \nconsole_printf\n, with its well understood formatting options in C, is more convenient and easy on the eyes than the raw output of \nconsole_write\n, the associated code size is considerably larger.\n\n\nExample\n\n\nExample #1:\n\n\nchar adv_data_buf[32];\n\nvoid\ntask()\n{\n   char adv_data_buf[32];\n\n   console_printf(\n%s\n, adv_data_buf);\n}\n\n\n\n\n\nExample #2:\n\n\nstruct exception_frame {\n    uint32_t r0;\n    uint32_t r1;\n\nstruct trap_frame {\n    struct exception_frame *ef;\n    uint32_t r2;\n    uint32_t r3;\n};\n\nvoid\ntask(struct trap_frame *tf)\n{\n     console_printf(\n r0:%8.8x  r1:%8.8x\n, tf-\nef-\nr0, tf-\nef-\nr1);\n     console_printf(\n r8:%8.8x  r9:%8.8x\n, tf-\nr2, tf-\nr3);\n}", 
            "title": "console_printf"
        }, 
        {
            "location": "/os/modules/console/console_printf/#console_printf", 
            "text": "void\n    console_printf(const char *fmt, ...)  Writes a formatted message instead of raw output to the console. It first composes a C string containing text specified as arguments to the function or containing the elements in the variable argument list passed to it using snprintf or vsnprintf, respectively. It then uses function  console_write  to output the formatted data (messages) on the console.", 
            "title": " console_printf"
        }, 
        {
            "location": "/os/modules/console/console_printf/#arguments", 
            "text": "Arguments  Description      fmt  Pointer to C string that contains a format string that follows the same specifications as format in printf. The string is printed to console.    ...  Depending on the format string, the function may expect either a sequence of additional arguments to be used to replace a format specifier in the format string or a variable arguments list. va_list is a special type defined in   in stdarg.h.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/console/console_printf/#returned-values", 
            "text": "None", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/console/console_printf/#notes", 
            "text": "While  console_printf , with its well understood formatting options in C, is more convenient and easy on the eyes than the raw output of  console_write , the associated code size is considerably larger.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/console/console_printf/#example", 
            "text": "Example #1:  char adv_data_buf[32];\n\nvoid\ntask()\n{\n   char adv_data_buf[32];\n\n   console_printf( %s , adv_data_buf);\n}  Example #2:  struct exception_frame {\n    uint32_t r0;\n    uint32_t r1;\n\nstruct trap_frame {\n    struct exception_frame *ef;\n    uint32_t r2;\n    uint32_t r3;\n};\n\nvoid\ntask(struct trap_frame *tf)\n{\n     console_printf(  r0:%8.8x  r1:%8.8x , tf- ef- r0, tf- ef- r1);\n     console_printf(  r8:%8.8x  r9:%8.8x , tf- r2, tf- r3);\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/console/console_read/", 
            "text": "console_read \n\n\n  int\n  console_read(char *str, int cnt)\n\n\n\n\n\nCopies up to \ncnt\n bytes of received data to buffer pointed by \nstr\n. Function tries to break the input into separate lines; once it encounters a newline character, it replaces that with end-of-string and returns.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstr\n\n\nBuffer where data is copied to.\n\n\n\n\n\n\ncnt\n\n\nMaximum number of characters to copy.\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns the number of characters copied. 0 if there was no data\navailable, or if the first received character was '\\n'.\n\n\nExample\n\n\nvoid\ntask1_loop(void *arg)\n{\n    struct os_event *ev;\n    char rx_msg[128];\n    int rx_len;\n\n    while (1) {\n        ev = os_eventq_get(\ntask1_evq);\n        assert(ev);\n        if (ev-\nev_type == CONS_EV_TYPE) {\n            rx_len = console_read(rx_msg, sizeof(rx_msg));\n            if (rx_len) {\n                    if (!strncmp(rx_msg, \nreset\n, rx_len)) {\n                            assert(0);\n                    }", 
            "title": "console_read"
        }, 
        {
            "location": "/os/modules/console/console_read/#console_read", 
            "text": "int\n  console_read(char *str, int cnt)  Copies up to  cnt  bytes of received data to buffer pointed by  str . Function tries to break the input into separate lines; once it encounters a newline character, it replaces that with end-of-string and returns.", 
            "title": " console_read "
        }, 
        {
            "location": "/os/modules/console/console_read/#arguments", 
            "text": "Arguments  Description      str  Buffer where data is copied to.    cnt  Maximum number of characters to copy.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/console/console_read/#returned-values", 
            "text": "Returns the number of characters copied. 0 if there was no data\navailable, or if the first received character was '\\n'.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/console/console_read/#example", 
            "text": "void\ntask1_loop(void *arg)\n{\n    struct os_event *ev;\n    char rx_msg[128];\n    int rx_len;\n\n    while (1) {\n        ev = os_eventq_get( task1_evq);\n        assert(ev);\n        if (ev- ev_type == CONS_EV_TYPE) {\n            rx_len = console_read(rx_msg, sizeof(rx_msg));\n            if (rx_len) {\n                    if (!strncmp(rx_msg,  reset , rx_len)) {\n                            assert(0);\n                    }", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/console/console_write/", 
            "text": "console_write \n\n\n   void\n   console_write(char *str, int cnt)\n\n\n\n\n\nQueues characters to console display over serial port.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*str\n\n\npointer to the character or packet to be transmitted\n\n\n\n\n\n\ncnt\n\n\nnumber of characters in \nstr\n\n\n\n\n\n\n\n\nReturned values\n\n\nN/A\n\n\nExample\n\n\nHere is an example of the function being used in an echo command with a newline at the end.\n\n\nstatic int\nshell_echo_cmd(int argc, char **argv)\n{\n    int i;\n\n    for (i = 1; i \n argc; i++) {\n        console_write(argv[i], strlen(argv[i]));\n        console_write(\n \n, sizeof(\n \n)-1);\n    }\n    console_write(\n\\n\n, sizeof(\n\\n\n)-1);\n\n    return (0);\n}", 
            "title": "console_write"
        }, 
        {
            "location": "/os/modules/console/console_write/#console_write", 
            "text": "void\n   console_write(char *str, int cnt)  Queues characters to console display over serial port.", 
            "title": " console_write "
        }, 
        {
            "location": "/os/modules/console/console_write/#arguments", 
            "text": "Arguments  Description      *str  pointer to the character or packet to be transmitted    cnt  number of characters in  str", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/console/console_write/#returned-values", 
            "text": "N/A", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/console/console_write/#example", 
            "text": "Here is an example of the function being used in an echo command with a newline at the end.  static int\nshell_echo_cmd(int argc, char **argv)\n{\n    int i;\n\n    for (i = 1; i   argc; i++) {\n        console_write(argv[i], strlen(argv[i]));\n        console_write(   , sizeof(   )-1);\n    }\n    console_write( \\n , sizeof( \\n )-1);\n\n    return (0);\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/shell/shell/", 
            "text": "Shell\n\n\nThe shell is package sitting on top of console, handling 2 jobs: processing console input and implementing newtmgr line protocol over serial line. Shell runs on its own task.\n\n\nDescription\n\n\n\n\n\n\nShell's first job is directing incoming commands to other subsystems. It parses the incoming character string, and splits it into tokens. Then it looks for the subsystem to handle this command based on the first token of input.\n\n\nSubsystems register their command handlers using \nshell_cmd_register()\n. When shell calls the command handler, it passes the other tokens as arguments.\n\n\nA few commands are currently available in the shell - \ntasks\n, \nlog\n, and \nstat stat\n. A $ prompt sign will be coming soon!\n\n\n\n\n\n\nShell's second job is doing framing, encoding and decoding newtmgr protocol when it's carried over the console. Protocol handler (libs/newtmgr) registers itself using \nshell_nlip_input_register()\n, and shell calls the registered handler for every frame. Outgoing frames for the protocol are sent using \nshell_nlip_output()\n.\n\n\n\n\n\n\n\n\nCreate a sim target to check out these commands available in shell.\n\n\nuser@~/dev/larva$ newt target create blinky_sim\nCreating target blinky_sim\nTarget blinky_sim successfully created!\nuser@~/dev/larva$ newt target set blinky_sim name=blinky_sim\nTarget blinky_sim successfully set name to blinky_sim\nuser@~/dev/larva$ newt target set blinky_sim arch=sim\nTarget blinky_sim successfully set arch to sim\nuser@~/dev/larva$ newt target set blinky_sim project=blinky\nTarget blinky_sim successfully set project to blinky\nuser@~/dev/larva$ newt target set blinky_sim bsp=hw/bsp/native\nTarget blinky_sim successfully set bsp to hw/bsp/native\nuser@~/dev/larva$ newt target set blinky_sim compiler_def=debug\nTarget blinky_sim successfully set compiler_def to debug\nuser@~/dev/larva$ newt target set blinky_sim compiler=sim\nTarget blinky_sim successfully set compiler to sim\nuser@~/dev/larva$ newt target show\nblinky_sim\n    arch: sim\n    bsp: hw/bsp/native\n    compiler: sim\n    compiler_def: debug\n    name: blinky_sim\n    project: blinky\nuser@~/dev/larva$ newt target build blinky_sim\nBuilding target blinky_sim (project = blinky)\nCompiling case.c\nCompiling suite.c\nCompiling testutil.c\n..\n..\nBuilding project blinky\nLinking blinky.elf\nSuccessfully run!\n\nuser@~/dev/larva$ ./project/blinky/bin/blinky_sim/blinky.elf\nuart0 at /dev/ttys005\n\n\n\n\n\nOpen up a new terminal to run minicom, a text-based serial port control and terminal emulation program. Set device name to the serial port of the target. \n\n\nuser@~$ minicom -D /dev/ttys005\nWelcome to minicom 2.7\n\nOPTIONS: \nCompiled on Nov 24 2015, 16:14:21.\nPort /dev/ttys005, 11:32:17\n\nPress Meta-Z for help on special keys\n\nlog \n174578:[0] bla\n174578:[0] bab\n\ntasks\n217809:6 tasks: \n217809:  shell (prio: 3, nw: 0, flags: 0x0, ssize: 0, cswcnt: 59, tot_run_time: 0ms)\n217840:  idle (prio: 255, nw: 0, flags: 0x0, ssize: 0, cswcnt: 18763, tot_run_time: 217809ms)\n217878:  uart_poller (prio: 0, nw: 217819, flags: 0x0, ssize: 0, cswcnt: 18667, tot_run_time: 0ms)\n217923:  task1 (prio: 1, nw: 218710, flags: 0x0, ssize: 0, cswcnt: 218, tot_run_time: 0ms)\n217953:  os_sanity (prio: 254, nw: 218710, flags: 0x0, ssize: 0, cswcnt: 218, tot_run_time: 0ms)\n218010:  task2 (prio: 2, nw: 217709, flags: 0x3, ssize: 0, cswcnt: 218, tot_run_time: 0ms)\n\nstat stat\n229881:s0: 1\n\n\n\n\n\nData structures\n\n\nThis data structure is used in holding information about registered command handlers.\n\n\nstruct shell_cmd {\n    char *sc_cmd;\n    shell_cmd_func_t sc_cmd_func;\n    STAILQ_ENTRY(shell_cmd) sc_next;\n};\n\n\n\n\n\n\n\n\n\n\n\nElement\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsc_cmd\n\n\nCharacter string of the command\n\n\n\n\n\n\nsc_cmd_func\n\n\nPointer to the command handler\n\n\n\n\n\n\nsc_next\n\n\nBookkeeping linkage internal for shell\n\n\n\n\n\n\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nshell_task_init\n\n\nshell_cmd_register\n\n\nshell_nlip_input_register\n\n\nshell_nlip_output", 
            "title": "toc"
        }, 
        {
            "location": "/os/modules/shell/shell/#shell", 
            "text": "The shell is package sitting on top of console, handling 2 jobs: processing console input and implementing newtmgr line protocol over serial line. Shell runs on its own task.", 
            "title": "Shell"
        }, 
        {
            "location": "/os/modules/shell/shell/#description", 
            "text": "Shell's first job is directing incoming commands to other subsystems. It parses the incoming character string, and splits it into tokens. Then it looks for the subsystem to handle this command based on the first token of input.  Subsystems register their command handlers using  shell_cmd_register() . When shell calls the command handler, it passes the other tokens as arguments.  A few commands are currently available in the shell -  tasks ,  log , and  stat stat . A $ prompt sign will be coming soon!    Shell's second job is doing framing, encoding and decoding newtmgr protocol when it's carried over the console. Protocol handler (libs/newtmgr) registers itself using  shell_nlip_input_register() , and shell calls the registered handler for every frame. Outgoing frames for the protocol are sent using  shell_nlip_output() .     Create a sim target to check out these commands available in shell.  user@~/dev/larva$ newt target create blinky_sim\nCreating target blinky_sim\nTarget blinky_sim successfully created!\nuser@~/dev/larva$ newt target set blinky_sim name=blinky_sim\nTarget blinky_sim successfully set name to blinky_sim\nuser@~/dev/larva$ newt target set blinky_sim arch=sim\nTarget blinky_sim successfully set arch to sim\nuser@~/dev/larva$ newt target set blinky_sim project=blinky\nTarget blinky_sim successfully set project to blinky\nuser@~/dev/larva$ newt target set blinky_sim bsp=hw/bsp/native\nTarget blinky_sim successfully set bsp to hw/bsp/native\nuser@~/dev/larva$ newt target set blinky_sim compiler_def=debug\nTarget blinky_sim successfully set compiler_def to debug\nuser@~/dev/larva$ newt target set blinky_sim compiler=sim\nTarget blinky_sim successfully set compiler to sim\nuser@~/dev/larva$ newt target show\nblinky_sim\n    arch: sim\n    bsp: hw/bsp/native\n    compiler: sim\n    compiler_def: debug\n    name: blinky_sim\n    project: blinky\nuser@~/dev/larva$ newt target build blinky_sim\nBuilding target blinky_sim (project = blinky)\nCompiling case.c\nCompiling suite.c\nCompiling testutil.c\n..\n..\nBuilding project blinky\nLinking blinky.elf\nSuccessfully run!\n\nuser@~/dev/larva$ ./project/blinky/bin/blinky_sim/blinky.elf\nuart0 at /dev/ttys005  Open up a new terminal to run minicom, a text-based serial port control and terminal emulation program. Set device name to the serial port of the target.   user@~$ minicom -D /dev/ttys005\nWelcome to minicom 2.7\n\nOPTIONS: \nCompiled on Nov 24 2015, 16:14:21.\nPort /dev/ttys005, 11:32:17\n\nPress Meta-Z for help on special keys\n\nlog \n174578:[0] bla\n174578:[0] bab\n\ntasks\n217809:6 tasks: \n217809:  shell (prio: 3, nw: 0, flags: 0x0, ssize: 0, cswcnt: 59, tot_run_time: 0ms)\n217840:  idle (prio: 255, nw: 0, flags: 0x0, ssize: 0, cswcnt: 18763, tot_run_time: 217809ms)\n217878:  uart_poller (prio: 0, nw: 217819, flags: 0x0, ssize: 0, cswcnt: 18667, tot_run_time: 0ms)\n217923:  task1 (prio: 1, nw: 218710, flags: 0x0, ssize: 0, cswcnt: 218, tot_run_time: 0ms)\n217953:  os_sanity (prio: 254, nw: 218710, flags: 0x0, ssize: 0, cswcnt: 218, tot_run_time: 0ms)\n218010:  task2 (prio: 2, nw: 217709, flags: 0x3, ssize: 0, cswcnt: 218, tot_run_time: 0ms)\n\nstat stat\n229881:s0: 1", 
            "title": "Description"
        }, 
        {
            "location": "/os/modules/shell/shell/#data-structures", 
            "text": "This data structure is used in holding information about registered command handlers.  struct shell_cmd {\n    char *sc_cmd;\n    shell_cmd_func_t sc_cmd_func;\n    STAILQ_ENTRY(shell_cmd) sc_next;\n};     Element  Description      sc_cmd  Character string of the command    sc_cmd_func  Pointer to the command handler    sc_next  Bookkeeping linkage internal for shell", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/modules/shell/shell/#list-of-functions", 
            "text": "The functions available in this OS feature are:   shell_task_init  shell_cmd_register  shell_nlip_input_register  shell_nlip_output", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/modules/shell/shell_task_init/", 
            "text": "shell_task_init\n\n\nint shell_task_init(uint8_t prio, os_stack_t *stack, uint16_t stack_size,\n                    int max_input_length);\n\n\n\n\n\nInitializes the shell package. This creates a task for shell, and registers few commands on its own (\necho\n, \n?\n, for example). It also allocates memory for buffering console input.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprio\n\n\nPriority of the shell task\n\n\n\n\n\n\nstack\n\n\nPointer to shell tasks's stack\n\n\n\n\n\n\nstack_size\n\n\nSize of the aforementioned stack (in units of os_stack_t)\n\n\n\n\n\n\nmax_input_length\n\n\nthe maximum expected length of line for input\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns 0 on success; nonzero on failure.\n\n\nNotes\n\n\nYou can register commands before calling this, but only if OS has not been started.\n\n\nExample\n\n\nHere's an example of stand-alone code which allows the user to execute regression tests for sys/config package only.\n\n\n#define SHELL_TASK_PRIO (3)\n#define SHELL_MAX_INPUT_LEN     (256)\n#define SHELL_TASK_STACK_SIZE (OS_STACK_ALIGN(384))\nos_stack_t shell_stack[SHELL_TASK_STACK_SIZE];\n\nint\nmain(int argc, char **argv)\n{\n    ....\n    shell_task_init(SHELL_TASK_PRIO, shell_stack, SHELL_TASK_STACK_SIZE,\n                    SHELL_MAX_INPUT_LEN);\n    ....\n}", 
            "title": "shell_task_init"
        }, 
        {
            "location": "/os/modules/shell/shell_task_init/#shell_task_init", 
            "text": "int shell_task_init(uint8_t prio, os_stack_t *stack, uint16_t stack_size,\n                    int max_input_length);  Initializes the shell package. This creates a task for shell, and registers few commands on its own ( echo ,  ? , for example). It also allocates memory for buffering console input.", 
            "title": " shell_task_init"
        }, 
        {
            "location": "/os/modules/shell/shell_task_init/#arguments", 
            "text": "Arguments  Description      prio  Priority of the shell task    stack  Pointer to shell tasks's stack    stack_size  Size of the aforementioned stack (in units of os_stack_t)    max_input_length  the maximum expected length of line for input", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/shell/shell_task_init/#returned-values", 
            "text": "Returns 0 on success; nonzero on failure.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/shell/shell_task_init/#notes", 
            "text": "You can register commands before calling this, but only if OS has not been started.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/shell/shell_task_init/#example", 
            "text": "Here's an example of stand-alone code which allows the user to execute regression tests for sys/config package only.  #define SHELL_TASK_PRIO (3)\n#define SHELL_MAX_INPUT_LEN     (256)\n#define SHELL_TASK_STACK_SIZE (OS_STACK_ALIGN(384))\nos_stack_t shell_stack[SHELL_TASK_STACK_SIZE];\n\nint\nmain(int argc, char **argv)\n{\n    ....\n    shell_task_init(SHELL_TASK_PRIO, shell_stack, SHELL_TASK_STACK_SIZE,\n                    SHELL_MAX_INPUT_LEN);\n    ....\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/shell/shell_cmd_register/", 
            "text": "shell_cmd_register \n\n\nint shell_cmd_register(struct shell_cmd *sc)\n\n\n\n\n\nRegisters a handler for incoming console commands. Within the structure there is the command string and the handler for those commands. Caller must allocate the memory for this structure and keep it around as shell links this to its own internal data structures.\n\n\nCommand handler is of type \nint(*shell_cmd_func_t)(int argc, char **argv)\n. Command line arguments are passed to it as an array of character pointers.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsc\n\n\nStructure containing info about the command.\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns 0 on success.\nNon-zero on failure.\n\n\nExample\n\n\nstatic int fs_ls_cmd(int argc, char **argv);\n\nstatic struct shell_cmd fs_ls_struct = {\n    .sc_cmd = \nls\n,\n    .sc_cmd_func = fs_ls_cmd\n};\n\nvoid\nfs_cli_init(void)\n{\n    shell_cmd_register(\nfs_ls_struct);\n    ....\n}", 
            "title": "shell_cmd_register"
        }, 
        {
            "location": "/os/modules/shell/shell_cmd_register/#shell_cmd_register", 
            "text": "int shell_cmd_register(struct shell_cmd *sc)  Registers a handler for incoming console commands. Within the structure there is the command string and the handler for those commands. Caller must allocate the memory for this structure and keep it around as shell links this to its own internal data structures.  Command handler is of type  int(*shell_cmd_func_t)(int argc, char **argv) . Command line arguments are passed to it as an array of character pointers.", 
            "title": " shell_cmd_register "
        }, 
        {
            "location": "/os/modules/shell/shell_cmd_register/#arguments", 
            "text": "Arguments  Description      sc  Structure containing info about the command.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/shell/shell_cmd_register/#returned-values", 
            "text": "Returns 0 on success.\nNon-zero on failure.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/shell/shell_cmd_register/#example", 
            "text": "static int fs_ls_cmd(int argc, char **argv);\n\nstatic struct shell_cmd fs_ls_struct = {\n    .sc_cmd =  ls ,\n    .sc_cmd_func = fs_ls_cmd\n};\n\nvoid\nfs_cli_init(void)\n{\n    shell_cmd_register( fs_ls_struct);\n    ....\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/shell/shell_nlip_input_register/", 
            "text": "shell_nlip_input_register \n\n\nint shell_nlip_input_register(shell_nlip_input_func_t nf, void *arg)\n\n\n\n\n\nRegisters a handler for incoming newtmgr messages. Shell receives incoming data stream from UART and when it detects NLIP frame, it decodes it and passes it on by calling the function \nnf\n.\n\n\nHandler function is of type \nint (*shell_nlip_input_func_t)(struct os_mbuf *m, void *arg)\n. Shell passes the incoming newtmgr message inside os_mbuf \nm\n, and \narg\n is the argument that was passed in during handler registration.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnf\n\n\nHandler for incoming newtmgr datagrams.\n\n\n\n\n\n\narg\n\n\nArgument that gets passed to this handler, along with the datagram\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns 0 on success.\n\n\nExample\n\n\nstatic int\nnmgr_shell_in(struct os_mbuf *m, void *arg)\n{\n    ....\n}\n\nint \nnmgr_task_init(uint8_t prio, os_stack_t *stack_ptr, uint16_t stack_len)\n{\n    int rc;\n    ....\n    rc = shell_nlip_input_register(nmgr_shell_in, \n            (void *) \ng_nmgr_shell_transport);\n    if (rc != 0) {\n        goto err;\n    }\n    ....\n}", 
            "title": "shell_nlip_input_register"
        }, 
        {
            "location": "/os/modules/shell/shell_nlip_input_register/#shell_nlip_input_register", 
            "text": "int shell_nlip_input_register(shell_nlip_input_func_t nf, void *arg)  Registers a handler for incoming newtmgr messages. Shell receives incoming data stream from UART and when it detects NLIP frame, it decodes it and passes it on by calling the function  nf .  Handler function is of type  int (*shell_nlip_input_func_t)(struct os_mbuf *m, void *arg) . Shell passes the incoming newtmgr message inside os_mbuf  m , and  arg  is the argument that was passed in during handler registration.", 
            "title": " shell_nlip_input_register "
        }, 
        {
            "location": "/os/modules/shell/shell_nlip_input_register/#arguments", 
            "text": "Arguments  Description      nf  Handler for incoming newtmgr datagrams.    arg  Argument that gets passed to this handler, along with the datagram", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/shell/shell_nlip_input_register/#returned-values", 
            "text": "Returns 0 on success.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/shell/shell_nlip_input_register/#example", 
            "text": "static int\nnmgr_shell_in(struct os_mbuf *m, void *arg)\n{\n    ....\n}\n\nint \nnmgr_task_init(uint8_t prio, os_stack_t *stack_ptr, uint16_t stack_len)\n{\n    int rc;\n    ....\n    rc = shell_nlip_input_register(nmgr_shell_in, \n            (void *)  g_nmgr_shell_transport);\n    if (rc != 0) {\n        goto err;\n    }\n    ....\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/shell/shell_nlip_output/", 
            "text": "shell_nlip_output \n\n\nint shell_nlip_output(struct os_mbuf *m)\n\n\n\n\n\nQueue outgoing newtmgr message for transmission. Shell package will encode this and frame it while sending it out via console.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nm\n\n\nos_mbuf containing the message\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns 0 on success.\n\n\nExample\n\n\nstatic int \nnmgr_shell_out(struct nmgr_transport *nt, struct os_mbuf *m)\n{\n    int rc;\n\n    rc = shell_nlip_output(m);\n    if (rc != 0) {\n        goto err;\n    }\n\n    return (0);\nerr:\n    return (rc);\n}", 
            "title": "shell_nlip_output"
        }, 
        {
            "location": "/os/modules/shell/shell_nlip_output/#shell_nlip_output", 
            "text": "int shell_nlip_output(struct os_mbuf *m)  Queue outgoing newtmgr message for transmission. Shell package will encode this and frame it while sending it out via console.", 
            "title": " shell_nlip_output "
        }, 
        {
            "location": "/os/modules/shell/shell_nlip_output/#arguments", 
            "text": "Arguments  Description      m  os_mbuf containing the message", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/shell/shell_nlip_output/#returned-values", 
            "text": "Returns 0 on success.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/shell/shell_nlip_output/#example", 
            "text": "static int \nnmgr_shell_out(struct nmgr_transport *nt, struct os_mbuf *m)\n{\n    int rc;\n\n    rc = shell_nlip_output(m);\n    if (rc != 0) {\n        goto err;\n    }\n\n    return (0);\nerr:\n    return (rc);\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/bootloader/bootloader/", 
            "text": "Bootloader\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe module here, special features, how pieces fit together etc.\n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in bootloader are:\n\n\n\n\nboot_build_status\n\n\nboot_build_status_one\n\n\nboot_clear_status\n\n\nboot_copy_area\n\n\nboot_copy_image\n\n\nboot_erase_area\n\n\nboot_fill_slot\n\n\nboot_find_image_area_idx\n\n\nboot_find_image_part\n\n\nboot_find_image_slot\n\n\nboot_go\n\n\nboot_init_flash\n\n\nboot_move_area\n\n\nboot_read_image_header\n\n\nboot_read_image_headers\n\n\nboot_read_status\n\n\nboot_select_image_slot\n\n\nboot_slot_addr\n\n\nboot_slot_to_area_idx\n\n\nboot_swap_areas\n\n\nboot_vect_delete_main\n\n\nboot_vect_delete_test\n\n\nboot_vect_read_main\n\n\nboot_vect_read_one\n\n\nboot_vect_read_test\n\n\nboot_write_status", 
            "title": "toc"
        }, 
        {
            "location": "/os/modules/bootloader/bootloader/#bootloader", 
            "text": "Insert synopsis here", 
            "title": "Bootloader"
        }, 
        {
            "location": "/os/modules/bootloader/bootloader/#description", 
            "text": "Describe module here, special features, how pieces fit together etc.", 
            "title": "Description"
        }, 
        {
            "location": "/os/modules/bootloader/bootloader/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/modules/bootloader/bootloader/#list-of-functions", 
            "text": "The functions available in bootloader are:   boot_build_status  boot_build_status_one  boot_clear_status  boot_copy_area  boot_copy_image  boot_erase_area  boot_fill_slot  boot_find_image_area_idx  boot_find_image_part  boot_find_image_slot  boot_go  boot_init_flash  boot_move_area  boot_read_image_header  boot_read_image_headers  boot_read_status  boot_select_image_slot  boot_slot_addr  boot_slot_to_area_idx  boot_swap_areas  boot_vect_delete_main  boot_vect_delete_test  boot_vect_read_main  boot_vect_read_one  boot_vect_read_test  boot_write_status", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/modules/bootloader/boot_build_status/", 
            "text": "", 
            "title": "boot_build_status"
        }, 
        {
            "location": "/os/modules/bootloader/boot_build_status_one/", 
            "text": "", 
            "title": "boot_build_status_one"
        }, 
        {
            "location": "/os/modules/bootloader/boot_clear_status/", 
            "text": "", 
            "title": "boot_clear_status"
        }, 
        {
            "location": "/os/modules/bootloader/boot_copy_area/", 
            "text": "", 
            "title": "boot_copy_area"
        }, 
        {
            "location": "/os/modules/bootloader/boot_copy_image/", 
            "text": "", 
            "title": "boot_copy_image"
        }, 
        {
            "location": "/os/modules/bootloader/boot_erase_area/", 
            "text": "", 
            "title": "boot_erase_area"
        }, 
        {
            "location": "/os/modules/bootloader/boot_fill_slot/", 
            "text": "", 
            "title": "boot_fill_slot"
        }, 
        {
            "location": "/os/modules/bootloader/boot_find_image_area_idx/", 
            "text": "", 
            "title": "boot_find_image_area_idx"
        }, 
        {
            "location": "/os/modules/bootloader/boot_find_image_part/", 
            "text": "", 
            "title": "boot_find_image_part"
        }, 
        {
            "location": "/os/modules/bootloader/boot_find_image_slot/", 
            "text": "", 
            "title": "boot_find_image_slot"
        }, 
        {
            "location": "/os/modules/bootloader/boot_go/", 
            "text": "", 
            "title": "boot_go"
        }, 
        {
            "location": "/os/modules/bootloader/boot_init_flash/", 
            "text": "", 
            "title": "boot_init_flash"
        }, 
        {
            "location": "/os/modules/bootloader/boot_move_area/", 
            "text": "", 
            "title": "boot_move_area"
        }, 
        {
            "location": "/os/modules/bootloader/boot_read_image_header/", 
            "text": "", 
            "title": "boot_read_image_header"
        }, 
        {
            "location": "/os/modules/bootloader/boot_read_image_headers/", 
            "text": "", 
            "title": "boot_read_image_headers"
        }, 
        {
            "location": "/os/modules/bootloader/boot_read_status/", 
            "text": "", 
            "title": "boot_read_status"
        }, 
        {
            "location": "/os/modules/bootloader/boot_select_image_slot/", 
            "text": "", 
            "title": "boot_select_image_slot"
        }, 
        {
            "location": "/os/modules/bootloader/boot_slot_addr/", 
            "text": "", 
            "title": "boot_slot_addr"
        }, 
        {
            "location": "/os/modules/bootloader/boot_slot_to_area_idx/", 
            "text": "", 
            "title": "boot_slot_to_area_idx"
        }, 
        {
            "location": "/os/modules/bootloader/boot_swap_areas/", 
            "text": "", 
            "title": "boot_swap_areas"
        }, 
        {
            "location": "/os/modules/bootloader/boot_vect_delete_main/", 
            "text": "", 
            "title": "boot_vect_delete_main"
        }, 
        {
            "location": "/os/modules/bootloader/boot_vect_delete_test/", 
            "text": "", 
            "title": "boot_vect_delete_test"
        }, 
        {
            "location": "/os/modules/bootloader/boot_vect_read_main/", 
            "text": "", 
            "title": "boot_vect_read_main"
        }, 
        {
            "location": "/os/modules/bootloader/boot_vect_read_one/", 
            "text": "", 
            "title": "boot_vect_read_one"
        }, 
        {
            "location": "/os/modules/bootloader/boot_vect_read_test/", 
            "text": "", 
            "title": "boot_vect_read_test"
        }, 
        {
            "location": "/os/modules/bootloader/boot_write_status/", 
            "text": "", 
            "title": "boot_write_status"
        }, 
        {
            "location": "/os/modules/fs/fs/fs/", 
            "text": "File System Abstraction\n\n\nMynewt provides a file system abstraction layer (\nfs/fs\n) to allow client code to be file system agnostic.  By accessing the file system via the \nfs/fs\n API, client code can perform file system operations without being tied to a particular implementation.  When possible, library code should use the \nfs/fs\n API rather than accessing the underlying file system directly.\n\n\nDescription\n\n\nApplications should aim to minimize the amount of code which depends on a particular file system implementation.  When possible, only depend on the \nfs/fs\n package.  In the simplest case, the only code which needs to know which file system is in use is the code which initializes the file system.  In terms of the Mynewt hierarchy, the \nproject\n package must depend on a specific file system package, while \nlibrary\n packages should only depend on \nfs/fs\n.\n\n\nThe following example illustrates how file system dependencies should be managed.  In the slinky application, the project is responsible for initializing the file system, so it depends on a concrete file system package called \nfs/nffs\n (Newtron Flash File System). The project explicitly initializes nffs via calls to \nnffs_init()\n, \nnffs_detect()\n and \nnffs_format()\n.\n\n\n# project/slinky/pkg.yml\n\npkg.name: project/slinky\npkg.vers: 0.8.0\npkg.deps:\n    - fs/nffs\n\n# [...]\n\n\n\n\n\n// project/slinky/src/main.c\n\n#include \nnffs/nffs.h\n\n\nint\nmain(int argc, char **argv)\n{\n    int rc;\n    int cnt;\n    struct nffs_area_desc descs[NFFS_AREA_MAX];\n\n    rc = nffs_init();\n    assert(rc == 0);\n\n    cnt = NFFS_AREA_MAX;\n    rc = flash_area_to_nffs_desc(FLASH_AREA_NFFS, \ncnt, descs);\n    assert(rc == 0);\n    if (nffs_detect(descs) == FS_ECORRUPT) {\n        rc = nffs_format(descs);\n        assert(rc == 0);\n    }\n    // [...]\n}\n\n\n\n\n\nOn the other hand, code which uses the file system after it has been initialized need only depend on \nfs/fs\n.  For example, the \nlibs/imgmgr\n package is a library which provides firmware upload and download functionality via the use of a file system.  This library is only used after the main project has initialized the file system, and therefore only depends on the \nfs/fs\n package.\n\n\n# libs/imgmgr/pkg.yml\npkg.name: libs/imgmgr\npkg.vers: 0.8.0\npkg.deps:\n    - fs/fs\n\n# [...]\n\n\n\n\n\nThe \nlibs/imgmgr\n package uses the \nfs/fs\n API for all file system operations.\n\n\nThread Safety\n\n\nAll \nfs/fs\n functions are thread safe.\n\n\nHeader Files\n\n\nAll code which uses the \nfs/fs\n package needs to include the following header:\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nData Structures\n\n\nAll \nfs/fs\n data structures are opaque to client code.\n\n\nstruct fs_file;\nstruct fs_dir;\nstruct fs_dirent;\n\n\n\n\n\nAPI\n\n\nFunctions in \nfs/fs\n that indicate success or failure do so with the following set of return codes:\n\n\n\n\nReturn Codes\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nfs_close\n\n\nfs_closedir\n\n\nfs_dirent_is_dir\n\n\nfs_dirent_name\n\n\nfs_filelen\n\n\nfs_getpos\n\n\nfs_mkdir\n\n\nfs_open\n\n\nfs_opendir\n\n\nfs_read\n\n\nfs_readdir\n\n\nfs_rename\n\n\nfs_seek\n\n\nfs_unlink\n\n\nfs_write\n\n\n\n\nAdditional file system utilities that bundle some of the basic functions above are:\n\n\n\n\nfsutil_read_file\n\n\nfsutil_write_file", 
            "title": "toc"
        }, 
        {
            "location": "/os/modules/fs/fs/fs/#file-system-abstraction", 
            "text": "Mynewt provides a file system abstraction layer ( fs/fs ) to allow client code to be file system agnostic.  By accessing the file system via the  fs/fs  API, client code can perform file system operations without being tied to a particular implementation.  When possible, library code should use the  fs/fs  API rather than accessing the underlying file system directly.", 
            "title": "File System Abstraction"
        }, 
        {
            "location": "/os/modules/fs/fs/fs/#description", 
            "text": "Applications should aim to minimize the amount of code which depends on a particular file system implementation.  When possible, only depend on the  fs/fs  package.  In the simplest case, the only code which needs to know which file system is in use is the code which initializes the file system.  In terms of the Mynewt hierarchy, the  project  package must depend on a specific file system package, while  library  packages should only depend on  fs/fs .  The following example illustrates how file system dependencies should be managed.  In the slinky application, the project is responsible for initializing the file system, so it depends on a concrete file system package called  fs/nffs  (Newtron Flash File System). The project explicitly initializes nffs via calls to  nffs_init() ,  nffs_detect()  and  nffs_format() .  # project/slinky/pkg.yml\n\npkg.name: project/slinky\npkg.vers: 0.8.0\npkg.deps:\n    - fs/nffs\n\n# [...]  // project/slinky/src/main.c\n\n#include  nffs/nffs.h \n\nint\nmain(int argc, char **argv)\n{\n    int rc;\n    int cnt;\n    struct nffs_area_desc descs[NFFS_AREA_MAX];\n\n    rc = nffs_init();\n    assert(rc == 0);\n\n    cnt = NFFS_AREA_MAX;\n    rc = flash_area_to_nffs_desc(FLASH_AREA_NFFS,  cnt, descs);\n    assert(rc == 0);\n    if (nffs_detect(descs) == FS_ECORRUPT) {\n        rc = nffs_format(descs);\n        assert(rc == 0);\n    }\n    // [...]\n}  On the other hand, code which uses the file system after it has been initialized need only depend on  fs/fs .  For example, the  libs/imgmgr  package is a library which provides firmware upload and download functionality via the use of a file system.  This library is only used after the main project has initialized the file system, and therefore only depends on the  fs/fs  package.  # libs/imgmgr/pkg.yml\npkg.name: libs/imgmgr\npkg.vers: 0.8.0\npkg.deps:\n    - fs/fs\n\n# [...]  The  libs/imgmgr  package uses the  fs/fs  API for all file system operations.", 
            "title": "Description"
        }, 
        {
            "location": "/os/modules/fs/fs/fs/#thread-safety", 
            "text": "All  fs/fs  functions are thread safe.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/os/modules/fs/fs/fs/#header-files", 
            "text": "All code which uses the  fs/fs  package needs to include the following header:  #include  fs/fs.h", 
            "title": "Header Files"
        }, 
        {
            "location": "/os/modules/fs/fs/fs/#data-structures", 
            "text": "All  fs/fs  data structures are opaque to client code.  struct fs_file;\nstruct fs_dir;\nstruct fs_dirent;", 
            "title": "Data Structures"
        }, 
        {
            "location": "/os/modules/fs/fs/fs/#api", 
            "text": "Functions in  fs/fs  that indicate success or failure do so with the following set of return codes:   Return Codes   The functions available in this OS feature are:   fs_close  fs_closedir  fs_dirent_is_dir  fs_dirent_name  fs_filelen  fs_getpos  fs_mkdir  fs_open  fs_opendir  fs_read  fs_readdir  fs_rename  fs_seek  fs_unlink  fs_write   Additional file system utilities that bundle some of the basic functions above are:   fsutil_read_file  fsutil_write_file", 
            "title": "API"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_return_codes/", 
            "text": "fs/fs Return Codes\n\n\nFunctions in \nfs/fs\n that indicate success or failure do so with the following set of return codes:\n\n\n\n\n\n\n\n\nReturn code\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nFS_EOK\n\n\nSuccess\n\n\n\n\n\n\nFS_ECORRUPT\n\n\nFile system corrupt\n\n\n\n\n\n\nFS_EHW\n\n\nError accessing storage medium\n\n\n\n\n\n\nFS_EOFFSET\n\n\nInvalid offset\n\n\n\n\n\n\nFS_EINVAL\n\n\nInvalid argument\n\n\n\n\n\n\nFS_ENOMEM\n\n\nInsufficient memory\n\n\n\n\n\n\nFS_ENOENT\n\n\nNo such file or directory\n\n\n\n\n\n\nFS_EEMPTY\n\n\nSpecified region is empty (internal only)\n\n\n\n\n\n\nFS_EFULL\n\n\nDisk full\n\n\n\n\n\n\nFS_EUNEXP\n\n\nDisk contains unexpected metadata\n\n\n\n\n\n\nFS_EOS\n\n\nOS error\n\n\n\n\n\n\nFS_EEXIST\n\n\nFile or directory already exists\n\n\n\n\n\n\nFS_EACCESS\n\n\nOperation prohibited by file open mode\n\n\n\n\n\n\nFS_EUNINIT\n\n\nFile system not initialized\n\n\n\n\n\n\n\n\nHeader file\n\n\n#include \nfs/fs.h", 
            "title": "Return Codes"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_return_codes/#fsfs-return-codes", 
            "text": "Functions in  fs/fs  that indicate success or failure do so with the following set of return codes:     Return code  Description      FS_EOK  Success    FS_ECORRUPT  File system corrupt    FS_EHW  Error accessing storage medium    FS_EOFFSET  Invalid offset    FS_EINVAL  Invalid argument    FS_ENOMEM  Insufficient memory    FS_ENOENT  No such file or directory    FS_EEMPTY  Specified region is empty (internal only)    FS_EFULL  Disk full    FS_EUNEXP  Disk contains unexpected metadata    FS_EOS  OS error    FS_EEXIST  File or directory already exists    FS_EACCESS  Operation prohibited by file open mode    FS_EUNINIT  File system not initialized", 
            "title": "fs/fs Return Codes"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_return_codes/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_ops/", 
            "text": "struct fs_ops\n\n\nstruct fs_ops {\n    int (*f_open)(const char *filename, uint8_t access_flags,\n              struct fs_file **out_file);\n    int (*f_close)(struct fs_file *file);\n    int (*f_read)(struct fs_file *file, uint32_t len, void *out_data,\n      uint32_t *out_len);\n    int (*f_write)(struct fs_file *file, const void *data, int len);\n\n    int (*f_seek)(struct fs_file *file, uint32_t offset);\n    uint32_t (*f_getpos)(const struct fs_file *file);\n    int (*f_filelen)(const struct fs_file *file, uint32_t *out_len);\n\n    int (*f_unlink)(const char *filename);\n    int (*f_rename)(const char *from, const char *to);\n    int (*f_mkdir)(const char *path);\n\n    int (*f_opendir)(const char *path, struct fs_dir **out_dir);\n    int (*f_readdir)(struct fs_dir *dir, struct fs_dirent **out_dirent);\n    int (*f_closedir)(struct fs_dir *dir);\n\n    int (*f_dirent_name)(const struct fs_dirent *dirent, size_t max_len,\n      char *out_name, uint8_t *out_name_len);\n    int (*f_dirent_is_dir)(const struct fs_dirent *dirent);\n\n    const char *f_name;\n};\n\n\n\n\n\nThis data structure consists of a set of function pointers.  Each function pointer corresponds to a file system operation.  When registering a file system with the abstraction layer, each function pointer must be pointed at the corresponding routine in the custom file system package.\n\n\nThe required behavior of each corresponding function is documented in the \nfile system abstraction layer API\n.\n\n\nHeader file\n\n\n#include \nfs/fs_if.h", 
            "title": "struct fs_ops"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_ops/#struct-fs95ops", 
            "text": "struct fs_ops {\n    int (*f_open)(const char *filename, uint8_t access_flags,\n              struct fs_file **out_file);\n    int (*f_close)(struct fs_file *file);\n    int (*f_read)(struct fs_file *file, uint32_t len, void *out_data,\n      uint32_t *out_len);\n    int (*f_write)(struct fs_file *file, const void *data, int len);\n\n    int (*f_seek)(struct fs_file *file, uint32_t offset);\n    uint32_t (*f_getpos)(const struct fs_file *file);\n    int (*f_filelen)(const struct fs_file *file, uint32_t *out_len);\n\n    int (*f_unlink)(const char *filename);\n    int (*f_rename)(const char *from, const char *to);\n    int (*f_mkdir)(const char *path);\n\n    int (*f_opendir)(const char *path, struct fs_dir **out_dir);\n    int (*f_readdir)(struct fs_dir *dir, struct fs_dirent **out_dirent);\n    int (*f_closedir)(struct fs_dir *dir);\n\n    int (*f_dirent_name)(const struct fs_dirent *dirent, size_t max_len,\n      char *out_name, uint8_t *out_name_len);\n    int (*f_dirent_is_dir)(const struct fs_dirent *dirent);\n\n    const char *f_name;\n};  This data structure consists of a set of function pointers.  Each function pointer corresponds to a file system operation.  When registering a file system with the abstraction layer, each function pointer must be pointed at the corresponding routine in the custom file system package.  The required behavior of each corresponding function is documented in the  file system abstraction layer API .", 
            "title": "struct fs_ops"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_ops/#header-file", 
            "text": "#include  fs/fs_if.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_close/", 
            "text": "fs_close\n\n\nint fs_close(struct fs_file *file)\n\n\n\n\n\nCloses the specified file and invalidates the file handle.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nPointer to the file to close\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS error code\n on failure\n\n\n\n\nNotes\n\n\nIf the file has already been unlinked, and the file has no other open handles, the \nfs_close()\n function causes the file to be deleted from the disk.\n\n\nHeader file\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nExample\n\n\nThe below code opens the file \n/settings/config.txt\n for reading, reads some data, and then closes the file.\n\n\nint\nread_config(void)\n{\n    struct fs_file *file;\n    uint32_t bytes_read;\n    uint8_t buf[16];\n    int rc;\n\n    /* Open the file for reading. */\n    rc = fs_open(\n/settings/config.txt\n, FS_ACCESS_READ, \nfile);\n    if (rc != 0) {\n        return -1;\n    }\n\n    /* Read up to 16 bytes from the file. */\n    rc = fs_read(file, sizeof buf, buf, \nbytes_read);\n    if (rc == 0) {\n        /* buf now contains up to 16 bytes of file data. */\n        console_printf(\nread %u bytes\\n\n, bytes_read)\n    }\n\n    /* Close the file. */\n    fs_close(file);\n\n    return rc == 0 ? 0 : -1;\n}", 
            "title": "fs_close"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_close/#fs95close", 
            "text": "int fs_close(struct fs_file *file)  Closes the specified file and invalidates the file handle.", 
            "title": "fs_close"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_close/#arguments", 
            "text": "Arguments  Description      file  Pointer to the file to close", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_close/#returned-values", 
            "text": "0 on success  FS error code  on failure", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_close/#notes", 
            "text": "If the file has already been unlinked, and the file has no other open handles, the  fs_close()  function causes the file to be deleted from the disk.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_close/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_close/#example", 
            "text": "The below code opens the file  /settings/config.txt  for reading, reads some data, and then closes the file.  int\nread_config(void)\n{\n    struct fs_file *file;\n    uint32_t bytes_read;\n    uint8_t buf[16];\n    int rc;\n\n    /* Open the file for reading. */\n    rc = fs_open( /settings/config.txt , FS_ACCESS_READ,  file);\n    if (rc != 0) {\n        return -1;\n    }\n\n    /* Read up to 16 bytes from the file. */\n    rc = fs_read(file, sizeof buf, buf,  bytes_read);\n    if (rc == 0) {\n        /* buf now contains up to 16 bytes of file data. */\n        console_printf( read %u bytes\\n , bytes_read)\n    }\n\n    /* Close the file. */\n    fs_close(file);\n\n    return rc == 0 ? 0 : -1;\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_closedir/", 
            "text": "fs_closedir\n\n\nint fs_closedir(struct fs_dir *dir)\n\n\n\n\n\nCloses the specified directory handle. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndir\n\n\nThe name of the directory to close\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS error code\n on failure\n\n\n\n\nHeader file\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nExample\n\n\nThis example iterates through the contents of a directory, printing the name of each child node.  When the traversal is complete, the code closes the directory handle.\n\n\nint\ntraverse_dir(const char *dirname)\n{\n    struct fs_dirent *dirent;\n    struct fs_dir *dir;\n    char buf[64];\n    uint8_t name_len;\n    int rc;\n\n    rc = fs_opendir(dirname, \ndir);\n    if (rc != 0) {\n        return -1;\n    }\n\n    /* Iterate through the parent directory, printing the name of each child\n     * entry.  The loop only terminates via a function return.\n     */\n    while (1) {\n        /* Retrieve the next child node. */\n        rc = fs_readdir(dir, \ndirent); \n        if (rc == FS_ENOENT) {\n            /* Traversal complete. */\n            return 0;\n        } else if (rc != 0) {\n            /* Unexpected error. */\n            return -1;\n        }\n\n        /* Read the child node\ns name from the file system. */\n        rc = fs_dirent_name(dirent, sizeof buf, buf, \nname_len);\n        if (rc != 0) {\n            return -1;\n        }\n\n        /* Print the child node\ns name to the console. */\n        if (fs_dirent_is_dir(dirent)) {\n            console_printf(\n dir: \n);\n        } else {\n            console_printf(\nfile: \n);\n        }\n        console_printf(\n%s\\n\n, buf);\n    }\n}", 
            "title": "fs_closedir"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_closedir/#fs95closedir", 
            "text": "int fs_closedir(struct fs_dir *dir)  Closes the specified directory handle.", 
            "title": "fs_closedir"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_closedir/#arguments", 
            "text": "Arguments  Description      dir  The name of the directory to close", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_closedir/#returned-values", 
            "text": "0 on success  FS error code  on failure", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_closedir/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_closedir/#example", 
            "text": "This example iterates through the contents of a directory, printing the name of each child node.  When the traversal is complete, the code closes the directory handle.  int\ntraverse_dir(const char *dirname)\n{\n    struct fs_dirent *dirent;\n    struct fs_dir *dir;\n    char buf[64];\n    uint8_t name_len;\n    int rc;\n\n    rc = fs_opendir(dirname,  dir);\n    if (rc != 0) {\n        return -1;\n    }\n\n    /* Iterate through the parent directory, printing the name of each child\n     * entry.  The loop only terminates via a function return.\n     */\n    while (1) {\n        /* Retrieve the next child node. */\n        rc = fs_readdir(dir,  dirent); \n        if (rc == FS_ENOENT) {\n            /* Traversal complete. */\n            return 0;\n        } else if (rc != 0) {\n            /* Unexpected error. */\n            return -1;\n        }\n\n        /* Read the child node s name from the file system. */\n        rc = fs_dirent_name(dirent, sizeof buf, buf,  name_len);\n        if (rc != 0) {\n            return -1;\n        }\n\n        /* Print the child node s name to the console. */\n        if (fs_dirent_is_dir(dirent)) {\n            console_printf(  dir:  );\n        } else {\n            console_printf( file:  );\n        }\n        console_printf( %s\\n , buf);\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_dirent_is_dir/", 
            "text": "fs_dirent_is_dir\n\n\nint fs_dirent_is_dir(const struct fs_dirent *dirent)\n\n\n\n\n\nTells you whether the specified directory entry is a sub-directory or a regular file. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndirent\n\n\nPointer to the directory entry to query\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n1: The entry is a directory\n\n\n0: The entry is a regular file.\n\n\n\n\nHeader file\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nExample\n\n\nThis example iterates through the contents of a directory, printing the name of each child node.  When the traversal is complete, the code closes the directory handle.\n\n\nint\ntraverse_dir(const char *dirname)\n{\n    struct fs_dirent *dirent;\n    struct fs_dir *dir;\n    char buf[64];\n    uint8_t name_len;\n    int rc;\n\n    rc = fs_opendir(dirname, \ndir);\n    if (rc != 0) {\n        return -1;\n    }\n\n    /* Iterate through the parent directory, printing the name of each child\n     * entry.  The loop only terminates via a function return.\n     */\n    while (1) {\n        /* Retrieve the next child node. */\n        rc = fs_readdir(dir, \ndirent); \n        if (rc == FS_ENOENT) {\n            /* Traversal complete. */\n            return 0;\n        } else if (rc != 0) {\n            /* Unexpected error. */\n            return -1;\n        }\n\n        /* Read the child node\ns name from the file system. */\n        rc = fs_dirent_name(dirent, sizeof buf, buf, \nname_len);\n        if (rc != 0) {\n            return -1;\n        }\n\n        /* Print the child node\ns name to the console. */\n        if (fs_dirent_is_dir(dirent)) {\n            console_printf(\n dir: \n);\n        } else {\n            console_printf(\nfile: \n);\n        }\n        console_printf(\n%s\\n\n, buf);\n    }\n}", 
            "title": "fs_dirent_is_dir"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_dirent_is_dir/#fs95dirent95is95dir", 
            "text": "int fs_dirent_is_dir(const struct fs_dirent *dirent)  Tells you whether the specified directory entry is a sub-directory or a regular file.", 
            "title": "fs_dirent_is_dir"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_dirent_is_dir/#arguments", 
            "text": "Arguments  Description      dirent  Pointer to the directory entry to query", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_dirent_is_dir/#returned-values", 
            "text": "1: The entry is a directory  0: The entry is a regular file.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_dirent_is_dir/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_dirent_is_dir/#example", 
            "text": "This example iterates through the contents of a directory, printing the name of each child node.  When the traversal is complete, the code closes the directory handle.  int\ntraverse_dir(const char *dirname)\n{\n    struct fs_dirent *dirent;\n    struct fs_dir *dir;\n    char buf[64];\n    uint8_t name_len;\n    int rc;\n\n    rc = fs_opendir(dirname,  dir);\n    if (rc != 0) {\n        return -1;\n    }\n\n    /* Iterate through the parent directory, printing the name of each child\n     * entry.  The loop only terminates via a function return.\n     */\n    while (1) {\n        /* Retrieve the next child node. */\n        rc = fs_readdir(dir,  dirent); \n        if (rc == FS_ENOENT) {\n            /* Traversal complete. */\n            return 0;\n        } else if (rc != 0) {\n            /* Unexpected error. */\n            return -1;\n        }\n\n        /* Read the child node s name from the file system. */\n        rc = fs_dirent_name(dirent, sizeof buf, buf,  name_len);\n        if (rc != 0) {\n            return -1;\n        }\n\n        /* Print the child node s name to the console. */\n        if (fs_dirent_is_dir(dirent)) {\n            console_printf(  dir:  );\n        } else {\n            console_printf( file:  );\n        }\n        console_printf( %s\\n , buf);\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_dirent_name/", 
            "text": "fs_dirent_name\n\n\nint fs_dirent_name(const struct fs_dirent *dirent, size_t max_len,\n                   char *out_name, uint8_t *out_name_len)\n\n\n\n\n\nRetrieves the filename of the specified directory entry. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndirent\n\n\nPointer to the directory entry to query\n\n\n\n\n\n\nmax_len\n\n\nSize of the \"out_name\" character buffer\n\n\n\n\n\n\nout_name\n\n\nOn success, the entry's filename is written here; always null-terminated\n\n\n\n\n\n\nout_name_len\n\n\nOn success, contains the actual length of the filename, NOT including the null-terminator\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS error code\n on failure\n\n\n\n\nNotes\n\n\nThe retrieved filename is always null-terminated.  To ensure enough space to hold the full filename plus a null-termintor, a destination buffer of size \nfilename-max-length + 1\n should be used.\n\n\nHeader file\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nExample\n\n\nThis example iterates through the contents of a directory, printing the name of each child node.  When the traversal is complete, the code closes the directory handle.\n\n\nint\ntraverse_dir(const char *dirname)\n{\n    struct fs_dirent *dirent;\n    struct fs_dir *dir;\n    char buf[64];\n    uint8_t name_len;\n    int rc;\n\n    rc = fs_opendir(dirname, \ndir);\n    if (rc != 0) {\n        return -1;\n    }\n\n    /* Iterate through the parent directory, printing the name of each child\n     * entry.  The loop only terminates via a function return.\n     */\n    while (1) {\n        /* Retrieve the next child node. */\n        rc = fs_readdir(dir, \ndirent); \n        if (rc == FS_ENOENT) {\n            /* Traversal complete. */\n            return 0;\n        } else if (rc != 0) {\n            /* Unexpected error. */\n            return -1;\n        }\n\n        /* Read the child node\ns name from the file system. */\n        rc = fs_dirent_name(dirent, sizeof buf, buf, \nname_len);\n        if (rc != 0) {\n            return -1;\n        }\n\n        /* Print the child node\ns name to the console. */\n        if (fs_dirent_is_dir(dirent)) {\n            console_printf(\n dir: \n);\n        } else {\n            console_printf(\nfile: \n);\n        }\n        console_printf(\n%s\\n\n, buf);\n    }\n}", 
            "title": "fs_dirent_name"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_dirent_name/#fs95dirent95name", 
            "text": "int fs_dirent_name(const struct fs_dirent *dirent, size_t max_len,\n                   char *out_name, uint8_t *out_name_len)  Retrieves the filename of the specified directory entry.", 
            "title": "fs_dirent_name"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_dirent_name/#arguments", 
            "text": "Arguments  Description      dirent  Pointer to the directory entry to query    max_len  Size of the \"out_name\" character buffer    out_name  On success, the entry's filename is written here; always null-terminated    out_name_len  On success, contains the actual length of the filename, NOT including the null-terminator", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_dirent_name/#returned-values", 
            "text": "0 on success  FS error code  on failure", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_dirent_name/#notes", 
            "text": "The retrieved filename is always null-terminated.  To ensure enough space to hold the full filename plus a null-termintor, a destination buffer of size  filename-max-length + 1  should be used.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_dirent_name/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_dirent_name/#example", 
            "text": "This example iterates through the contents of a directory, printing the name of each child node.  When the traversal is complete, the code closes the directory handle.  int\ntraverse_dir(const char *dirname)\n{\n    struct fs_dirent *dirent;\n    struct fs_dir *dir;\n    char buf[64];\n    uint8_t name_len;\n    int rc;\n\n    rc = fs_opendir(dirname,  dir);\n    if (rc != 0) {\n        return -1;\n    }\n\n    /* Iterate through the parent directory, printing the name of each child\n     * entry.  The loop only terminates via a function return.\n     */\n    while (1) {\n        /* Retrieve the next child node. */\n        rc = fs_readdir(dir,  dirent); \n        if (rc == FS_ENOENT) {\n            /* Traversal complete. */\n            return 0;\n        } else if (rc != 0) {\n            /* Unexpected error. */\n            return -1;\n        }\n\n        /* Read the child node s name from the file system. */\n        rc = fs_dirent_name(dirent, sizeof buf, buf,  name_len);\n        if (rc != 0) {\n            return -1;\n        }\n\n        /* Print the child node s name to the console. */\n        if (fs_dirent_is_dir(dirent)) {\n            console_printf(  dir:  );\n        } else {\n            console_printf( file:  );\n        }\n        console_printf( %s\\n , buf);\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_filelen/", 
            "text": "fs_filelen\n\n\nint fs_filelen(const struct fs_file *file, uint32_t *out_len)\n\n\n\n\n\nRetrieves the current length of the specified open file.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nPointer to the file to query\n\n\n\n\n\n\nout_len\n\n\nOn success, the number of bytes in the file gets written here\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS error code\n on failure\n\n\n\n\nHeader file\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nExample\n\n\nint\nwrite_config(void)\n{\n    struct fs_file *file;\n    int rc;\n\n    /* If the file doesn\nt exist, create it.  If it does exist, truncate it to\n     * zero bytes.\n     */\n    rc = fs_open(\n/settings/config.txt\n, FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE,\n                 \nfile);\n    if (rc == 0) {\n        /* Write 5 bytes of data to the file. */\n        rc = fs_write(file, \nhello\n, 5);\n        if (rc == 0) {\n            /* The file should now contain exactly five bytes. */\n            assert(fs_filelen(file) == 5);\n        }\n\n        /* Close the file. */\n        fs_close(file);\n    }\n\n    return rc == 0 ? 0 : -1;\n}", 
            "title": "fs_filelen"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_filelen/#fs95filelen", 
            "text": "int fs_filelen(const struct fs_file *file, uint32_t *out_len)  Retrieves the current length of the specified open file.", 
            "title": "fs_filelen"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_filelen/#arguments", 
            "text": "Arguments  Description      file  Pointer to the file to query    out_len  On success, the number of bytes in the file gets written here", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_filelen/#returned-values", 
            "text": "0 on success  FS error code  on failure", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_filelen/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_filelen/#example", 
            "text": "int\nwrite_config(void)\n{\n    struct fs_file *file;\n    int rc;\n\n    /* If the file doesn t exist, create it.  If it does exist, truncate it to\n     * zero bytes.\n     */\n    rc = fs_open( /settings/config.txt , FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE,\n                  file);\n    if (rc == 0) {\n        /* Write 5 bytes of data to the file. */\n        rc = fs_write(file,  hello , 5);\n        if (rc == 0) {\n            /* The file should now contain exactly five bytes. */\n            assert(fs_filelen(file) == 5);\n        }\n\n        /* Close the file. */\n        fs_close(file);\n    }\n\n    return rc == 0 ? 0 : -1;\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_getpos/", 
            "text": "fs_getpos\n\n\nuint32_t fs_getpos(const struct fs_file *file)\n\n\n\n\n\nRetrieves the current read and write position of the specified open file. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nPointer to the file to query\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\nThe file offset, in bytes\n\n\n\n\nNotes\n\n\nIf a file is opened in append mode, its write pointer is always positioned at the end of the file.  Calling this function on such a file only indicates the read position.\n\n\nHeader file\n\n\n#include \nfs/fs.h", 
            "title": "fs_getpos"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_getpos/#fs95getpos", 
            "text": "uint32_t fs_getpos(const struct fs_file *file)  Retrieves the current read and write position of the specified open file.", 
            "title": "fs_getpos"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_getpos/#arguments", 
            "text": "Arguments  Description      file  Pointer to the file to query", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_getpos/#returned-values", 
            "text": "The file offset, in bytes", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_getpos/#notes", 
            "text": "If a file is opened in append mode, its write pointer is always positioned at the end of the file.  Calling this function on such a file only indicates the read position.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_getpos/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_mkdir/", 
            "text": "fs_mkdir\n\n\nint fs_mkdir(const char *path)\n\n\n\n\n\nCreates the directory represented by the specified path.  \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nThe name of the directory to create\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS error code\n on failure.\n\n\n\n\nNotes\n\n\nAll intermediate directories must already exist.  The specified path must start with a '/' character.\n\n\nHeader file\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nExample\n\n\nThis example demonstrates creating a series of nested directories.\n\n\nint\ncreate_path(void)\n{\n    int rc;\n\n    rc = fs_mkdir(\n/data\n);\n    if (rc != 0) goto err;\n\n    rc = fs_mkdir(\n/data/logs\n);\n    if (rc != 0) goto err;\n\n    rc = fs_mkdir(\n/data/logs/temperature\n);\n    if (rc != 0) goto err;\n\n    rc = fs_mkdir(\n/data/logs/temperature/current\n);\n    if (rc != 0) goto err;\n\n    return 0;\n\nerr:\n    /* Clean up the incomplete directory tree, if any. */\n    fs_unlink(\n/data\n);\n    return -1;\n}", 
            "title": "fs_mkdir"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_mkdir/#fs95mkdir", 
            "text": "int fs_mkdir(const char *path)  Creates the directory represented by the specified path.", 
            "title": "fs_mkdir"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_mkdir/#arguments", 
            "text": "Arguments  Description      path  The name of the directory to create", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_mkdir/#returned-values", 
            "text": "0 on success  FS error code  on failure.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_mkdir/#notes", 
            "text": "All intermediate directories must already exist.  The specified path must start with a '/' character.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_mkdir/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_mkdir/#example", 
            "text": "This example demonstrates creating a series of nested directories.  int\ncreate_path(void)\n{\n    int rc;\n\n    rc = fs_mkdir( /data );\n    if (rc != 0) goto err;\n\n    rc = fs_mkdir( /data/logs );\n    if (rc != 0) goto err;\n\n    rc = fs_mkdir( /data/logs/temperature );\n    if (rc != 0) goto err;\n\n    rc = fs_mkdir( /data/logs/temperature/current );\n    if (rc != 0) goto err;\n\n    return 0;\n\nerr:\n    /* Clean up the incomplete directory tree, if any. */\n    fs_unlink( /data );\n    return -1;\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_open/", 
            "text": "fs_open\n\n\nint fs_open(const char *filename, uint8_t access_flags,\n            struct fs_file **out_file)\n\n\n\n\n\nOpens a file at the specified path.  The result of opening a nonexistent file depends on the access flags specified.  All intermediate directories must already exist.\n\n\nThe access flags are best understood by comparing them to their equivalent mode strings accepted by the C standard library function \nfopen()\n.\nThe mode strings passed to \nfopen()\n map to \nfs_open()\n's access flags as follows:\n\n\nr\n  -  FS_ACCESS_READ\n\nr+\n -  FS_ACCESS_READ  | FS_ACCESS_WRITE\n\nw\n  -  FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE\n\nw+\n -  FS_ACCESS_READ  | FS_ACCESS_WRITE    | FS_ACCESS_TRUNCATE\n\na\n  -  FS_ACCESS_WRITE | FS_ACCESS_APPEND\n\na+\n -  FS_ACCESS_READ  | FS_ACCESS_WRITE    | FS_ACCESS_APPEND\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfilename\n\n\nNull-terminated string indicating the full path of the file to open\n\n\n\n\n\n\naccess_flags\n\n\nFlags controlling file access; see above table\n\n\n\n\n\n\nout_file\n\n\nOn success, a pointer to the newly-created file handle gets written here\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS error code\n on failure\n\n\n\n\nNotes\n\n\n\n\n\n\nThere is no concept of current working directory. Therefore all file names should start with '/'.\n\n\n\n\n\n\nAlways close files when you are done using them.  If you forget to close a file, the file stays open forever.  Do this too many times, and the underlying file system will run out of file handles, causing subsequent open operations to fail.  This type of bug is known as a file handle leak or a file descriptor leak.\n\n\n\n\n\n\nHeader file\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nExample\n\n\nThe below code opens the file \n/settings/config.txt\n for reading, reads some data, and then closes the file.\n\n\nint\nread_config(void)\n{\n    struct fs_file *file;\n    uint32_t bytes_read;\n    uint8_t buf[16];\n    int rc;\n\n    /* Open the file for reading. */\n    rc = fs_open(\n/settings/config.txt\n, FS_ACCESS_READ, \nfile);\n    if (rc != 0) {\n        return -1;\n    }\n\n    /* Read up to 16 bytes from the file. */\n    rc = fs_read(file, sizeof buf, buf, \nbytes_read);\n    if (rc == 0) {\n        /* buf now contains up to 16 bytes of file data. */\n        console_printf(\nread %u bytes\\n\n, bytes_read)\n    }\n\n    /* Close the file. */\n    fs_close(file);\n\n    return rc == 0 ? 0 : -1;\n}", 
            "title": "fs_open"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_open/#fs95open", 
            "text": "int fs_open(const char *filename, uint8_t access_flags,\n            struct fs_file **out_file)  Opens a file at the specified path.  The result of opening a nonexistent file depends on the access flags specified.  All intermediate directories must already exist.  The access flags are best understood by comparing them to their equivalent mode strings accepted by the C standard library function  fopen() .\nThe mode strings passed to  fopen()  map to  fs_open() 's access flags as follows:  r   -  FS_ACCESS_READ r+  -  FS_ACCESS_READ  | FS_ACCESS_WRITE w   -  FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE w+  -  FS_ACCESS_READ  | FS_ACCESS_WRITE    | FS_ACCESS_TRUNCATE a   -  FS_ACCESS_WRITE | FS_ACCESS_APPEND a+  -  FS_ACCESS_READ  | FS_ACCESS_WRITE    | FS_ACCESS_APPEND", 
            "title": "fs_open"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_open/#arguments", 
            "text": "Argument  Description      filename  Null-terminated string indicating the full path of the file to open    access_flags  Flags controlling file access; see above table    out_file  On success, a pointer to the newly-created file handle gets written here", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_open/#returned-values", 
            "text": "0 on success  FS error code  on failure", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_open/#notes", 
            "text": "There is no concept of current working directory. Therefore all file names should start with '/'.    Always close files when you are done using them.  If you forget to close a file, the file stays open forever.  Do this too many times, and the underlying file system will run out of file handles, causing subsequent open operations to fail.  This type of bug is known as a file handle leak or a file descriptor leak.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_open/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_open/#example", 
            "text": "The below code opens the file  /settings/config.txt  for reading, reads some data, and then closes the file.  int\nread_config(void)\n{\n    struct fs_file *file;\n    uint32_t bytes_read;\n    uint8_t buf[16];\n    int rc;\n\n    /* Open the file for reading. */\n    rc = fs_open( /settings/config.txt , FS_ACCESS_READ,  file);\n    if (rc != 0) {\n        return -1;\n    }\n\n    /* Read up to 16 bytes from the file. */\n    rc = fs_read(file, sizeof buf, buf,  bytes_read);\n    if (rc == 0) {\n        /* buf now contains up to 16 bytes of file data. */\n        console_printf( read %u bytes\\n , bytes_read)\n    }\n\n    /* Close the file. */\n    fs_close(file);\n\n    return rc == 0 ? 0 : -1;\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_opendir/", 
            "text": "fs_opendir\n\n\nint fs_opendir(const char *path, struct fs_dir **out_dir)\n\n\n\n\n\nOpens the directory at the specified path.  The directory's contents can be read with subsequent calls to fs_readdir().  When you are done with the directory handle, close it with fs_closedir(). \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nThe name of the directory to open\n\n\n\n\n\n\nout_dir\n\n\nOn success, points to the directory handle\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS_ENOENT if the specified directory does not exist\n\n\nOther \nFS error code\n on error.\n\n\n\n\nNotes\n\n\n\n\n\n\nUnlinking files from the directory while it is open may result in unpredictable behavior during subsequent calls to \nfs_readdir()\n.  New files can be created inside the directory without causing problems.\n\n\n\n\n\n\nAlways close a directory when you are done reading from it.  If you forget to close a directory, the directory stays open forever.  Do this too many times, and the underlying file system will run out of directory handles, causing subsequent open operations to fail.  This type of bug is known as a file handle leak or a file descriptor leak.\n\n\n\n\n\n\nHeader file\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nExample\n\n\nThis example iterates through the contents of a directory, printing the name of each child node.  When the traversal is complete, the code closes the directory handle.\n\n\nint\ntraverse_dir(const char *dirname)\n{\n    struct fs_dirent *dirent;\n    struct fs_dir *dir;\n    char buf[64];\n    uint8_t name_len;\n    int rc;\n\n    rc = fs_opendir(dirname, \ndir);\n    if (rc != 0) {\n        return -1;\n    }\n\n    /* Iterate through the parent directory, printing the name of each child\n     * entry.  The loop only terminates via a function return.\n     */\n    while (1) {\n        /* Retrieve the next child node. */\n        rc = fs_readdir(dir, \ndirent); \n        if (rc == FS_ENOENT) {\n            /* Traversal complete. */\n            return 0;\n        } else if (rc != 0) {\n            /* Unexpected error. */\n            return -1;\n        }\n\n        /* Read the child node\ns name from the file system. */\n        rc = fs_dirent_name(dirent, sizeof buf, buf, \nname_len);\n        if (rc != 0) {\n            return -1;\n        }\n\n        /* Print the child node\ns name to the console. */\n        if (fs_dirent_is_dir(dirent)) {\n            console_printf(\n dir: \n);\n        } else {\n            console_printf(\nfile: \n);\n        }\n        console_printf(\n%s\\n\n, buf);\n    }\n}", 
            "title": "fs_opendir"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_opendir/#fs95opendir", 
            "text": "int fs_opendir(const char *path, struct fs_dir **out_dir)  Opens the directory at the specified path.  The directory's contents can be read with subsequent calls to fs_readdir().  When you are done with the directory handle, close it with fs_closedir().", 
            "title": "fs_opendir"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_opendir/#arguments", 
            "text": "Arguments  Description      path  The name of the directory to open    out_dir  On success, points to the directory handle", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_opendir/#returned-values", 
            "text": "0 on success  FS_ENOENT if the specified directory does not exist  Other  FS error code  on error.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_opendir/#notes", 
            "text": "Unlinking files from the directory while it is open may result in unpredictable behavior during subsequent calls to  fs_readdir() .  New files can be created inside the directory without causing problems.    Always close a directory when you are done reading from it.  If you forget to close a directory, the directory stays open forever.  Do this too many times, and the underlying file system will run out of directory handles, causing subsequent open operations to fail.  This type of bug is known as a file handle leak or a file descriptor leak.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_opendir/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_opendir/#example", 
            "text": "This example iterates through the contents of a directory, printing the name of each child node.  When the traversal is complete, the code closes the directory handle.  int\ntraverse_dir(const char *dirname)\n{\n    struct fs_dirent *dirent;\n    struct fs_dir *dir;\n    char buf[64];\n    uint8_t name_len;\n    int rc;\n\n    rc = fs_opendir(dirname,  dir);\n    if (rc != 0) {\n        return -1;\n    }\n\n    /* Iterate through the parent directory, printing the name of each child\n     * entry.  The loop only terminates via a function return.\n     */\n    while (1) {\n        /* Retrieve the next child node. */\n        rc = fs_readdir(dir,  dirent); \n        if (rc == FS_ENOENT) {\n            /* Traversal complete. */\n            return 0;\n        } else if (rc != 0) {\n            /* Unexpected error. */\n            return -1;\n        }\n\n        /* Read the child node s name from the file system. */\n        rc = fs_dirent_name(dirent, sizeof buf, buf,  name_len);\n        if (rc != 0) {\n            return -1;\n        }\n\n        /* Print the child node s name to the console. */\n        if (fs_dirent_is_dir(dirent)) {\n            console_printf(  dir:  );\n        } else {\n            console_printf( file:  );\n        }\n        console_printf( %s\\n , buf);\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_read/", 
            "text": "fs_read\n\n\nint fs_read(struct fs_file *file, uint32_t len, void *out_data, uint32_t *out_len)\n\n\n\n\n\nReads data from the specified file.  If more data is requested than remains in the file, all available data is retrieved and a success code is returned.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nPointer to the the file to read from\n\n\n\n\n\n\nlen\n\n\nThe number of bytes to attempt to read\n\n\n\n\n\n\nout_data\n\n\nThe destination buffer to read into\n\n\n\n\n\n\nout_len\n\n\nOn success, the number of bytes actually read gets written here.  Pass null if you don't care.\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS error code\n on failure\n\n\n\n\nHeader file\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nExample\n\n\nThe below code opens the file \n/settings/config.txt\n for reading, reads some data, and then closes the file.\n\n\nint\nread_config(void)\n{\n    struct fs_file *file;\n    uint32_t bytes_read;\n    uint8_t buf[16];\n    int rc;\n\n    /* Open the file for reading. */\n    rc = fs_open(\n/settings/config.txt\n, FS_ACCESS_READ, \nfile);\n    if (rc != 0) {\n        return -1;\n    }\n\n    /* Read up to 16 bytes from the file. */\n    rc = fs_read(file, sizeof buf, buf, \nbytes_read);\n    if (rc == 0) {\n        /* buf now contains up to 16 bytes of file data. */\n        console_printf(\nread %u bytes\\n\n, bytes_read)\n    }\n\n    /* Close the file. */\n    fs_close(file);\n\n    return rc == 0 ? 0 : -1;\n}", 
            "title": "fs_read"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_read/#fs95read", 
            "text": "int fs_read(struct fs_file *file, uint32_t len, void *out_data, uint32_t *out_len)  Reads data from the specified file.  If more data is requested than remains in the file, all available data is retrieved and a success code is returned.", 
            "title": "fs_read"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_read/#arguments", 
            "text": "Arguments  Description      file  Pointer to the the file to read from    len  The number of bytes to attempt to read    out_data  The destination buffer to read into    out_len  On success, the number of bytes actually read gets written here.  Pass null if you don't care.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_read/#returned-values", 
            "text": "0 on success  FS error code  on failure", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_read/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_read/#example", 
            "text": "The below code opens the file  /settings/config.txt  for reading, reads some data, and then closes the file.  int\nread_config(void)\n{\n    struct fs_file *file;\n    uint32_t bytes_read;\n    uint8_t buf[16];\n    int rc;\n\n    /* Open the file for reading. */\n    rc = fs_open( /settings/config.txt , FS_ACCESS_READ,  file);\n    if (rc != 0) {\n        return -1;\n    }\n\n    /* Read up to 16 bytes from the file. */\n    rc = fs_read(file, sizeof buf, buf,  bytes_read);\n    if (rc == 0) {\n        /* buf now contains up to 16 bytes of file data. */\n        console_printf( read %u bytes\\n , bytes_read)\n    }\n\n    /* Close the file. */\n    fs_close(file);\n\n    return rc == 0 ? 0 : -1;\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_readdir/", 
            "text": "fs_readdir\n\n\nint fs_readdir(struct fs_dir *dir, struct fs_dirent **out_dirent);\n\n\n\n\n\nReads the next entry in an open directory. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndir\n\n\nThe directory handle to read from\n\n\n\n\n\n\nout_dirent\n\n\nOn success, points to the next child entry in the specified directory\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS_ENOENT if there are no more entries in the parent directory\n\n\nOther \nFS error code\n on error.\n\n\n\n\nHeader file\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nExample\n\n\nThis example iterates through the contents of a directory, printing the name of each child node.  When the traversal is complete, the code closes the directory handle.\n\n\nint\ntraverse_dir(const char *dirname)\n{\n    struct fs_dirent *dirent;\n    struct fs_dir *dir;\n    char buf[64];\n    uint8_t name_len;\n    int rc;\n\n    rc = fs_opendir(dirname, \ndir);\n    if (rc != 0) {\n        return -1;\n    }\n\n    /* Iterate through the parent directory, printing the name of each child\n     * entry.  The loop only terminates via a function return.\n     */\n    while (1) {\n        /* Retrieve the next child node. */\n        rc = fs_readdir(dir, \ndirent); \n        if (rc == FS_ENOENT) {\n            /* Traversal complete. */\n            return 0;\n        } else if (rc != 0) {\n            /* Unexpected error. */\n            return -1;\n        }\n\n        /* Read the child node\ns name from the file system. */\n        rc = fs_dirent_name(dirent, sizeof buf, buf, \nname_len);\n        if (rc != 0) {\n            return -1;\n        }\n\n        /* Print the child node\ns name to the console. */\n        if (fs_dirent_is_dir(dirent)) {\n            console_printf(\n dir: \n);\n        } else {\n            console_printf(\nfile: \n);\n        }\n        console_printf(\n%s\\n\n, buf);\n    }\n}", 
            "title": "fs_readdir"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_readdir/#fs_readdir", 
            "text": "int fs_readdir(struct fs_dir *dir, struct fs_dirent **out_dirent);  Reads the next entry in an open directory.", 
            "title": "fs_readdir"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_readdir/#arguments", 
            "text": "Arguments  Description      dir  The directory handle to read from    out_dirent  On success, points to the next child entry in the specified directory", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_readdir/#returned-values", 
            "text": "0 on success  FS_ENOENT if there are no more entries in the parent directory  Other  FS error code  on error.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_readdir/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_readdir/#example", 
            "text": "This example iterates through the contents of a directory, printing the name of each child node.  When the traversal is complete, the code closes the directory handle.  int\ntraverse_dir(const char *dirname)\n{\n    struct fs_dirent *dirent;\n    struct fs_dir *dir;\n    char buf[64];\n    uint8_t name_len;\n    int rc;\n\n    rc = fs_opendir(dirname,  dir);\n    if (rc != 0) {\n        return -1;\n    }\n\n    /* Iterate through the parent directory, printing the name of each child\n     * entry.  The loop only terminates via a function return.\n     */\n    while (1) {\n        /* Retrieve the next child node. */\n        rc = fs_readdir(dir,  dirent); \n        if (rc == FS_ENOENT) {\n            /* Traversal complete. */\n            return 0;\n        } else if (rc != 0) {\n            /* Unexpected error. */\n            return -1;\n        }\n\n        /* Read the child node s name from the file system. */\n        rc = fs_dirent_name(dirent, sizeof buf, buf,  name_len);\n        if (rc != 0) {\n            return -1;\n        }\n\n        /* Print the child node s name to the console. */\n        if (fs_dirent_is_dir(dirent)) {\n            console_printf(  dir:  );\n        } else {\n            console_printf( file:  );\n        }\n        console_printf( %s\\n , buf);\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_register/", 
            "text": "fs_register\n\n\nint fs_register(const struct fs_ops *fops)\n\n\n\n\n\nRegisters a file system with the abstraction layer.  On success, all calls into \nfs/fs\n will use the registered file system.\n\n\nArguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfops\n\n\nA pointer to const \nstruct fs_ops\n. Specifies which file system routines get mapped to the \nfs/fs\n API.  All function pointers must be filled in.\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS_EEXIST\n if a file system has already been registered\n\n\n\n\nNotes\n\n\nOnly one file system can be registered.  The registered file system is mounted in the root directory (\n/\n).\n\n\nHeader file\n\n\n#include \nfs/fs.h", 
            "title": "fs_register"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_register/#fs95register", 
            "text": "int fs_register(const struct fs_ops *fops)  Registers a file system with the abstraction layer.  On success, all calls into  fs/fs  will use the registered file system.", 
            "title": "fs_register"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_register/#arguments", 
            "text": "Argument  Description      fops  A pointer to const  struct fs_ops . Specifies which file system routines get mapped to the  fs/fs  API.  All function pointers must be filled in.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_register/#returned-values", 
            "text": "0 on success  FS_EEXIST  if a file system has already been registered", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_register/#notes", 
            "text": "Only one file system can be registered.  The registered file system is mounted in the root directory ( / ).", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_register/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_rename/", 
            "text": "fs_rename\n\n\nint fs_rename(const char *from, const char *to)\n\n\n\n\n\nPerforms a rename and / or move of the specified source path to the specified destination.  The source path can refer to a file or a directory.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfrom\n\n\nThe source path\n\n\n\n\n\n\nto\n\n\nThe destination path\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS error code\n on failure\n\n\n\n\nNotes\n\n\nThe source path can refer to either a file or a directory.  All intermediate directories in the destination path must already exist.  If the source path refers to a file, the destination path must contain a full filename path, rather than just the new parent directory.  If an object already exists at the specified destination path, this function causes it to be unlinked prior to the rename (i.e., the destination gets clobbered).\n\n\nHeader file\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nExample\n\n\nThis example demonstrates how to use fs_rename() to perform a log rotation.  In this example, there is one primary log and three archived logs.  \nFS_ENOENT\n errors returned by \nfs_rename()\n are ignored; it is not an error if an archived log was never created.\n\n\nint\nrotate_logs(void)\n{\n    struct fs_file *file;\n    int rc;\n\n    /* Rotate each of the log files. */\n    rc = fs_rename(\n/var/log/messages.2\n, \n/var/log/messages.3\n)\n    if (rc != 0 \n rc != FS_ENOENT) return -1;\n\n    rc = fs_rename(\n/var/log/messages.1\n, \n/var/log/messages.2\n)\n    if (rc != 0 \n rc != FS_ENOENT) return -1;\n\n    rc = fs_rename(\n/var/log/messages.0\n, \n/var/log/messages.1\n)\n    if (rc != 0 \n rc != FS_ENOENT) return -1;\n\n    rc = fs_rename(\n/var/log/messages\n, \n/var/log/messages.0\n)\n    if (rc != 0 \n rc != FS_ENOENT) return -1;\n\n    /* Now create the new log file. */\n    rc = fs_open(\n/var/log/messages\n, FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE,\n                 \nfile);\n    if (rc != 0) return -1;\n\n    rc = fs_write(file, \nCreating new log file.\\n\n, 23);\n    fs_close(file);\n\n    return rc == 0 ? 0 : -1;\n}", 
            "title": "fs_rename"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_rename/#fs95rename", 
            "text": "int fs_rename(const char *from, const char *to)  Performs a rename and / or move of the specified source path to the specified destination.  The source path can refer to a file or a directory.", 
            "title": "fs_rename"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_rename/#arguments", 
            "text": "Arguments  Description      from  The source path    to  The destination path", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_rename/#returned-values", 
            "text": "0 on success  FS error code  on failure", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_rename/#notes", 
            "text": "The source path can refer to either a file or a directory.  All intermediate directories in the destination path must already exist.  If the source path refers to a file, the destination path must contain a full filename path, rather than just the new parent directory.  If an object already exists at the specified destination path, this function causes it to be unlinked prior to the rename (i.e., the destination gets clobbered).", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_rename/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_rename/#example", 
            "text": "This example demonstrates how to use fs_rename() to perform a log rotation.  In this example, there is one primary log and three archived logs.   FS_ENOENT  errors returned by  fs_rename()  are ignored; it is not an error if an archived log was never created.  int\nrotate_logs(void)\n{\n    struct fs_file *file;\n    int rc;\n\n    /* Rotate each of the log files. */\n    rc = fs_rename( /var/log/messages.2 ,  /var/log/messages.3 )\n    if (rc != 0   rc != FS_ENOENT) return -1;\n\n    rc = fs_rename( /var/log/messages.1 ,  /var/log/messages.2 )\n    if (rc != 0   rc != FS_ENOENT) return -1;\n\n    rc = fs_rename( /var/log/messages.0 ,  /var/log/messages.1 )\n    if (rc != 0   rc != FS_ENOENT) return -1;\n\n    rc = fs_rename( /var/log/messages ,  /var/log/messages.0 )\n    if (rc != 0   rc != FS_ENOENT) return -1;\n\n    /* Now create the new log file. */\n    rc = fs_open( /var/log/messages , FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE,\n                  file);\n    if (rc != 0) return -1;\n\n    rc = fs_write(file,  Creating new log file.\\n , 23);\n    fs_close(file);\n\n    return rc == 0 ? 0 : -1;\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_seek/", 
            "text": "fs_seek\n\n\nint fs_seek(struct fs_file *file, uint32_t offset)\n\n\n\n\n\nPositions a file's read and write pointer at the specified offset.  The offset is expressed as the number of bytes from the start of the file (i.e., seeking to offset 0 places the pointer at the first byte in the file).\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nPointer to the file to reposition\n\n\n\n\n\n\noffset\n\n\nThe 0-based file offset to seek to\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS error code\n on failure\n\n\n\n\nNotes\n\n\nIf a file is opened in append mode, its write pointer is always positioned at the end of the file.  Calling this function on such a file only affects the read pointer.\n\n\nHeader file\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nExample\n\n\nThe following example reads four bytes from a file, starting at an offset of eight.\n\n\nint\nread_part1_middle(void)\n{\n    struct fs_file *file;\n    uint32_t bytes_read;\n    uint8_t buf[4];\n    int rc;\n\n    rc = fs_open(\n/data/parts/1.bin\n, FS_ACCESS_READ, \nfile);\n    if (rc == 0) {\n        /* Advance to offset 8. */\n        rc = fs_seek(file, 8);\n        if (rc == 0) {\n            /* Read bytes 8, 9, 10, and 11. */\n            rc = fs_read(file, 4, buf, \nbytes_read);\n            if (rc == 0) {\n                /* buf now contains up to 4 bytes of file data. */\n                console_printf(\nread %u bytes\\n\n, bytes_read)\n            }\n        }\n\n        /* Close the file. */\n        fs_close(file);\n    }\n\n    return rc == 0 ? 0 : -1;\n}", 
            "title": "fs_seek"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_seek/#fs95seek", 
            "text": "int fs_seek(struct fs_file *file, uint32_t offset)  Positions a file's read and write pointer at the specified offset.  The offset is expressed as the number of bytes from the start of the file (i.e., seeking to offset 0 places the pointer at the first byte in the file).", 
            "title": "fs_seek"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_seek/#arguments", 
            "text": "Arguments  Description      file  Pointer to the file to reposition    offset  The 0-based file offset to seek to", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_seek/#returned-values", 
            "text": "0 on success  FS error code  on failure", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_seek/#notes", 
            "text": "If a file is opened in append mode, its write pointer is always positioned at the end of the file.  Calling this function on such a file only affects the read pointer.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_seek/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_seek/#example", 
            "text": "The following example reads four bytes from a file, starting at an offset of eight.  int\nread_part1_middle(void)\n{\n    struct fs_file *file;\n    uint32_t bytes_read;\n    uint8_t buf[4];\n    int rc;\n\n    rc = fs_open( /data/parts/1.bin , FS_ACCESS_READ,  file);\n    if (rc == 0) {\n        /* Advance to offset 8. */\n        rc = fs_seek(file, 8);\n        if (rc == 0) {\n            /* Read bytes 8, 9, 10, and 11. */\n            rc = fs_read(file, 4, buf,  bytes_read);\n            if (rc == 0) {\n                /* buf now contains up to 4 bytes of file data. */\n                console_printf( read %u bytes\\n , bytes_read)\n            }\n        }\n\n        /* Close the file. */\n        fs_close(file);\n    }\n\n    return rc == 0 ? 0 : -1;\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_unlink/", 
            "text": "fs_unlink\n\n\nint fs_unlink(const char *filename)\n\n\n\n\n\nUnlinks the file or directory at the specified path.  This is the function to use if you want to delete a file or directory from the disk.  If the path refers to a directory, all the directory's descendants are recursively unlinked.  Any open file handles refering to an unlinked file remain valid, and can be read from and written to as long as they remain open.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfilename\n\n\nThe path of the file or directory to unlink\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS error code\n on failure\n\n\n\n\nHeader file\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nExample\n\n\nThe following example creates a file and then immediately unlinks it.  By unlinking the file, this function prevents other OS tasks from accessing it.  When the function closes the file, it is deleted from the disk.\n\n\nint\nprocess_data(void)\n{\n    struct fs_file *file;\n    int rc;\n\n    /* If the file doesn\nt exist, create it.  If it does exist, truncate it to\n     * zero bytes.\n     */\n    rc = fs_open(\n/tmp/buffer.bin\n, FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE, \nfile);\n    if (rc == 0) {\n        /* Unlink the file so that other tasks cannot access it. */\n        fs_unlink(\n/tmp/buffer.bin\n)\n\n        /* \nuse the file as a data buffer\n */\n\n        /* Close the file.  This operation causes the file to be deleted from\n         * the disk because it was unlinked earlier (and it has no other open\n         * file handles).\n         */\n        fs_close(file);\n    }\n\n    return rc == 0 ? 0 : -1;\n}", 
            "title": "fs_unlink"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_unlink/#fs95unlink", 
            "text": "int fs_unlink(const char *filename)  Unlinks the file or directory at the specified path.  This is the function to use if you want to delete a file or directory from the disk.  If the path refers to a directory, all the directory's descendants are recursively unlinked.  Any open file handles refering to an unlinked file remain valid, and can be read from and written to as long as they remain open.", 
            "title": "fs_unlink"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_unlink/#arguments", 
            "text": "Arguments  Description      filename  The path of the file or directory to unlink", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_unlink/#returned-values", 
            "text": "0 on success  FS error code  on failure", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_unlink/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_unlink/#example", 
            "text": "The following example creates a file and then immediately unlinks it.  By unlinking the file, this function prevents other OS tasks from accessing it.  When the function closes the file, it is deleted from the disk.  int\nprocess_data(void)\n{\n    struct fs_file *file;\n    int rc;\n\n    /* If the file doesn t exist, create it.  If it does exist, truncate it to\n     * zero bytes.\n     */\n    rc = fs_open( /tmp/buffer.bin , FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE,  file);\n    if (rc == 0) {\n        /* Unlink the file so that other tasks cannot access it. */\n        fs_unlink( /tmp/buffer.bin )\n\n        /*  use the file as a data buffer  */\n\n        /* Close the file.  This operation causes the file to be deleted from\n         * the disk because it was unlinked earlier (and it has no other open\n         * file handles).\n         */\n        fs_close(file);\n    }\n\n    return rc == 0 ? 0 : -1;\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_write/", 
            "text": "fs_write\n\n\nint fs_write(struct fs_file *file, const void *data, int len)\n\n\n\n\n\nWrites the supplied data to the current offset of the specified file handle.  \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nPointer to the file to write to\n\n\n\n\n\n\ndata\n\n\nThe data to write\n\n\n\n\n\n\nlen\n\n\nThe number of bytes to write\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS error code\n on failure\n\n\n\n\nNotes\n\n\nFor files opened in append mode, the specified data is always written to the end.\n\n\nHeader file\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nExample\n\n\nint\nwrite_config(void)\n{\n    struct fs_file *file;\n    int rc;\n\n    /* If the file doesn\nt exist, create it.  If it does exist, truncate it to\n     * zero bytes.\n     */\n    rc = fs_open(\n/settings/config.txt\n, FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE,\n                 \nfile);\n    if (rc == 0) {\n        /* Write 5 bytes of data to the file. */\n        rc = fs_write(file, \nhello\n, 5);\n        if (rc == 0) {\n            /* The file should now contain exactly five bytes. */\n            assert(fs_filelen(file) == 5);\n        }\n\n        /* Close the file. */\n        fs_close(file);\n    }\n\n    return rc == 0 ? 0 : -1;\n}", 
            "title": "fs_write"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_write/#fs95write", 
            "text": "int fs_write(struct fs_file *file, const void *data, int len)  Writes the supplied data to the current offset of the specified file handle.", 
            "title": "fs_write"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_write/#arguments", 
            "text": "Arguments  Description      file  Pointer to the file to write to    data  The data to write    len  The number of bytes to write", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_write/#returned-values", 
            "text": "0 on success  FS error code  on failure", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_write/#notes", 
            "text": "For files opened in append mode, the specified data is always written to the end.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_write/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fs_write/#example", 
            "text": "int\nwrite_config(void)\n{\n    struct fs_file *file;\n    int rc;\n\n    /* If the file doesn t exist, create it.  If it does exist, truncate it to\n     * zero bytes.\n     */\n    rc = fs_open( /settings/config.txt , FS_ACCESS_WRITE | FS_ACCESS_TRUNCATE,\n                  file);\n    if (rc == 0) {\n        /* Write 5 bytes of data to the file. */\n        rc = fs_write(file,  hello , 5);\n        if (rc == 0) {\n            /* The file should now contain exactly five bytes. */\n            assert(fs_filelen(file) == 5);\n        }\n\n        /* Close the file. */\n        fs_close(file);\n    }\n\n    return rc == 0 ? 0 : -1;\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/fs/fsutil_read_file/", 
            "text": "fsutil_read_file\n\n\nint fsutil_read_file(const char *path, uint32_t offset, uint32_t len,\n                     void *dst, uint32_t *out_len)\n\n\n\n\n\nCalls fs_open(), fs_read(), and fs_close() to open a file at the specified path, retrieve data from the file starting from the specified offset, and close the file and invalidate the file handle.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nPointer to the directory entry to query\n\n\n\n\n\n\noffset\n\n\nPosition of the file's read pointer\n\n\n\n\n\n\nlen\n\n\nNumber of bytes to attempt to read\n\n\n\n\n\n\ndst\n\n\nDestination buffer to read into\n\n\n\n\n\n\nout_len\n\n\nOn success, the number of bytes actually read gets written here.  Pass null if you don't care.\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS error code\n on failure\n\n\n\n\nNotes\n\n\nThis is a convenience function. It is useful when the amount of data to be read from the file is small (i.e., all the data read can easily fit in a single buffer).\n\n\nHeader file\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nExample\n\n\nThis example demonstrates reading a small text file in its entirety and printing its contents to the console.\n\n\nint\nprint_status(void)\n{\n    uint32_t bytes_read;\n    uint8_t buf[16];\n    int rc;\n\n    /* Read up to 15 bytes from the start of the file. */\n    rc = fsutil_read_file(\n/cfg/status.txt\n, 0, sizeof buf - 1, buf,\n                          \nbytes_read);\n    if (rc != 0) return -1;\n\n    /* Null-terminate the string just read. */\n    buf[bytes_read] = \n\\0\n;\n\n    /* Print the file contents to the console. */\n    console_printf(\n%s\\n\n, buf);\n\n    return 0;\n}", 
            "title": "fsutil_read_file"
        }, 
        {
            "location": "/os/modules/fs/fs/fsutil_read_file/#fsutil95read95file", 
            "text": "int fsutil_read_file(const char *path, uint32_t offset, uint32_t len,\n                     void *dst, uint32_t *out_len)  Calls fs_open(), fs_read(), and fs_close() to open a file at the specified path, retrieve data from the file starting from the specified offset, and close the file and invalidate the file handle.", 
            "title": "fsutil_read_file"
        }, 
        {
            "location": "/os/modules/fs/fs/fsutil_read_file/#arguments", 
            "text": "Arguments  Description      path  Pointer to the directory entry to query    offset  Position of the file's read pointer    len  Number of bytes to attempt to read    dst  Destination buffer to read into    out_len  On success, the number of bytes actually read gets written here.  Pass null if you don't care.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fsutil_read_file/#returned-values", 
            "text": "0 on success  FS error code  on failure", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fsutil_read_file/#notes", 
            "text": "This is a convenience function. It is useful when the amount of data to be read from the file is small (i.e., all the data read can easily fit in a single buffer).", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/fs/fs/fsutil_read_file/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fsutil_read_file/#example", 
            "text": "This example demonstrates reading a small text file in its entirety and printing its contents to the console.  int\nprint_status(void)\n{\n    uint32_t bytes_read;\n    uint8_t buf[16];\n    int rc;\n\n    /* Read up to 15 bytes from the start of the file. */\n    rc = fsutil_read_file( /cfg/status.txt , 0, sizeof buf - 1, buf,\n                           bytes_read);\n    if (rc != 0) return -1;\n\n    /* Null-terminate the string just read. */\n    buf[bytes_read] =  \\0 ;\n\n    /* Print the file contents to the console. */\n    console_printf( %s\\n , buf);\n\n    return 0;\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/fs/fsutil_write_file/", 
            "text": "fsutil_write_file\n\n\nint fsutil_write_file(const char *path, const void *data, uint32_t len)\n\n\n\n\n\nCalls fs_open(), fs_write(), and fs_close() to open a file at the specified path, write the supplied data to the current offset of the specified file handle, and close the file and invalidate the file handle.  If the specified file already exists, it is truncated and overwritten with the specified data.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nPointer to the file to write to\n\n\n\n\n\n\ndata\n\n\nThe data to write\n\n\n\n\n\n\nlen\n\n\nThe number of bytes to write\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS error code\n on failure\n\n\n\n\nHeader file\n\n\n#include \nfs/fs.h\n\n\n\n\n\n\nExample\n\n\nThis example creates a 4-byte file.\n\n\nint\nwrite_id(void)\n{\n    int rc;\n\n    /* Create the parent directory. */\n    rc = fs_mkdir(\n/cfg\n);\n    if (rc != 0 \n rc != FS_EALREADY) {\n        return -1;\n    }\n\n    /* Create a file and write four bytes to it. */\n    rc = fsutil_write_file(\n/cfg/id.txt\n, \n1234\n, 4);\n    if (rc != 0) {\n        return -1;\n    }\n\n    return 0;\n}", 
            "title": "fsutil_write_file"
        }, 
        {
            "location": "/os/modules/fs/fs/fsutil_write_file/#fsutil95write95file", 
            "text": "int fsutil_write_file(const char *path, const void *data, uint32_t len)  Calls fs_open(), fs_write(), and fs_close() to open a file at the specified path, write the supplied data to the current offset of the specified file handle, and close the file and invalidate the file handle.  If the specified file already exists, it is truncated and overwritten with the specified data.", 
            "title": "fsutil_write_file"
        }, 
        {
            "location": "/os/modules/fs/fs/fsutil_write_file/#arguments", 
            "text": "Arguments  Description      path  Pointer to the file to write to    data  The data to write    len  The number of bytes to write", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/fs/fsutil_write_file/#returned-values", 
            "text": "0 on success  FS error code  on failure", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/fs/fsutil_write_file/#header-file", 
            "text": "#include  fs/fs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/fs/fsutil_write_file/#example", 
            "text": "This example creates a 4-byte file.  int\nwrite_id(void)\n{\n    int rc;\n\n    /* Create the parent directory. */\n    rc = fs_mkdir( /cfg );\n    if (rc != 0   rc != FS_EALREADY) {\n        return -1;\n    }\n\n    /* Create a file and write four bytes to it. */\n    rc = fsutil_write_file( /cfg/id.txt ,  1234 , 4);\n    if (rc != 0) {\n        return -1;\n    }\n\n    return 0;\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs/", 
            "text": "Newtron Flash Filesystem (nffs)\n\n\nMynewt includes the Newtron Flash File System (nffs).  This file system is designed with two priorities that makes it suitable for embedded use: \n\n\n\n\nMinimal RAM usage\n\n\nReliability\n\n\n\n\nMynewt also provides an abstraction layer API (fs) to allow you to swap out nffs with a different file system of your choice.\n\n\nDescription\n\n\nAreas\n\n\nAt the top level, an nffs disk is partitioned into \nareas\n.  An area is a region of disk with the following properties:\n\n\n\n\nAn area can be fully erased without affecting any other areas.\n\n\nWriting to one area does not restrict writes to other areas.\n\n\n\n\nRegarding property 1:\n Generally, flash hardware divides its memory space into \"blocks.\"  When erasing flash, entire blocks must be erased in a single operation; partial erases are not possible.\n\n\nRegarding property 2:\n Furthermore, some flash hardware imposes a restriction with regards to writes: writes within a block must be strictly sequential.  For example, if you wish to write to the first 16 bytes of a block, you must write bytes 1 through 15 before writing byte 16.  This restriction only applies at the block level; writes to one block have no effect on what parts of other blocks can be written.\n\n\nThus, each area must comprise a discrete number of blocks.\n\n\nInitialization\n\n\nBefore nffs can be used, it must be initialized.  There are two means of initializing an nffs file system:\n\n\n\n\nRestore an existing file system via detection.\n\n\nCreate a new file system via formatting.\n\n\n\n\nA typical initialization sequence is the following:\n\n\n\n\nDetect an nffs file system in a specific region of flash.\n\n\nIf no file system was detected, format a new file system in the same flash region.\n\n\n\n\nBoth methods require the user to describe how the flash memory should be divided into nffs areas.  This is accomplished with an array of \nstruct nffs_area_desc\n.\n\n\nTypically, a product's flash layout is exposed via its BSP-specific \nbsp_flash_dev()\n function.  This function retrieves the layout of the specified flash device resident in the BSP.  The result of this function can then be converted into the \nstruct nffs_area_desc[]\n that nffs requires.  The below example, taken from the slinky project, illustrates the nffs initialization procedure.\n\n\n/*** hw/hal/include/hal/flash_map.h */\n\n/*\n * Flash area types\n */\n#define FLASH_AREA_BOOTLOADER           0\n#define FLASH_AREA_IMAGE_0              1\n#define FLASH_AREA_IMAGE_1              2\n#define FLASH_AREA_IMAGE_SCRATCH        3\n#define FLASH_AREA_NFFS                 4\n\n\n\n\n\n/*** project/slinky/src/main.c */\n\nint\nmain(int argc, char **argv)\n{\n    int rc;\n    int cnt;\n\n    /* NFFS_AREA_MAX is defined in the BSP-specified bsp.h header file. */\n    struct nffs_area_desc descs[NFFS_AREA_MAX];\n\n    /* Initialize nffs\ns internal state. */\n    rc = nffs_init();\n    assert(rc == 0);\n\n    /* Convert the set of flash blocks we intend to use for nffs into an array\n     * of nffs area descriptors.\n     */\n    cnt = NFFS_AREA_MAX;\n    rc = flash_area_to_nffs_desc(FLASH_AREA_NFFS, \ncnt, descs);\n    assert(rc == 0);\n\n    /* Attempt to restore an existing nffs file system from flash. */\n    if (nffs_detect(descs) == FS_ECORRUPT) {\n        /* No valid nffs instance detected; format a new one. */\n        rc = nffs_format(descs);\n        assert(rc == 0);\n    }\n    /* [ ... ] */\n}\n\n\n\n\n\nAfter nffs has been initialized, the application can access the file system via the \nfile system abstraction layer\n.\n\n\nConfiguration\n\n\nThe nffs file system is configured by populating fields in a global \nstruct nffs_config\n instance.  Each field in the structure corresponds to a setting.  All configuration must be done prior to calling nffs_init().\n\n\nThe global \nstruct nffs_config\n instance is exposed in \nnffs/nffs.h\n as follows:\n\n\nextern struct nffs_config nffs_config;\n\n\n\n\n\nData Structures\n\n\nThe \nfs/nffs\n package exposes the following data structures:\n\n\n\n\nstruct nffs_area_desc\n\n\nstruct nffs_config\n\n\n\n\nAPI\n\n\nThe functions available in this OS feature are:\n\n\n\n\nnffs_detect\n\n\nnffs_format\n\n\nnffs_init\n\n\n\n\nMiscellaneous measures\n\n\n\n\n\n\nRAM usage:\n\n\n\n\n24 bytes per inode\n\n\n12 bytes per data block\n\n\n36 bytes per inode cache entry\n\n\n32 bytes per data block cache entry\n\n\n\n\n\n\n\n\nMaximum filename size: 256 characters (no null terminator required)\n\n\n\n\nDisallowed filename characters: '/' and '\\0'\n\n\n\n\nInternals\n\n\nnffs implementation details can be found here:\n\n\n\n\nnffs_internals\n\n\n\n\nFuture enhancements\n\n\n\n\nError correction.\n\n\nEncryption.\n\n\nCompression.", 
            "title": "toc"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs/#newtron-flash-filesystem-nffs", 
            "text": "Mynewt includes the Newtron Flash File System (nffs).  This file system is designed with two priorities that makes it suitable for embedded use:    Minimal RAM usage  Reliability   Mynewt also provides an abstraction layer API (fs) to allow you to swap out nffs with a different file system of your choice.", 
            "title": "Newtron Flash Filesystem (nffs)"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs/#description", 
            "text": "", 
            "title": "Description"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs/#areas", 
            "text": "At the top level, an nffs disk is partitioned into  areas .  An area is a region of disk with the following properties:   An area can be fully erased without affecting any other areas.  Writing to one area does not restrict writes to other areas.   Regarding property 1:  Generally, flash hardware divides its memory space into \"blocks.\"  When erasing flash, entire blocks must be erased in a single operation; partial erases are not possible.  Regarding property 2:  Furthermore, some flash hardware imposes a restriction with regards to writes: writes within a block must be strictly sequential.  For example, if you wish to write to the first 16 bytes of a block, you must write bytes 1 through 15 before writing byte 16.  This restriction only applies at the block level; writes to one block have no effect on what parts of other blocks can be written.  Thus, each area must comprise a discrete number of blocks.", 
            "title": "Areas"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs/#initialization", 
            "text": "Before nffs can be used, it must be initialized.  There are two means of initializing an nffs file system:   Restore an existing file system via detection.  Create a new file system via formatting.   A typical initialization sequence is the following:   Detect an nffs file system in a specific region of flash.  If no file system was detected, format a new file system in the same flash region.   Both methods require the user to describe how the flash memory should be divided into nffs areas.  This is accomplished with an array of  struct nffs_area_desc .  Typically, a product's flash layout is exposed via its BSP-specific  bsp_flash_dev()  function.  This function retrieves the layout of the specified flash device resident in the BSP.  The result of this function can then be converted into the  struct nffs_area_desc[]  that nffs requires.  The below example, taken from the slinky project, illustrates the nffs initialization procedure.  /*** hw/hal/include/hal/flash_map.h */\n\n/*\n * Flash area types\n */\n#define FLASH_AREA_BOOTLOADER           0\n#define FLASH_AREA_IMAGE_0              1\n#define FLASH_AREA_IMAGE_1              2\n#define FLASH_AREA_IMAGE_SCRATCH        3\n#define FLASH_AREA_NFFS                 4  /*** project/slinky/src/main.c */\n\nint\nmain(int argc, char **argv)\n{\n    int rc;\n    int cnt;\n\n    /* NFFS_AREA_MAX is defined in the BSP-specified bsp.h header file. */\n    struct nffs_area_desc descs[NFFS_AREA_MAX];\n\n    /* Initialize nffs s internal state. */\n    rc = nffs_init();\n    assert(rc == 0);\n\n    /* Convert the set of flash blocks we intend to use for nffs into an array\n     * of nffs area descriptors.\n     */\n    cnt = NFFS_AREA_MAX;\n    rc = flash_area_to_nffs_desc(FLASH_AREA_NFFS,  cnt, descs);\n    assert(rc == 0);\n\n    /* Attempt to restore an existing nffs file system from flash. */\n    if (nffs_detect(descs) == FS_ECORRUPT) {\n        /* No valid nffs instance detected; format a new one. */\n        rc = nffs_format(descs);\n        assert(rc == 0);\n    }\n    /* [ ... ] */\n}  After nffs has been initialized, the application can access the file system via the  file system abstraction layer .", 
            "title": "Initialization"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs/#configuration", 
            "text": "The nffs file system is configured by populating fields in a global  struct nffs_config  instance.  Each field in the structure corresponds to a setting.  All configuration must be done prior to calling nffs_init().  The global  struct nffs_config  instance is exposed in  nffs/nffs.h  as follows:  extern struct nffs_config nffs_config;", 
            "title": "Configuration"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs/#data-structures", 
            "text": "The  fs/nffs  package exposes the following data structures:   struct nffs_area_desc  struct nffs_config", 
            "title": "Data Structures"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs/#api", 
            "text": "The functions available in this OS feature are:   nffs_detect  nffs_format  nffs_init", 
            "title": "API"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs/#miscellaneous-measures", 
            "text": "RAM usage:   24 bytes per inode  12 bytes per data block  36 bytes per inode cache entry  32 bytes per data block cache entry     Maximum filename size: 256 characters (no null terminator required)   Disallowed filename characters: '/' and '\\0'", 
            "title": "Miscellaneous measures"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs/#internals", 
            "text": "nffs implementation details can be found here:   nffs_internals", 
            "title": "Internals"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs/#future-enhancements", 
            "text": "Error correction.  Encryption.  Compression.", 
            "title": "Future enhancements"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_area_desc/", 
            "text": "struct nffs_area_desc\n\n\nstruct nffs_area_desc {\n    uint32_t nad_offset;    /* Flash offset of start of area. */\n    uint32_t nad_length;    /* Size of area, in bytes. */\n    uint8_t nad_flash_id;   /* Logical flash id */\n};\n\n\n\n\n\nDescriptor for a single nffs area.  An area is a region of disk with the following properties:\n\n\n\n\nAn area can be fully erased without affecting any other areas.\n\n\nWriting to one area does not restrict writes to other areas.\n\n\n\n\nRegarding property 1:\n Generally, flash hardware divides its memory space into \"blocks.\"  When erasing flash, entire blocks must be erased in a single operation; partial erases are not possible.\n\n\nRegarding property 2:\n Furthermore, some flash hardware imposes a restriction with regards to writes: writes within a block must be strictly sequential.  For example, if you wish to write to the first 16 bytes of a block, you must write bytes 1 through 15 before writing byte 16.  This restriction only applies at the block level; writes to one block have no effect on what parts of other blocks can be written.\n\n\nThus, each area must comprise a discrete number of blocks.\n\n\nAn array of area descriptors is terminated by an entry with a \nnad_length\n value of 0.\n\n\nNotes\n\n\nTypically, a product's flash layout is exposed via its BSP-specific \nbsp_flash_dev()\n function.  This function retrieves the layout of the specified flash device resident in the BSP.  The result of this function can then be converted into the \nstruct nffs_area_desc[]\n that nffs requires.\n\n\nHeader file\n\n\n#include \nnffs/nffs.h", 
            "title": "struct nffs_area_desc"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_area_desc/#struct-nffs95area95desc", 
            "text": "struct nffs_area_desc {\n    uint32_t nad_offset;    /* Flash offset of start of area. */\n    uint32_t nad_length;    /* Size of area, in bytes. */\n    uint8_t nad_flash_id;   /* Logical flash id */\n};  Descriptor for a single nffs area.  An area is a region of disk with the following properties:   An area can be fully erased without affecting any other areas.  Writing to one area does not restrict writes to other areas.   Regarding property 1:  Generally, flash hardware divides its memory space into \"blocks.\"  When erasing flash, entire blocks must be erased in a single operation; partial erases are not possible.  Regarding property 2:  Furthermore, some flash hardware imposes a restriction with regards to writes: writes within a block must be strictly sequential.  For example, if you wish to write to the first 16 bytes of a block, you must write bytes 1 through 15 before writing byte 16.  This restriction only applies at the block level; writes to one block have no effect on what parts of other blocks can be written.  Thus, each area must comprise a discrete number of blocks.  An array of area descriptors is terminated by an entry with a  nad_length  value of 0.", 
            "title": "struct nffs_area_desc"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_area_desc/#notes", 
            "text": "Typically, a product's flash layout is exposed via its BSP-specific  bsp_flash_dev()  function.  This function retrieves the layout of the specified flash device resident in the BSP.  The result of this function can then be converted into the  struct nffs_area_desc[]  that nffs requires.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_area_desc/#header-file", 
            "text": "#include  nffs/nffs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_config/", 
            "text": "struct nffs_config\n\n\nstruct nffs_config {\n    /** Maximum number of inodes; default=1024. */\n    uint32_t nc_num_inodes;\n\n    /** Maximum number of data blocks; default=4096. */\n    uint32_t nc_num_blocks;\n\n    /** Maximum number of open files; default=4. */\n    uint32_t nc_num_files;\n\n    /** Inode cache size; default=4. */\n    uint32_t nc_num_cache_inodes;\n\n    /** Data block cache size; default=64. */\n    uint32_t nc_num_cache_blocks;\n};\n\n\n\n\n\nThe file system is configured by populating fields in a global \nstruct nffs_config\n instance.  Each field in the structure corresponds to a setting.  All configuration must be done prior to calling nffs_init().\n\n\nAny fields that are set to 0 (or not set at all) inherit the corresponding default value.  This means that it is impossible to configure any setting with a value of zero.\n\n\nNotes\n\n\nThe global \nstruct nffs_config\n instance is exposed in \nnffs/nffs.h\n as follows:\n\n\nextern struct nffs_config nffs_config;\n\n\n\n\n\nHeader file\n\n\n#include \nnffs/nffs.h", 
            "title": "struct nffs_config"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_config/#struct-nffs95config", 
            "text": "struct nffs_config {\n    /** Maximum number of inodes; default=1024. */\n    uint32_t nc_num_inodes;\n\n    /** Maximum number of data blocks; default=4096. */\n    uint32_t nc_num_blocks;\n\n    /** Maximum number of open files; default=4. */\n    uint32_t nc_num_files;\n\n    /** Inode cache size; default=4. */\n    uint32_t nc_num_cache_inodes;\n\n    /** Data block cache size; default=64. */\n    uint32_t nc_num_cache_blocks;\n};  The file system is configured by populating fields in a global  struct nffs_config  instance.  Each field in the structure corresponds to a setting.  All configuration must be done prior to calling nffs_init().  Any fields that are set to 0 (or not set at all) inherit the corresponding default value.  This means that it is impossible to configure any setting with a value of zero.", 
            "title": "struct nffs_config"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_config/#notes", 
            "text": "The global  struct nffs_config  instance is exposed in  nffs/nffs.h  as follows:  extern struct nffs_config nffs_config;", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_config/#header-file", 
            "text": "#include  nffs/nffs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_detect/", 
            "text": "nffs_detect\n\n\nint nffs_detect(const struct nffs_area_desc *area_descs)\n\n\n\n\n\nSearches for a valid nffs file system among the specified areas.  This function succeeds if a file system is detected among any subset of the supplied areas.  If the area set does not contain a valid file system, a new one can be created via a separate call to nffs_format().\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\narea_descs\n\n\nThe set of areas to search.  This array must be terminated with a 0-length area.\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS_ECORRUPT if no valid file system was detected\n\n\nOther \nFS error code\n on failure\n\n\n\n\nHeader file\n\n\n#include \nnffs/nffs.h\n\n\n\n\n\n\nExample\n\n\n/*** hw/hal/include/hal/flash_map.h */\n\n/*\n * Flash area types\n */\n#define FLASH_AREA_BOOTLOADER           0\n#define FLASH_AREA_IMAGE_0              1\n#define FLASH_AREA_IMAGE_1              2\n#define FLASH_AREA_IMAGE_SCRATCH        3\n#define FLASH_AREA_NFFS                 4\n\n\n\n\n\n/*** project/slinky/src/main.c */\n\nint\nmain(int argc, char **argv)\n{\n    int rc;\n    int cnt;\n\n    /* NFFS_AREA_MAX is defined in the BSP-specified bsp.h header file. */\n    struct nffs_area_desc descs[NFFS_AREA_MAX];\n\n    /* Initialize nffs\ns internal state. */\n    rc = nffs_init();\n    assert(rc == 0);\n\n    /* Convert the set of flash blocks we intend to use for nffs into an array\n     * of nffs area descriptors.\n     */\n    cnt = NFFS_AREA_MAX;\n    rc = flash_area_to_nffs_desc(FLASH_AREA_NFFS, \ncnt, descs);\n    assert(rc == 0);\n\n    /* Attempt to restore an existing nffs file system from flash. */\n    if (nffs_detect(descs) == FS_ECORRUPT) {\n        /* No valid nffs instance detected; format a new one. */\n        rc = nffs_format(descs);\n        assert(rc == 0);\n    }\n    /* [ ... ] */\n}", 
            "title": "nffs_detect"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_detect/#nffs95detect", 
            "text": "int nffs_detect(const struct nffs_area_desc *area_descs)  Searches for a valid nffs file system among the specified areas.  This function succeeds if a file system is detected among any subset of the supplied areas.  If the area set does not contain a valid file system, a new one can be created via a separate call to nffs_format().", 
            "title": "nffs_detect"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_detect/#arguments", 
            "text": "Arguments  Description      area_descs  The set of areas to search.  This array must be terminated with a 0-length area.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_detect/#returned-values", 
            "text": "0 on success  FS_ECORRUPT if no valid file system was detected  Other  FS error code  on failure", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_detect/#header-file", 
            "text": "#include  nffs/nffs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_detect/#example", 
            "text": "/*** hw/hal/include/hal/flash_map.h */\n\n/*\n * Flash area types\n */\n#define FLASH_AREA_BOOTLOADER           0\n#define FLASH_AREA_IMAGE_0              1\n#define FLASH_AREA_IMAGE_1              2\n#define FLASH_AREA_IMAGE_SCRATCH        3\n#define FLASH_AREA_NFFS                 4  /*** project/slinky/src/main.c */\n\nint\nmain(int argc, char **argv)\n{\n    int rc;\n    int cnt;\n\n    /* NFFS_AREA_MAX is defined in the BSP-specified bsp.h header file. */\n    struct nffs_area_desc descs[NFFS_AREA_MAX];\n\n    /* Initialize nffs s internal state. */\n    rc = nffs_init();\n    assert(rc == 0);\n\n    /* Convert the set of flash blocks we intend to use for nffs into an array\n     * of nffs area descriptors.\n     */\n    cnt = NFFS_AREA_MAX;\n    rc = flash_area_to_nffs_desc(FLASH_AREA_NFFS,  cnt, descs);\n    assert(rc == 0);\n\n    /* Attempt to restore an existing nffs file system from flash. */\n    if (nffs_detect(descs) == FS_ECORRUPT) {\n        /* No valid nffs instance detected; format a new one. */\n        rc = nffs_format(descs);\n        assert(rc == 0);\n    }\n    /* [ ... ] */\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_format/", 
            "text": "nffs_format\n\n\nint nffs_format(const struct nffs_area_desc *area_descs)\n\n\n\n\n\nErases all the specified areas and initializes them with a clean nffs file system.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\narea_descs\n\n\nThe set of areas to format\n\n\n\n\n\n\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS error code\n on failure.\n\n\n\n\nHeader file\n\n\n#include \nnffs/nffs.h\n\n\n\n\n\n\nExample\n\n\n/*** hw/hal/include/hal/flash_map.h */\n\n/*\n * Flash area types\n */\n#define FLASH_AREA_BOOTLOADER           0\n#define FLASH_AREA_IMAGE_0              1\n#define FLASH_AREA_IMAGE_1              2\n#define FLASH_AREA_IMAGE_SCRATCH        3\n#define FLASH_AREA_NFFS                 4\n\n\n\n\n\n/*** project/slinky/src/main.c */\n\nint\nmain(int argc, char **argv)\n{\n    int rc;\n    int cnt;\n\n    /* NFFS_AREA_MAX is defined in the BSP-specified bsp.h header file. */\n    struct nffs_area_desc descs[NFFS_AREA_MAX];\n\n    /* Initialize nffs\ns internal state. */\n    rc = nffs_init();\n    assert(rc == 0);\n\n    /* Convert the set of flash blocks we intend to use for nffs into an array\n     * of nffs area descriptors.\n     */\n    cnt = NFFS_AREA_MAX;\n    rc = flash_area_to_nffs_desc(FLASH_AREA_NFFS, \ncnt, descs);\n    assert(rc == 0);\n\n    /* Attempt to restore an existing nffs file system from flash. */\n    if (nffs_detect(descs) == FS_ECORRUPT) {\n        /* No valid nffs instance detected; format a new one. */\n        rc = nffs_format(descs);\n        assert(rc == 0);\n    }\n    /* [ ... ] */\n}", 
            "title": "nffs_format"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_format/#nffs95format", 
            "text": "int nffs_format(const struct nffs_area_desc *area_descs)  Erases all the specified areas and initializes them with a clean nffs file system.", 
            "title": "nffs_format"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_format/#arguments", 
            "text": "Arguments  Description      area_descs  The set of areas to format", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_format/#returned-values", 
            "text": "0 on success  FS error code  on failure.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_format/#header-file", 
            "text": "#include  nffs/nffs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_format/#example", 
            "text": "/*** hw/hal/include/hal/flash_map.h */\n\n/*\n * Flash area types\n */\n#define FLASH_AREA_BOOTLOADER           0\n#define FLASH_AREA_IMAGE_0              1\n#define FLASH_AREA_IMAGE_1              2\n#define FLASH_AREA_IMAGE_SCRATCH        3\n#define FLASH_AREA_NFFS                 4  /*** project/slinky/src/main.c */\n\nint\nmain(int argc, char **argv)\n{\n    int rc;\n    int cnt;\n\n    /* NFFS_AREA_MAX is defined in the BSP-specified bsp.h header file. */\n    struct nffs_area_desc descs[NFFS_AREA_MAX];\n\n    /* Initialize nffs s internal state. */\n    rc = nffs_init();\n    assert(rc == 0);\n\n    /* Convert the set of flash blocks we intend to use for nffs into an array\n     * of nffs area descriptors.\n     */\n    cnt = NFFS_AREA_MAX;\n    rc = flash_area_to_nffs_desc(FLASH_AREA_NFFS,  cnt, descs);\n    assert(rc == 0);\n\n    /* Attempt to restore an existing nffs file system from flash. */\n    if (nffs_detect(descs) == FS_ECORRUPT) {\n        /* No valid nffs instance detected; format a new one. */\n        rc = nffs_format(descs);\n        assert(rc == 0);\n    }\n    /* [ ... ] */\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_init/", 
            "text": "nffs_init\n\n\nint nffs_init(void)\n\n\n\n\n\nInitializes internal nffs memory and data structures.  This must be called before any nffs operations are attempted.\n\n\nReturned values\n\n\n\n\n0 on success\n\n\nFS error code\n on failure\n\n\n\n\nHeader file\n\n\n#include \nnffs/nffs.h", 
            "title": "nffs_init"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_init/#nffs95init", 
            "text": "int nffs_init(void)  Initializes internal nffs memory and data structures.  This must be called before any nffs operations are attempted.", 
            "title": "nffs_init"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_init/#returned-values", 
            "text": "0 on success  FS error code  on failure", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_init/#header-file", 
            "text": "#include  nffs/nffs.h", 
            "title": "Header file"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_internals/", 
            "text": "Internals of nffs\n\n\nDisk structure\n\n\nOn disk, each area is prefixed with the following header:\n\n\n/** On-disk representation of an area header. */\nstruct nffs_disk_area {\n    uint32_t nda_magic[4];  /* NFFS_AREA_MAGIC{0,1,2,3} */\n    uint32_t nda_length;    /* Total size of area, in bytes. */\n    uint8_t nda_ver;        /* Current nffs version: 0 */\n    uint8_t nda_gc_seq;     /* Garbage collection count. */\n    uint8_t reserved8;\n    uint8_t nda_id;         /* 0xff if scratch area. */\n};\n\n\n\n\n\nBeyond its header, an area contains a sequence of disk objects, representing the contents of the file system.  There are two types of objects: \ninodes\n and \ndata blocks\n.  An inode represents a file or directory; a data block represents part of a file's contents.\n\n\n/** On-disk representation of an inode (file or directory). */\nstruct nffs_disk_inode {\n    uint32_t ndi_magic;         /* NFFS_INODE_MAGIC */\n    uint32_t ndi_id;            /* Unique object ID. */\n    uint32_t ndi_seq;           /* Sequence number; greater supersedes\n                                   lesser. */\n    uint32_t ndi_parent_id;     /* Object ID of parent directory inode. */\n    uint8_t reserved8;\n    uint8_t ndi_filename_len;   /* Length of filename, in bytes. */\n    uint16_t ndi_crc16;         /* Covers rest of header and filename. */\n    /* Followed by filename. */\n};\n\n\n\n\n\nAn inode filename's length cannot exceed 256 bytes.  The filename is not null-terminated.  The following ASCII characters are not allowed in a filename:\n\n\n\n\n/  (slash character)\n\n\n\\0 (NUL character)\n\n\n\n\n/** On-disk representation of a data block. */\nstruct nffs_disk_block {\n    uint32_t ndb_magic;     /* NFFS_BLOCK_MAGIC */\n    uint32_t ndb_id;        /* Unique object ID. */\n    uint32_t ndb_seq;       /* Sequence number; greater supersedes lesser. */\n    uint32_t ndb_inode_id;  /* Object ID of owning inode. */\n    uint32_t ndb_prev_id;   /* Object ID of previous block in file;\n                               NFFS_ID_NONE if this is the first block. */\n    uint16_t ndb_data_len;  /* Length of data contents, in bytes. */\n    uint16_t ndb_crc16;     /* Covers rest of header and data. */\n    /* Followed by \nndb_data_len\n bytes of data. */\n};\n\n\n\n\n\nEach data block contains the ID of the previous data block in the file.  Together, the set of blocks in a file form a reverse singly-linked list.\n\n\nThe maximum number of data bytes that a block can contain is determined at initialization-time.  The result is the greatest number which satisfies all of the following restrictions:\n\n\n\n\nNo more than 2048.\n\n\nAt least two maximum-sized blocks can fit in the smallest area.\n\n\n\n\nThe 2048 number was chosen somewhat arbitrarily, and may change in the future.\n\n\nID space\n\n\nAll disk objects have a unique 32-bit ID.  The ID space is partitioned as\nfollows:\n\n\n\n\n\n\n\n\nID range\n\n\nNode type\n\n\n\n\n\n\n\n\n\n\n0x00000000 - 0x0fffffff\n\n\nDirectory inodes\n\n\n\n\n\n\n0x10000000 - 0x7fffffff\n\n\nFile inodes\n\n\n\n\n\n\n0x80000000 - 0xfffffffe\n\n\nData blocks\n\n\n\n\n\n\n0xffffffff\n\n\nReserved (NFFS_ID_NONE)\n\n\n\n\n\n\n\n\nScratch area\n\n\nA valid nffs file system must contain a single \"scratch area.\"  The scratch area does not contain any objects of its own, and is only used during garbage collection.  The scratch area must have a size greater than or equal to each of the other areas in flash.\n\n\nRAM representation\n\n\nEvery object in the file system is stored in a 256-entry hash table.  An object's hash key is derived from its 32-bit ID.  Each list in the hash table is sorted by time of use; most-recently-used is at the front of the list. All objects are represented by the following structure:\n\n\n/**\n * What gets stored in the hash table.  Each entry represents a data block or\n * an inode.\n */\nstruct nffs_hash_entry {\n    SLIST_ENTRY(nffs_hash_entry) nhe_next;\n    uint32_t nhe_id;        /* 0 - 0x7fffffff if inode; else if block. */\n    uint32_t nhe_flash_loc; /* Upper-byte = area idx; rest = area offset. */\n};\n\n\n\n\n\nFor each data block, the above structure is all that is stored in RAM.  To acquire more information about a data block, the block header must be read from flash.\n\n\nInodes require a fuller RAM representation to capture the structure of the file system.  There are two types of inodes: \nfiles\n and \ndirectories\n.  Each inode hash entry is actually an instance of the following structure:\n\n\n/** Each inode hash entry is actually one of these. */\nstruct nffs_inode_entry {\n    struct nffs_hash_entry nie_hash_entry;\n    SLIST_ENTRY(nffs_inode_entry) nie_sibling_next;\n    union {\n        struct nffs_inode_list nie_child_list;           /* If directory */\n        struct nffs_hash_entry *nie_last_block_entry;    /* If file */\n    };\n    uint8_t nie_refcnt;\n};\n\n\n\n\n\nA directory inode contains a list of its child files and directories (\nfie_child_list\n).  These entries are sorted alphabetically using the ASCII character set.\n\n\nA file inode contains a pointer to the last data block in the file (\nnie_last_block_entry\n).  For most file operations, the reversed block list must be walked backwards.  This introduces a number of speed inefficiencies:\n\n\n\n\nAll data blocks must be read to determine the length of the file.\n\n\nData blocks often need to be processed sequentially.  The reversed nature of the block list transforms this from linear time to an O(n^2) operation.\n\n\n\n\nFurthermore, obtaining information about any constituent data block requires a separate flash read.\n\n\nInode cache and Data Block cache\n\n\nThe speed issues are addressed by a pair of caches.  Cached inodes entries contain the file length and a much more convenient doubly-linked list of cached data blocks.  The benefit of using caches is that the size of the caches need not be proportional to the size of the file system.  In other words, caches can address speed efficiency concerns without negatively impacting the file system's scalability.\n\n\nnffs requires both caches during normal operation, so it is not possible to disable them.  However, the cache sizes are configurable, and both caches can be configured with a size of one if RAM usage must be minimized.\n\n\nThe following data structures are used in the inode and data block caches.\n\n\n/** Full data block representation; not stored permanently in RAM. */\nstruct nffs_block {\n    struct nffs_hash_entry *nb_hash_entry;   /* Points to real block entry. */\n    uint32_t nb_seq;                         /* Sequence number; greater\n                                                supersedes lesser. */\n    struct nffs_inode_entry *nb_inode_entry; /* Owning inode. */\n    struct nffs_hash_entry *nb_prev;         /* Previous block in file. */\n    uint16_t nb_data_len;                    /* # of data bytes in block. */\n    uint16_t reserved16;\n};\n\n\n\n\n\n/** Represents a single cached data block. */\nstruct nffs_cache_block {\n    TAILQ_ENTRY(nffs_cache_block) ncb_link; /* Next / prev cached block. */\n    struct nffs_block ncb_block;            /* Full data block. */\n    uint32_t ncb_file_offset;               /* File offset of this block. */\n};\n\n\n\n\n\n/** Full inode representation; not stored permanently in RAM. */\nstruct nffs_inode {\n    struct nffs_inode_entry *ni_inode_entry; /* Points to real inode entry. */\n    uint32_t ni_seq;                         /* Sequence number; greater\n                                                supersedes lesser. */\n    struct nffs_inode_entry *ni_parent;      /* Points to parent directory. */\n    uint8_t ni_filename_len;                 /* # chars in filename. */\n    uint8_t ni_filename[NFFS_SHORT_FILENAME_LEN]; /* First 3 bytes. */\n};\n\n\n\n\n\n/** Doubly-linked tail queue of cached blocks; contained in cached inodes. */\nTAILQ_HEAD(nffs_block_cache_list, nffs_block_cache_entry);\n\n/** Represents a single cached file inode. */\nstruct nffs_cache_inode {\n    TAILQ_ENTRY(nffs_cache_inode) nci_link;        /* Sorted; LRU at tail. */\n    struct nffs_inode nci_inode;                   /* Full inode. */\n    struct nffs_cache_block_list nci_block_list;   /* List of cached blocks. */\n    uint32_t nci_file_size;                        /* Total file size. */\n};\n\n\n\n\n\nOnly file inodes are cached; directory inodes are never cached.\n\n\nWithin a cached inode, all cached data blocks are contiguous.  E.g., if the start and end of a file are cached, then the middle must also be cached.  A data block is only cached if its owning file is also cached.\n\n\nInternally, cached inodes are stored in a singly-linked list, ordered by time of use.  The most-recently-used entry is the first element in the list.  If a new inode needs to be cached, but the inode cache is full, the least-recently-used entry is freed to make room for the new one.  The following operations cause an inode to be cached:\n\n\n\n\nQuerying a file's length.\n\n\nSeeking within a file.\n\n\nReading from a file.\n\n\nWriting to a file.\n\n\n\n\nThe following operations cause a data block to be cached:\n\n\n\n\nReading from the block.\n\n\nWriting to the block.\n\n\n\n\nIf one of the above operations is applied to a data block that is not currently cached, nffs uses the following procedure to cache the necessary block:\n\n\n\n\nIf none of the owning inode's blocks are currently cached, allocate a cached block entry corresponding to the requested block and insert it into the inode's list.\n\n\nElse if the requested file offset is less than that of the first cached block, bridge the gap between the inode's sequence of cached blocks and the block that now needs to be cached.  This is accomplished by caching each block in the gap, finishing with the requested block.\n\n\nElse (the requested offset is beyond the end of the cache),\n\n\nIf the requested offset belongs to the block that immediately follows the end of the cache, cache the block and append it to the list.\n\n\nElse, clear the cache, and populate it with the single entry corresponding to the requested block.\n\n\n\n\n\n\n\n\nIf the system is unable to allocate a cached block entry at any point during the above procedure, the system frees up other blocks currently in the cache. This is accomplished as follows:\n\n\n\n\nIterate the inode cache in reverse (i.e., start with the least-recently-used entry).  For each entry:\n\n\nIf the entry's cached block list is empty, advance to the next entry.\n\n\nElse, free all the cached blocks in the entry's list.\n\n\n\n\n\n\n\n\nBecause the system imposes a minimum block cache size of one, the above procedure will always reclaim at least one cache block entry.  The above procedure may result in the freeing of the block list that belongs to the very inode being operated on.  This is OK, as the final block to get cached is always the block being requested.\n\n\nDetection\n\n\nThe file system detection process consists of scanning a specified set of flash regions for valid nffs areas, and then populating the RAM representation of the file system with the detected objects.  Detection is initiated with the \nnffs_detect()\n function.\n\n\nNot every area descriptor passed to \nnffs_detect()\n needs to reference a valid nffs area.  Detection is successful as long as a complete file system is detected somewhere in the specified regions of flash.  If an application is unsure where a file system might be located, it can initiate detection across the entire flash region.\n\n\nA detected file system is valid if:\n\n\n\n\nAt least one non-scratch area is present.\n\n\nAt least one scratch area is present (only the first gets used if there is more than one).\n\n\nThe root directory inode is present.\n\n\n\n\nDuring detection, each indicated region of flash is checked for a valid area header.  The contents of each valid non-scratch area are then restored into the nffs RAM representation.  The following procedure is applied to each object in the area:\n\n\n\n\nVerify the object's integrity via a crc16 check.  If invalid, the object is discarded and the procedure restarts on the next object in the area.\n\n\nConvert the disk object into its corresponding RAM representation and insert it into the hash table.  If the object is an inode, its reference count is initialized to 1, indicating ownership by its parent directory.\n\n\nIf an object with the same ID is already present, then one supersedes the other.  Accept the object with the greater sequence number and discard the other.\n\n\nIf the object references a nonexistant inode (parent directory in the case of an inode; owning file in the case of a data block), insert a temporary \"dummy\" inode into the hash table so that inter-object links can be maintained until the absent inode is eventually restored.  Dummy inodes are identified by a reference count of 0.\n\n\nIf a delete record for an inode is encountered, the inode's parent pointer is set to null to indicate that it should be removed from RAM.\n\n\n\n\nIf nffs encounters an object that cannot be identified (i.e., its magic number is not valid), it scans the remainder of the flash area for the next valid magic number.  Upon encountering a valid object, nffs resumes the procedure described above.\n\n\nAfter all areas have been restored, a sweep is performed across the entire RAM representation so that invalid inodes can be deleted from memory.\n\n\nFor each directory inode:\n\n\n\n\nIf its reference count is 0 (i.e., it is a dummy), migrate its children to the \n/lost+found\n directory, and delete it from the RAM representation. This should only happen in the case of file system corruption.\n\n\nIf its parent reference is null (i.e., it was deleted), delete it and all its children from the RAM representation.\n\n\n\n\nFor each file inode:\n\n\n\n\nIf its reference count is 0 (i.e., it is a dummy), delete it from the RAM representation.  This should only happen in the case of file system corruption.  (We should try to migrate the file to the lost+found directory in this case, as mentioned in the todo section).\n\n\n\n\nWhen an object is deleted during this sweep, it is only deleted from the RAM representation; nothing is written to disk.\n\n\nWhen objects are migrated to the lost+found directory, their parent inode reference is permanently updated on the disk.\n\n\nIn addition, a single scratch area is identified during the detection process.  The first area whose \nfda_id\n value is set to 0xff is designated as the file system scratch area.  If no valid scratch area is found, the cause could be that the system was restarted while a garbage collection cycle was in progress.  Such a condition is identified by the presence of two areas with the same ID.  In such a case, the shorter of the two areas is erased and designated as the scratch area.\n\n\nFormatting\n\n\nA new nffs file system is created via formatting.  Formatting is achieved via the \nnffs_format()\n function.\n\n\nDuring a successful format, an area header is written to each of the specified locations.  One of the areas in the set is designated as the initial scratch area.\n\n\nFlash writes\n\n\nThe nffs implementation always writes in a strictly sequential fashion within an area.  For each area, the system keeps track of the current offset.  Whenever an object gets written to an area, it gets written to that area's current offset, and the offset is increased by the object's disk size.\n\n\nWhen a write needs to be performed, the nffs implementation selects the appropriate destination area by iterating though each area until one with sufficient free space is encountered.\n\n\nThere is no write buffering.  Each call to a write function results in a write operation being sent to the flash hardware.\n\n\nNew objects\n\n\nWhenever a new object is written to disk, it is assigned the following properties:\n\n\n\n\nID:\n A unique value is selected from the 32-bit ID space, as appropriate for the object's type.\n\n\nSequence number:\n 0\n\n\n\n\nWhen a new file or directory is created, a corresponding inode is written to flash.  Likewise, a new data block also results in the writing of a corresponding disk object.\n\n\nMoving/Renaming files and directories\n\n\nWhen a file or directory is moved or renamed, its corresponding inode is rewritten to flash with the following properties:\n\n\n\n\nID:\n Unchanged\n\n\nSequence number:\n Previous value plus one.\n\n\nParent inode:\n As specified by the move / rename operation.\n\n\nFilename:\n As specified by the move / rename operation.\n\n\n\n\nBecause the inode's ID is unchanged, all dependent objects remain valid.\n\n\nUnlinking files and directories\n\n\nWhen a file or directory is unlinked from its parent directory, a deletion record for the unlinked inode gets written to flash.  The deletion record is an inode with the following properties:\n\n\n\n\nID:\n Unchanged\n\n\nSequence number:\n Previous value plus one.\n\n\nParent inode ID:\n NFFS_ID_NONE\n\n\n\n\nWhen an inode is unlinked, no deletion records need to be written for the inode's dependent objects (constituent data blocks or child inodes).  During the next file system detection, it is recognized that the objects belong to a deleted inode, so they are not restored into the RAM representation.\n\n\nIf a file has an open handle at the time it gets unlinked, application code can continued to use the file handle to read and write data.  All files retain a reference count, and a file isn't deleted from the RAM representation until its reference code drops to 0.  Any attempt to open an unlinked file fails, even if the file is referenced by other file handles.\n\n\nWriting to a file\n\n\nThe following procedure is used whenever the application code writes to a file.  First, if the write operation specifies too much data to fit into a single block, the operation is split into several separate write operations.  Then, for each write operation:\n\n\n\n\nDetermine which existing blocks the write operation overlaps (n = number of overwritten blocks).\n\n\nIf \nn = 0\n, this is an append operation.  Write a data block with the following properties:\n\n\nID:\n New unique value.\n\n\nSequence number:\n 0.\n\n\n\n\n\n\nElse \n(n \n 1)\n, this write overlaps existing data.\n\n\nFor each block in \n[1, 2, ... n-1]\n, write a new block containing the updated contents.  Each new block supersedes the block it overwrites.  That is, each block has the following properties:\n\n\nID:\n Unchanged\n\n\nSequence number:\n Previous value plus one.\n\n\n\n\n\n\nWrite the nth block.  The nth block includes all appended data, if any.  As with the other blocks, its ID is unchanged and its sequence number is incremented.\n\n\n\n\n\n\n\n\nAppended data can only be written to the end of the file.  That is, \"holes\" are not supported.\n\n\nGarbage collection\n\n\nWhen the file system is too full to accomodate a write operation, the system must perform garbage collection to make room.  The garbage collection procedure is described below:\n\n\n\n\nThe non-scratch area with the lowest garbage collection sequence number is selected as the \"source area.\"  If there are other areas with the same sequence number, the one with the smallest flash offset is selected. \n\n\nThe source area's ID is written to the scratch area's header, transforming it into a non-scratch ID.  This former scratch area is now known as the \"destination area.\"\n\n\nThe RAM representation is exhaustively searched for collectible objects.  The following procedure is applied to each inode in the system:\n\n\nIf the inode is resident in the source area, copy the inode record to the destination area.\n\n\nIf the inode is a file inode, walk the inode's list of data blocks, starting with the last block in the file.  Each block that is resident in the source area is copied to the destination area.  If there is a run of two or more blocks that are resident in the source area, they are consolidated and copied to the destination area as a single new block (subject to the maximum block size restriction).\n\n\n\n\n\n\nThe source area is reformatted as a scratch sector (i.e., is is fully erased, and its header is rewritten with an ID of 0xff).  The area's garbage collection sequence number is incremented prior to rewriting the header.  This area is now the new scratch sector.", 
            "title": "Internals"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_internals/#internals-of-nffs", 
            "text": "", 
            "title": "Internals of nffs"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_internals/#disk-structure", 
            "text": "On disk, each area is prefixed with the following header:  /** On-disk representation of an area header. */\nstruct nffs_disk_area {\n    uint32_t nda_magic[4];  /* NFFS_AREA_MAGIC{0,1,2,3} */\n    uint32_t nda_length;    /* Total size of area, in bytes. */\n    uint8_t nda_ver;        /* Current nffs version: 0 */\n    uint8_t nda_gc_seq;     /* Garbage collection count. */\n    uint8_t reserved8;\n    uint8_t nda_id;         /* 0xff if scratch area. */\n};  Beyond its header, an area contains a sequence of disk objects, representing the contents of the file system.  There are two types of objects:  inodes  and  data blocks .  An inode represents a file or directory; a data block represents part of a file's contents.  /** On-disk representation of an inode (file or directory). */\nstruct nffs_disk_inode {\n    uint32_t ndi_magic;         /* NFFS_INODE_MAGIC */\n    uint32_t ndi_id;            /* Unique object ID. */\n    uint32_t ndi_seq;           /* Sequence number; greater supersedes\n                                   lesser. */\n    uint32_t ndi_parent_id;     /* Object ID of parent directory inode. */\n    uint8_t reserved8;\n    uint8_t ndi_filename_len;   /* Length of filename, in bytes. */\n    uint16_t ndi_crc16;         /* Covers rest of header and filename. */\n    /* Followed by filename. */\n};  An inode filename's length cannot exceed 256 bytes.  The filename is not null-terminated.  The following ASCII characters are not allowed in a filename:   /  (slash character)  \\0 (NUL character)   /** On-disk representation of a data block. */\nstruct nffs_disk_block {\n    uint32_t ndb_magic;     /* NFFS_BLOCK_MAGIC */\n    uint32_t ndb_id;        /* Unique object ID. */\n    uint32_t ndb_seq;       /* Sequence number; greater supersedes lesser. */\n    uint32_t ndb_inode_id;  /* Object ID of owning inode. */\n    uint32_t ndb_prev_id;   /* Object ID of previous block in file;\n                               NFFS_ID_NONE if this is the first block. */\n    uint16_t ndb_data_len;  /* Length of data contents, in bytes. */\n    uint16_t ndb_crc16;     /* Covers rest of header and data. */\n    /* Followed by  ndb_data_len  bytes of data. */\n};  Each data block contains the ID of the previous data block in the file.  Together, the set of blocks in a file form a reverse singly-linked list.  The maximum number of data bytes that a block can contain is determined at initialization-time.  The result is the greatest number which satisfies all of the following restrictions:   No more than 2048.  At least two maximum-sized blocks can fit in the smallest area.   The 2048 number was chosen somewhat arbitrarily, and may change in the future.", 
            "title": "Disk structure"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_internals/#id-space", 
            "text": "All disk objects have a unique 32-bit ID.  The ID space is partitioned as\nfollows:     ID range  Node type      0x00000000 - 0x0fffffff  Directory inodes    0x10000000 - 0x7fffffff  File inodes    0x80000000 - 0xfffffffe  Data blocks    0xffffffff  Reserved (NFFS_ID_NONE)", 
            "title": "ID space"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_internals/#scratch-area", 
            "text": "A valid nffs file system must contain a single \"scratch area.\"  The scratch area does not contain any objects of its own, and is only used during garbage collection.  The scratch area must have a size greater than or equal to each of the other areas in flash.", 
            "title": "Scratch area"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_internals/#ram-representation", 
            "text": "Every object in the file system is stored in a 256-entry hash table.  An object's hash key is derived from its 32-bit ID.  Each list in the hash table is sorted by time of use; most-recently-used is at the front of the list. All objects are represented by the following structure:  /**\n * What gets stored in the hash table.  Each entry represents a data block or\n * an inode.\n */\nstruct nffs_hash_entry {\n    SLIST_ENTRY(nffs_hash_entry) nhe_next;\n    uint32_t nhe_id;        /* 0 - 0x7fffffff if inode; else if block. */\n    uint32_t nhe_flash_loc; /* Upper-byte = area idx; rest = area offset. */\n};  For each data block, the above structure is all that is stored in RAM.  To acquire more information about a data block, the block header must be read from flash.  Inodes require a fuller RAM representation to capture the structure of the file system.  There are two types of inodes:  files  and  directories .  Each inode hash entry is actually an instance of the following structure:  /** Each inode hash entry is actually one of these. */\nstruct nffs_inode_entry {\n    struct nffs_hash_entry nie_hash_entry;\n    SLIST_ENTRY(nffs_inode_entry) nie_sibling_next;\n    union {\n        struct nffs_inode_list nie_child_list;           /* If directory */\n        struct nffs_hash_entry *nie_last_block_entry;    /* If file */\n    };\n    uint8_t nie_refcnt;\n};  A directory inode contains a list of its child files and directories ( fie_child_list ).  These entries are sorted alphabetically using the ASCII character set.  A file inode contains a pointer to the last data block in the file ( nie_last_block_entry ).  For most file operations, the reversed block list must be walked backwards.  This introduces a number of speed inefficiencies:   All data blocks must be read to determine the length of the file.  Data blocks often need to be processed sequentially.  The reversed nature of the block list transforms this from linear time to an O(n^2) operation.   Furthermore, obtaining information about any constituent data block requires a separate flash read.", 
            "title": "RAM representation"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_internals/#inode-cache-and-data-block-cache", 
            "text": "The speed issues are addressed by a pair of caches.  Cached inodes entries contain the file length and a much more convenient doubly-linked list of cached data blocks.  The benefit of using caches is that the size of the caches need not be proportional to the size of the file system.  In other words, caches can address speed efficiency concerns without negatively impacting the file system's scalability.  nffs requires both caches during normal operation, so it is not possible to disable them.  However, the cache sizes are configurable, and both caches can be configured with a size of one if RAM usage must be minimized.  The following data structures are used in the inode and data block caches.  /** Full data block representation; not stored permanently in RAM. */\nstruct nffs_block {\n    struct nffs_hash_entry *nb_hash_entry;   /* Points to real block entry. */\n    uint32_t nb_seq;                         /* Sequence number; greater\n                                                supersedes lesser. */\n    struct nffs_inode_entry *nb_inode_entry; /* Owning inode. */\n    struct nffs_hash_entry *nb_prev;         /* Previous block in file. */\n    uint16_t nb_data_len;                    /* # of data bytes in block. */\n    uint16_t reserved16;\n};  /** Represents a single cached data block. */\nstruct nffs_cache_block {\n    TAILQ_ENTRY(nffs_cache_block) ncb_link; /* Next / prev cached block. */\n    struct nffs_block ncb_block;            /* Full data block. */\n    uint32_t ncb_file_offset;               /* File offset of this block. */\n};  /** Full inode representation; not stored permanently in RAM. */\nstruct nffs_inode {\n    struct nffs_inode_entry *ni_inode_entry; /* Points to real inode entry. */\n    uint32_t ni_seq;                         /* Sequence number; greater\n                                                supersedes lesser. */\n    struct nffs_inode_entry *ni_parent;      /* Points to parent directory. */\n    uint8_t ni_filename_len;                 /* # chars in filename. */\n    uint8_t ni_filename[NFFS_SHORT_FILENAME_LEN]; /* First 3 bytes. */\n};  /** Doubly-linked tail queue of cached blocks; contained in cached inodes. */\nTAILQ_HEAD(nffs_block_cache_list, nffs_block_cache_entry);\n\n/** Represents a single cached file inode. */\nstruct nffs_cache_inode {\n    TAILQ_ENTRY(nffs_cache_inode) nci_link;        /* Sorted; LRU at tail. */\n    struct nffs_inode nci_inode;                   /* Full inode. */\n    struct nffs_cache_block_list nci_block_list;   /* List of cached blocks. */\n    uint32_t nci_file_size;                        /* Total file size. */\n};  Only file inodes are cached; directory inodes are never cached.  Within a cached inode, all cached data blocks are contiguous.  E.g., if the start and end of a file are cached, then the middle must also be cached.  A data block is only cached if its owning file is also cached.  Internally, cached inodes are stored in a singly-linked list, ordered by time of use.  The most-recently-used entry is the first element in the list.  If a new inode needs to be cached, but the inode cache is full, the least-recently-used entry is freed to make room for the new one.  The following operations cause an inode to be cached:   Querying a file's length.  Seeking within a file.  Reading from a file.  Writing to a file.   The following operations cause a data block to be cached:   Reading from the block.  Writing to the block.   If one of the above operations is applied to a data block that is not currently cached, nffs uses the following procedure to cache the necessary block:   If none of the owning inode's blocks are currently cached, allocate a cached block entry corresponding to the requested block and insert it into the inode's list.  Else if the requested file offset is less than that of the first cached block, bridge the gap between the inode's sequence of cached blocks and the block that now needs to be cached.  This is accomplished by caching each block in the gap, finishing with the requested block.  Else (the requested offset is beyond the end of the cache),  If the requested offset belongs to the block that immediately follows the end of the cache, cache the block and append it to the list.  Else, clear the cache, and populate it with the single entry corresponding to the requested block.     If the system is unable to allocate a cached block entry at any point during the above procedure, the system frees up other blocks currently in the cache. This is accomplished as follows:   Iterate the inode cache in reverse (i.e., start with the least-recently-used entry).  For each entry:  If the entry's cached block list is empty, advance to the next entry.  Else, free all the cached blocks in the entry's list.     Because the system imposes a minimum block cache size of one, the above procedure will always reclaim at least one cache block entry.  The above procedure may result in the freeing of the block list that belongs to the very inode being operated on.  This is OK, as the final block to get cached is always the block being requested.", 
            "title": "Inode cache and Data Block cache"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_internals/#detection", 
            "text": "The file system detection process consists of scanning a specified set of flash regions for valid nffs areas, and then populating the RAM representation of the file system with the detected objects.  Detection is initiated with the  nffs_detect()  function.  Not every area descriptor passed to  nffs_detect()  needs to reference a valid nffs area.  Detection is successful as long as a complete file system is detected somewhere in the specified regions of flash.  If an application is unsure where a file system might be located, it can initiate detection across the entire flash region.  A detected file system is valid if:   At least one non-scratch area is present.  At least one scratch area is present (only the first gets used if there is more than one).  The root directory inode is present.   During detection, each indicated region of flash is checked for a valid area header.  The contents of each valid non-scratch area are then restored into the nffs RAM representation.  The following procedure is applied to each object in the area:   Verify the object's integrity via a crc16 check.  If invalid, the object is discarded and the procedure restarts on the next object in the area.  Convert the disk object into its corresponding RAM representation and insert it into the hash table.  If the object is an inode, its reference count is initialized to 1, indicating ownership by its parent directory.  If an object with the same ID is already present, then one supersedes the other.  Accept the object with the greater sequence number and discard the other.  If the object references a nonexistant inode (parent directory in the case of an inode; owning file in the case of a data block), insert a temporary \"dummy\" inode into the hash table so that inter-object links can be maintained until the absent inode is eventually restored.  Dummy inodes are identified by a reference count of 0.  If a delete record for an inode is encountered, the inode's parent pointer is set to null to indicate that it should be removed from RAM.   If nffs encounters an object that cannot be identified (i.e., its magic number is not valid), it scans the remainder of the flash area for the next valid magic number.  Upon encountering a valid object, nffs resumes the procedure described above.  After all areas have been restored, a sweep is performed across the entire RAM representation so that invalid inodes can be deleted from memory.  For each directory inode:   If its reference count is 0 (i.e., it is a dummy), migrate its children to the  /lost+found  directory, and delete it from the RAM representation. This should only happen in the case of file system corruption.  If its parent reference is null (i.e., it was deleted), delete it and all its children from the RAM representation.   For each file inode:   If its reference count is 0 (i.e., it is a dummy), delete it from the RAM representation.  This should only happen in the case of file system corruption.  (We should try to migrate the file to the lost+found directory in this case, as mentioned in the todo section).   When an object is deleted during this sweep, it is only deleted from the RAM representation; nothing is written to disk.  When objects are migrated to the lost+found directory, their parent inode reference is permanently updated on the disk.  In addition, a single scratch area is identified during the detection process.  The first area whose  fda_id  value is set to 0xff is designated as the file system scratch area.  If no valid scratch area is found, the cause could be that the system was restarted while a garbage collection cycle was in progress.  Such a condition is identified by the presence of two areas with the same ID.  In such a case, the shorter of the two areas is erased and designated as the scratch area.", 
            "title": "Detection"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_internals/#formatting", 
            "text": "A new nffs file system is created via formatting.  Formatting is achieved via the  nffs_format()  function.  During a successful format, an area header is written to each of the specified locations.  One of the areas in the set is designated as the initial scratch area.", 
            "title": "Formatting"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_internals/#flash-writes", 
            "text": "The nffs implementation always writes in a strictly sequential fashion within an area.  For each area, the system keeps track of the current offset.  Whenever an object gets written to an area, it gets written to that area's current offset, and the offset is increased by the object's disk size.  When a write needs to be performed, the nffs implementation selects the appropriate destination area by iterating though each area until one with sufficient free space is encountered.  There is no write buffering.  Each call to a write function results in a write operation being sent to the flash hardware.", 
            "title": "Flash writes"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_internals/#new-objects", 
            "text": "Whenever a new object is written to disk, it is assigned the following properties:   ID:  A unique value is selected from the 32-bit ID space, as appropriate for the object's type.  Sequence number:  0   When a new file or directory is created, a corresponding inode is written to flash.  Likewise, a new data block also results in the writing of a corresponding disk object.", 
            "title": "New objects"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_internals/#movingrenaming-files-and-directories", 
            "text": "When a file or directory is moved or renamed, its corresponding inode is rewritten to flash with the following properties:   ID:  Unchanged  Sequence number:  Previous value plus one.  Parent inode:  As specified by the move / rename operation.  Filename:  As specified by the move / rename operation.   Because the inode's ID is unchanged, all dependent objects remain valid.", 
            "title": "Moving/Renaming files and directories"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_internals/#unlinking-files-and-directories", 
            "text": "When a file or directory is unlinked from its parent directory, a deletion record for the unlinked inode gets written to flash.  The deletion record is an inode with the following properties:   ID:  Unchanged  Sequence number:  Previous value plus one.  Parent inode ID:  NFFS_ID_NONE   When an inode is unlinked, no deletion records need to be written for the inode's dependent objects (constituent data blocks or child inodes).  During the next file system detection, it is recognized that the objects belong to a deleted inode, so they are not restored into the RAM representation.  If a file has an open handle at the time it gets unlinked, application code can continued to use the file handle to read and write data.  All files retain a reference count, and a file isn't deleted from the RAM representation until its reference code drops to 0.  Any attempt to open an unlinked file fails, even if the file is referenced by other file handles.", 
            "title": "Unlinking files and directories"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_internals/#writing-to-a-file", 
            "text": "The following procedure is used whenever the application code writes to a file.  First, if the write operation specifies too much data to fit into a single block, the operation is split into several separate write operations.  Then, for each write operation:   Determine which existing blocks the write operation overlaps (n = number of overwritten blocks).  If  n = 0 , this is an append operation.  Write a data block with the following properties:  ID:  New unique value.  Sequence number:  0.    Else  (n   1) , this write overlaps existing data.  For each block in  [1, 2, ... n-1] , write a new block containing the updated contents.  Each new block supersedes the block it overwrites.  That is, each block has the following properties:  ID:  Unchanged  Sequence number:  Previous value plus one.    Write the nth block.  The nth block includes all appended data, if any.  As with the other blocks, its ID is unchanged and its sequence number is incremented.     Appended data can only be written to the end of the file.  That is, \"holes\" are not supported.", 
            "title": "Writing to a file"
        }, 
        {
            "location": "/os/modules/fs/nffs/nffs_internals/#garbage-collection", 
            "text": "When the file system is too full to accomodate a write operation, the system must perform garbage collection to make room.  The garbage collection procedure is described below:   The non-scratch area with the lowest garbage collection sequence number is selected as the \"source area.\"  If there are other areas with the same sequence number, the one with the smallest flash offset is selected.   The source area's ID is written to the scratch area's header, transforming it into a non-scratch ID.  This former scratch area is now known as the \"destination area.\"  The RAM representation is exhaustively searched for collectible objects.  The following procedure is applied to each inode in the system:  If the inode is resident in the source area, copy the inode record to the destination area.  If the inode is a file inode, walk the inode's list of data blocks, starting with the last block in the file.  Each block that is resident in the source area is copied to the destination area.  If there is a run of two or more blocks that are resident in the source area, they are consolidated and copied to the destination area as a single new block (subject to the maximum block size restriction).    The source area is reformatted as a scratch sector (i.e., is is fully erased, and its header is rewritten with an ID of 0xff).  The area's garbage collection sequence number is incremented prior to rewriting the header.  This area is now the new scratch sector.", 
            "title": "Garbage collection"
        }, 
        {
            "location": "/os/modules/fs/otherfs/", 
            "text": "Other File Systems\n\n\nLibraries use Mynewt's file system abstraction layer (\nfs/fs\n) for all file operations.  Because clients use an abstraction layer, the underlying file system can be swapped out without affecting client code.  This page documents the procedure for plugging a custom file system into the Mynewt file system abstraction layer.\n\n\n1. Specify \nfs/fs\n as a dependency of your file system package.\n\n\nThe file system package must register itself with the \nfs/fs\n package, so it must specify \nfs/fs\n as a dependency.  As an example, part of the Newtron Flash File System (nffs) \npkg.yml\n is reproduced below.   Notice the first item in the \npkg.deps\n list.\n\n\npkg.name: fs/nffs\npkg.deps:\n    - fs/fs\n    - hw/hal\n    - libs/os\n    - libs/testutil\n    - sys/log\n\n\n\n\n\n2. Register your package's API with the \nfs/fs\n interface.\n\n\nThe \nfs/fs\n package calls into the underlying file system via a collection of function pointers.  To plug your file system into the \nfs/fs\n API, you must assign these function pointers to the corresponding routines in your file system package.\n\n\nFor example, \nnffs\n registers itself with \nfs/fs\n as follows (from \nfs/nffs/src/nffs.c\n):\n\n\nstatic const struct fs_ops nffs_ops = {\n    .f_open = nffs_open,\n    .f_close = nffs_close,\n    .f_read = nffs_read,\n    .f_write = nffs_write,\n\n    .f_seek = nffs_seek,\n    .f_getpos = nffs_getpos,\n    .f_filelen = nffs_file_len,\n\n    .f_unlink = nffs_unlink,\n    .f_rename = nffs_rename,\n    .f_mkdir = nffs_mkdir,\n\n    .f_opendir = nffs_opendir,\n    .f_readdir = nffs_readdir,\n    .f_closedir = nffs_closedir,\n\n    .f_dirent_name = nffs_dirent_name,\n    .f_dirent_is_dir = nffs_dirent_is_dir,\n\n    .f_name = \nnffs\n\n};\n\nint\nnffs_init(void)\n{\n    /* [...] */\n    fs_register(\nnffs_ops);\n}\n\n\n\n\n\nHeader Files\n\n\nTo gain access to \nfs/fs\n's registration interface, include the following header:\n\n\n#include \nfs/fs_if.h", 
            "title": "Other File Systems"
        }, 
        {
            "location": "/os/modules/fs/otherfs/#other-file-systems", 
            "text": "Libraries use Mynewt's file system abstraction layer ( fs/fs ) for all file operations.  Because clients use an abstraction layer, the underlying file system can be swapped out without affecting client code.  This page documents the procedure for plugging a custom file system into the Mynewt file system abstraction layer.", 
            "title": "Other File Systems"
        }, 
        {
            "location": "/os/modules/fs/otherfs/#1-specify-fsfs-as-a-dependency-of-your-file-system-package", 
            "text": "The file system package must register itself with the  fs/fs  package, so it must specify  fs/fs  as a dependency.  As an example, part of the Newtron Flash File System (nffs)  pkg.yml  is reproduced below.   Notice the first item in the  pkg.deps  list.  pkg.name: fs/nffs\npkg.deps:\n    - fs/fs\n    - hw/hal\n    - libs/os\n    - libs/testutil\n    - sys/log", 
            "title": "1. Specify fs/fs as a dependency of your file system package."
        }, 
        {
            "location": "/os/modules/fs/otherfs/#2-register-your-packages-api-with-the-fsfs-interface", 
            "text": "The  fs/fs  package calls into the underlying file system via a collection of function pointers.  To plug your file system into the  fs/fs  API, you must assign these function pointers to the corresponding routines in your file system package.  For example,  nffs  registers itself with  fs/fs  as follows (from  fs/nffs/src/nffs.c ):  static const struct fs_ops nffs_ops = {\n    .f_open = nffs_open,\n    .f_close = nffs_close,\n    .f_read = nffs_read,\n    .f_write = nffs_write,\n\n    .f_seek = nffs_seek,\n    .f_getpos = nffs_getpos,\n    .f_filelen = nffs_file_len,\n\n    .f_unlink = nffs_unlink,\n    .f_rename = nffs_rename,\n    .f_mkdir = nffs_mkdir,\n\n    .f_opendir = nffs_opendir,\n    .f_readdir = nffs_readdir,\n    .f_closedir = nffs_closedir,\n\n    .f_dirent_name = nffs_dirent_name,\n    .f_dirent_is_dir = nffs_dirent_is_dir,\n\n    .f_name =  nffs \n};\n\nint\nnffs_init(void)\n{\n    /* [...] */\n    fs_register( nffs_ops);\n}", 
            "title": "2. Register your package's API with the fs/fs interface."
        }, 
        {
            "location": "/os/modules/fs/otherfs/#header-files", 
            "text": "To gain access to  fs/fs 's registration interface, include the following header:  #include  fs/fs_if.h", 
            "title": "Header Files"
        }, 
        {
            "location": "/os/modules/hal/hal/", 
            "text": "Hardware Abstraction Layer\n\n\nDescription\n\n\nThe Hardware Abstraction Layer (HAL) includes a set of APIs \n(Application Programmer Interface) to connect to \nthe underlying hardware components including MCU components and peripheral\ncomponents.\n\n\nThe goal is to allow libraries, modules and applications written for Mynewt to \nbe shared within the Mynewt community and used across the variety of supported\nMynewt platforms. A secondary goal is to provide a simple consistent API \nto commonly used MCU components and peripherals to make development easier.\nNothing in the HAL precludes the user of the underlying physical devices,\nit only limits the portability of the end application.\n\n\nExample\n\n\nA Mynewt contributor might write a light-switch \nmodule (\nlibs/light\n) that provides the functionality of an intelligent light \nswitch.  This might involve using a timer, a General Purpose Output (GPO) \nto set the light to the on or off state, and flash memory to log the times the \nlights were turned on or off.  The contributor would like this module to \nwork with as many different hardware platforms as possible, but can't \npossibly test across the complete set of hardware supported by Mynewt.\n\n\nSolution\n:  The contributor uses the HAL APIs to control the peripherals.\nThe Mynewt team ensures that the underlying HAL devices all work equivalently\nthrough the HAL APIs. The contributors library is independent of the specifics\nof the hardware.  \n\n\nDependency\n\n\nTo include the HAL within your project,  simply add it to your package\ndependencies as follows:\n\n\npkg.deps: \n    . . .\n    hw/hal\n\n\n\n\n\nPlatform Support\n\n\nNot all platforms (MCU and BSP) support all HAL devices. Consult your MCU\nor BSP documentation to find out if you have hardware support for the \nperipherals you are interested in using.  Once you verify support, then\nconsult the MCU implementation and see if the specific HAL interface you are\nusing is in the \nmcu/xxx/src/hal_xxxx.c\n implementation.  Finally, you \ncan build your project and ensure that there are no unresolved hal_xxx \nexternals.\n\n\nImplementing HAL Interfaces\n\n\nIt might be that a specific HAL interface is not supported on your MCU or\nplatform.  See the specific HAL documentation for that interface for tips\non implementing this for your MCU.", 
            "title": "toc"
        }, 
        {
            "location": "/os/modules/hal/hal/#hardware-abstraction-layer", 
            "text": "", 
            "title": "Hardware Abstraction Layer"
        }, 
        {
            "location": "/os/modules/hal/hal/#description", 
            "text": "The Hardware Abstraction Layer (HAL) includes a set of APIs \n(Application Programmer Interface) to connect to \nthe underlying hardware components including MCU components and peripheral\ncomponents.  The goal is to allow libraries, modules and applications written for Mynewt to \nbe shared within the Mynewt community and used across the variety of supported\nMynewt platforms. A secondary goal is to provide a simple consistent API \nto commonly used MCU components and peripherals to make development easier.\nNothing in the HAL precludes the user of the underlying physical devices,\nit only limits the portability of the end application.", 
            "title": "Description"
        }, 
        {
            "location": "/os/modules/hal/hal/#example", 
            "text": "A Mynewt contributor might write a light-switch \nmodule ( libs/light ) that provides the functionality of an intelligent light \nswitch.  This might involve using a timer, a General Purpose Output (GPO) \nto set the light to the on or off state, and flash memory to log the times the \nlights were turned on or off.  The contributor would like this module to \nwork with as many different hardware platforms as possible, but can't \npossibly test across the complete set of hardware supported by Mynewt.  Solution :  The contributor uses the HAL APIs to control the peripherals.\nThe Mynewt team ensures that the underlying HAL devices all work equivalently\nthrough the HAL APIs. The contributors library is independent of the specifics\nof the hardware.", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/hal/hal/#dependency", 
            "text": "To include the HAL within your project,  simply add it to your package\ndependencies as follows:  pkg.deps: \n    . . .\n    hw/hal", 
            "title": "Dependency"
        }, 
        {
            "location": "/os/modules/hal/hal/#platform-support", 
            "text": "Not all platforms (MCU and BSP) support all HAL devices. Consult your MCU\nor BSP documentation to find out if you have hardware support for the \nperipherals you are interested in using.  Once you verify support, then\nconsult the MCU implementation and see if the specific HAL interface you are\nusing is in the  mcu/xxx/src/hal_xxxx.c  implementation.  Finally, you \ncan build your project and ensure that there are no unresolved hal_xxx \nexternals.", 
            "title": "Platform Support"
        }, 
        {
            "location": "/os/modules/hal/hal/#implementing-hal-interfaces", 
            "text": "It might be that a specific HAL interface is not supported on your MCU or\nplatform.  See the specific HAL documentation for that interface for tips\non implementing this for your MCU.", 
            "title": "Implementing HAL Interfaces"
        }, 
        {
            "location": "/os/modules/hal/hal_api/", 
            "text": "HAL Interfaces\n\n\nThe HAL supports separate interfaces for many peripherals.  A brief\ndescription of the interfaces are shown below.\n\n\n\n\n\n\n\n\nHal Name\n\n\n Interface File \n\n\nDescription \n\n\n\n\n\n\n\n\n\n\ncputime\n\n\nhal_cputime.h\n\n\nAn interface for getting the CPU uptime, an interface to set arbitrary timers based on the CPU time, and an interface for a blocking delay if CPU time.\n\n\n\n\n\n\nflash\n\n\nhal_flash.h\n\n\nA blocking interface to access flash memory\n\n\n\n\n\n\nflash_int\n\n\nhal_flash_int.h\n\n\nThe underlying API that the flash drivers implement.  If you are writing a new flash driver, this is how you hook it into the HAL.\n\n\n\n\n\n\nflash map\n\n\nflash_map.h\n\n\nAn interface to query information about the flash map (regions and sectors)\n\n\n\n\n\n\ngpio\n\n\nhal_gpio.h\n\n\nAn interface for manipulating General Purpose Inputs and Outputs\n\n\n\n\n\n\nsystem\n\n\nhal_system.h\n\n\nAn interface for starting and resetting the system\n\n\n\n\n\n\nuart\n\n\nhal_uart.h\n\n\nAn interface for communicating via asyncrhonous serial interface", 
            "title": "Summary"
        }, 
        {
            "location": "/os/modules/hal/hal_api/#hal-interfaces", 
            "text": "The HAL supports separate interfaces for many peripherals.  A brief\ndescription of the interfaces are shown below.     Hal Name   Interface File   Description       cputime  hal_cputime.h  An interface for getting the CPU uptime, an interface to set arbitrary timers based on the CPU time, and an interface for a blocking delay if CPU time.    flash  hal_flash.h  A blocking interface to access flash memory    flash_int  hal_flash_int.h  The underlying API that the flash drivers implement.  If you are writing a new flash driver, this is how you hook it into the HAL.    flash map  flash_map.h  An interface to query information about the flash map (regions and sectors)    gpio  hal_gpio.h  An interface for manipulating General Purpose Inputs and Outputs    system  hal_system.h  An interface for starting and resetting the system    uart  hal_uart.h  An interface for communicating via asyncrhonous serial interface", 
            "title": "HAL Interfaces"
        }, 
        {
            "location": "/os/modules/hal/hal_gpio/hal_gpio/", 
            "text": "hal_gpio\n\n\nThis is the hardware independent GPIO (General Purpose Input Output) Interface for Mynewt.\n\n\nDescription\n\n\nContains the basic operations to set and read General Purpose Digital I/O Pins\nwithin a Mynewt system.\n\n\nIndividual GPIOs are referenced in the APIs as \npins\n. However, in this interface the \npins\n are virtual GPIO pins. The MCU hal driver maps these virtual \npins\n to the physical GPIO ports and pins. \n\n\nTypically, the BSP code may define named I/O pins in terms of these virtual \npins\n to describe the devices attached to the physical pins.\n\n\nHere's a brief example so you can get the gist of the translation.\n\n\nSuppose my product uses the stm32F4xx processor.  There already exists support for this processor within Mynewt.  The processor has N ports (A,B,C..) of 16 GPIO pins per port.   The MCU hal_gpio driver maps these to a set of virtual pins 0-N where port A maps to 0-15, Port B maps to 16-31, Port C maps to 32-47 and so on.  The exact number of physical port (and virtual \nport pins) depends on the specific variant of the stm32F4xx.  \n\n\nSo if I want to turn on port B pin 3, that would be virtual pin  1*16 + 3 = 19. \nThis translation is defined in the MCU implementation of \n\nhal_gpio.c\n \nfor the stmf32F4xx.  Each MCU will typically have a different translation method \ndepending on its GPIO architecture. \n\n\nNow, when writing a BSP, it's common to give names to the relevant port pins that you are using.  Thus, the BSP may define a mapping between a function and a virtual port pin.  For example\n\n\n#define SYSTEM_LED              (37)\n#define FLASH_SPI_CHIP_SELECT   (3)\n\n\n\n\n\nwould map the system indicator LED to virtual pin 37 which on the stm32F4xx would be Port C pin 5 and the chip select line for the external SPI flash to virtual pin 3 which on the stm32F4xxis port A pin 3.\n\n\nSaid another way, in this specific system we get\n\n\nSYSTEM_LED --\n hal_gpio virtual pin 37 --\n port C pin 5 on the stm34F4xx\n\n\n\n\n\nDefinition\n\n\nhal_gpio.h\n\n\nExamples\n\n\nBlinky\n\n\nBlinky uses the hal_gpio to blink the system LED.  The blinky source code is available \n\nhere\n.\nExamine how \ntask1_handler\n initializes and toggles the GPIO to control the LED.", 
            "title": "GPIO"
        }, 
        {
            "location": "/os/modules/hal/hal_gpio/hal_gpio/#hal_gpio", 
            "text": "This is the hardware independent GPIO (General Purpose Input Output) Interface for Mynewt.", 
            "title": "hal_gpio"
        }, 
        {
            "location": "/os/modules/hal/hal_gpio/hal_gpio/#description", 
            "text": "Contains the basic operations to set and read General Purpose Digital I/O Pins\nwithin a Mynewt system.  Individual GPIOs are referenced in the APIs as  pins . However, in this interface the  pins  are virtual GPIO pins. The MCU hal driver maps these virtual  pins  to the physical GPIO ports and pins.   Typically, the BSP code may define named I/O pins in terms of these virtual  pins  to describe the devices attached to the physical pins.  Here's a brief example so you can get the gist of the translation.  Suppose my product uses the stm32F4xx processor.  There already exists support for this processor within Mynewt.  The processor has N ports (A,B,C..) of 16 GPIO pins per port.   The MCU hal_gpio driver maps these to a set of virtual pins 0-N where port A maps to 0-15, Port B maps to 16-31, Port C maps to 32-47 and so on.  The exact number of physical port (and virtual \nport pins) depends on the specific variant of the stm32F4xx.    So if I want to turn on port B pin 3, that would be virtual pin  1*16 + 3 = 19. \nThis translation is defined in the MCU implementation of  hal_gpio.c  \nfor the stmf32F4xx.  Each MCU will typically have a different translation method \ndepending on its GPIO architecture.   Now, when writing a BSP, it's common to give names to the relevant port pins that you are using.  Thus, the BSP may define a mapping between a function and a virtual port pin.  For example  #define SYSTEM_LED              (37)\n#define FLASH_SPI_CHIP_SELECT   (3)  would map the system indicator LED to virtual pin 37 which on the stm32F4xx would be Port C pin 5 and the chip select line for the external SPI flash to virtual pin 3 which on the stm32F4xxis port A pin 3.  Said another way, in this specific system we get  SYSTEM_LED --  hal_gpio virtual pin 37 --  port C pin 5 on the stm34F4xx", 
            "title": "Description"
        }, 
        {
            "location": "/os/modules/hal/hal_gpio/hal_gpio/#definition", 
            "text": "hal_gpio.h", 
            "title": "Definition"
        }, 
        {
            "location": "/os/modules/hal/hal_gpio/hal_gpio/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/os/modules/hal/hal_gpio/hal_gpio/#blinky", 
            "text": "Blinky uses the hal_gpio to blink the system LED.  The blinky source code is available  here .\nExamine how  task1_handler  initializes and toggles the GPIO to control the LED.", 
            "title": "Blinky"
        }, 
        {
            "location": "/os/modules/hal/hal_flash/hal_flash/", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/os/modules/hal/hal_flash/hal_flash_int/", 
            "text": "", 
            "title": "flash_int"
        }, 
        {
            "location": "/os/modules/hal/hal_flash/hal_flash_map/", 
            "text": "", 
            "title": "flash_map"
        }, 
        {
            "location": "/os/modules/hal/hal_cputime/hal_cpu_timer/", 
            "text": "hal_cputime\n\n\nThe hardware independent interface to system time.\n\n\nDescription\n\n\nContains several different interface.\n\n\n\n\nAn interface to get the current CPU time \n\n\nInterfaces to convert between CPU time and clock time (microseconds etc.)\n\n\nAn Interface to set up a software timer based on CPU time.\n\n\n\n\nDefinition\n\n\nhal_cputime.h\n\n\nCPU Time\n\n\nThe CPU time is not the same as the \nos_time\n.  Typically,\nthe os_time is set to a much slower tick rate than the CPU time.  The CPU\ntime should be used for timing real-time events at exact times.  The os_time\nshould be used for system level timeout etc that are not in fine time \nresolutions.  In fact, cputime is not part of the os at all, but a hardware\nlayer abstraction to high resolution timers. \n\n\nThere are methods to get the cputime as 32-bit and 64-bit values.  Both \nvalues may eventually wrap, but for timing short events a 32-bit value\nmay be sufficient and would", 
            "title": "CPU timer"
        }, 
        {
            "location": "/os/modules/hal/hal_cputime/hal_cpu_timer/#hal_cputime", 
            "text": "The hardware independent interface to system time.", 
            "title": "hal_cputime"
        }, 
        {
            "location": "/os/modules/hal/hal_cputime/hal_cpu_timer/#description", 
            "text": "Contains several different interface.   An interface to get the current CPU time   Interfaces to convert between CPU time and clock time (microseconds etc.)  An Interface to set up a software timer based on CPU time.", 
            "title": "Description"
        }, 
        {
            "location": "/os/modules/hal/hal_cputime/hal_cpu_timer/#definition", 
            "text": "hal_cputime.h", 
            "title": "Definition"
        }, 
        {
            "location": "/os/modules/hal/hal_cputime/hal_cpu_timer/#cpu-time", 
            "text": "The CPU time is not the same as the  os_time .  Typically,\nthe os_time is set to a much slower tick rate than the CPU time.  The CPU\ntime should be used for timing real-time events at exact times.  The os_time\nshould be used for system level timeout etc that are not in fine time \nresolutions.  In fact, cputime is not part of the os at all, but a hardware\nlayer abstraction to high resolution timers.   There are methods to get the cputime as 32-bit and 64-bit values.  Both \nvalues may eventually wrap, but for timing short events a 32-bit value\nmay be sufficient and would", 
            "title": "CPU Time"
        }, 
        {
            "location": "/os/modules/hal/hal_uart/hal_uart/", 
            "text": "hal_uart\n\n\nThe hardware independent UART interface for Mynewt.\n\n\nDescription\n\n\nContains the basic operations to send and receive data over a UART\n(Universal Asynchronous Receiver Transmitter).  \n\n\nDefinition\n\n\nhal_uart.h\n\n\nExamples\n\n\nThis example shows a user writing a character to the uart\n\n\n/* write to the console with blocking */\n{\n    char *str = \nHello World!\n;\n    char *ptr = str;\n\n    while(*ptr++) {\n        hal_uart_blocking_tx(MY_UART, *ptr);        \n    }\n    hal_uart_blocking_tx(MY_UART, \n\\n\n);        \n}", 
            "title": "UART"
        }, 
        {
            "location": "/os/modules/hal/hal_uart/hal_uart/#hal_uart", 
            "text": "The hardware independent UART interface for Mynewt.", 
            "title": "hal_uart"
        }, 
        {
            "location": "/os/modules/hal/hal_uart/hal_uart/#description", 
            "text": "Contains the basic operations to send and receive data over a UART\n(Universal Asynchronous Receiver Transmitter).", 
            "title": "Description"
        }, 
        {
            "location": "/os/modules/hal/hal_uart/hal_uart/#definition", 
            "text": "hal_uart.h", 
            "title": "Definition"
        }, 
        {
            "location": "/os/modules/hal/hal_uart/hal_uart/#examples", 
            "text": "This example shows a user writing a character to the uart  /* write to the console with blocking */\n{\n    char *str =  Hello World! ;\n    char *ptr = str;\n\n    while(*ptr++) {\n        hal_uart_blocking_tx(MY_UART, *ptr);        \n    }\n    hal_uart_blocking_tx(MY_UART,  \\n );        \n}", 
            "title": "Examples"
        }, 
        {
            "location": "/os/modules/hal/hal_system/hal_sys/", 
            "text": "", 
            "title": "System"
        }, 
        {
            "location": "/os/modules/hal/hal_in_libraries/", 
            "text": "Using HAL in Your Libraries\n\n\nThis page describes the recommended way to implement libraries that \nutilize HAL functionality.\n\n\nConsider the light switch example from the \nHAL overview\n page.\n\n\nThe light switch module needs a GPIO pin to set\nthe light switch to on or off.  The module declares that the GPIO to \ncontrol the light switch is declared elsewhere in one of two methods.\n\n\n   extern const int light_switch_gpio;\n\n\n\n\n\nor\n\n\n    extern int bsp_light_app_get_light_gpio();\n\n\n\n\n\nWhich method a library uses \n(extern const versus function) depends on what functionality the library\nmight wish to declare.  The \nextern const\n model uses the smallest code \nfootprint, but since its constant cannot be changed at runtime (based on \nthe configuration of the device say).  The \nextern function\n call requires\nthe BSP to implement a function which allows flexibility to assign the \nGPIO for the light switch to be determined at runtime with a small expense of\nslightly more code.\n\n\nThen the \nlibs/light\n would go on to use the specified GPIO during its runtime\nexecution. For example this shows both ways the library could interface to the \nbsp to get the right GPIO:\n\n\n    void light_on(void) {\n        . . .\n        /* finally time to turn the light on */\n        hal_gpio_set(light_switch_gpio);\n    }\n\n    void light_on(void) {\n        . . .\n        int pin = bsp_light_app_get_light_gpio();\n        /* finally time to turn the light on */\n        hal_gpio_set(pin);\n    }\n\n\n\n\n\nWhen you library user includes \nlibs/light\n as a dependency and then builds\nwith \nnewt\n, they will get an unresolved external for either \nlight_switch_gpio\n \nor \nbsp_light_app_get_light_gpio()\n and will need to add to their BSP.\n\n\nIn their BSP, they can add \n\n\n   const int light_switch_gpio = 5;\n\n\n\n\n\nor\n\n\n   int bsp_light_app_get_light_gpio(void) {\n        return my_configured_lightswitch_io();\n   }\n\n\n\n\n\nSo where did the number \n5\n come from.  Their BSP already includes the specific\nMCU that they are using. And their \nmcu/xxx/hal_gpio.c\n already defines \nthe mapping between physical pins and the virtual device ids.  \n\n\nThe user can determine (when writing code) from their boards physical pinmap \nand from the \nhal_gpio.c\n MCU mapping which virtual device_id corresponds \nto the correct physical pin in their system.", 
            "title": "Using"
        }, 
        {
            "location": "/os/modules/hal/hal_in_libraries/#using-hal-in-your-libraries", 
            "text": "This page describes the recommended way to implement libraries that \nutilize HAL functionality.  Consider the light switch example from the  HAL overview  page.  The light switch module needs a GPIO pin to set\nthe light switch to on or off.  The module declares that the GPIO to \ncontrol the light switch is declared elsewhere in one of two methods.     extern const int light_switch_gpio;  or      extern int bsp_light_app_get_light_gpio();  Which method a library uses \n(extern const versus function) depends on what functionality the library\nmight wish to declare.  The  extern const  model uses the smallest code \nfootprint, but since its constant cannot be changed at runtime (based on \nthe configuration of the device say).  The  extern function  call requires\nthe BSP to implement a function which allows flexibility to assign the \nGPIO for the light switch to be determined at runtime with a small expense of\nslightly more code.  Then the  libs/light  would go on to use the specified GPIO during its runtime\nexecution. For example this shows both ways the library could interface to the \nbsp to get the right GPIO:      void light_on(void) {\n        . . .\n        /* finally time to turn the light on */\n        hal_gpio_set(light_switch_gpio);\n    }\n\n    void light_on(void) {\n        . . .\n        int pin = bsp_light_app_get_light_gpio();\n        /* finally time to turn the light on */\n        hal_gpio_set(pin);\n    }  When you library user includes  libs/light  as a dependency and then builds\nwith  newt , they will get an unresolved external for either  light_switch_gpio  \nor  bsp_light_app_get_light_gpio()  and will need to add to their BSP.  In their BSP, they can add      const int light_switch_gpio = 5;  or     int bsp_light_app_get_light_gpio(void) {\n        return my_configured_lightswitch_io();\n   }  So where did the number  5  come from.  Their BSP already includes the specific\nMCU that they are using. And their  mcu/xxx/hal_gpio.c  already defines \nthe mapping between physical pins and the virtual device ids.    The user can determine (when writing code) from their boards physical pinmap \nand from the  hal_gpio.c  MCU mapping which virtual device_id corresponds \nto the correct physical pin in their system.", 
            "title": "Using HAL in Your Libraries"
        }, 
        {
            "location": "/os/modules/hal/hal_creation/", 
            "text": "Creating New HAL Interfaces\n\n\nHAL API\n\n\nA HAL always includes header file with function declarations \nfor the HAL functionality in \n/hw/hal/include/hal\n.\nThe first argument of all functions in the interface include the virtual \ndevice_id of the device you are controlling.  \n\n\nFor example, in \nhal_gpio.h\n \nthe device enumeration is the first argument to all methods and called \npin\n.\n\n\n    void hal_gpio_set(int pin);\n\n\n\n\n\nThe device_id (in this case called \npin\n) is not a physical device \n(actual hardware pin), but a virtual pin which is defined by the \nimplementation of the HAL (and documented in the implementation of the HAL)\n\n\nBelow this, there are two different paradigms for HAL interface.  They are \ndiscussed below.\n\n\nDirect HAL Interface\n\n\nIn one HAL paradigm called \ndirect HAL\n, the header file is the only component \nof the HAL interface.   Implementers of this HAL would create a source file\nthat implements these methods.  \n\n\nThis has the advantage of being simple, small, and low execution overhead.\n\n\nIt has the disadvantage that its not possible to have two different implementations\nof the same \ndirect HAL\n within the same image. Said another way, if I create\na \ndirect HAL\n \nhal_foo.h\n, there can be many implementations of \n\nxxx/hal_foo.c\n but only one can be included in a project.  \n\n\nFor example, support there is an ADC attached directly to the MCU and an ADC\nthat is attached via SPI.  There would be no way in this simple paradigm\nto use both these devices from the HAL API at the same time.\n\n\nThis brings up the second paradigm.\n\n\nIndirect HAL Interface\n\n\nThe second paradigm, \nindirect HAL\n  preserves the simple function \nAPI with enumerated device_id but adds a small layer of code in the \nHAL to allow different implementations to connect at runtime.\n\n\nThe abstract interface contains three components:\n\n\n\n\nA header file \nhal_foo.h\n that includes the API above with a \ndevice_id\n\n\nAn implementation \nhal/hal_foo.c\n which maps the \ndevice_id\n to \na driver interface structure.  \n\n\nA driver interface structure that is defined for the underlying implementation\n\n\n\n\nUsing this simple model, the user can be exposed to a simple function \ninterface (without structures or function pointers) and the system can provide\na different software implementation for each device id.\n\n\nAlthough the GPIO interface for Mynewt uses the \ndirect HAL\n, we can describe\nwhat it might look like for an indirect HAL.  \n\n\nThe API \nhal_gpio.h\n is identical with a direct or indirect HAL.\n\n\nIn the indirect HAL there is an additional header file \nhal_gpio_int.h\n\n which describes the driver interface for underlying implementations.  It \nlooks similar to the HAL API except is driven by function pointers.\n\n\nstruct hal_gpio_funcs {\n    void (*hgpio_set)(void);\n    . . .\n};\n\nstruct hal_gpio_int {\n    struct hal_gpio_funcs funcs;\n}\n\nconst struct hal_gpio_int *bsp_gpio_dev(uint8_t pin);\n\n\n\n\n\nThe BSP specific function is what will map the specific pin (device_id) \nto its implementation.\n\n\nThis is different than the \ndirect HAL\n which maps this virtual/physical \ndevice pairing in the MCU implementation.  For the \nindirect HAL\n the \nmapping has to be done in the BSP since that is the place where multiple \ndisparate devices can be enumerated into a single \ndevice_id\n space.\n\n\nAn interface file \nhal/hal_gpio.c\n would perform the mapping as \nfollows:\n\n\n    void hal_gpio_set(int pin) {\n        const struct hal_gpio_int *pgpio;\n        pgpio = bsp_get_gpio_device(pin);\n        if(pgpio) {\n            pgpio-\nfuncs.set();\n        }\n    }\n\n\n\n\n\nThe implementer of GPIO functionality (say in \nmcu/xxx/hal_gpio.c\n) would \nimplement the structure and provide the function pointers.\n\n\nvoid xxx_hal_gpio_set(void) {\n    /* implementation for this particular gpio device */\n    . . .\n}\n\nstruct hal_gpio_int xxx_hal_gpio = {\n    .funcs.hgpio_set = xxx_hal_gpio_set;\n}\n\n\n\n\n\nThis leaves the BSP implementation to complete the function \n\n\nconst struct hal_gpio_int *bsp_gpio_dev(uint8_t pin) {\n    switch(pin) {\n        case 0:\n            return \nxxx_hal_gpio;\n        case 1:\n            return \nyyy_hal_gpio;\n    }\n    return NULL;\n}\n\n\n\n\n\nNOTE\n: In this example there could be 10s of GPIO. It may be memory inefficient\nto have that many \nhal_gpio_int\n structures around to basically call the \nsame functions.  In Mynewt today, the hal_gpio is a \ndirect HAL\n and does \nnot have this overhead. More HAL paradigms may be added in the future to address \nthe flexibility of the \nindirect HAL\n with the memory efficiency of the \ndirect HAL", 
            "title": "Creating"
        }, 
        {
            "location": "/os/modules/hal/hal_creation/#creating-new-hal-interfaces", 
            "text": "", 
            "title": "Creating New HAL Interfaces"
        }, 
        {
            "location": "/os/modules/hal/hal_creation/#hal-api", 
            "text": "A HAL always includes header file with function declarations \nfor the HAL functionality in  /hw/hal/include/hal .\nThe first argument of all functions in the interface include the virtual \ndevice_id of the device you are controlling.    For example, in  hal_gpio.h  \nthe device enumeration is the first argument to all methods and called  pin .      void hal_gpio_set(int pin);  The device_id (in this case called  pin ) is not a physical device \n(actual hardware pin), but a virtual pin which is defined by the \nimplementation of the HAL (and documented in the implementation of the HAL)  Below this, there are two different paradigms for HAL interface.  They are \ndiscussed below.", 
            "title": "HAL API"
        }, 
        {
            "location": "/os/modules/hal/hal_creation/#direct-hal-interface", 
            "text": "In one HAL paradigm called  direct HAL , the header file is the only component \nof the HAL interface.   Implementers of this HAL would create a source file\nthat implements these methods.    This has the advantage of being simple, small, and low execution overhead.  It has the disadvantage that its not possible to have two different implementations\nof the same  direct HAL  within the same image. Said another way, if I create\na  direct HAL   hal_foo.h , there can be many implementations of  xxx/hal_foo.c  but only one can be included in a project.    For example, support there is an ADC attached directly to the MCU and an ADC\nthat is attached via SPI.  There would be no way in this simple paradigm\nto use both these devices from the HAL API at the same time.  This brings up the second paradigm.", 
            "title": "Direct HAL Interface"
        }, 
        {
            "location": "/os/modules/hal/hal_creation/#indirect-hal-interface", 
            "text": "The second paradigm,  indirect HAL   preserves the simple function \nAPI with enumerated device_id but adds a small layer of code in the \nHAL to allow different implementations to connect at runtime.  The abstract interface contains three components:   A header file  hal_foo.h  that includes the API above with a  device_id  An implementation  hal/hal_foo.c  which maps the  device_id  to \na driver interface structure.    A driver interface structure that is defined for the underlying implementation   Using this simple model, the user can be exposed to a simple function \ninterface (without structures or function pointers) and the system can provide\na different software implementation for each device id.  Although the GPIO interface for Mynewt uses the  direct HAL , we can describe\nwhat it might look like for an indirect HAL.    The API  hal_gpio.h  is identical with a direct or indirect HAL.  In the indirect HAL there is an additional header file  hal_gpio_int.h \n which describes the driver interface for underlying implementations.  It \nlooks similar to the HAL API except is driven by function pointers.  struct hal_gpio_funcs {\n    void (*hgpio_set)(void);\n    . . .\n};\n\nstruct hal_gpio_int {\n    struct hal_gpio_funcs funcs;\n}\n\nconst struct hal_gpio_int *bsp_gpio_dev(uint8_t pin);  The BSP specific function is what will map the specific pin (device_id) \nto its implementation.  This is different than the  direct HAL  which maps this virtual/physical \ndevice pairing in the MCU implementation.  For the  indirect HAL  the \nmapping has to be done in the BSP since that is the place where multiple \ndisparate devices can be enumerated into a single  device_id  space.  An interface file  hal/hal_gpio.c  would perform the mapping as \nfollows:      void hal_gpio_set(int pin) {\n        const struct hal_gpio_int *pgpio;\n        pgpio = bsp_get_gpio_device(pin);\n        if(pgpio) {\n            pgpio- funcs.set();\n        }\n    }  The implementer of GPIO functionality (say in  mcu/xxx/hal_gpio.c ) would \nimplement the structure and provide the function pointers.  void xxx_hal_gpio_set(void) {\n    /* implementation for this particular gpio device */\n    . . .\n}\n\nstruct hal_gpio_int xxx_hal_gpio = {\n    .funcs.hgpio_set = xxx_hal_gpio_set;\n}  This leaves the BSP implementation to complete the function   const struct hal_gpio_int *bsp_gpio_dev(uint8_t pin) {\n    switch(pin) {\n        case 0:\n            return  xxx_hal_gpio;\n        case 1:\n            return  yyy_hal_gpio;\n    }\n    return NULL;\n}  NOTE : In this example there could be 10s of GPIO. It may be memory inefficient\nto have that many  hal_gpio_int  structures around to basically call the \nsame functions.  In Mynewt today, the hal_gpio is a  direct HAL  and does \nnot have this overhead. More HAL paradigms may be added in the future to address \nthe flexibility of the  indirect HAL  with the memory efficiency of the  direct HAL", 
            "title": "Indirect HAL Interface"
        }, 
        {
            "location": "/os/modules/testutil/testutil/", 
            "text": "testutil\n\n\nThe testutil package is a test framework that provides facilities for specifying test cases and recording test results.\n\n\nYou would use it to build regression tests for your library.\n\n\nDescription\n\n\nA package may optionally contain a set of test cases.  Test cases are not normally compiled and linked when a package is built; they are only included\nwhen the \"test\" identity is specified.  All of a package's test code goes in its \nsrc/test\n directory.  For example, the nffs package's test code is located in the following directory:\n\n\n    * fs/nffs/src/test/\n\n\n\n\n\nThis directory contains the source and header files that implement the nffs test code.\n\n\nThe test code has access to all the header files in the following directories:\n\n\n    * src\n    * src/arch/\ntarget-arch\n\n    * include\n    * src/test\n    * src/test/arch/\ntarget-arch\n\n    * include directories of all package dependencies\n\n\n\n\n\nPackage test code typically depends on the testutil package, described later in this document.  If a package's test code uses testutil, then the package itself needs to have testutil in its dependency list.\n\n\nSome test cases or test initialization code may be platform-specific.  In such cases, the platform-specific function definitions are placed in arch subdirectories within the package test directory.\n\n\nWhile building the test code (i.e., when the \ntest\n identity is specified), the newt tool defines the \nTEST\n macro.  This macro is defined during compilation of all C source files in all projects and packages.\n\n\nTests are structured according to the following hierarchy:\n\n\n                [test]\n               /      \\\n        [suite]        [suite]\n       /       \\      /       \\\n     [case] [case]  [case] [case]\n\n\n\n\n\nI.e., a test consists of test suites, and a test suite consists of test cases.\n\n\nThe test code uses testutil to define test suites and test cases.\n\n\nRegression test can then be executed using 'newt target test' command, or by including a call to your test suite from \nproject/test/src/test.c\n.\n\n\nExample\n\n\nThis Tutorial\n shows how to create a test suite\nfor a Mynewt package.\n\n\nData structures\n\n\nstruct tu_config {\n    int tc_print_results;\n    int tc_system_assert;\n\n    tu_case_init_fn_t *tc_case_init_cb;\n    void *tc_case_init_arg;\n\n    tu_case_report_fn_t *tc_case_fail_cb;\n    void *tc_case_fail_arg;\n\n    tu_case_report_fn_t *tc_case_pass_cb;\n    void *tc_case_pass_arg;\n\n    tu_suite_init_fn_t *tc_suite_init_cb;\n    void *tc_suite_init_arg;\n\n    tu_restart_fn_t *tc_restart_cb;\n    void *tc_restart_arg;\n};\nextern struct tu_config tu_config;\n\n\n\n\n\nThe global \ntu_config\n struct contains all the testutil package's settings.\nThis should be populated before \ntu_init()\n is called.\n\n\nList of Functions\n\n\n\n\nThe functions, and macros available in \ntestutil\n are:\n\n\n\n\ntu_init\n\n\nTEST_ASSERT\n\n\nTEST_PASS\n\n\nTEST_SUITE\n\n\nTEST_CASE\n\n\nTEST_CASE_DECL\n\n\ntu_restart", 
            "title": "toc"
        }, 
        {
            "location": "/os/modules/testutil/testutil/#testutil", 
            "text": "The testutil package is a test framework that provides facilities for specifying test cases and recording test results.  You would use it to build regression tests for your library.", 
            "title": "testutil"
        }, 
        {
            "location": "/os/modules/testutil/testutil/#description", 
            "text": "A package may optionally contain a set of test cases.  Test cases are not normally compiled and linked when a package is built; they are only included\nwhen the \"test\" identity is specified.  All of a package's test code goes in its  src/test  directory.  For example, the nffs package's test code is located in the following directory:      * fs/nffs/src/test/  This directory contains the source and header files that implement the nffs test code.  The test code has access to all the header files in the following directories:      * src\n    * src/arch/ target-arch \n    * include\n    * src/test\n    * src/test/arch/ target-arch \n    * include directories of all package dependencies  Package test code typically depends on the testutil package, described later in this document.  If a package's test code uses testutil, then the package itself needs to have testutil in its dependency list.  Some test cases or test initialization code may be platform-specific.  In such cases, the platform-specific function definitions are placed in arch subdirectories within the package test directory.  While building the test code (i.e., when the  test  identity is specified), the newt tool defines the  TEST  macro.  This macro is defined during compilation of all C source files in all projects and packages.  Tests are structured according to the following hierarchy:                  [test]\n               /      \\\n        [suite]        [suite]\n       /       \\      /       \\\n     [case] [case]  [case] [case]  I.e., a test consists of test suites, and a test suite consists of test cases.  The test code uses testutil to define test suites and test cases.  Regression test can then be executed using 'newt target test' command, or by including a call to your test suite from  project/test/src/test.c .", 
            "title": "Description"
        }, 
        {
            "location": "/os/modules/testutil/testutil/#example", 
            "text": "This Tutorial  shows how to create a test suite\nfor a Mynewt package.", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/testutil/testutil/#data-structures", 
            "text": "struct tu_config {\n    int tc_print_results;\n    int tc_system_assert;\n\n    tu_case_init_fn_t *tc_case_init_cb;\n    void *tc_case_init_arg;\n\n    tu_case_report_fn_t *tc_case_fail_cb;\n    void *tc_case_fail_arg;\n\n    tu_case_report_fn_t *tc_case_pass_cb;\n    void *tc_case_pass_arg;\n\n    tu_suite_init_fn_t *tc_suite_init_cb;\n    void *tc_suite_init_arg;\n\n    tu_restart_fn_t *tc_restart_cb;\n    void *tc_restart_arg;\n};\nextern struct tu_config tu_config;  The global  tu_config  struct contains all the testutil package's settings.\nThis should be populated before  tu_init()  is called.", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/modules/testutil/testutil/#list-of-functions", 
            "text": "The functions, and macros available in  testutil  are:   tu_init  TEST_ASSERT  TEST_PASS  TEST_SUITE  TEST_CASE  TEST_CASE_DECL  tu_restart", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/modules/testutil/tu_init/", 
            "text": "tu_init\n\n\nint tu_init(void)\n\n\n\n\n\nInitializes the test framework according to the contents of the \ntu_config\n struct. This function must be called before any tests are run.\n\n\nArguments\n\n\nN/A\n\n\nReturned values\n\n\nReturns 0 on success; nonzero on failure.\n\n\nExample\n\n\nHere's an example of stand-alone code which allows the user to execute regression tests for sys/config package only.\n\n\n#ifdef PKG_TEST\n\nint\nmain(int argc, char **argv)\n{\n    tu_config.tc_print_results = 1;\n    tu_init();\n\n    conf_init();\n    config_test_all();\n\n    return tu_any_failed;\n}\n\n#endif", 
            "title": "tu_init"
        }, 
        {
            "location": "/os/modules/testutil/tu_init/#tu_init", 
            "text": "int tu_init(void)  Initializes the test framework according to the contents of the  tu_config  struct. This function must be called before any tests are run.", 
            "title": " tu_init"
        }, 
        {
            "location": "/os/modules/testutil/tu_init/#arguments", 
            "text": "N/A", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/testutil/tu_init/#returned-values", 
            "text": "Returns 0 on success; nonzero on failure.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/testutil/tu_init/#example", 
            "text": "Here's an example of stand-alone code which allows the user to execute regression tests for sys/config package only.  #ifdef PKG_TEST\n\nint\nmain(int argc, char **argv)\n{\n    tu_config.tc_print_results = 1;\n    tu_init();\n\n    conf_init();\n    config_test_all();\n\n    return tu_any_failed;\n}\n\n#endif", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/testutil/test_assert/", 
            "text": "TEST_ASSERT\n\n\nTEST_ASSERT(expression, fail_msg, ...)\n\n\n\n\n\nTEST_ASSERT_FATAL(expression, fail_msg, ...)\n\n\n\n\n\nAsserts that the specified condition is true.  If the expression is true, nothing gets reported. \nfail_msg\n will be printed out if the expression is false. The expression argument is mandatory; the rest are optional.  The fail_msg argument is a printf format string which specifies how the remaining arguments are parsed.\n\n\nTEST_ASSERT_FATAL()\n causes the current test case to be aborted, if expression fails.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nexpression\n\n\nCondition being tested. If it fails, test is considered a failure, and a message is printed out.\n\n\n\n\n\n\nfail_msg\n\n\nPointer to C string that contains a format string that follows the same specifications as format in printf.\n\n\n\n\n\n\n...\n\n\nDepending on the format string, the function may expect either a sequence of additional arguments to be used to replace a format specifier in the format string or a variable arguments list. va_list is a special type defined in \n in stdarg.h.\n\n\n\n\n\n\n\n\nReturned values\n\n\nNone\n\n\nNotes\n\n\nWhile \nconsole_printf\n, with its well understood formatting options in C, is more convenient and easy on the eyes than the raw output of \nconsole_write\n, the associated code size is considerably larger.\n\n\nExample\n\n\nExample #1:\n\n\nTEST_CASE(config_test_insert)\n{\n    int rc;\n\n    rc = conf_register(\nconfig_test_handler);\n    TEST_ASSERT(rc == 0);\n}\n\n\n\n\n\nExample #2:\n\n\nTEST_CASE(nffs_test_unlink)\n{\n    int rc;\n\n    ....\n\n    rc = nffs_format(nffs_area_descs);\n    TEST_ASSERT_FATAL(rc == 0);\n\n    ....\n}\n\n\n\n\n\nExample #3:\n\n\nstatic int \ncbmem_test_case_1_walk(struct cbmem *cbmem, struct cbmem_entry_hdr *hdr, \n        void *arg)\n{\n    ....\n\n    rc = cbmem_read(cbmem, hdr, \nactual, 0, sizeof(actual));\n    TEST_ASSERT_FATAL(rc == 1, \nCouldn\nt read 1 byte from cbmem\n);\n    TEST_ASSERT_FATAL(actual == expected, \n            \nActual doesn\nt equal expected (%d = %d)\n, actual, expected);\n\n    ....\n}", 
            "title": "TEST_ASSERT"
        }, 
        {
            "location": "/os/modules/testutil/test_assert/#test_assert", 
            "text": "TEST_ASSERT(expression, fail_msg, ...)  TEST_ASSERT_FATAL(expression, fail_msg, ...)  Asserts that the specified condition is true.  If the expression is true, nothing gets reported.  fail_msg  will be printed out if the expression is false. The expression argument is mandatory; the rest are optional.  The fail_msg argument is a printf format string which specifies how the remaining arguments are parsed.  TEST_ASSERT_FATAL()  causes the current test case to be aborted, if expression fails.", 
            "title": " TEST_ASSERT"
        }, 
        {
            "location": "/os/modules/testutil/test_assert/#arguments", 
            "text": "Arguments  Description      expression  Condition being tested. If it fails, test is considered a failure, and a message is printed out.    fail_msg  Pointer to C string that contains a format string that follows the same specifications as format in printf.    ...  Depending on the format string, the function may expect either a sequence of additional arguments to be used to replace a format specifier in the format string or a variable arguments list. va_list is a special type defined in   in stdarg.h.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/testutil/test_assert/#returned-values", 
            "text": "None", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/testutil/test_assert/#notes", 
            "text": "While  console_printf , with its well understood formatting options in C, is more convenient and easy on the eyes than the raw output of  console_write , the associated code size is considerably larger.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/testutil/test_assert/#example", 
            "text": "Example #1:  TEST_CASE(config_test_insert)\n{\n    int rc;\n\n    rc = conf_register( config_test_handler);\n    TEST_ASSERT(rc == 0);\n}  Example #2:  TEST_CASE(nffs_test_unlink)\n{\n    int rc;\n\n    ....\n\n    rc = nffs_format(nffs_area_descs);\n    TEST_ASSERT_FATAL(rc == 0);\n\n    ....\n}  Example #3:  static int \ncbmem_test_case_1_walk(struct cbmem *cbmem, struct cbmem_entry_hdr *hdr, \n        void *arg)\n{\n    ....\n\n    rc = cbmem_read(cbmem, hdr,  actual, 0, sizeof(actual));\n    TEST_ASSERT_FATAL(rc == 1,  Couldn t read 1 byte from cbmem );\n    TEST_ASSERT_FATAL(actual == expected, \n             Actual doesn t equal expected (%d = %d) , actual, expected);\n\n    ....\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/testutil/test_pass/", 
            "text": "TEST_PASS \n\n\nTEST_PASS(msg, ...)\n\n\n\n\n\nReports a success result for the current test.  This function is not normally needed, as all successful tests automatically write an empty pass result at completion. It is only needed when the success result report should contain text.  The msg argument is a printf format string\n    which specifies how the remaining arguments are parsed.  The result file\n    produced by this function contains the following text:\n\n\n        |\nfile\n:\nline-number\n| manual pass\n        \nmsg\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmsg\n\n\nThis is a printf format string which specifies how the remaining arguments are parsed\n\n\n\n\n\n\n...\n\n\nDepending on the format string, the function may expect either a sequence of additional arguments to be used to replace a format specifier in the format string or a variable arguments list. va_list is a special type defined in \n in stdarg.h.\n\n\n\n\n\n\n\n\nReturned values\n\n\nNone\n\n\nNotes\n\n\nAfter this function is called, the remainder of the test case is not executed.", 
            "title": "TEST_PASS"
        }, 
        {
            "location": "/os/modules/testutil/test_pass/#test_pass", 
            "text": "TEST_PASS(msg, ...)  Reports a success result for the current test.  This function is not normally needed, as all successful tests automatically write an empty pass result at completion. It is only needed when the success result report should contain text.  The msg argument is a printf format string\n    which specifies how the remaining arguments are parsed.  The result file\n    produced by this function contains the following text:          | file : line-number | manual pass\n         msg", 
            "title": " TEST_PASS "
        }, 
        {
            "location": "/os/modules/testutil/test_pass/#arguments", 
            "text": "Arguments  Description      msg  This is a printf format string which specifies how the remaining arguments are parsed    ...  Depending on the format string, the function may expect either a sequence of additional arguments to be used to replace a format specifier in the format string or a variable arguments list. va_list is a special type defined in   in stdarg.h.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/testutil/test_pass/#returned-values", 
            "text": "None", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/testutil/test_pass/#notes", 
            "text": "After this function is called, the remainder of the test case is not executed.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/testutil/test_suite/", 
            "text": "TEST_SUITE \n\n\nTEST_SUITE(test_suite_name)\n\n\n\n\n\nDeclares a test suite function with the following type \nint test_suite_name(void)\n. This can then be called from either \nproject/test\n, or from main routine for package specific regression test.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntest_suite_name\n\n\nUsed as the function name for this test suite.\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturn value is 0 if the test suite passed; nonzero if it failed. Generally, the return code is not used. It is expected that the individual test cases will pass/fail with tests done using \nTEST_ASSERT()\n.\n\n\nExample\n\n\nTEST_SUITE(os_sem_test_suite)\n{\n    os_sem_test_basic();\n    os_sem_test_case_1();\n    os_sem_test_case_2();\n    os_sem_test_case_3();\n    os_sem_test_case_4();\n}", 
            "title": "TEST_SUITE"
        }, 
        {
            "location": "/os/modules/testutil/test_suite/#test_suite", 
            "text": "TEST_SUITE(test_suite_name)  Declares a test suite function with the following type  int test_suite_name(void) . This can then be called from either  project/test , or from main routine for package specific regression test.", 
            "title": " TEST_SUITE "
        }, 
        {
            "location": "/os/modules/testutil/test_suite/#arguments", 
            "text": "Arguments  Description      test_suite_name  Used as the function name for this test suite.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/testutil/test_suite/#returned-values", 
            "text": "Return value is 0 if the test suite passed; nonzero if it failed. Generally, the return code is not used. It is expected that the individual test cases will pass/fail with tests done using  TEST_ASSERT() .", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/testutil/test_suite/#example", 
            "text": "TEST_SUITE(os_sem_test_suite)\n{\n    os_sem_test_basic();\n    os_sem_test_case_1();\n    os_sem_test_case_2();\n    os_sem_test_case_3();\n    os_sem_test_case_4();\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/testutil/test_case/", 
            "text": "TEST_CASE \n\n\nTEST_CASE(test_case_name)\n\n\n\n\n\nDefines a test case function with the following type \nint test_case_name(void)\n. This can then be called from regression test's \nTEST_SUITE()\n function.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntest_case_name\n\n\nUsed as the function name for this test case.\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturn value is 0 if the test case passed; nonzero if it failed. Generally, the return code is not used. It is expected that the case will pass/fail with tests done using \nTEST_ASSERT()\n.\n\n\nExample\n\n\nTEST_CASE(config_test_insert)\n{\n     ....\n}", 
            "title": "TEST_CASE"
        }, 
        {
            "location": "/os/modules/testutil/test_case/#test_case", 
            "text": "TEST_CASE(test_case_name)  Defines a test case function with the following type  int test_case_name(void) . This can then be called from regression test's  TEST_SUITE()  function.", 
            "title": " TEST_CASE "
        }, 
        {
            "location": "/os/modules/testutil/test_case/#arguments", 
            "text": "Arguments  Description      test_case_name  Used as the function name for this test case.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/testutil/test_case/#returned-values", 
            "text": "Return value is 0 if the test case passed; nonzero if it failed. Generally, the return code is not used. It is expected that the case will pass/fail with tests done using  TEST_ASSERT() .", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/testutil/test_case/#example", 
            "text": "TEST_CASE(config_test_insert)\n{\n     ....\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/testutil/test_decl/", 
            "text": "TEST_CASE_DECL \n\n\nTEST_CASE_DECL(test_case_name)\n\n\n\n\n\nDeclares a test case function with the following type \nint test_case_name(void)\n. This can then be called from regression test's \nTEST_SUITE()\n function.  This is only required if the test case function \nexists in a different file than the test suite.  This will allow the test suite\nto find the test case\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntest_case_name\n\n\nUsed as the function name for this test case.\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturn value is 0 if the test case passed; nonzero if it failed. Generally, the return code is not used. It is expected that the case will pass/fail with tests done using \nTEST_ASSERT()\n.\n\n\nExample file \ntest_cases.h\n\n\nTEST_CASE_DECL(test_case_1)\nTEST_CASE_DECL(test_case_2)\nTEST_CASE_DECL(test_case_3)", 
            "title": "TEST_CASE_DECL"
        }, 
        {
            "location": "/os/modules/testutil/test_decl/#test_case_decl", 
            "text": "TEST_CASE_DECL(test_case_name)  Declares a test case function with the following type  int test_case_name(void) . This can then be called from regression test's  TEST_SUITE()  function.  This is only required if the test case function \nexists in a different file than the test suite.  This will allow the test suite\nto find the test case", 
            "title": " TEST_CASE_DECL "
        }, 
        {
            "location": "/os/modules/testutil/test_decl/#arguments", 
            "text": "Arguments  Description      test_case_name  Used as the function name for this test case.", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/testutil/test_decl/#returned-values", 
            "text": "Return value is 0 if the test case passed; nonzero if it failed. Generally, the return code is not used. It is expected that the case will pass/fail with tests done using  TEST_ASSERT() .", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/testutil/test_decl/#example-file-test_casesh", 
            "text": "TEST_CASE_DECL(test_case_1)\nTEST_CASE_DECL(test_case_2)\nTEST_CASE_DECL(test_case_3)", 
            "title": "Example file test_cases.h"
        }, 
        {
            "location": "/os/modules/testutil/tu_restart/", 
            "text": "tu_restart \n\n\nvoid tu_restart(void)\n\n\n\n\n\nThis function is used when a system reset is necessary to proceed with testing.  For example, the OS is designed to run forever once started, so a test which creates several OS tasks and then starts the OS has no means of completing. This function, when called from such a test, gracefully ends the current test case and proceeds to the next test case.\n\n\nThe particulars of this function depend on whether it is called from a simulated environment.  In a simulated environment, this function uses a \nlongjmp()\n call to break out of the current test case.\n\n\nArguments\n\n\nN/A\n\n\nReturned values\n\n\nReturns 0 on success; nonzero on failure.\n\n\nExample\n\n\nvoid\nos_test_restart(void)\n{\n    ....\n\n    tu_restart();\n}\n#endif", 
            "title": "tu_restart"
        }, 
        {
            "location": "/os/modules/testutil/tu_restart/#tu_restart", 
            "text": "void tu_restart(void)  This function is used when a system reset is necessary to proceed with testing.  For example, the OS is designed to run forever once started, so a test which creates several OS tasks and then starts the OS has no means of completing. This function, when called from such a test, gracefully ends the current test case and proceeds to the next test case.  The particulars of this function depend on whether it is called from a simulated environment.  In a simulated environment, this function uses a  longjmp()  call to break out of the current test case.", 
            "title": " tu_restart "
        }, 
        {
            "location": "/os/modules/testutil/tu_restart/#arguments", 
            "text": "N/A", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/testutil/tu_restart/#returned-values", 
            "text": "Returns 0 on success; nonzero on failure.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/testutil/tu_restart/#example", 
            "text": "void\nos_test_restart(void)\n{\n    ....\n\n    tu_restart();\n}\n#endif", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/imgmgr/imgmgr/", 
            "text": "Image Manager\n\n\nDescription\n\n\nThis library accepts incoming image management commands from newtmgr and acts on them.\n\n\nImages can be uploaded, present images listed, and system can be told to switch to another image.\n\n\nCurrently the package assumes that there are 2 image slots, one active one and another one in standby. When new image is uploaded, it replaces the one in standby slot. This is the model for scenario when MCU has internal flash only, it executes the code from that flash, and there is enough space to store 2 full images.\n\n\nImage manager interacts with bootloader by telling it to boot to a specific image. At the moment this has to be done by writing a file which contains a version number of the image to boot. Note that image manager itself does not replace the active image.\n\n\nImage manager also can upload files to filesystem as well as download them.\n\n\nNote that commands accessing filesystems (next boot target, file upload/download) will not be available unless project includes filesystem implementation.\n\n\nData structures\n\n\nN/A.\n\n\nList of Functions\n\n\n\n\nThe functions available in imgmgr are:\n\n\n\n\nimgmgr_module_init\n\n\nimgr_ver_parse\n\n\nimgr_ver_str", 
            "title": "toc"
        }, 
        {
            "location": "/os/modules/imgmgr/imgmgr/#image-manager", 
            "text": "", 
            "title": "Image Manager"
        }, 
        {
            "location": "/os/modules/imgmgr/imgmgr/#description", 
            "text": "This library accepts incoming image management commands from newtmgr and acts on them.  Images can be uploaded, present images listed, and system can be told to switch to another image.  Currently the package assumes that there are 2 image slots, one active one and another one in standby. When new image is uploaded, it replaces the one in standby slot. This is the model for scenario when MCU has internal flash only, it executes the code from that flash, and there is enough space to store 2 full images.  Image manager interacts with bootloader by telling it to boot to a specific image. At the moment this has to be done by writing a file which contains a version number of the image to boot. Note that image manager itself does not replace the active image.  Image manager also can upload files to filesystem as well as download them.  Note that commands accessing filesystems (next boot target, file upload/download) will not be available unless project includes filesystem implementation.", 
            "title": "Description"
        }, 
        {
            "location": "/os/modules/imgmgr/imgmgr/#data-structures", 
            "text": "N/A.", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/modules/imgmgr/imgmgr/#list-of-functions", 
            "text": "The functions available in imgmgr are:   imgmgr_module_init  imgr_ver_parse  imgr_ver_str", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/modules/imgmgr/imgmgr_module_init/", 
            "text": "imgmgr_module_init \n\n\n   int\n   imgmgr_module_init(void)\n\n\n\n\n\nRegisters image manager commands with newtmgr. This function should be called while initializing the project, preferably after newtmgr itself has been initialized.\n\n\nArguments\n\n\nN/A\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nExample\n\n\nint main(int argc, char **argv)\n{\n    ...\n\n    nmgr_task_init(NEWTMGR_TASK_PRIO, newtmgr_stack, NEWTMGR_TASK_STACK_SIZE);\n    imgmgr_module_init();\n\n    ...\n}", 
            "title": "imgmgr_module_init"
        }, 
        {
            "location": "/os/modules/imgmgr/imgmgr_module_init/#imgmgr_module_init", 
            "text": "int\n   imgmgr_module_init(void)  Registers image manager commands with newtmgr. This function should be called while initializing the project, preferably after newtmgr itself has been initialized.", 
            "title": " imgmgr_module_init "
        }, 
        {
            "location": "/os/modules/imgmgr/imgmgr_module_init/#arguments", 
            "text": "N/A", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/imgmgr/imgmgr_module_init/#returned-values", 
            "text": "List any values returned.\nError codes?", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/imgmgr/imgmgr_module_init/#notes", 
            "text": "", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/imgmgr/imgmgr_module_init/#example", 
            "text": "int main(int argc, char **argv)\n{\n    ...\n\n    nmgr_task_init(NEWTMGR_TASK_PRIO, newtmgr_stack, NEWTMGR_TASK_STACK_SIZE);\n    imgmgr_module_init();\n\n    ...\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/imgmgr/imgr_ver_parse/", 
            "text": "imgr_ver_parse \n\n\n   int\n   imgr_ver_parse(char *src, struct image_version *ver)\n\n\n\n\n\nParses character string containing image version number \nsrc\n and writes that to \nver\n. Version number string should be in format \n.\n.\n.\n. Major and minor numbers should be within range 0-255, revision between 0-65535 and build_number 0-4294967295.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nPointer to C string that contains version number being parsed\n\n\n\n\n\n\nver\n\n\nImage version number structure containing the returned value\n\n\n\n\n\n\n\n\nReturned values\n\n\n0 on success and \n0 if version number string could not be parsed.\n\n\nNotes\n\n\nNumbers within the string are separated by \n.\n. The first   number is the major number, and must be provided. Rest of the numbers (minor etc.) are optional.\n\n\nExample\n\n\nint main(int argc, char **argv)\n{\n    struct image_version hdr_ver;\n    int rc;\n    ...\n\n    rc = imgr_ver_parse(argv[3], \nhdr_ver);\n    if (rc != 0) {\n        print_usage(stderr);\n        return 1;\n    }\n    ...\n}", 
            "title": "imgr_ver_parse"
        }, 
        {
            "location": "/os/modules/imgmgr/imgr_ver_parse/#imgr_ver_parse", 
            "text": "int\n   imgr_ver_parse(char *src, struct image_version *ver)  Parses character string containing image version number  src  and writes that to  ver . Version number string should be in format  . . . . Major and minor numbers should be within range 0-255, revision between 0-65535 and build_number 0-4294967295.", 
            "title": " imgr_ver_parse "
        }, 
        {
            "location": "/os/modules/imgmgr/imgr_ver_parse/#arguments", 
            "text": "Arguments  Description      src  Pointer to C string that contains version number being parsed    ver  Image version number structure containing the returned value", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/imgmgr/imgr_ver_parse/#returned-values", 
            "text": "0 on success and  0 if version number string could not be parsed.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/imgmgr/imgr_ver_parse/#notes", 
            "text": "Numbers within the string are separated by  . . The first   number is the major number, and must be provided. Rest of the numbers (minor etc.) are optional.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/imgmgr/imgr_ver_parse/#example", 
            "text": "int main(int argc, char **argv)\n{\n    struct image_version hdr_ver;\n    int rc;\n    ...\n\n    rc = imgr_ver_parse(argv[3],  hdr_ver);\n    if (rc != 0) {\n        print_usage(stderr);\n        return 1;\n    }\n    ...\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/imgmgr/imgr_ver_str/", 
            "text": "imgr_ver_str \n\n\n   int\n   imgr_ver_str(struct image_version *ver, char *dst)\n\n\n\n\n\nTakes the version string from \nver\n and formats that into a printable string to \ndst\n. Caller must make sure that \ndst\n contains enough space to hold maximum lenght version string. The convenience defininition for max length version string is named \nIMGMGR_MAX_VER_STR\n.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nver\n\n\nImage version number structure containing the value being formatted\n\n\n\n\n\n\ndst\n\n\nPointer to C string where results will be stored\n\n\n\n\n\n\n\n\nReturned values\n\n\nFunction returns the number of characters filled into the destination string.\n\n\nNotes\n\n\nIf build number is \n0\n in image version structure, it will be left out of the string.\n\n\nExample\n\n\nstatic void\nimgr_ver_jsonstr(struct json_encoder *enc, char *key,\n  struct image_version *ver)\n{\n    char ver_str[IMGMGR_MAX_VER_STR];\n    int ver_len;\n    ...\n    ver_len = imgr_ver_str(ver, ver_str)\n    ...\n}", 
            "title": "imgr_ver_str"
        }, 
        {
            "location": "/os/modules/imgmgr/imgr_ver_str/#imgr_ver_str", 
            "text": "int\n   imgr_ver_str(struct image_version *ver, char *dst)  Takes the version string from  ver  and formats that into a printable string to  dst . Caller must make sure that  dst  contains enough space to hold maximum lenght version string. The convenience defininition for max length version string is named  IMGMGR_MAX_VER_STR .", 
            "title": " imgr_ver_str "
        }, 
        {
            "location": "/os/modules/imgmgr/imgr_ver_str/#arguments", 
            "text": "Arguments  Description      ver  Image version number structure containing the value being formatted    dst  Pointer to C string where results will be stored", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/imgmgr/imgr_ver_str/#returned-values", 
            "text": "Function returns the number of characters filled into the destination string.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/imgmgr/imgr_ver_str/#notes", 
            "text": "If build number is  0  in image version structure, it will be left out of the string.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/imgmgr/imgr_ver_str/#example", 
            "text": "static void\nimgr_ver_jsonstr(struct json_encoder *enc, char *key,\n  struct image_version *ver)\n{\n    char ver_str[IMGMGR_MAX_VER_STR];\n    int ver_len;\n    ...\n    ver_len = imgr_ver_str(ver, ver_str)\n    ...\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/baselibc/", 
            "text": "Baselibc\n\n\nBaselibc is a very simple libc for embedded systems geared primarily for 32-bit microcontrollers in the 10-100kB memory range. The library of basic system calls and facilities compiles to less than 5kB total on Cortex-M3, and much less if some functions aren't used.\n\n\nThe code is based on klibc and tinyprintf modules, and licensed under the BSD license.\n\n\nBaselibc comes from https://github.com/PetteriAimonen/Baselibc.git\n\n\nDescription\n\n\nMynewt OS can utilize libc which comes with compiler (e.g. newlib bundled with some binary distributions of arm-none-eabi-gcc). However, you may choose to replace the libc with baselibc for a reduced image size. Baselibc optimizes for size rather than performance, which is usually a more important goal in embedded environments.\n\n\nHow to switch to baselibc\n\n\nIn order to switch from using libc to using baselibc you have to add the baselibc pkg as a dependency in the project pkg. Specifying this dependency ensures that the linker first looks for the functions in baselibc before falling back to libc while creating the executable. For example, project \nboot\n uses baselibc. Its project description file \nboot.yml\n looks like the following:\n\n\nno-highlight\n   project.name: boot\n   project.identities: bootloader\n   project.pkgs:\n       - libs/os\n       - libs/bootutil\n       - libs/nffs\n       - libs/console/stub\n       - libs/util\n       - libs/baselibc\n\n\nList of Functions\n\n\nDocumentation for libc functions is available from multiple places. One example are the on-line manual pages at \nhttps://www.freebsd.org/cgi/man.cgi\n.\n\n\nbaselibc supports most libc functionality; malloc(), printf-family, string handling, and conversion routines.\n\n\nThere is some functionality which is not available, e.g. support for floating point numbers, and limited support for 'long long'.", 
            "title": "Baselibc library"
        }, 
        {
            "location": "/os/modules/baselibc/#baselibc", 
            "text": "Baselibc is a very simple libc for embedded systems geared primarily for 32-bit microcontrollers in the 10-100kB memory range. The library of basic system calls and facilities compiles to less than 5kB total on Cortex-M3, and much less if some functions aren't used.  The code is based on klibc and tinyprintf modules, and licensed under the BSD license.  Baselibc comes from https://github.com/PetteriAimonen/Baselibc.git", 
            "title": "Baselibc"
        }, 
        {
            "location": "/os/modules/baselibc/#description", 
            "text": "Mynewt OS can utilize libc which comes with compiler (e.g. newlib bundled with some binary distributions of arm-none-eabi-gcc). However, you may choose to replace the libc with baselibc for a reduced image size. Baselibc optimizes for size rather than performance, which is usually a more important goal in embedded environments.", 
            "title": "Description"
        }, 
        {
            "location": "/os/modules/baselibc/#how-to-switch-to-baselibc", 
            "text": "In order to switch from using libc to using baselibc you have to add the baselibc pkg as a dependency in the project pkg. Specifying this dependency ensures that the linker first looks for the functions in baselibc before falling back to libc while creating the executable. For example, project  boot  uses baselibc. Its project description file  boot.yml  looks like the following:  no-highlight\n   project.name: boot\n   project.identities: bootloader\n   project.pkgs:\n       - libs/os\n       - libs/bootutil\n       - libs/nffs\n       - libs/console/stub\n       - libs/util\n       - libs/baselibc", 
            "title": "How to switch to baselibc"
        }, 
        {
            "location": "/os/modules/baselibc/#list-of-functions", 
            "text": "Documentation for libc functions is available from multiple places. One example are the on-line manual pages at  https://www.freebsd.org/cgi/man.cgi .  baselibc supports most libc functionality; malloc(), printf-family, string handling, and conversion routines.  There is some functionality which is not available, e.g. support for floating point numbers, and limited support for 'long long'.", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/modules/elua/elua/", 
            "text": "elua\n\n\nDescription\n\n\nThis package contains a Lua interpreter. See http://lua.org for documentation of the language.\n\n\nYou can execute lua scripts either from console with shell or start the execution programmatically.\n\n\nData structures\n\n\nNotes\n\n\nCurrently we don't have language extension modules which would go together with this one, but those should be added.\n\n\nList of Functions\n\n\n\n\nlua_init\n\n\nlua_main", 
            "title": "toc"
        }, 
        {
            "location": "/os/modules/elua/elua/#elua", 
            "text": "", 
            "title": "elua"
        }, 
        {
            "location": "/os/modules/elua/elua/#description", 
            "text": "This package contains a Lua interpreter. See http://lua.org for documentation of the language.  You can execute lua scripts either from console with shell or start the execution programmatically.", 
            "title": "Description"
        }, 
        {
            "location": "/os/modules/elua/elua/#data-structures", 
            "text": "", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/modules/elua/elua/#notes", 
            "text": "Currently we don't have language extension modules which would go together with this one, but those should be added.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/elua/elua/#list-of-functions", 
            "text": "lua_init  lua_main", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/modules/elua/lua_init/", 
            "text": "lua_init \n\n\n   int\n   lua_init(void)\n\n\n\n\n\nRegisters 'lua' command with shell. This function should be called while initializing the project, preferably after shell itself has been initialized.\n\n\nArguments\n\n\nN/A\n\n\nReturned values\n\n\nReturns \n\n\nNotes\n\n\nCalling this is meaningful only if you include the shell package in your project.\n\n\nExample\n\n\nint main(int argc, char **argv)\n{\n    ...\n    shell_task_init(SHELL_TASK_PRIO, shell_stack, SHELL_TASK_STACK_SIZE,\n                         SHELL_MAX_INPUT_LEN);\n    ...\n    lua_init();\n    ...\n}", 
            "title": "lua_init"
        }, 
        {
            "location": "/os/modules/elua/lua_init/#lua_init", 
            "text": "int\n   lua_init(void)  Registers 'lua' command with shell. This function should be called while initializing the project, preferably after shell itself has been initialized.", 
            "title": " lua_init "
        }, 
        {
            "location": "/os/modules/elua/lua_init/#arguments", 
            "text": "N/A", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/elua/lua_init/#returned-values", 
            "text": "Returns", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/elua/lua_init/#notes", 
            "text": "Calling this is meaningful only if you include the shell package in your project.", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/elua/lua_init/#example", 
            "text": "int main(int argc, char **argv)\n{\n    ...\n    shell_task_init(SHELL_TASK_PRIO, shell_stack, SHELL_TASK_STACK_SIZE,\n                         SHELL_MAX_INPUT_LEN);\n    ...\n    lua_init();\n    ...\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/elua/lua_main/", 
            "text": "lua_main \n\n\n   int\n   lua_main(int argc, char **argv)\n\n\n\n\n\nExecutes lua script in current task's context. Arguments given are passed to lua interpreter.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nargc\n\n\nNumber of elements in argv array\n\n\n\n\n\n\nargv\n\n\nArray of character strings\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns the return code from the lua interpreter.\n\n\nNotes\n\n\nExample\n\n\nstatic int\nlua_cmd(int argc, char **argv)\n{\n    lua_main(argc, argv);\n    return 0;\n}", 
            "title": "lua_main"
        }, 
        {
            "location": "/os/modules/elua/lua_main/#lua_main", 
            "text": "int\n   lua_main(int argc, char **argv)  Executes lua script in current task's context. Arguments given are passed to lua interpreter.", 
            "title": " lua_main "
        }, 
        {
            "location": "/os/modules/elua/lua_main/#arguments", 
            "text": "Arguments  Description      argc  Number of elements in argv array    argv  Array of character strings", 
            "title": "Arguments"
        }, 
        {
            "location": "/os/modules/elua/lua_main/#returned-values", 
            "text": "Returns the return code from the lua interpreter.", 
            "title": "Returned values"
        }, 
        {
            "location": "/os/modules/elua/lua_main/#notes", 
            "text": "", 
            "title": "Notes"
        }, 
        {
            "location": "/os/modules/elua/lua_main/#example", 
            "text": "static int\nlua_cmd(int argc, char **argv)\n{\n    lua_main(argc, argv);\n    return 0;\n}", 
            "title": "Example"
        }, 
        {
            "location": "/os/modules/json/json/", 
            "text": "JSON\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe module here, special features, how pieces fit together etc.\n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in json are:\n\n\n\n\njson_encode_object_entry\n\n\njson_encode_object_finish\n\n\njson_encode_object_key\n\n\njson_encode_object_start\n\n\njson_encode_value\n\n\njson_internal_read_object\n\n\njson_read_array\n\n\njson_read_object\n\n\njson_target_address", 
            "title": "toc"
        }, 
        {
            "location": "/os/modules/json/json/#json", 
            "text": "Insert synopsis here", 
            "title": "JSON"
        }, 
        {
            "location": "/os/modules/json/json/#description", 
            "text": "Describe module here, special features, how pieces fit together etc.", 
            "title": "Description"
        }, 
        {
            "location": "/os/modules/json/json/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/os/modules/json/json/#list-of-functions", 
            "text": "The functions available in json are:   json_encode_object_entry  json_encode_object_finish  json_encode_object_key  json_encode_object_start  json_encode_value  json_internal_read_object  json_read_array  json_read_object  json_target_address", 
            "title": "List of Functions"
        }, 
        {
            "location": "/os/modules/json/json_encode_object_entry/", 
            "text": "", 
            "title": "json_encode_object_entry"
        }, 
        {
            "location": "/os/modules/json/json_encode_object_finish/", 
            "text": "", 
            "title": "json_encode_object_finish"
        }, 
        {
            "location": "/os/modules/json/json_encode_object_key/", 
            "text": "", 
            "title": "json_encode_object_key"
        }, 
        {
            "location": "/os/modules/json/json_encode_object_start/", 
            "text": "", 
            "title": "json_encode_object_start"
        }, 
        {
            "location": "/os/modules/json/json_encode_value/", 
            "text": "", 
            "title": "json_encode_value"
        }, 
        {
            "location": "/os/modules/json/json_internal_read_object/", 
            "text": "", 
            "title": "json_internal_read_object"
        }, 
        {
            "location": "/os/modules/json/json_read_array/", 
            "text": "", 
            "title": "json_read_array"
        }, 
        {
            "location": "/os/modules/json/json_read_object/", 
            "text": "", 
            "title": "json_read_object"
        }, 
        {
            "location": "/os/modules/json/json_target_address/", 
            "text": "", 
            "title": "json_target_address"
        }, 
        {
            "location": "/network/ble/ble_intro/", 
            "text": "", 
            "title": "toc"
        }, 
        {
            "location": "/newt/newt_intro/", 
            "text": "Introduction\n\n\nWhat is newt tool?", 
            "title": "Introduction"
        }, 
        {
            "location": "/newt/newt_intro/#introduction", 
            "text": "What is newt tool?", 
            "title": "Introduction"
        }, 
        {
            "location": "/newt/tutorials/newt_mac/", 
            "text": "Building newt tool on your Mac\n\n\nGetting your Mac Ready\n\n\nIf you want to build the \nnewt\n tool from its source code, follow the following steps:\n\n\n1. Install Homebrew on your Mac OS X\n\n\n\n\nDo you have Homebrew? If not, open a terminal on your Mac and paste the following at a Terminal prompt. It will ask you for your sudo password.\n\n\n\n\n        $ ruby -e \n$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\n\n\n\n\n\n\nAlternatively, you can just extract (or \ngit clone\n) Homebrew and install it to \n/usr/local\n.\n\n\n2. Install Go, the programming language\n\n\n\n\n\n\nGo language enviroment dictates a directory structure. Known in Go parlanace as workspace, it must contain three sibling directories with the directory names src, pkg and bin, as explained below. \n\n\n\n\n\n\nsrc contains Go source files organized into packages (one package per directory),\n\n\n\n\n\n\npkg contains package objects, and\n\n\n\n\n\n\nbin contains executable commands.\n\n\n\n\n\n\nThe GOPATH environment variable specifies the location of your workspace. To setup this workspace environment, create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory where you will soon clone the \nnewt\n tool repository.\n\n\n\n\n\n\n        $ cd $HOME\n        $ mkdir -p dev/go  \n        $ cd dev/go\n        $ export GOPATH=`pwd`\n\n\n\n\n\n(Note that you need to add export statements to ~/.bash_profile to export variables permanently. Don't forget to source the file for the change to go into effect.)\n\n\n        $ vi ~/.bash_profile\n        $ source ~/.bash_profile\n\n\n\n\n\n\n\nNext, using \nbrew\n, install Go. When installed, Go offers you as a developer a language enviroment (to compile Go code), construct Go packages (to assemble Go packages) and import Go code (from github). In the next step, you will use the Go commands to import \nnewt\n repo into your local Go environment.\n\n\n\n\n        $ brew install go\n        ==\n \n        ...\n        ... \n        ==\n *Summary*\n        \ud83c\udf7a  /usr/local/Cellar/go/1.5.1: 5330 files, 273M\n\n\n\n\n\nAlternatively, you can download the Go package directly from (https://golang.org/dl/) instead of brewing it. Install it in /usr/local directory.\n\n\n3. Create local repository\n\n\n\n\nUse Go commands to copy the directory (currently the ASF incubator directory). Be patient as it may take a minute or two. Check the directories installed.\n\n\n\n\n        $ go get mynewt.apache.org/newt/...\n\n\n\n\n\n\n\nCheck that newt.go is in place.\n\n\n\n\n        $ ls $GOPATH/src/mynewt.apache.org/newt\n        DISCLAIMER  NOTICE      newt        newtvm      viper\n        LICENSE     README.md   newtmgr     util        yaml\n\n\n\n\n\n4. Build the Newt tool\n\n\n\n\nUse Go to run the newt.go program to build the \nnewt\n tool. The command \ngo install\n compiles and writes the resulting executable to an output file named \nnewt\n, which is then installed, along with its dependencies, in $GOPATH/bin.\n\n\n\n\n        $ cd $GOPATH/src/mynewt.apache.org/newt/newt\n        $ go install\n        $ ls \n$GOPATH\n/bin/\n        newt newtmgr newtvm\n\n\n\n\n\n\n\nAt this point, you can try using \nnewt\n. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.\n\n\n\n\n(Note: If you are going to be modifying the \nnewt\n often and going to be compile the program every time you call it, you will want to store the command in a variable in your .bash_profile. So type in \nexport newt=\"go run $GOPATH/mynewt.apache.org/newt/newt/newt.go\"\n in your .bash_profile and execute it by calling \n$newt\n at the prompt instead of \nnewt\n. Essentially, \n$newt\n calls \ngo run\n which runs the compiled binary directly without producing an executable. Don't forget to reload the updated bash profile by typing \nsource ~/.bash_profile\n at the prompt! )\n\n\n        $ newt version\n        Newt version:  1.0\n        $ newt -h\n        Newt allows you to create your own embedded project based on the Mynewt\n        operating system. Newt provides both build and package management in a\n        single tool, which allows you to compose an embedded workspace, and set\n        of projects, and then build the necessary artifacts from those projects.\n        For more information on the Mynewt operating system, please visit\n        https://www.github.com/mynewt/documentation.\n\n        Please use the newt help command, and specify the name of the command\n        you want help for, for help on how to use a specific command\n\n        Usage:\n         newt [flags]\n         newt [command]\n\n        Examples:\n         newt\n         newt help [\ncommand-name\n]\n           For help on \ncommand-name\n.  If not specified, print this message.\n\n\n        Available Commands:\n         version     Display the Newt version number.\n         target      Set and view target information\n         egg         Commands to list and inspect eggs on a nest\n         nest        Commands to manage nests \n clutches (remote egg repositories)\n         help        Help about any command\n\n        Flags:\n         -h, --help=false: help for newt\n         -l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n         -q, --quiet=false: Be quiet; only display error output.\n         -s, --silent=false: Be silent; don\nt output anything.\n         -v, --verbose=false: Enable verbose output when executing commands.\n\n\n        Use \nnewt help [command]\n for more information about a command.\n\n\n\n\n\n\n\nWithout creating a project repository, you can't do a whole lot with the *newt tool. So you'll have to wait till you have downloaded an app to try out the tool.", 
            "title": "Install Newt on Mac"
        }, 
        {
            "location": "/newt/tutorials/newt_mac/#building-newt-tool-on-your-mac", 
            "text": "", 
            "title": "Building newt tool on your Mac"
        }, 
        {
            "location": "/newt/tutorials/newt_mac/#getting-your-mac-ready", 
            "text": "If you want to build the  newt  tool from its source code, follow the following steps:", 
            "title": "Getting your Mac Ready"
        }, 
        {
            "location": "/newt/tutorials/newt_mac/#1-install-homebrew-on-your-mac-os-x", 
            "text": "Do you have Homebrew? If not, open a terminal on your Mac and paste the following at a Terminal prompt. It will ask you for your sudo password.           $ ruby -e  $(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)   Alternatively, you can just extract (or  git clone ) Homebrew and install it to  /usr/local .", 
            "title": "1. Install Homebrew on your Mac OS X"
        }, 
        {
            "location": "/newt/tutorials/newt_mac/#2-install-go-the-programming-language", 
            "text": "Go language enviroment dictates a directory structure. Known in Go parlanace as workspace, it must contain three sibling directories with the directory names src, pkg and bin, as explained below.     src contains Go source files organized into packages (one package per directory),    pkg contains package objects, and    bin contains executable commands.    The GOPATH environment variable specifies the location of your workspace. To setup this workspace environment, create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory where you will soon clone the  newt  tool repository.            $ cd $HOME\n        $ mkdir -p dev/go  \n        $ cd dev/go\n        $ export GOPATH=`pwd`  (Note that you need to add export statements to ~/.bash_profile to export variables permanently. Don't forget to source the file for the change to go into effect.)          $ vi ~/.bash_profile\n        $ source ~/.bash_profile   Next, using  brew , install Go. When installed, Go offers you as a developer a language enviroment (to compile Go code), construct Go packages (to assemble Go packages) and import Go code (from github). In the next step, you will use the Go commands to import  newt  repo into your local Go environment.           $ brew install go\n        ==  \n        ...\n        ... \n        ==  *Summary*\n        \ud83c\udf7a  /usr/local/Cellar/go/1.5.1: 5330 files, 273M  Alternatively, you can download the Go package directly from (https://golang.org/dl/) instead of brewing it. Install it in /usr/local directory.", 
            "title": "2. Install Go, the programming language"
        }, 
        {
            "location": "/newt/tutorials/newt_mac/#3-create-local-repository", 
            "text": "Use Go commands to copy the directory (currently the ASF incubator directory). Be patient as it may take a minute or two. Check the directories installed.           $ go get mynewt.apache.org/newt/...   Check that newt.go is in place.           $ ls $GOPATH/src/mynewt.apache.org/newt\n        DISCLAIMER  NOTICE      newt        newtvm      viper\n        LICENSE     README.md   newtmgr     util        yaml", 
            "title": "3. Create local repository"
        }, 
        {
            "location": "/newt/tutorials/newt_mac/#4-build-the-newt-tool", 
            "text": "Use Go to run the newt.go program to build the  newt  tool. The command  go install  compiles and writes the resulting executable to an output file named  newt , which is then installed, along with its dependencies, in $GOPATH/bin.           $ cd $GOPATH/src/mynewt.apache.org/newt/newt\n        $ go install\n        $ ls  $GOPATH /bin/\n        newt newtmgr newtvm   At this point, you can try using  newt . For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.   (Note: If you are going to be modifying the  newt  often and going to be compile the program every time you call it, you will want to store the command in a variable in your .bash_profile. So type in  export newt=\"go run $GOPATH/mynewt.apache.org/newt/newt/newt.go\"  in your .bash_profile and execute it by calling  $newt  at the prompt instead of  newt . Essentially,  $newt  calls  go run  which runs the compiled binary directly without producing an executable. Don't forget to reload the updated bash profile by typing  source ~/.bash_profile  at the prompt! )          $ newt version\n        Newt version:  1.0\n        $ newt -h\n        Newt allows you to create your own embedded project based on the Mynewt\n        operating system. Newt provides both build and package management in a\n        single tool, which allows you to compose an embedded workspace, and set\n        of projects, and then build the necessary artifacts from those projects.\n        For more information on the Mynewt operating system, please visit\n        https://www.github.com/mynewt/documentation.\n\n        Please use the newt help command, and specify the name of the command\n        you want help for, for help on how to use a specific command\n\n        Usage:\n         newt [flags]\n         newt [command]\n\n        Examples:\n         newt\n         newt help [ command-name ]\n           For help on  command-name .  If not specified, print this message.\n\n\n        Available Commands:\n         version     Display the Newt version number.\n         target      Set and view target information\n         egg         Commands to list and inspect eggs on a nest\n         nest        Commands to manage nests   clutches (remote egg repositories)\n         help        Help about any command\n\n        Flags:\n         -h, --help=false: help for newt\n         -l, --loglevel= WARN : Log level, defaults to WARN.\n         -q, --quiet=false: Be quiet; only display error output.\n         -s, --silent=false: Be silent; don t output anything.\n         -v, --verbose=false: Enable verbose output when executing commands.\n\n\n        Use  newt help [command]  for more information about a command.   Without creating a project repository, you can't do a whole lot with the *newt tool. So you'll have to wait till you have downloaded an app to try out the tool.", 
            "title": "4. Build the Newt tool"
        }, 
        {
            "location": "/newt/tutorials/define_target/", 
            "text": "How to Define a Target\n\n\nWhat newt commands to use?", 
            "title": "Define a target"
        }, 
        {
            "location": "/newt/tutorials/define_target/#how-to-define-a-target", 
            "text": "What newt commands to use?", 
            "title": "How to Define a Target"
        }, 
        {
            "location": "/newt/newt_ops/", 
            "text": "Command Structure\n\n\nJust like verbs are actions in a sentence and adverdbs modifiy verbs, so in \nnewt\n tool, commands are actions and flags modify actions. A command can have subcommands, too. Arguments to commands and subcommands, with appropriate flags, will dictate the execution and result of a command. \n\n\nFor instance, in the example below, the \nnewt\n command has the subcommand \ntarget set\n in which the argument 'my_target1' is the target whose attribute, \narch\n, is set to 'cortex_md.' \n\n\n    newt target set my_target1 arch=cortex_m4\n\n\n\n\n\nGlobal flags work uniformly across \nnewt\n commands. Consider the flag \n-v, --verbose,\n It works both for command and subcommands, to generate verbose output. Likewise, the help flag \n-h\n or  \n--help,\n  to print helpful messsages.\n\n\nA command may additionally take flags specific to it. For example, the \n-b\n flag instructs \nnewt pkg install\n to install the pkg from a git \nbranch.\n\n\n    newt pkg install -b \nbranchname\n \neggname\n\n\n\n\n\n\nIn addition to the \nNewt Tool Manual\n in docs, command-line help is available for each command (and subcommand), through the \n-h\n or \n--help\n options. \n\n\n    $ newt target export --help\n    Export build targets from the current nest, and print them to \n    standard output. If the -a (or -export-all) option is specified, \n    then all targets will be exported. Otherwise, \ntarget-name\n \n    must be specified, and only that target will be exported.\n\n    Usage: \n      newt target export [flags]\n\n    Examples:\n      newt target export [-a -export-all] [\ntarget-name\n]\n      newt target export -a \n my_exports.txt\n      newt target export my_target \n my_target_export.txt\n\n    Flags:\n      -a, --export-all=false: If present, export all targets\n      -h, --help=false: help for export\n\n    Global Flags:\n      -l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n      -q, --quiet=false: Be quiet; only display error output.\n      -s, --silent=false: Be silent; don\nt output anything.\n      -v, --verbose=false: Enable verbose output when executing commands.", 
            "title": "Command structure"
        }, 
        {
            "location": "/newt/newt_ops/#command-structure", 
            "text": "Just like verbs are actions in a sentence and adverdbs modifiy verbs, so in  newt  tool, commands are actions and flags modify actions. A command can have subcommands, too. Arguments to commands and subcommands, with appropriate flags, will dictate the execution and result of a command.   For instance, in the example below, the  newt  command has the subcommand  target set  in which the argument 'my_target1' is the target whose attribute,  arch , is set to 'cortex_md.'       newt target set my_target1 arch=cortex_m4  Global flags work uniformly across  newt  commands. Consider the flag  -v, --verbose,  It works both for command and subcommands, to generate verbose output. Likewise, the help flag  -h  or   --help,   to print helpful messsages.  A command may additionally take flags specific to it. For example, the  -b  flag instructs  newt pkg install  to install the pkg from a git  branch.      newt pkg install -b  branchname   eggname   In addition to the  Newt Tool Manual  in docs, command-line help is available for each command (and subcommand), through the  -h  or  --help  options.       $ newt target export --help\n    Export build targets from the current nest, and print them to \n    standard output. If the -a (or -export-all) option is specified, \n    then all targets will be exported. Otherwise,  target-name  \n    must be specified, and only that target will be exported.\n\n    Usage: \n      newt target export [flags]\n\n    Examples:\n      newt target export [-a -export-all] [ target-name ]\n      newt target export -a   my_exports.txt\n      newt target export my_target   my_target_export.txt\n\n    Flags:\n      -a, --export-all=false: If present, export all targets\n      -h, --help=false: help for export\n\n    Global Flags:\n      -l, --loglevel= WARN : Log level, defaults to WARN.\n      -q, --quiet=false: Be quiet; only display error output.\n      -s, --silent=false: Be silent; don t output anything.\n      -v, --verbose=false: Enable verbose output when executing commands.", 
            "title": "Command Structure"
        }, 
        {
            "location": "/newt/command_list/newt_app/", 
            "text": "newt app \n\n\nUsage:\n\n\n    newt app [command][flags] input1 input2...\n\n\n\n\n\nAvailable commands:\n\n\n    generate-pkg-list Generate a pkg-list file from the pkgs in the current directory\n    add-pkg-list      Add a remote pkg-list, and put it in the current app\n    list-pkg-listes   List the pkg-listes installed in the current app\n    show-pkg-list     Show an individual pkg-list in the current app\n\n\n\n\n\nFlags:\n\n\n    -h, --help=false: help for app\n\n\n\n\n\nGlobal Flags:\n\n\n    -h, --help=false: help for newt\n    -l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n    -q, --quiet=false: Be quiet; only display error output.\n    -s, --silent=false: Be silent; don\nt output anything.\n    -v, --verbose=false: Enable verbose output when executing commands.\n\n\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSub-command\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\ngenerate-pkg-list\n\n\nTakes a snapshot of the pkgs in the current local directory and combines them into a pkg-list by the name of \ninput1\n and with the url of \ninput2\n and generates a standard output of the pkg-list details that can be redirected to a \n.yml\n pkg-list file. Typically the pkg-list file name is chosen to match the pkg-list name which means the standard output should be directed to a pkg-list file named \ninput1.yml\n\n\n\n\n\n\nadd-pkg-list\n\n\nDownloads the pkg-list of the name \ninput1\n from the master branch of the github repository \ninput2\n into the current app. A file named \ninput1.yml\n file is added in the \n.app/pkg-lists\n subdirectory inside the current local app. The \n.app/\n directory structure is created automatically if it does not exist.\n\n\n\n\n\n\nlist-pkg-lists\n\n\nLists all the pkg-lists present in the current app, including pkg-lists that may have been added from other apps on github. The output shows all the remote pkg-list names and the total pkgshells in each of the pkg-lists.\n\n\n\n\n\n\nshow-pkg-list\n\n\nShows information about the pkg-list that has the name given in the \ninput1\n argument. Output includes the pkg-list name, url, and all the constituent pkgs with their version numbers.\n\n\n\n\n\n\n\n\nCommand-specific flags\n\n\n\n\n\n\n\n\nSub-command\n\n\nAvailable flags\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nadd-pkg-list\n\n\n-b, --branch=\"\n\"\n\n\nFetches the pkg-list file with name \ninput1\n from the specified branch at \ninput1\n url of the github repository. All subsequent pkg installations will be done from that branch.\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\ngenerate-pkg-list\n\n\nnewt app generate-pkg-list mypkg-list https://github.com/apache/incubator-mynewt-larva \n mypkg-list.yml\n\n\nTakes a snapshot of the pkgs in the current app to form a pkg-list named mypkg-list with the url https://github.com/apache/incubator-mynewt-larva. The output is written to a file named \nmypkg-list.yml\n and describes the properties and contents of the pkg-list (name, url, pkgs).\n\n\n\n\n\n\nadd-pkg-list\n\n\nnewt app add-pkg-list larva https://github.com/apache/incubator-mynewt-larva\n\n\nAdds the remote pkg-list named larva at https://github.com/apache/incubator-mynewt-larva to the local app.\n\n\n\n\n\n\nlist-pkg-lists\n\n\nnewt app list-pkg-lists\n\n\nShows all the remote pkg-list description files that been downloaded into the current app. Output includes each list with name and summary of included packages e.g. \nRemote package list larva@master (num_pkgs: 44)\n\n\n\n\n\n\nshow-pkg-list\n\n\nnewt app show-pkg-list larva\n\n\nOutputs the details of the pkg-list named larva such as the github url where the remote sits, the constituent pkgs and their versions", 
            "title": "newt app"
        }, 
        {
            "location": "/newt/command_list/newt_app/#newt-app", 
            "text": "", 
            "title": "newt app "
        }, 
        {
            "location": "/newt/command_list/newt_app/#usage", 
            "text": "newt app [command][flags] input1 input2...", 
            "title": "Usage:"
        }, 
        {
            "location": "/newt/command_list/newt_app/#available-commands", 
            "text": "generate-pkg-list Generate a pkg-list file from the pkgs in the current directory\n    add-pkg-list      Add a remote pkg-list, and put it in the current app\n    list-pkg-listes   List the pkg-listes installed in the current app\n    show-pkg-list     Show an individual pkg-list in the current app", 
            "title": "Available commands:"
        }, 
        {
            "location": "/newt/command_list/newt_app/#flags", 
            "text": "-h, --help=false: help for app", 
            "title": "Flags:"
        }, 
        {
            "location": "/newt/command_list/newt_app/#global-flags", 
            "text": "-h, --help=false: help for newt\n    -l, --loglevel= WARN : Log level, defaults to WARN.\n    -q, --quiet=false: Be quiet; only display error output.\n    -s, --silent=false: Be silent; don t output anything.\n    -v, --verbose=false: Enable verbose output when executing commands.", 
            "title": "Global Flags:"
        }, 
        {
            "location": "/newt/command_list/newt_app/#description", 
            "text": "Sub-command  Explanation      generate-pkg-list  Takes a snapshot of the pkgs in the current local directory and combines them into a pkg-list by the name of  input1  and with the url of  input2  and generates a standard output of the pkg-list details that can be redirected to a  .yml  pkg-list file. Typically the pkg-list file name is chosen to match the pkg-list name which means the standard output should be directed to a pkg-list file named  input1.yml    add-pkg-list  Downloads the pkg-list of the name  input1  from the master branch of the github repository  input2  into the current app. A file named  input1.yml  file is added in the  .app/pkg-lists  subdirectory inside the current local app. The  .app/  directory structure is created automatically if it does not exist.    list-pkg-lists  Lists all the pkg-lists present in the current app, including pkg-lists that may have been added from other apps on github. The output shows all the remote pkg-list names and the total pkgshells in each of the pkg-lists.    show-pkg-list  Shows information about the pkg-list that has the name given in the  input1  argument. Output includes the pkg-list name, url, and all the constituent pkgs with their version numbers.", 
            "title": "Description"
        }, 
        {
            "location": "/newt/command_list/newt_app/#command-specific-flags", 
            "text": "Sub-command  Available flags  Explanation      add-pkg-list  -b, --branch=\" \"  Fetches the pkg-list file with name  input1  from the specified branch at  input1  url of the github repository. All subsequent pkg installations will be done from that branch.", 
            "title": "Command-specific flags"
        }, 
        {
            "location": "/newt/command_list/newt_app/#examples", 
            "text": "Sub-command  Usage  Explanation      generate-pkg-list  newt app generate-pkg-list mypkg-list https://github.com/apache/incubator-mynewt-larva   mypkg-list.yml  Takes a snapshot of the pkgs in the current app to form a pkg-list named mypkg-list with the url https://github.com/apache/incubator-mynewt-larva. The output is written to a file named  mypkg-list.yml  and describes the properties and contents of the pkg-list (name, url, pkgs).    add-pkg-list  newt app add-pkg-list larva https://github.com/apache/incubator-mynewt-larva  Adds the remote pkg-list named larva at https://github.com/apache/incubator-mynewt-larva to the local app.    list-pkg-lists  newt app list-pkg-lists  Shows all the remote pkg-list description files that been downloaded into the current app. Output includes each list with name and summary of included packages e.g.  Remote package list larva@master (num_pkgs: 44)    show-pkg-list  newt app show-pkg-list larva  Outputs the details of the pkg-list named larva such as the github url where the remote sits, the constituent pkgs and their versions", 
            "title": "Examples"
        }, 
        {
            "location": "/newt/command_list/newt_help/", 
            "text": "newt help \n\n\nUsage:\n\n\n    newt help [input1]\n\n\n\n\n\nFlags:\n\n\n-h, --help=false: help for newt\n-l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don\nt output anything.\n-v, --verbose=false: Enable verbose output when executing commands.\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nhelp\n\n\nnewt help target\n\n\nDisplays the help text for the newt command 'target'\n\n\n\n\n\n\nhelp\n\n\nnewt help\n\n\nDisplays the help text for newt tool", 
            "title": "newt help"
        }, 
        {
            "location": "/newt/command_list/newt_help/#newt-help", 
            "text": "", 
            "title": "newt help "
        }, 
        {
            "location": "/newt/command_list/newt_help/#usage", 
            "text": "newt help [input1]", 
            "title": "Usage:"
        }, 
        {
            "location": "/newt/command_list/newt_help/#flags", 
            "text": "-h, --help=false: help for newt\n-l, --loglevel= WARN : Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don t output anything.\n-v, --verbose=false: Enable verbose output when executing commands.", 
            "title": "Flags:"
        }, 
        {
            "location": "/newt/command_list/newt_help/#examples", 
            "text": "Sub-command  Usage  Explanation      help  newt help target  Displays the help text for the newt command 'target'    help  newt help  Displays the help text for newt tool", 
            "title": "Examples"
        }, 
        {
            "location": "/newt/command_list/newt_new/", 
            "text": "newt new \n\n\nCreate a new application, specified by \n, from a given skeleton. If the optional \n parameter is specified, then download the skeleton of the application from \nthat URL instead of using the default, and create a new app directory by the name of \n. Currently, the default skeleton is the \ntadpole repository\n in Apache Mynewt. \n\n\nUsage:\n\n\n    newt new [flags] \napp-name\n [, \napp-url\n]\n\n\n\n\n\nFlags:\n\n\n    -h, --help=false: help for app\n\n\n\n\n\nGlobal Flags:\n\n\n    -h, --help=false: help for newt\n    -l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n    -q, --quiet=false: Be quiet; only display error output.\n    -s, --silent=false: Be silent; don\nt output anything.\n    -v, --verbose=false: Enable verbose output when executing commands.\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nnewt new\n\n\nnewt new test_project\n\n\nCreates a new app named \"test_project \" using the default skeleton\n\n\n\n\n\n\n\n\nnewt new myapp \n\n\nCreates a new app named \"myapp\" using the skeleton at the \n specified", 
            "title": "newt new"
        }, 
        {
            "location": "/newt/command_list/newt_new/#newt-new", 
            "text": "Create a new application, specified by  , from a given skeleton. If the optional   parameter is specified, then download the skeleton of the application from \nthat URL instead of using the default, and create a new app directory by the name of  . Currently, the default skeleton is the  tadpole repository  in Apache Mynewt.", 
            "title": "newt new "
        }, 
        {
            "location": "/newt/command_list/newt_new/#usage", 
            "text": "newt new [flags]  app-name  [,  app-url ]", 
            "title": "Usage:"
        }, 
        {
            "location": "/newt/command_list/newt_new/#flags", 
            "text": "-h, --help=false: help for app", 
            "title": "Flags:"
        }, 
        {
            "location": "/newt/command_list/newt_new/#global-flags", 
            "text": "-h, --help=false: help for newt\n    -l, --loglevel= WARN : Log level, defaults to WARN.\n    -q, --quiet=false: Be quiet; only display error output.\n    -s, --silent=false: Be silent; don t output anything.\n    -v, --verbose=false: Enable verbose output when executing commands.", 
            "title": "Global Flags:"
        }, 
        {
            "location": "/newt/command_list/newt_new/#examples", 
            "text": "Sub-command  Usage  Explanation      newt new  newt new test_project  Creates a new app named \"test_project \" using the default skeleton     newt new myapp   Creates a new app named \"myapp\" using the skeleton at the   specified", 
            "title": "Examples"
        }, 
        {
            "location": "/newt/command_list/newt_pkg/", 
            "text": "newt pkg \n\n\nProvides sub-commands to search, display and install packages in your current application or workspace.\n\n\nUsage:\n\n\n    newt pkg [command][flag] input1 input2\n\n\n\n\n\nAvailable Commands:\n\n\n    list        List pkgs in the current app\n    checkdeps   Check pkg dependencies\n    hunt        Search for pkg from pkg-lists\n    show        Show the contents of a pkg.\n    install     Install a pkg\n    remove      Remove a pkg\n\n\n\n\n\nFlags:\n\n\n    -h, --help=false: help for pkg\n\n#### Global Flags:\n\n    -l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n    -q, --quiet=false: Be quiet; only display error output.\n    -s, --silent=false: Be silent; don\nt output anything.\n    -v, --verbose=false: Enable verbose output when executing commands.\n\n\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSub-command\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nlist\n\n\nList all the pkgs in the current app. The output shows the name, version, path, and any additional attributes of each pkg in the app such as dependencies, capabilities, and linker scripts. The newt command gets the attributes of each pkg from the corresponsing pkg.yml description file.\n\n\n\n\n\n\ncheckdeps\n\n\nResolve all dependencies in the local app. This command goes through all pkgs currently installed, checks their dependencies, and prints any unresolved dependencies between pkgs.\n\n\n\n\n\n\nsearch\n\n\nSearches for a pkg, specified by \ninput1\n. The local app, along with all remote apps (pkg-lists) are searched. All matched pkgs are shown along with the pkg-list informaton. Installed pkgs are called out as such. The command can be invoked from anywhere in the app.\n\n\n\n\n\n\nshow\n\n\nShow the contents of the pkg named \ninput2\n found in the pkg-list named \ninput1\n. The pkg-list name is optional; if only the pkg name is given as the argument it is resolved using all the pkg-lists installed in the current app. If the pkg is present in multiple pkg-lists it will list all of them along with the pkg-list information for each.\n\n\n\n\n\n\ninstall\n\n\nInstall the pkg specified by \ninput2\n from the pkg-list named \ninput1\n. The command downloads the pkg from the github repository using the URL in the pkg-list description file (typically downloaded as 'input1@\n.yml' in .app/pkg-lists). It also downloads all the dependencies (constituent pkgs) as decribed in the pkg's description file ('pkg.yml') and installs all of them. The pkg-list name is optional. If only the pkg name is given as the argument, the command looks for the pkg name in all the pkg-lists in the local app and installs accordingly. A pkg is installed by this command only if it has not already been installed.\n\n\n\n\n\n\nremove\n\n\nRemove a pkg named \ninput2\n from pkg-list \ninput1\n, if pkg-list is specified. Otherwise only one input required - that of the name of the pkg to be removed from the local app.\n\n\n\n\n\n\n\n\nCommand-specific flags\n\n\n\n\n\n\n\n\nSub-command\n\n\nAvailable flags\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\ninstall\n\n\n-b, --branch=\"\n\"\n\n\nInstalls the pkgs from the branch name or tag of the pkg-list specified\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nlist\n\n\nnewt pkg list\n\n\nCList all of the pkgs in the current app and the details of the pkgs.\n\n\n\n\n\n\ncheckdeps\n\n\nnewt pkg checkdeps\n\n\nChecks all the dependencies between pkgs in the app. Lists any unresolved dependencies.\n\n\n\n\n\n\nhunt\n\n\nnewt pkg hunt blinky\n\n\nHunts for the pkg named 'blinky'. The command can be invoked from anywhere in the app. Results show if the pkg is installed and which pkg-list, if any, has the pkg.\n\n\n\n\n\n\nshow\n\n\nnewt pkg show larva libs/os\n\n\nShow the contents of the pkg named 'libs/os' in the pkg-list named larva. The contents are essentially derived from the pkg's 'pkg.yml' file.\n\n\n\n\n\n\ninstall\n\n\nnewt pkg install hw/bsp/stm32f3discovery\n\n\nDownloads and installs the pkg named \"stm32f3discovery\" (specified with its full path name inside the remote app) along with all its dependencies from the remote app on github. Since no pkg-list is specified, the URL for the remote app in the pkg-list description file found in the local app (in .app/pkg-lists for the project) is used.\n\n\n\n\n\n\nremove\n\n\nnewt pkg remove larva blinky\n\n\nRemoves the pkg named blinky only from the pkg-list named larva\n\n\n\n\n\n\nremove\n\n\nnewt pkg remove blinky\n\n\nRemoves the pkg named blinky from the local app", 
            "title": "newt pkg"
        }, 
        {
            "location": "/newt/command_list/newt_pkg/#newt-pkg", 
            "text": "Provides sub-commands to search, display and install packages in your current application or workspace.", 
            "title": "newt pkg "
        }, 
        {
            "location": "/newt/command_list/newt_pkg/#usage", 
            "text": "newt pkg [command][flag] input1 input2", 
            "title": "Usage:"
        }, 
        {
            "location": "/newt/command_list/newt_pkg/#available-commands", 
            "text": "list        List pkgs in the current app\n    checkdeps   Check pkg dependencies\n    hunt        Search for pkg from pkg-lists\n    show        Show the contents of a pkg.\n    install     Install a pkg\n    remove      Remove a pkg", 
            "title": "Available Commands:"
        }, 
        {
            "location": "/newt/command_list/newt_pkg/#flags", 
            "text": "-h, --help=false: help for pkg\n\n#### Global Flags:\n\n    -l, --loglevel= WARN : Log level, defaults to WARN.\n    -q, --quiet=false: Be quiet; only display error output.\n    -s, --silent=false: Be silent; don t output anything.\n    -v, --verbose=false: Enable verbose output when executing commands.", 
            "title": "Flags:"
        }, 
        {
            "location": "/newt/command_list/newt_pkg/#description", 
            "text": "Sub-command  Explanation      list  List all the pkgs in the current app. The output shows the name, version, path, and any additional attributes of each pkg in the app such as dependencies, capabilities, and linker scripts. The newt command gets the attributes of each pkg from the corresponsing pkg.yml description file.    checkdeps  Resolve all dependencies in the local app. This command goes through all pkgs currently installed, checks their dependencies, and prints any unresolved dependencies between pkgs.    search  Searches for a pkg, specified by  input1 . The local app, along with all remote apps (pkg-lists) are searched. All matched pkgs are shown along with the pkg-list informaton. Installed pkgs are called out as such. The command can be invoked from anywhere in the app.    show  Show the contents of the pkg named  input2  found in the pkg-list named  input1 . The pkg-list name is optional; if only the pkg name is given as the argument it is resolved using all the pkg-lists installed in the current app. If the pkg is present in multiple pkg-lists it will list all of them along with the pkg-list information for each.    install  Install the pkg specified by  input2  from the pkg-list named  input1 . The command downloads the pkg from the github repository using the URL in the pkg-list description file (typically downloaded as 'input1@ .yml' in .app/pkg-lists). It also downloads all the dependencies (constituent pkgs) as decribed in the pkg's description file ('pkg.yml') and installs all of them. The pkg-list name is optional. If only the pkg name is given as the argument, the command looks for the pkg name in all the pkg-lists in the local app and installs accordingly. A pkg is installed by this command only if it has not already been installed.    remove  Remove a pkg named  input2  from pkg-list  input1 , if pkg-list is specified. Otherwise only one input required - that of the name of the pkg to be removed from the local app.", 
            "title": "Description"
        }, 
        {
            "location": "/newt/command_list/newt_pkg/#command-specific-flags", 
            "text": "Sub-command  Available flags  Explanation      install  -b, --branch=\" \"  Installs the pkgs from the branch name or tag of the pkg-list specified", 
            "title": "Command-specific flags"
        }, 
        {
            "location": "/newt/command_list/newt_pkg/#examples", 
            "text": "Sub-command  Usage  Explanation      list  newt pkg list  CList all of the pkgs in the current app and the details of the pkgs.    checkdeps  newt pkg checkdeps  Checks all the dependencies between pkgs in the app. Lists any unresolved dependencies.    hunt  newt pkg hunt blinky  Hunts for the pkg named 'blinky'. The command can be invoked from anywhere in the app. Results show if the pkg is installed and which pkg-list, if any, has the pkg.    show  newt pkg show larva libs/os  Show the contents of the pkg named 'libs/os' in the pkg-list named larva. The contents are essentially derived from the pkg's 'pkg.yml' file.    install  newt pkg install hw/bsp/stm32f3discovery  Downloads and installs the pkg named \"stm32f3discovery\" (specified with its full path name inside the remote app) along with all its dependencies from the remote app on github. Since no pkg-list is specified, the URL for the remote app in the pkg-list description file found in the local app (in .app/pkg-lists for the project) is used.    remove  newt pkg remove larva blinky  Removes the pkg named blinky only from the pkg-list named larva    remove  newt pkg remove blinky  Removes the pkg named blinky from the local app", 
            "title": "Examples"
        }, 
        {
            "location": "/newt/command_list/newt_target/", 
            "text": "newt target \n\n\nProvides commands to create, build, delete, and query targets. \n\n\nUsage:\n\n\n    newt target [command] input1 [flag1] [flag2]\n\n\n\n\n\nAvailable Commands:\n\n\n    set         Set target configuration variable\n    unset       Unset target configuration variable\n    delete      Delete target\n    create      Create a target\n    show        View target configuration variables\n    build       Build target\n    test        Test target\n    size        Size of the target\n    label       Add image header to target binary\n    download    Download project to target\n    debug       Open debugger session to target\n    export      Export target\n    import      Import target\n\n\n\n\n\nFlags:\n\n\n    -h, --help=false: help for target\n\n\n\n\n\nGlobal Flags:\n\n\n    -l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n    -q, --quiet=false: Be quiet; only display error output.\n    -s, --silent=false: Be silent; don\nt output anything.\n    -v, --verbose=false: Enable verbose output when executing commands.\n\n\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSub-command\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nset\n\n\nSet attributes (variables) of the target. Currently the list of possible attributes (variables) are:\narch, compiler, compiler_def, project, bsp, pkg, identities, capabilities, dependencies, cflags, lflags\n. Typically only the first 5 need to be set for a hardware target. For a simulated target, e.g. for software testing purposes, \narch=sim\n, \ncompiler=sim\n, and \npkg=\npkg name to be tested\n. You cannot set both the project and pkg for a target.\n\n\n\n\n\n\n\n\nTo display all the existing values for any target attribute (variable), you can simply hit return after that variable. For example, \nnewt target set target1 arch\n displays the valid values available for the attribute \narch\n for a target named \ntarget1\n.\n\n\n\n\n\n\nunset\n\n\nUnset attributes of the target in its configuration.\n\n\n\n\n\n\ndelete\n\n\nDeletes only the description for the target. Does not delete the target directory with associated binaries. If you want to clean out the binaries, list files, and executables use\nnewt target build \ntarget-name\n clean\n \nbefore\n deleting the target!\n\n\n\n\n\n\ncreate\n\n\nCreates a target description or build definition by the name \ninput1\n. By default it assigns the sim (simulator) architecture to it which allows you to build new projects and software on your native OS and try it out.\n\n\n\n\n\n\nshow\n\n\nDisplay the configuration defined for the target named \ninput1\n. If no \ninput1\n is specified then show the details for all the targets in the app.\n\n\n\n\n\n\nbuild\n\n\nBuild the source code into an image that can be loaded on the hardware associated with the target named \ninput1\n to do the application enabled by the 'project' associated with that target (via the target definition). It creates 'bin/' and 'bin/\n/' subdirectories inside the base directory for the project, compiles and generates binaries and executables, and places them in 'bin/\n/.\n\n\n\n\n\n\ntest\n\n\nTest a pkg on the target named \ninput1\n. The pkg is either supplied as an argument to the command line invocation of \nnewt target test\n or added as part of the target definition. If only the target is specified as \ninput1\n, then the pkg in the target's definition is automatically chosen to be tested. You currently cannot test an entire project on a hardware target. The test command is envisioned for use if one or two pkgs gets updated and each needs to be tested against a target. Alternatively, a script may be written for a series of tests on several pkgs.\n\n\n\n\n\n\nsize\n\n\nDisplays the memory used (in bytes) by the component libraries that have been compiled and linked to form the executable for the specified target build (input1). The memory usage of the different components is shown by each memory type available in the bsp (board support package) used in the target e.g. RAM, flash, CCM etc.\n\n\n\n\n\n\nlabel\n\n\nAppends an image header to the created binary file for the target named \ninput1\n. Version number in the header is set to the value given as \n[flag1]\n. The manifest.json file in the directory with the binaries (project/\n/bin/\n) reflects the version number. A manifest.json file is created if none exists for the target.\n\n\n\n\n\n\nexport\n\n\nExports the configurations of the specified target \ninput1\n. If -a or -export-all flag is used, then all targets are exported and printed out to standard out. You may redirect the output to a file.\n\n\n\n\n\n\nimport\n\n\nImport one or more target configuration from standard input or a file. Each target starts with \n@target=\ntarget-name\n followed by the attributes. The list of targets should end with \n@endtargets\n.\n\n\n\n\n\n\ndownload\n\n\nDownloads the binary executable \ntarget-name\n.elf.bin\n to the board.\n\n\n\n\n\n\ndebug\n\n\nDownloads the binary executable \ntarget-name\n.elf.bin\n to the board and starts up the openocd/gdb combination session. gdb takes over the terminal.\n\n\n\n\n\n\n\n\nCommand-specific flags\n\n\n\n\n\n\n\n\nSub-command\n\n\nAvailable flags\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nbuild\n\n\nclean\n\n\nAll the binaries and object files for the specified target will be removed. The subdirectory named after the specified target within that project is removed.\n\n\n\n\n\n\nbuild clean\n\n\nall\n\n\nAll the binaries and object files for all targets are removed, and subdirectories of all targets for the project are removed. However, the entire repository is not emptied since any pkgs or projects that the specified target doesn't reference are not touched.\n\n\n\n\n\n\nexport\n\n\n-a, -export-all\n\n\nExport all targets. \ninput1\n is not necessary when this flag is used.\n\n\n\n\n\n\nimport\n\n\n-a, -import-all\n\n\nImport all targets typed into standard input or redirected from a file.\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nset\n\n\nnewt target set myblinky compiler=arm-none-eabi-m4\n\n\nSet the compiler for the 'myblinky' target to the gcc compiler for embedded ARM chips.\n\n\n\n\n\n\nset\n\n\nnewt target set myblinky compiler\n\n\nLists the valid values currently available to be assigned for target attribute (variable) 'compiler'. For example, arm-none-eabi-m0, arm-none-eabi-m4, sim. As Mynewt grows, the number of possible values will grow.\n\n\n\n\n\n\nunset\n\n\nnewt target unset myblinky compiler\n\n\nRemove the setting for the compiler for the 'myblinky' target.\n\n\n\n\n\n\ndelete\n\n\nnewt target delete myblinky\n\n\nDelete the target description for the target named 'myblinky'. Note that it does not remove any binaries or clean out the directory for this target.\n\n\n\n\n\n\ncreate\n\n\nnewt target create blink_f3disc\n\n\nCreate a new target description by the name 'blink_f3disc'. The architecture is 'sim' by default and can be changed using subcommand 'set' above.\n\n\n\n\n\n\nshow\n\n\nnewt target show myblinky\n\n\nShow the target attributes set for 'myblinky'\n\n\n\n\n\n\nbuild\n\n\nnewt target build blink_f3disc\n\n\nCompile the source code for the target named blink_f3disc and generate binaries that can be loaded into the target hardware.\n\n\n\n\n\n\ntest\n\n\nnewt target test test_target pkg=libs/os\n\n\nTests the pkg named 'libs/os' against the target named 'test_target'\n\n\n\n\n\n\nsize\n\n\nnewt target size -v boot_olimex\n\n\nDisplays the memory footprint in bytes for all object and linked files for the target named boot_olimex. The -v option shows all the steps of loading and inspecting the different pkgs required for the project on this target as well as the different memory locations available. The memory usage for each component is broken up into the different memory types used. An example output is shown for \nnewt target size boot_olimex\n below.\n\n\n\n\n\n\nlabel\n\n\nnewt target label boot_olimex 2.0.1\n\n\nAppends an image header specifying the version number as 2.0.1 to the binary image file for target named boot_olimex. The version number in the manifest.json file for this target is also updated to 2.0.1.\n\n\n\n\n\n\nexport\n\n\nnewt target export -a \n my_exports.txt\n\n\nExport all build targets from the current app, and redirect output to a file named 'my_exports.txt'.\n\n\n\n\n\n\nexport\n\n\nnewt target export -export-all\n\n\nExport all build targets from the current app, and print them to standard output on the screen.\n\n\n\n\n\n\nexport\n\n\nnewt target export my_target\n\n\nExport only target named 'my_target' and print it to standard output on the screen.\n\n\n\n\n\n\nimport\n\n\nnewt target import ex_tgt_1 \n exported_targets.txt\n\n\nImports the target configuration for 'ex_tgt_1' in 'exported_targets.txt'.\n\n\n\n\n\n\nimport\n\n\nnewt target import -a \n in_targets.txt\n\n\nImports all the targets specified in the file named \nin_targets.txt\n. A sample file is shown after this table.\n\n\n\n\n\n\nimport\n\n\nnewt target import test3\n\n\nAwaits all the configuration variables for a target named 'test3'. This allows you to define all the attributes in one shot e.g. by cutting and pasting the contents of \nin_targets.txt\n file shown at the bottom of this page.\n\n\n\n\n\n\nsize\n\n\nnewt target size blink_nordic\n\n\nInspects and lists the RAM and Flash memory use by each component (object files and libraries) of the target.\n\n\n\n\n\n\ndownload\n\n\nnewt target -v -lVERBOSE download blinky\n\n\nDownloads \nblinky.elf.bin\n to the hardware in verbose mode with logging turned on at VERBOSE level.\n\n\n\n\n\n\ndebug\n\n\nnewt target debug blinky\n\n\nDownloads \nblinky.elf.bin\n to the hardware, opens up a gdb session with \nblinky.elf\n in the terminal, and halts for further input in gdb.\n\n\n\n\n\n\n\n\nExample output for \nnewt target size boot_olimex\n:\n\n\n$ newt target size boot_olimex\nInspecting target boot_olimex (project = boot)\n  FLASH     CCM     RAM \n     13       0       3 *fill*\n    239       0       0 boot.o\n    124       0       0 crt0.o\n     84       0      40 crtbegin.o\n      4       0       4 crtend.o\n      8       0       0 crti.o\n     16       0       0 crtn.o\n   1396       0      50 libbaselibc.a\n   2054       0    1104 libbootutil.a\n     84       0       0 libcmsis-core.a\n    266       0       4 libfs.a\n     80       0       0 libg.a\n   1452       0       0 libgcc.a\n    940       0       8 libhal.a\n  12130       0     538 libnffs.a\n   1172    3072      68 libolimex_stm32-e407_devboard.a\n   3654       0     645 libos.a\n   1504       0      32 libstm32f4xx.a\n\n\n\n\n\nExample content for \nin_targets.txt\n file used for importing targets \ntest3\n and \ntest4\n.\n\n\n\n\n@target=test3\n\nproject=blinked\n\narch=sim\n\ncompiler_def=debug\n\ncompiler=arm-none-eabi-m4\n\n@target=test4\n\nproject=super_blinky\n\narch=sim\n\ncompiler_def=debug\n\ncompiler=arm-none-eabi-m4\n\n@endtargets", 
            "title": "newt target"
        }, 
        {
            "location": "/newt/command_list/newt_target/#newt-target", 
            "text": "Provides commands to create, build, delete, and query targets.", 
            "title": "newt target "
        }, 
        {
            "location": "/newt/command_list/newt_target/#usage", 
            "text": "newt target [command] input1 [flag1] [flag2]", 
            "title": "Usage:"
        }, 
        {
            "location": "/newt/command_list/newt_target/#available-commands", 
            "text": "set         Set target configuration variable\n    unset       Unset target configuration variable\n    delete      Delete target\n    create      Create a target\n    show        View target configuration variables\n    build       Build target\n    test        Test target\n    size        Size of the target\n    label       Add image header to target binary\n    download    Download project to target\n    debug       Open debugger session to target\n    export      Export target\n    import      Import target", 
            "title": "Available Commands:"
        }, 
        {
            "location": "/newt/command_list/newt_target/#flags", 
            "text": "-h, --help=false: help for target", 
            "title": "Flags:"
        }, 
        {
            "location": "/newt/command_list/newt_target/#global-flags", 
            "text": "-l, --loglevel= WARN : Log level, defaults to WARN.\n    -q, --quiet=false: Be quiet; only display error output.\n    -s, --silent=false: Be silent; don t output anything.\n    -v, --verbose=false: Enable verbose output when executing commands.", 
            "title": "Global Flags:"
        }, 
        {
            "location": "/newt/command_list/newt_target/#description", 
            "text": "Sub-command  Explanation      set  Set attributes (variables) of the target. Currently the list of possible attributes (variables) are: arch, compiler, compiler_def, project, bsp, pkg, identities, capabilities, dependencies, cflags, lflags . Typically only the first 5 need to be set for a hardware target. For a simulated target, e.g. for software testing purposes,  arch=sim ,  compiler=sim , and  pkg= pkg name to be tested . You cannot set both the project and pkg for a target.     To display all the existing values for any target attribute (variable), you can simply hit return after that variable. For example,  newt target set target1 arch  displays the valid values available for the attribute  arch  for a target named  target1 .    unset  Unset attributes of the target in its configuration.    delete  Deletes only the description for the target. Does not delete the target directory with associated binaries. If you want to clean out the binaries, list files, and executables use newt target build  target-name  clean   before  deleting the target!    create  Creates a target description or build definition by the name  input1 . By default it assigns the sim (simulator) architecture to it which allows you to build new projects and software on your native OS and try it out.    show  Display the configuration defined for the target named  input1 . If no  input1  is specified then show the details for all the targets in the app.    build  Build the source code into an image that can be loaded on the hardware associated with the target named  input1  to do the application enabled by the 'project' associated with that target (via the target definition). It creates 'bin/' and 'bin/ /' subdirectories inside the base directory for the project, compiles and generates binaries and executables, and places them in 'bin/ /.    test  Test a pkg on the target named  input1 . The pkg is either supplied as an argument to the command line invocation of  newt target test  or added as part of the target definition. If only the target is specified as  input1 , then the pkg in the target's definition is automatically chosen to be tested. You currently cannot test an entire project on a hardware target. The test command is envisioned for use if one or two pkgs gets updated and each needs to be tested against a target. Alternatively, a script may be written for a series of tests on several pkgs.    size  Displays the memory used (in bytes) by the component libraries that have been compiled and linked to form the executable for the specified target build (input1). The memory usage of the different components is shown by each memory type available in the bsp (board support package) used in the target e.g. RAM, flash, CCM etc.    label  Appends an image header to the created binary file for the target named  input1 . Version number in the header is set to the value given as  [flag1] . The manifest.json file in the directory with the binaries (project/ /bin/ ) reflects the version number. A manifest.json file is created if none exists for the target.    export  Exports the configurations of the specified target  input1 . If -a or -export-all flag is used, then all targets are exported and printed out to standard out. You may redirect the output to a file.    import  Import one or more target configuration from standard input or a file. Each target starts with  @target= target-name  followed by the attributes. The list of targets should end with  @endtargets .    download  Downloads the binary executable  target-name .elf.bin  to the board.    debug  Downloads the binary executable  target-name .elf.bin  to the board and starts up the openocd/gdb combination session. gdb takes over the terminal.", 
            "title": "Description"
        }, 
        {
            "location": "/newt/command_list/newt_target/#command-specific-flags", 
            "text": "Sub-command  Available flags  Explanation      build  clean  All the binaries and object files for the specified target will be removed. The subdirectory named after the specified target within that project is removed.    build clean  all  All the binaries and object files for all targets are removed, and subdirectories of all targets for the project are removed. However, the entire repository is not emptied since any pkgs or projects that the specified target doesn't reference are not touched.    export  -a, -export-all  Export all targets.  input1  is not necessary when this flag is used.    import  -a, -import-all  Import all targets typed into standard input or redirected from a file.", 
            "title": "Command-specific flags"
        }, 
        {
            "location": "/newt/command_list/newt_target/#examples", 
            "text": "Sub-command  Usage  Explanation      set  newt target set myblinky compiler=arm-none-eabi-m4  Set the compiler for the 'myblinky' target to the gcc compiler for embedded ARM chips.    set  newt target set myblinky compiler  Lists the valid values currently available to be assigned for target attribute (variable) 'compiler'. For example, arm-none-eabi-m0, arm-none-eabi-m4, sim. As Mynewt grows, the number of possible values will grow.    unset  newt target unset myblinky compiler  Remove the setting for the compiler for the 'myblinky' target.    delete  newt target delete myblinky  Delete the target description for the target named 'myblinky'. Note that it does not remove any binaries or clean out the directory for this target.    create  newt target create blink_f3disc  Create a new target description by the name 'blink_f3disc'. The architecture is 'sim' by default and can be changed using subcommand 'set' above.    show  newt target show myblinky  Show the target attributes set for 'myblinky'    build  newt target build blink_f3disc  Compile the source code for the target named blink_f3disc and generate binaries that can be loaded into the target hardware.    test  newt target test test_target pkg=libs/os  Tests the pkg named 'libs/os' against the target named 'test_target'    size  newt target size -v boot_olimex  Displays the memory footprint in bytes for all object and linked files for the target named boot_olimex. The -v option shows all the steps of loading and inspecting the different pkgs required for the project on this target as well as the different memory locations available. The memory usage for each component is broken up into the different memory types used. An example output is shown for  newt target size boot_olimex  below.    label  newt target label boot_olimex 2.0.1  Appends an image header specifying the version number as 2.0.1 to the binary image file for target named boot_olimex. The version number in the manifest.json file for this target is also updated to 2.0.1.    export  newt target export -a   my_exports.txt  Export all build targets from the current app, and redirect output to a file named 'my_exports.txt'.    export  newt target export -export-all  Export all build targets from the current app, and print them to standard output on the screen.    export  newt target export my_target  Export only target named 'my_target' and print it to standard output on the screen.    import  newt target import ex_tgt_1   exported_targets.txt  Imports the target configuration for 'ex_tgt_1' in 'exported_targets.txt'.    import  newt target import -a   in_targets.txt  Imports all the targets specified in the file named  in_targets.txt . A sample file is shown after this table.    import  newt target import test3  Awaits all the configuration variables for a target named 'test3'. This allows you to define all the attributes in one shot e.g. by cutting and pasting the contents of  in_targets.txt  file shown at the bottom of this page.    size  newt target size blink_nordic  Inspects and lists the RAM and Flash memory use by each component (object files and libraries) of the target.    download  newt target -v -lVERBOSE download blinky  Downloads  blinky.elf.bin  to the hardware in verbose mode with logging turned on at VERBOSE level.    debug  newt target debug blinky  Downloads  blinky.elf.bin  to the hardware, opens up a gdb session with  blinky.elf  in the terminal, and halts for further input in gdb.", 
            "title": "Examples"
        }, 
        {
            "location": "/newt/command_list/newt_target/#example-output-for-newt-target-size-boot_olimex", 
            "text": "$ newt target size boot_olimex\nInspecting target boot_olimex (project = boot)\n  FLASH     CCM     RAM \n     13       0       3 *fill*\n    239       0       0 boot.o\n    124       0       0 crt0.o\n     84       0      40 crtbegin.o\n      4       0       4 crtend.o\n      8       0       0 crti.o\n     16       0       0 crtn.o\n   1396       0      50 libbaselibc.a\n   2054       0    1104 libbootutil.a\n     84       0       0 libcmsis-core.a\n    266       0       4 libfs.a\n     80       0       0 libg.a\n   1452       0       0 libgcc.a\n    940       0       8 libhal.a\n  12130       0     538 libnffs.a\n   1172    3072      68 libolimex_stm32-e407_devboard.a\n   3654       0     645 libos.a\n   1504       0      32 libstm32f4xx.a", 
            "title": "Example output for newt target size boot_olimex:"
        }, 
        {
            "location": "/newt/command_list/newt_target/#example-content-for-in_targetstxt-file-used-for-importing-targets-test3-and-test4", 
            "text": "@target=test3 \nproject=blinked \narch=sim \ncompiler_def=debug \ncompiler=arm-none-eabi-m4 \n@target=test4 \nproject=super_blinky \narch=sim \ncompiler_def=debug \ncompiler=arm-none-eabi-m4 \n@endtargets", 
            "title": "Example content for in_targets.txt file used for importing targets test3 and test4."
        }, 
        {
            "location": "/newt/command_list/newt_version/", 
            "text": "newt version \n\n\nAllows you to query the version of newt installed in your application space.\n\n\nUsage:\n\n\n    newt version [flags]\n\n\n\n\n\nFlags:\n\n\n    -h, --help=false: help for version\n\n\n\n\n\nGlobal Flags:\n\n\n    -l, --loglevel string   Log level, defaults to WARN. (default \nWARN\n)\n    -q, --quiet             Be quiet; only display error output.\n    -s, --silent            Be silent; don\nt output anything.\n    -v, --verbose           Enable verbose output when executing commands.\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nversion\n\n\nnewt version\n\n\nDisplays the version of newt tool installed", 
            "title": "newt version"
        }, 
        {
            "location": "/newt/command_list/newt_version/#newt-version", 
            "text": "Allows you to query the version of newt installed in your application space.", 
            "title": "newt version "
        }, 
        {
            "location": "/newt/command_list/newt_version/#usage", 
            "text": "newt version [flags]", 
            "title": "Usage:"
        }, 
        {
            "location": "/newt/command_list/newt_version/#flags", 
            "text": "-h, --help=false: help for version", 
            "title": "Flags:"
        }, 
        {
            "location": "/newt/command_list/newt_version/#global-flags", 
            "text": "-l, --loglevel string   Log level, defaults to WARN. (default  WARN )\n    -q, --quiet             Be quiet; only display error output.\n    -s, --silent            Be silent; don t output anything.\n    -v, --verbose           Enable verbose output when executing commands.", 
            "title": "Global Flags:"
        }, 
        {
            "location": "/newt/command_list/newt_version/#examples", 
            "text": "Sub-command  Usage  Explanation      version  newt version  Displays the version of newt tool installed", 
            "title": "Examples"
        }, 
        {
            "location": "/newtmgr/overview/", 
            "text": "Newt Manager\n\n\nNewt Manager (newtmgr) is the application tool that enables a user to communicate with and manage remote instances of Mynewt OS. \n\n\nDescription\n\n\nCommand List\n\n\nAvailable high-level commands\n\n\n    help        Lists commands and flags available \n    conn        Manage newtmgr connection profiles\n    echo        Send data to remote endpoint using newtmgr, and receive data back\n    image       Manage images on remote instance\n    stat        Read statistics from a remote endpoint\n    taskstats   Read statistics from a remote endpoint\n    mpstats     Read statistics from a remote endpoint\n    config      Read or write config value on target\n\n\n\n\n\nAvailable Flags\n\n\n  -c, --connection string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nnewtmgr -caditi03 taskstats\n\n\n\n\n\n\n\n\n\n\n\n\nhelp\n\n\nUsage:\n\n\n    newtmgr help [input1]\n\n\n\n\n\nYou can also use \"newtmgr [command] --help\" to display the help text for a newtmgr command.\n\n\nFlags:\n\n\n  -c, --connection string      connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nAvailable Flags\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\ntaskstats\n\n\nnewtmgr -cprofile1 taskstats\n\n\nRun the taskstats subcommand on the device connected via the 'profile1' connection\n\n\n\n\n\n\n\n\nconn\n\n\nUsage:\n\n\n    newtmgr conn [flags]\n    newtmgr conn [command]\n\n\n\n\n\nAvailable commands: \n\n\n    add         Add a newtmgr connection profile\n    delete      Delete a newtmgr connection profile\n    show        Show newtmgr connection profiles\n\n\n\n\n\nFlags:\n\n\n  -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)\n\n\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSub-command\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nadd\n\n\nAdds a connection profile. A properly defined profile needs a name, a connection type, and the physical or virtual port to be used for communication.\n\n\n\n\n\n\ndelete\n\n\nDeletes a connection profile associated with the given name\n\n\n\n\n\n\nshow\n\n\nList the specified or all the connection profiles with the name, connection type, and the controlling terminal or port.\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nadd\n\n\nnewtmgr conn add myserial02 type=serial connstring=/dev/ttys002\n\n\nAdds a newtmgr connection profile for the serial port /dev/ttys002 and names it 'myserial02'\n\n\n\n\n\n\ndelete\n\n\nnewtmgr conn delete myserial02\n\n\nDeletes the connection profile named 'myserial02'\n\n\n\n\n\n\nshow\n\n\nnewtmgr conn show myserial01\n\n\nShows the details of the profile named 'myserial01'\n\n\n\n\n\n\nshow\n\n\nnewtmgr conn show\n\n\nShows all the current profiles defined\n\n\n\n\n\n\n\n\necho\n\n\nUsage:\n\n\n    newtmgr echo [flags] [text]\n\n\n\n\n\nThis command sends the text to the remote device at the other end of the connection specified with the -c flag and outputs the text when it gets a response from the device. If the device is not responding or if the connection profile is invalid it displays errors. \n\n\nFlags:\n\n\n  -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\necho\n\n\nnewtmgr echo -c profile01 hello\n\n\nSends the string 'hello' to the remote device over the connection profile 'profile01' and receives the string back and displays it.\n\n\n\n\n\n\n\n\nimage\n\n\nUsage:\n\n\n  newtmgr image [flags]\n  newtmgr image [command]\n\n\n\n\n\nAvailable commands: \n\n\n    list         Show target images\n    upload       Upload image to target\n    boot         Which image to boot\n    fileupload   Upload file to target\n    filedownload Download file from target\n\n\n\n\n\nFlags:\n\n\n  -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)\n\n\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSub-command\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nlist\n\n\nAdds a connection profile. A properly defined profile needs a name, a connection type, and the physical or virtual port to be used for communication.\n\n\n\n\n\n\nupload\n\n\nDeletes a connection profile associated with the given name\n\n\n\n\n\n\nboot\n\n\nSpecify the image to boot\n\n\n\n\n\n\nfileupload\n\n\nupload file to the remote target\n\n\n\n\n\n\nfiledownload\n\n\ndownload/retrieve file from remote target\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nlist\n\n\nnewtmgr list\n\n\n\n\n\n\n\n\nupload\n\n\nnewtmgr upload\n\n\n\n\n\n\n\n\nboot\n\n\nnewtmgr boot\n\n\n\n\n\n\n\n\nfileupload\n\n\nnewtmgr fileupload\n\n\n\n\n\n\n\n\nfiledownload\n\n\nnewtmgr filedownload\n\n\n\n\n\n\n\n\n\n\nstat\n\n\nUsage:\n\n\n  newtmgr stat [flags]\n  newtmgr stat [command]\n\n\n\n\n\nFlags:\n\n\n  -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nstat\n\n\nnewtmgr stat\n\n\n\n\n\n\n\n\n\n\ntaskstats\n\n\nUsage:\n\n\n  newtmgr taskstats [flags]\n  newtmgr taskstats [command]\n\n\n\n\n\nLists all the tasks running on the remote endpoint at the end of the specified connection and for each task lists statistics such as priority, task id, runtime (how long the task has been running in ms), context switch count, stack size allocated, actual stack usage, last sanity checkin, next sanity check-in. \n\n\nFlags:\n\n\n  -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nstat\n\n\nnewtmgr taskstats -c profile01\n\n\nLists all the tasks running on the remote device at the end of connection named 'profile01'\n\n\n\n\n\n\n\n\nExample output\n\n\n$ newtmgr  -c profile01 taskstats\nReturn Code = 0\n  idle (prio=255 tid=0 runtime=3299340 cswcnt=280342 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  os_sanity (prio=254 tid=1 runtime=0 cswcnt=3287 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  shell (prio=3 tid=2 runtime=0 cswcnt=165 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  uart_poller (prio=0 tid=3 runtime=0 cswcnt=279368 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  newtmgr (prio=4 tid=4 runtime=0 cswcnt=14 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  task1 (prio=1 tid=5 runtime=0 cswcnt=3287 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  task2 (prio=2 tid=6 runtime=0 cswcnt=3287 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)", 
            "title": "Introduction"
        }, 
        {
            "location": "/newtmgr/overview/#newt-manager", 
            "text": "Newt Manager (newtmgr) is the application tool that enables a user to communicate with and manage remote instances of Mynewt OS.", 
            "title": "Newt Manager"
        }, 
        {
            "location": "/newtmgr/overview/#description", 
            "text": "", 
            "title": "Description"
        }, 
        {
            "location": "/newtmgr/overview/#command-list", 
            "text": "", 
            "title": "Command List"
        }, 
        {
            "location": "/newtmgr/overview/#available-high-level-commands", 
            "text": "help        Lists commands and flags available \n    conn        Manage newtmgr connection profiles\n    echo        Send data to remote endpoint using newtmgr, and receive data back\n    image       Manage images on remote instance\n    stat        Read statistics from a remote endpoint\n    taskstats   Read statistics from a remote endpoint\n    mpstats     Read statistics from a remote endpoint\n    config      Read or write config value on target", 
            "title": "Available high-level commands"
        }, 
        {
            "location": "/newtmgr/overview/#available-flags", 
            "text": "-c, --connection string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)  Examples     Sub-command  Usage  Explanation      newtmgr -caditi03 taskstats", 
            "title": "Available Flags"
        }, 
        {
            "location": "/newtmgr/overview/#help", 
            "text": "", 
            "title": "help"
        }, 
        {
            "location": "/newtmgr/overview/#usage", 
            "text": "newtmgr help [input1]  You can also use \"newtmgr [command] --help\" to display the help text for a newtmgr command.  Flags:    -c, --connection string      connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)  Examples     Sub-command  Available Flags  Explanation      taskstats  newtmgr -cprofile1 taskstats  Run the taskstats subcommand on the device connected via the 'profile1' connection", 
            "title": "Usage:"
        }, 
        {
            "location": "/newtmgr/overview/#conn", 
            "text": "", 
            "title": "conn"
        }, 
        {
            "location": "/newtmgr/overview/#usage_1", 
            "text": "newtmgr conn [flags]\n    newtmgr conn [command]  Available commands:       add         Add a newtmgr connection profile\n    delete      Delete a newtmgr connection profile\n    show        Show newtmgr connection profiles  Flags:    -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)  Description     Sub-command  Explanation      add  Adds a connection profile. A properly defined profile needs a name, a connection type, and the physical or virtual port to be used for communication.    delete  Deletes a connection profile associated with the given name    show  List the specified or all the connection profiles with the name, connection type, and the controlling terminal or port.     Examples     Sub-command  Usage  Explanation      add  newtmgr conn add myserial02 type=serial connstring=/dev/ttys002  Adds a newtmgr connection profile for the serial port /dev/ttys002 and names it 'myserial02'    delete  newtmgr conn delete myserial02  Deletes the connection profile named 'myserial02'    show  newtmgr conn show myserial01  Shows the details of the profile named 'myserial01'    show  newtmgr conn show  Shows all the current profiles defined", 
            "title": "Usage:"
        }, 
        {
            "location": "/newtmgr/overview/#echo", 
            "text": "", 
            "title": "echo"
        }, 
        {
            "location": "/newtmgr/overview/#usage_2", 
            "text": "newtmgr echo [flags] [text]  This command sends the text to the remote device at the other end of the connection specified with the -c flag and outputs the text when it gets a response from the device. If the device is not responding or if the connection profile is invalid it displays errors.   Flags:    -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)  Examples     Sub-command  Usage  Explanation      echo  newtmgr echo -c profile01 hello  Sends the string 'hello' to the remote device over the connection profile 'profile01' and receives the string back and displays it.", 
            "title": "Usage:"
        }, 
        {
            "location": "/newtmgr/overview/#image", 
            "text": "", 
            "title": "image"
        }, 
        {
            "location": "/newtmgr/overview/#usage_3", 
            "text": "newtmgr image [flags]\n  newtmgr image [command]  Available commands:       list         Show target images\n    upload       Upload image to target\n    boot         Which image to boot\n    fileupload   Upload file to target\n    filedownload Download file from target  Flags:    -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)  Description     Sub-command  Explanation      list  Adds a connection profile. A properly defined profile needs a name, a connection type, and the physical or virtual port to be used for communication.    upload  Deletes a connection profile associated with the given name    boot  Specify the image to boot    fileupload  upload file to the remote target    filedownload  download/retrieve file from remote target     Examples     Sub-command  Usage  Explanation      list  newtmgr list     upload  newtmgr upload     boot  newtmgr boot     fileupload  newtmgr fileupload     filedownload  newtmgr filedownload", 
            "title": "Usage:"
        }, 
        {
            "location": "/newtmgr/overview/#stat", 
            "text": "", 
            "title": "stat"
        }, 
        {
            "location": "/newtmgr/overview/#usage_4", 
            "text": "newtmgr stat [flags]\n  newtmgr stat [command]  Flags:    -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)  Examples     Sub-command  Usage  Explanation      stat  newtmgr stat", 
            "title": "Usage:"
        }, 
        {
            "location": "/newtmgr/overview/#taskstats", 
            "text": "", 
            "title": "taskstats"
        }, 
        {
            "location": "/newtmgr/overview/#usage_5", 
            "text": "newtmgr taskstats [flags]\n  newtmgr taskstats [command]  Lists all the tasks running on the remote endpoint at the end of the specified connection and for each task lists statistics such as priority, task id, runtime (how long the task has been running in ms), context switch count, stack size allocated, actual stack usage, last sanity checkin, next sanity check-in.   Flags:    -c, --conn string       connection profile to use.\n  -l, --loglevel string   log level to use (default WARN.)  Examples     Sub-command  Usage  Explanation      stat  newtmgr taskstats -c profile01  Lists all the tasks running on the remote device at the end of connection named 'profile01'     Example output  $ newtmgr  -c profile01 taskstats\nReturn Code = 0\n  idle (prio=255 tid=0 runtime=3299340 cswcnt=280342 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  os_sanity (prio=254 tid=1 runtime=0 cswcnt=3287 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  shell (prio=3 tid=2 runtime=0 cswcnt=165 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  uart_poller (prio=0 tid=3 runtime=0 cswcnt=279368 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  newtmgr (prio=4 tid=4 runtime=0 cswcnt=14 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  task1 (prio=1 tid=5 runtime=0 cswcnt=3287 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)\n  task2 (prio=2 tid=6 runtime=0 cswcnt=3287 stksize=1024 stkusage=1000 last_checkin=0 next_checkin=0)", 
            "title": "Usage:"
        }, 
        {
            "location": "/newtmgr/installing/", 
            "text": "Installing Newtmgr\n\n\nThis page shows you how to install newtmgr from source code.\n\n\nInstall Go (golang)\n\n\nIf you have not already done so, install Go for your platform.  \n\n\nThe easiest way on a MAC is to use \nbrew\n.  \n\n\nbrew install go\n==\n Downloading https://homebrew.bintray.com/bottles/go-1.5.3.mavericks.bottle.t\n...\n==\n Summary\n\ud83c\udf7a  /usr/local/Cellar/go/1.5.3: 5,336 files, 259.6M\n\n\n\n\n\n\n\nAlternatively, you can download binaries from \n\nthe golang.org site\n\nTo test your Go implementation, you can query Go for its version information\n\n\n$ go version\ngo version go1.5.3 darwin/amd64\n\n\n\n\n\n\n\nTo use go, you must set a \n$GOPATH\n variable in your environment.  This tells\ngo where to put all the packages it downloads, builds and runs.\n\n\n$ mkdir $HOME/dev\n$ export GOPATH=$HOME/dev/Go\n\n\n\n\n\n\n\nIts best to add this to your \n.profile\n so its set automatically for your \nenvironment. \n\n\n\n\nDownload the newtmgr source\n\n\nYou will first download the source code for newt.\n\n\n    go get mynewt.apache.org/newt/...\n        (wait a few minutes please, this sits without any indications of working)\n\n\n\n\n\n\n\nBuilding newtmgr\n\n\nChange into the directory where the newmgr tool was downloaded and \ninstall the newtmgr tool\n\n\n    cd $GOPATH/src/mynewt.apache.org/newt/newtmgr\n    go install\n    $ ls $GOPATH/bin\n    ... newtmgr ...\n\n\n\n\n\n\n\nNote:\n If the \ngo install\n command results in errors indicating some package \ncannot be found, do a \ngo get\n to download all the third-party files needed \nfrom github.com and then run \ngo install\n again. \n\n\nAdd to your Path\n\n\nAdd your \n$GOPATH/bin\n directory to your path.", 
            "title": "Installing"
        }, 
        {
            "location": "/newtmgr/installing/#installing-newtmgr", 
            "text": "This page shows you how to install newtmgr from source code.", 
            "title": "Installing Newtmgr"
        }, 
        {
            "location": "/newtmgr/installing/#install-go-golang", 
            "text": "If you have not already done so, install Go for your platform.    The easiest way on a MAC is to use  brew .    brew install go\n==  Downloading https://homebrew.bintray.com/bottles/go-1.5.3.mavericks.bottle.t\n...\n==  Summary\n\ud83c\udf7a  /usr/local/Cellar/go/1.5.3: 5,336 files, 259.6M   Alternatively, you can download binaries from  the golang.org site \nTo test your Go implementation, you can query Go for its version information  $ go version\ngo version go1.5.3 darwin/amd64   To use go, you must set a  $GOPATH  variable in your environment.  This tells\ngo where to put all the packages it downloads, builds and runs.  $ mkdir $HOME/dev\n$ export GOPATH=$HOME/dev/Go   Its best to add this to your  .profile  so its set automatically for your \nenvironment.", 
            "title": "Install Go (golang)"
        }, 
        {
            "location": "/newtmgr/installing/#download-the-newtmgr-source", 
            "text": "You will first download the source code for newt.      go get mynewt.apache.org/newt/...\n        (wait a few minutes please, this sits without any indications of working)", 
            "title": "Download the newtmgr source"
        }, 
        {
            "location": "/newtmgr/installing/#building-newtmgr", 
            "text": "Change into the directory where the newmgr tool was downloaded and \ninstall the newtmgr tool      cd $GOPATH/src/mynewt.apache.org/newt/newtmgr\n    go install\n    $ ls $GOPATH/bin\n    ... newtmgr ...   Note:  If the  go install  command results in errors indicating some package \ncannot be found, do a  go get  to download all the third-party files needed \nfrom github.com and then run  go install  again.", 
            "title": "Building newtmgr"
        }, 
        {
            "location": "/newtmgr/installing/#add-to-your-path", 
            "text": "Add your  $GOPATH/bin  directory to your path.", 
            "title": "Add to your Path"
        }, 
        {
            "location": "/newtmgr/project-slinky/", 
            "text": "Project Sim Slinky\n\n\nObjective\n\n\nThe goal of the project is to enable and demonstrate remote communications with the Mynewt OS via newt manager (newtmgr). We will do this through building a project with Mynewt called Slinky that runs via the native platform. \n\n\nWhat you need\n\n\n1.Personal Computer\n\n\nThe instructions assume the user is using a Bourne-compatible shell (e.g. bash or zsh) on your computer. The given instructions have been tested with the following releases of operating systems:\n\n\n\n\nMac: OS X Yosemite Version 10.10.5\n\n\n\n\nOverview of steps\n\n\n\n\nInstall dependencies\n\n\nDefine a target using the newt tool\n\n\nBuild executables for the targets using the newt tool\n\n\nSet up serial connection with the targets \n\n\nCreate a connection profile using the newtmgr tool\n\n\nUse the newtmgr tool to communicate with the targets\n\n\n\n\nInstalling newt\n\n\nIf you have not already installed \nnewt\n see the \n\nnewt installation instructions\n and ensure newt is installed an in your path.\n\n\nInstalling newtmgr\n\n\nIf you have not already installed \nnewtmgr\n see the \n\nnewtmgr installation instructions\n and ensure newtmgr is installed an in your path.\n\n\nCreating a new project\n\n\nInstructions for creating a project are located in the \nGetting Started\n section of the \nMynewt OS Manual\n\n\nWe will list only the steps here for brevity.  We will name the project\n\nslinky\n.\n\n\n    $ newt new slinky\n    Downloading project skeleton from apache/incubator-mynewt-blinky...\n    ...\n    Installing skeleton in slink...\n    Project slink successfully created\n    $ cd slinky\n    $ newt install -v\n    Downloading repository description for apache-mynewt-core... success!\n    ...\n    Repos successfully installed\n\n\n\n\n\nSetting up your target build\n\n\nCreate a target for \nslinky\n using the native bsp.  See \n\nHow to Define a Target\n for a detailed\ndescription.  We will list only the steps and suppress the tool output \nhere for brevity.\n\n\n    $ newt target create sim_slinky\n    $ newt target set sim_slinky bsp=@apache-mynewt-core/hw/bsp/native\n    $ newt target set sim_slinky build_profile=debug\n    $ newt target set sim_slinky app=@apache-mynewt-core/apps/slinky\n\n\n\n\n\nBuilding Your target\n\n\nTo build your target, use \nnewt build\n.  When complete, an executable file\nis created.\n\n\n    $ newt build sim_slinky \n    Compiling main.c\n    ...\n    Linking slinky.elf\n    App successfully built: ~/dev/slinky/bin/sim_slinky/apps/slinky/slinky.elf\n\n\n\n\n\nRun the target\n\n\nRun the executable you have build for the simulated environment. The serial port name on which the simulated target is connected is shown in the output\nwhen mynewt slinky starts.\n\n\n    $ ~/dev/slinky/bin/sim_slinky/apps/slinky/slinky.elf\n    uart0 at /dev/ttys005\n\n\n\n\n\n\n\nIn this example, the slinky app opened up a com port \n/dev/ttys005\n\nfor communications with newtmgr. \n\n\nNOTE:\n This application will block. You will need to open a new console (or execute this in another console) to continue the tutorial.*\n\n\n\n\nSetting up a connection profile\n\n\nYou will now set up a connection profile using \nnewtmgr\n for the serial port connection and start communicating with the simulated remote device.\n\n\n    $ newtmgr conn add sim1 type=serial connstring=/dev/ttys005\n    Connection profile sim1 successfully added\n    $ newtmgr conn show\n    Connection profiles: \n      sim1: type=serial, connstring=\n/dev/ttys007\n\n\n\n\n\n\nExecuting newtmgr commands with the target\n\n\nYou can now use connection profile \nsim1\n to talk to the running sim_blinky.\nAs an example, we will query the running mynewt OS for the usage of its \nmemory pools.  \n\n\n    $ newtmgr -c sim1 mpstats\n    Return Code = 0\n      nffs_cache_inode_pool (blksize=36 nblocks=4 nfree=4)\n      nffs_cache_block_pool (blksize=32 nblocks=64 nfree=64)\n      nffs_dir_pool (blksize=8 nblocks=4 nfree=4)\n      default_mbuf_data (blksize=256 nblocks=10 nfree=8)\n      nffs_file_pool (blksize=12 nblocks=4 nfree=4)\n      nffs_inode_entry_pool (blksize=24 nblocks=100 nfree=98)\n      nffs_block_entry_pool (blksize=12 nblocks=100 nfree=100)\n\n\n\n\n\nAs a test command, you can send an arbitrary string to the target and it\nwill echo that string back in a response to newtmgr.\n\n\n    $ newtmgr -c sim1 echo \nHello Mynewt\n\n    {\nr\n: \nHello Mynewt\n}\n\n\n\n\n\nThe response comes back as a json string.\n\n\nIn addition to these, you can also examine running tasks, statistics, \nlogs, image status (not on sim), and configuration.", 
            "title": "Sim Slinky"
        }, 
        {
            "location": "/newtmgr/project-slinky/#project-sim-slinky", 
            "text": "", 
            "title": "Project Sim Slinky"
        }, 
        {
            "location": "/newtmgr/project-slinky/#objective", 
            "text": "The goal of the project is to enable and demonstrate remote communications with the Mynewt OS via newt manager (newtmgr). We will do this through building a project with Mynewt called Slinky that runs via the native platform.", 
            "title": "Objective"
        }, 
        {
            "location": "/newtmgr/project-slinky/#what-you-need", 
            "text": "1.Personal Computer  The instructions assume the user is using a Bourne-compatible shell (e.g. bash or zsh) on your computer. The given instructions have been tested with the following releases of operating systems:   Mac: OS X Yosemite Version 10.10.5", 
            "title": "What you need"
        }, 
        {
            "location": "/newtmgr/project-slinky/#overview-of-steps", 
            "text": "Install dependencies  Define a target using the newt tool  Build executables for the targets using the newt tool  Set up serial connection with the targets   Create a connection profile using the newtmgr tool  Use the newtmgr tool to communicate with the targets", 
            "title": "Overview of steps"
        }, 
        {
            "location": "/newtmgr/project-slinky/#installing-newt", 
            "text": "If you have not already installed  newt  see the  newt installation instructions  and ensure newt is installed an in your path.", 
            "title": "Installing newt"
        }, 
        {
            "location": "/newtmgr/project-slinky/#installing-newtmgr", 
            "text": "If you have not already installed  newtmgr  see the  newtmgr installation instructions  and ensure newtmgr is installed an in your path.", 
            "title": "Installing newtmgr"
        }, 
        {
            "location": "/newtmgr/project-slinky/#creating-a-new-project", 
            "text": "Instructions for creating a project are located in the  Getting Started  section of the  Mynewt OS Manual  We will list only the steps here for brevity.  We will name the project slinky .      $ newt new slinky\n    Downloading project skeleton from apache/incubator-mynewt-blinky...\n    ...\n    Installing skeleton in slink...\n    Project slink successfully created\n    $ cd slinky\n    $ newt install -v\n    Downloading repository description for apache-mynewt-core... success!\n    ...\n    Repos successfully installed", 
            "title": "Creating a new project"
        }, 
        {
            "location": "/newtmgr/project-slinky/#setting-up-your-target-build", 
            "text": "Create a target for  slinky  using the native bsp.  See  How to Define a Target  for a detailed\ndescription.  We will list only the steps and suppress the tool output \nhere for brevity.      $ newt target create sim_slinky\n    $ newt target set sim_slinky bsp=@apache-mynewt-core/hw/bsp/native\n    $ newt target set sim_slinky build_profile=debug\n    $ newt target set sim_slinky app=@apache-mynewt-core/apps/slinky", 
            "title": "Setting up your target build"
        }, 
        {
            "location": "/newtmgr/project-slinky/#building-your-target", 
            "text": "To build your target, use  newt build .  When complete, an executable file\nis created.      $ newt build sim_slinky \n    Compiling main.c\n    ...\n    Linking slinky.elf\n    App successfully built: ~/dev/slinky/bin/sim_slinky/apps/slinky/slinky.elf", 
            "title": "Building Your target"
        }, 
        {
            "location": "/newtmgr/project-slinky/#run-the-target", 
            "text": "Run the executable you have build for the simulated environment. The serial port name on which the simulated target is connected is shown in the output\nwhen mynewt slinky starts.      $ ~/dev/slinky/bin/sim_slinky/apps/slinky/slinky.elf\n    uart0 at /dev/ttys005   In this example, the slinky app opened up a com port  /dev/ttys005 \nfor communications with newtmgr.   NOTE:  This application will block. You will need to open a new console (or execute this in another console) to continue the tutorial.*", 
            "title": "Run the target"
        }, 
        {
            "location": "/newtmgr/project-slinky/#setting-up-a-connection-profile", 
            "text": "You will now set up a connection profile using  newtmgr  for the serial port connection and start communicating with the simulated remote device.      $ newtmgr conn add sim1 type=serial connstring=/dev/ttys005\n    Connection profile sim1 successfully added\n    $ newtmgr conn show\n    Connection profiles: \n      sim1: type=serial, connstring= /dev/ttys007", 
            "title": "Setting up a connection profile"
        }, 
        {
            "location": "/newtmgr/project-slinky/#executing-newtmgr-commands-with-the-target", 
            "text": "You can now use connection profile  sim1  to talk to the running sim_blinky.\nAs an example, we will query the running mynewt OS for the usage of its \nmemory pools.        $ newtmgr -c sim1 mpstats\n    Return Code = 0\n      nffs_cache_inode_pool (blksize=36 nblocks=4 nfree=4)\n      nffs_cache_block_pool (blksize=32 nblocks=64 nfree=64)\n      nffs_dir_pool (blksize=8 nblocks=4 nfree=4)\n      default_mbuf_data (blksize=256 nblocks=10 nfree=8)\n      nffs_file_pool (blksize=12 nblocks=4 nfree=4)\n      nffs_inode_entry_pool (blksize=24 nblocks=100 nfree=98)\n      nffs_block_entry_pool (blksize=12 nblocks=100 nfree=100)  As a test command, you can send an arbitrary string to the target and it\nwill echo that string back in a response to newtmgr.      $ newtmgr -c sim1 echo  Hello Mynewt \n    { r :  Hello Mynewt }  The response comes back as a json string.  In addition to these, you can also examine running tasks, statistics, \nlogs, image status (not on sim), and configuration.", 
            "title": "Executing newtmgr commands with the target"
        }, 
        {
            "location": "/newtmgr/project-target-slinky/", 
            "text": "Project Slinky\n\n\nObjective\n\n\nThe goal of the project is to enable and demonstrate remote communications with the Mynewt OS via newt manager (newtmgr). We will do this through a project with Mynewt called Slinky that runs on the STM32-E407 board.\n\n\nWhat you need\n\n\n\n\nSTM32-E407 development board from Olimex. You can order it from \nhttp://www.mouser.com\n, \nhttp://www.digikey.com\n, and other places.\n\n\nARM-USB-TINY-H connector with JTAG interface for debugging ARM microcontrollers (comes with the ribbon cable to hook up to the board)\n\n\nUSB A-B type cable to connect the debugger to your personal computer\n\n\nA USB to TTL Serial Cable with female wiring harness. An example is \nhttp://www.amazon.com/JBtek\u00ae-WINDOWS-Supported-Raspberry-Programming/dp/B00QT7LQ88/ref=lp_464404_1_9?s=pc\nie=UTF8\nqid=1454631303\nsr=1-9\n\n\nPersonal Computer\n\n\n\n\nThe instructions assume the user is using a Bourne-compatible shell (e.g. bash or zsh) on your computer. The given instructions have been tested with the following releases of operating systems:\n\n\n\n\nMac: OS X Yosemite Version 10.10.5\n\n\n\n\nOverview of steps\n\n\n\n\nInstall dependencies\n\n\nDefine a target using the newt tool\n\n\nBuild executables for the targets using the newt tool\n\n\nSet up serial connection with the targets \n\n\nCreate a connection profile using the newtmgr tool\n\n\nUse the newtmgr tool to communicate with the targets\n\n\n\n\nInstall newt\n\n\nIf you have not already installed \nnewt\n, see the \n\nnewt installation instructions\n and ensure newt is installed an in your path.\n\n\nInstall newtmgr\n\n\nIf you have not already installed \nnewtmgr\n, see the \n\nnewtmgr installation instructions\n and ensure newtmgr is installed an in your path.\n\n\nCreate a new project\n\n\nInstructions for creating a project are located in the \nGetting Started\n section of the \nMynewt OS Manual\n.\n\n\nIf you already completed \nsim slinky\n you can skip this step.\n\n\nWe will list only the steps here for brevity.  We will name the project\n\nslinky\n.\n\n\n$ newt new slinky\nDownloading project skeleton from apache/incubator-mynewt-blinky...\n...\nInstalling skeleton in slink...\nProject slink successfully created\n$ cd slinky\n$newt install -v\nDownloading repository description for apache-mynewt-core... success!\n...\nRepos successfully installed\n\n\n\n\n\n\n\nSet up your target builds\n\n\nCreate a target for \nstm32_slinky\n using the native bsp.  See \n\nHow to Define a Target\n for a detailed\ndescription.  The tool output is suppressed below for brevity.\n\n\n$ newt target create stm32_slinky\n$ newt target set stm32_slinky bsp=@apache-mynewt-core/hw/bsp/olimex_stm32-e407_devboard\n$ newt target set stm32_slinky build_profile=debug\n$ newt target set stm32_slinky app=@apache-mynewt-core/apps/slinky\n\n\n\n\n\nCreate a second target for \nstm32_bootloader\n to build a bootloader to boot\nthe \nstm32_slinky\n image.  The tool output is suppressed below for brevity.\n\n\n$ newt target create stm32_bootloader\n$ newt target set stm32_bootloader bsp=@apache-mynewt-core/hw/bsp/olimex_stm32-e407_devboard\n$ newt target set stm32_bootloader build_profile=optimized\n$ newt target set stm32_bootloader target.app=@apache-mynewt-core/apps/boot\n\n\n\n\n\n\n\nBuild Targets\n\n\n$ newt build stm32_slinky\nCompiling main.c\n...\nLinking slinky.elf\nApp successfully built: ~/dev/slinky/bin/stm32_slinky/apps/slinky/slinky.elf\n\n\n\n\n\nnewt build stm32_bootloader\nCompiling crc16.c\n...\nLinking boot.elf\nApp successfully built: ~/slinky/bin/stm32_bootloader/apps/boot/boot.elf\n\n\n\n\n\nFor the main image, you need to create an image using newt create-image.\nGive this image some arbitrary version number \"1.2.3\".\n\n\n$ newt create-image stm32_slinky 1.2.3\nApp image succesfully generated: /Users/paulfdietrich/dev/slinky/bin/stm32_slinky/apps/slinky/slinky.img\nBuild manifest: /Users/paulfdietrich/dev/slinky/bin/stm32_slinky/apps/slinky/manifest.json\n\n\n\n\n\n\n\nUsing newtmgr with a remote target\n\n\n\n\n\n\nFirst make sure the USB A-B type cable is connected to the ARM-USB-TINY-H debugger connector on the Olimex board. \n\n\nNext go the to project directory and download the slinky project image to the flash of the Olimex board. \n\n\n\n\n\n\n$ newt load stm32_bootloader\n$ newt load stm32_slinky\n\n\n\n\n\nYou can now disconnect the debugging cable from the board. You should see the green LED blinking. If not, try powercycling the board.\n\n\n\n\n\n\n\n\nNow you have to set up the serial connection from your computer to the Olimex board. Locate the PC6/USART6_TX (pin#3), PC7/USART6_RX (pin#4), and GND (pin#2) of the UEXT connector on the Olimex board. More information on the UEXT connector can be found at \nhttps://www.olimex.com/Products/Modules/UEXT/\n. The schematic of the board can be found at \nhttps://www.olimex.com/Products/ARM/ST/STM32-E407/resources/STM32-E407_sch.pdf\n for reference.\n\n\n\n\n\n\nConnect the female RX pin of the USB-TTL serial cable to the TX of the UEXT connector on the board. \n\n\nConnect the female TX pin of the USB-TTL serial cable to the RX of the UEXT connector on the board. \n\n\nConnect the GND pin of the USB-TTL serial cable to the GND of the UEXT connector on the board.\n\n\n\n\n\n\n\n\n\n\n\n\nLocate the serial connection established in the /dev directory of your computer. It should be of the type \ntty.usbserial-\nsome identifier\n.\n\n\n\n\n        $ ls /dev/tty.usbserial-AJ03HAQQ \n        /dev/tty.usbserial-AJ03HAQQ\n\n\n\n\n\n\n\n\n\nYou now have to define a connection profile using newtmgr. You can give it any name you want. The example below shows the connection profile being named as the very imaginative \nolimex01\n.\n\n\n\n\n        $ pwd\n        /Users/\nuser\n/dev/larva/project/slinky\n        $ newtmgr conn add olimex01 type=serial connstring=/dev/tty.usbserial-AJ03HAQQ \n        Connection profile olimex01 successfully added\n        $ newtmgr conn show\n        Connection profiles: \n          sim1: type=serial, connstring=\n/dev/ttys007\n\n          olimex01: type=serial, connstring=\n/dev/tty.usbserial-AJ03HAQQ\n\n\n\n\n\n\n\n\n\n\nNow go ahead and query the Olimex board to get responses back. The simplest command is the \necho\n command to ask it to respond with the text you send it. \n\n\n\n\n    $ newtmgr echo -c olimex01 hello\n    {\nr\n: \nhello\n}\n    $ newtmgr image -c olimex01 list\n    Images:\n        0 : 1.2.3\n    $ newtmgr -c olimex01 taskstats\n    Return Code = 0\n      newtmgr (prio=4 tid=2 runtime=0 cswcnt=12 stksize=512 stkusage=255 last_checkin=0 next_checkin=0)\n      task1 (prio=1 tid=3 runtime=0 cswcnt=299 stksize=128 stkusage=33 last_checkin=0 next_checkin=0)\n      task2 (prio=2 tid=4 runtime=0 cswcnt=300 stksize=128 stkusage=31 last_checkin=0 next_checkin=0)\n      idle (prio=255 tid=0 runtime=299916 cswcnt=313 stksize=32 stkusage=18 last_checkin=0 next_checkin=0)\n      shell (prio=3 tid=1 runtime=1 cswcnt=20 stksize=384 stkusage=60 last_checkin=0 next_checkin=0)", 
            "title": "Target Slinky"
        }, 
        {
            "location": "/newtmgr/project-target-slinky/#project-slinky", 
            "text": "", 
            "title": "Project Slinky"
        }, 
        {
            "location": "/newtmgr/project-target-slinky/#objective", 
            "text": "The goal of the project is to enable and demonstrate remote communications with the Mynewt OS via newt manager (newtmgr). We will do this through a project with Mynewt called Slinky that runs on the STM32-E407 board.", 
            "title": "Objective"
        }, 
        {
            "location": "/newtmgr/project-target-slinky/#what-you-need", 
            "text": "STM32-E407 development board from Olimex. You can order it from  http://www.mouser.com ,  http://www.digikey.com , and other places.  ARM-USB-TINY-H connector with JTAG interface for debugging ARM microcontrollers (comes with the ribbon cable to hook up to the board)  USB A-B type cable to connect the debugger to your personal computer  A USB to TTL Serial Cable with female wiring harness. An example is  http://www.amazon.com/JBtek\u00ae-WINDOWS-Supported-Raspberry-Programming/dp/B00QT7LQ88/ref=lp_464404_1_9?s=pc ie=UTF8 qid=1454631303 sr=1-9  Personal Computer   The instructions assume the user is using a Bourne-compatible shell (e.g. bash or zsh) on your computer. The given instructions have been tested with the following releases of operating systems:   Mac: OS X Yosemite Version 10.10.5", 
            "title": "What you need"
        }, 
        {
            "location": "/newtmgr/project-target-slinky/#overview-of-steps", 
            "text": "Install dependencies  Define a target using the newt tool  Build executables for the targets using the newt tool  Set up serial connection with the targets   Create a connection profile using the newtmgr tool  Use the newtmgr tool to communicate with the targets", 
            "title": "Overview of steps"
        }, 
        {
            "location": "/newtmgr/project-target-slinky/#install-newt", 
            "text": "If you have not already installed  newt , see the  newt installation instructions  and ensure newt is installed an in your path.", 
            "title": "Install newt"
        }, 
        {
            "location": "/newtmgr/project-target-slinky/#install-newtmgr", 
            "text": "If you have not already installed  newtmgr , see the  newtmgr installation instructions  and ensure newtmgr is installed an in your path.", 
            "title": "Install newtmgr"
        }, 
        {
            "location": "/newtmgr/project-target-slinky/#create-a-new-project", 
            "text": "Instructions for creating a project are located in the  Getting Started  section of the  Mynewt OS Manual .  If you already completed  sim slinky  you can skip this step.  We will list only the steps here for brevity.  We will name the project slinky .  $ newt new slinky\nDownloading project skeleton from apache/incubator-mynewt-blinky...\n...\nInstalling skeleton in slink...\nProject slink successfully created\n$ cd slinky\n$newt install -v\nDownloading repository description for apache-mynewt-core... success!\n...\nRepos successfully installed", 
            "title": "Create a new project"
        }, 
        {
            "location": "/newtmgr/project-target-slinky/#set-up-your-target-builds", 
            "text": "Create a target for  stm32_slinky  using the native bsp.  See  How to Define a Target  for a detailed\ndescription.  The tool output is suppressed below for brevity.  $ newt target create stm32_slinky\n$ newt target set stm32_slinky bsp=@apache-mynewt-core/hw/bsp/olimex_stm32-e407_devboard\n$ newt target set stm32_slinky build_profile=debug\n$ newt target set stm32_slinky app=@apache-mynewt-core/apps/slinky  Create a second target for  stm32_bootloader  to build a bootloader to boot\nthe  stm32_slinky  image.  The tool output is suppressed below for brevity.  $ newt target create stm32_bootloader\n$ newt target set stm32_bootloader bsp=@apache-mynewt-core/hw/bsp/olimex_stm32-e407_devboard\n$ newt target set stm32_bootloader build_profile=optimized\n$ newt target set stm32_bootloader target.app=@apache-mynewt-core/apps/boot", 
            "title": "Set up your target builds"
        }, 
        {
            "location": "/newtmgr/project-target-slinky/#build-targets", 
            "text": "$ newt build stm32_slinky\nCompiling main.c\n...\nLinking slinky.elf\nApp successfully built: ~/dev/slinky/bin/stm32_slinky/apps/slinky/slinky.elf  newt build stm32_bootloader\nCompiling crc16.c\n...\nLinking boot.elf\nApp successfully built: ~/slinky/bin/stm32_bootloader/apps/boot/boot.elf  For the main image, you need to create an image using newt create-image.\nGive this image some arbitrary version number \"1.2.3\".  $ newt create-image stm32_slinky 1.2.3\nApp image succesfully generated: /Users/paulfdietrich/dev/slinky/bin/stm32_slinky/apps/slinky/slinky.img\nBuild manifest: /Users/paulfdietrich/dev/slinky/bin/stm32_slinky/apps/slinky/manifest.json", 
            "title": "Build Targets"
        }, 
        {
            "location": "/newtmgr/project-target-slinky/#using-newtmgr-with-a-remote-target", 
            "text": "First make sure the USB A-B type cable is connected to the ARM-USB-TINY-H debugger connector on the Olimex board.   Next go the to project directory and download the slinky project image to the flash of the Olimex board.     $ newt load stm32_bootloader\n$ newt load stm32_slinky  You can now disconnect the debugging cable from the board. You should see the green LED blinking. If not, try powercycling the board.     Now you have to set up the serial connection from your computer to the Olimex board. Locate the PC6/USART6_TX (pin#3), PC7/USART6_RX (pin#4), and GND (pin#2) of the UEXT connector on the Olimex board. More information on the UEXT connector can be found at  https://www.olimex.com/Products/Modules/UEXT/ . The schematic of the board can be found at  https://www.olimex.com/Products/ARM/ST/STM32-E407/resources/STM32-E407_sch.pdf  for reference.    Connect the female RX pin of the USB-TTL serial cable to the TX of the UEXT connector on the board.   Connect the female TX pin of the USB-TTL serial cable to the RX of the UEXT connector on the board.   Connect the GND pin of the USB-TTL serial cable to the GND of the UEXT connector on the board.       Locate the serial connection established in the /dev directory of your computer. It should be of the type  tty.usbserial- some identifier .           $ ls /dev/tty.usbserial-AJ03HAQQ \n        /dev/tty.usbserial-AJ03HAQQ    You now have to define a connection profile using newtmgr. You can give it any name you want. The example below shows the connection profile being named as the very imaginative  olimex01 .           $ pwd\n        /Users/ user /dev/larva/project/slinky\n        $ newtmgr conn add olimex01 type=serial connstring=/dev/tty.usbserial-AJ03HAQQ \n        Connection profile olimex01 successfully added\n        $ newtmgr conn show\n        Connection profiles: \n          sim1: type=serial, connstring= /dev/ttys007 \n          olimex01: type=serial, connstring= /dev/tty.usbserial-AJ03HAQQ     Now go ahead and query the Olimex board to get responses back. The simplest command is the  echo  command to ask it to respond with the text you send it.        $ newtmgr echo -c olimex01 hello\n    { r :  hello }\n    $ newtmgr image -c olimex01 list\n    Images:\n        0 : 1.2.3\n    $ newtmgr -c olimex01 taskstats\n    Return Code = 0\n      newtmgr (prio=4 tid=2 runtime=0 cswcnt=12 stksize=512 stkusage=255 last_checkin=0 next_checkin=0)\n      task1 (prio=1 tid=3 runtime=0 cswcnt=299 stksize=128 stkusage=33 last_checkin=0 next_checkin=0)\n      task2 (prio=2 tid=4 runtime=0 cswcnt=300 stksize=128 stkusage=31 last_checkin=0 next_checkin=0)\n      idle (prio=255 tid=0 runtime=299916 cswcnt=313 stksize=32 stkusage=18 last_checkin=0 next_checkin=0)\n      shell (prio=3 tid=1 runtime=1 cswcnt=20 stksize=384 stkusage=60 last_checkin=0 next_checkin=0)", 
            "title": "Using newtmgr with a remote target"
        }, 
        {
            "location": "/newtmgr/protocol/", 
            "text": "Newt Manager Protocol\n\n\n \n\n\nDescription\n\n\nHow it works", 
            "title": "Protocol"
        }, 
        {
            "location": "/newtmgr/protocol/#newt-manager-protocol", 
            "text": "", 
            "title": "Newt Manager Protocol"
        }, 
        {
            "location": "/newtmgr/protocol/#description", 
            "text": "", 
            "title": "Description"
        }, 
        {
            "location": "/newtmgr/protocol/#how-it-works", 
            "text": "", 
            "title": "How it works"
        }, 
        {
            "location": "/faq/answers/", 
            "text": "How do I submit a bug?\n\n\nIf you do not have a JIRA account sign up for an account on \nJIRA\n.\n\n\nSubmit a request to the @dev mailing list for your JIRA username to be added to the Apache Mynewt (MYNEWT) project. You can view the issues on JIRA for the MYNEWT project without an account but you need to log in for reporting a bug. \n\n\nLog in. Choose the \"MYNEWT\" project. Click on the \"Create\" button to create a ticket. Choose \"Bug\" as the Issue Type. Fill in the bug description, how it is triggered, and other details. \n\n\nHow do I request a feature?\n\n\nIf you do not have a JIRA account sign up for an account on \nJIRA\n.\n\n\nSubmit a request to the @dev mailing list for your JIRA username to be added to the Apache Mynewt (MYNEWT) project. You can view the issues on JIRA for the MYNEWT project without an account but you need to log in for reporting a bug. \n\n\nLog in. Choose the \"MYNEWT\" project. Click on the \"Create\" button to create a ticket. Choose \"Wish\" as the Issue Type. Fill in the feature description,  benefits, and any other implementation details. Note in the description whether you want to work on it yourself. \n\n\nIf you are not a committer and you wish to work on it, someone who is on the committer list will have to review your request and assign it to you. You will have to refer to this JIRA ticket in your pull request.\n\n\nI am not on the committer list. How do I submit a patch?\n\n\nYou submit your proposed changes for your peers with committer status to review and merge. \n\n\nYou may choose to submit patches in one of the two following ways:\n\n\n1. Go to the \nMynewt OS mirror\n or \nNewt Tool mirror\n on github.com, as appropriate. Click on the \"Fork\" button to create your own instance of the repo on github.com. Clone the forked repository into a local branch on your machine and make your changes. Push that branch to your fork on github. Then submit a pull request from that branch on your github repo.\n\n\nIn the comment for the pull request, include a description of the changes you have made and why. Github will automatically notify everyone on the commits@mynewt.incubator.apache.org mailing list about the newly opened pull requests. You can open a pull request even if you don't think the code is ready for merging but want some discussion on the matter.\nUpon receiving notification, one or more committers will review your work, ask for edits or clarifications, and merge when your proposed changes are ready.\n\n\n2.Use the \ngit format-patch\n command to produce a patch file. Submit the patch (your code changes along with a diff from the old code) via email to the @dev mailing list. Summarize the issue and your work in the email. Regular project members will review your suggested patch and add it to the repository, acknowledging your contribution by referencing your name in the commit message.\n\n\nI would like to make some edits to the documentation. What do I do?\n\n\nYou submit your proposed changes for your peers with committer status to review and merge. \n\n\nGo to the \ndocumentation mirror\n on github.com.\n\n\nNavigate to the file you wish to edit on github.com. All the technical documentation is in Markdown files under the \n/docs\n directory. Click on the pencil icon (\"Edit the file in your fork of this project\") and start making changes.\n\n\nClick the green \"Propose file change\" button. You will be directed to the page where you can start a pull request from the branch that was created for you. The branch is gets an automatic name \npatch-#\n where # is a number. Click on the green \"Compare \n pull request\" to open the pull request.\n\n\nIn the comment for the pull request, include a description of the changes you have made and why. Github will automatically notify everyone on the commits@mynewt.incubator.apache.org mailing list about the newly opened pull requests. You can open a pull request even if you don't think the code is ready for merging but want some discussion on the matter.\n\n\nUpon receiving notification, one or more committers will review your work, ask for edits or clarifications, and merge when your proposed changes are ready.\n\n\nIf you want to withdraw the pull request simply go to your fork \nhttps://github.com/\nyour github username\n/incubator-mynewt-site\n and click on \"branches\". You should see your branch under \"Your branches\". Click on the delete icon.\n\n\nI would like to make some edits to the documentation but want to use an editor on my own laptop. What do I do?\n\n\nYou submit your proposed changes for your peers with committer status to review and merge. \n\n\nGo to the \ndocumentation mirror\n on github.com. You need to create your own fork of the repo in github.com by clicking on the \"Fork\" button on the top right. Clone the forked repository into your laptop (using \ngit clone\n from a terminal or using the download buttons on the github page)and create a local branch for the edits and switching to it (using \ngit checkout -b \nnew-branchname\n or GitHub Desktop). \n\n\nMake your changes using the editor of your choice. Push that branch to your fork on github. Then submit a pull request from that branch on your github fork.\n\n\nThe review and merge process is the same as other pull requests described for earlier questions.", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/answers/#how-do-i-submit-a-bug", 
            "text": "If you do not have a JIRA account sign up for an account on  JIRA .  Submit a request to the @dev mailing list for your JIRA username to be added to the Apache Mynewt (MYNEWT) project. You can view the issues on JIRA for the MYNEWT project without an account but you need to log in for reporting a bug.   Log in. Choose the \"MYNEWT\" project. Click on the \"Create\" button to create a ticket. Choose \"Bug\" as the Issue Type. Fill in the bug description, how it is triggered, and other details.", 
            "title": "How do I submit a bug?"
        }, 
        {
            "location": "/faq/answers/#how-do-i-request-a-feature", 
            "text": "If you do not have a JIRA account sign up for an account on  JIRA .  Submit a request to the @dev mailing list for your JIRA username to be added to the Apache Mynewt (MYNEWT) project. You can view the issues on JIRA for the MYNEWT project without an account but you need to log in for reporting a bug.   Log in. Choose the \"MYNEWT\" project. Click on the \"Create\" button to create a ticket. Choose \"Wish\" as the Issue Type. Fill in the feature description,  benefits, and any other implementation details. Note in the description whether you want to work on it yourself.   If you are not a committer and you wish to work on it, someone who is on the committer list will have to review your request and assign it to you. You will have to refer to this JIRA ticket in your pull request.", 
            "title": "How do I request a feature?"
        }, 
        {
            "location": "/faq/answers/#i-am-not-on-the-committer-list-how-do-i-submit-a-patch", 
            "text": "You submit your proposed changes for your peers with committer status to review and merge.   You may choose to submit patches in one of the two following ways:  1. Go to the  Mynewt OS mirror  or  Newt Tool mirror  on github.com, as appropriate. Click on the \"Fork\" button to create your own instance of the repo on github.com. Clone the forked repository into a local branch on your machine and make your changes. Push that branch to your fork on github. Then submit a pull request from that branch on your github repo.  In the comment for the pull request, include a description of the changes you have made and why. Github will automatically notify everyone on the commits@mynewt.incubator.apache.org mailing list about the newly opened pull requests. You can open a pull request even if you don't think the code is ready for merging but want some discussion on the matter.\nUpon receiving notification, one or more committers will review your work, ask for edits or clarifications, and merge when your proposed changes are ready.  2.Use the  git format-patch  command to produce a patch file. Submit the patch (your code changes along with a diff from the old code) via email to the @dev mailing list. Summarize the issue and your work in the email. Regular project members will review your suggested patch and add it to the repository, acknowledging your contribution by referencing your name in the commit message.", 
            "title": "I am not on the committer list. How do I submit a patch?"
        }, 
        {
            "location": "/faq/answers/#i-would-like-to-make-some-edits-to-the-documentation-what-do-i-do", 
            "text": "You submit your proposed changes for your peers with committer status to review and merge.   Go to the  documentation mirror  on github.com.  Navigate to the file you wish to edit on github.com. All the technical documentation is in Markdown files under the  /docs  directory. Click on the pencil icon (\"Edit the file in your fork of this project\") and start making changes.  Click the green \"Propose file change\" button. You will be directed to the page where you can start a pull request from the branch that was created for you. The branch is gets an automatic name  patch-#  where # is a number. Click on the green \"Compare   pull request\" to open the pull request.  In the comment for the pull request, include a description of the changes you have made and why. Github will automatically notify everyone on the commits@mynewt.incubator.apache.org mailing list about the newly opened pull requests. You can open a pull request even if you don't think the code is ready for merging but want some discussion on the matter.  Upon receiving notification, one or more committers will review your work, ask for edits or clarifications, and merge when your proposed changes are ready.  If you want to withdraw the pull request simply go to your fork  https://github.com/ your github username /incubator-mynewt-site  and click on \"branches\". You should see your branch under \"Your branches\". Click on the delete icon.", 
            "title": "I would like to make some edits to the documentation. What do I do?"
        }, 
        {
            "location": "/faq/answers/#i-would-like-to-make-some-edits-to-the-documentation-but-want-to-use-an-editor-on-my-own-laptop-what-do-i-do", 
            "text": "You submit your proposed changes for your peers with committer status to review and merge.   Go to the  documentation mirror  on github.com. You need to create your own fork of the repo in github.com by clicking on the \"Fork\" button on the top right. Clone the forked repository into your laptop (using  git clone  from a terminal or using the download buttons on the github page)and create a local branch for the edits and switching to it (using  git checkout -b  new-branchname  or GitHub Desktop).   Make your changes using the editor of your choice. Push that branch to your fork on github. Then submit a pull request from that branch on your github fork.  The review and merge process is the same as other pull requests described for earlier questions.", 
            "title": "I would like to make some edits to the documentation but want to use an editor on my own laptop. What do I do?"
        }
    ]
}