{
    "docs": [
        {
            "location": "/", 
            "text": "Objective of Mynewt\n\n\nMynewt is an open source initiative to build a stack of modularized control, networking, and monitoring software for embedded devices like wearables, lightbulbs, locks, and doorbells. At the core is a real-time operating system that is designed to work on a variety of microcontrollers. The project includes the Newt tool to help you build and distribute embedded projects using Mynewt OS. The modular implementation allows the user the flexibility to mix and match hardware components and software stack depending on the feature and performance requirements of the particular application he or she has in mind.\n\n\nThe world of Mynewt, therefore, has three primary collaborative goals:\n\n\n\n\nBuild a modularized real-time operating system for a rich set of hardware components\n\n\nOffer a suite of open-source software for efficient and secure two-way communications with an embedded device\n\n\nDevelop method and tools necessary to build an optimized executable image on the desired hardware\n\n\n\n\nProject Information Links\n\n\n\n\n\n\nProject Proposal\n\n\n\n\n\n\nIssue Tracking\n\n\n\n\n\n\nProject Status\n\n\n\n\n\n\nProject GIT Repository\n\n\n\n\n\n\nDocumentation repository\n containing the markdown docs that generate the html pages you see here.\n\n\n\n\n\n\nMynewt OS development repository (larva)\n containing all code packages for newt operating system and middleware software being worked on.\n\n\n\n\n\n\nNewt tool development repository (newt)\n containing source code for the newt tool.\n\n\n\n\n\n\nMailing Lists\n\n\n\n\n\n\ndev@mynewt.incubator.apache.org \n\n\nThis is for both contributors and users. In order to subscribe to the dev list, send an email to dev-subscribe@mynewt.incubator.apache.org.\n\n\n\n\n\n\ncommits@mynewt.incubator.apache.org\n\n\nThis is mainly for contributors to code or documentation. In order to subscribe to the commits list, send an email to commits-subscribe@mynewt.incubator.apache.org.\n\n\n\n\n\n\nnotifications@mynewt.incubator.apache.org\n\n\nThis is for all autogenerated mail except commits e.g. JIRA notifications. In order to subscribe to the notifications list, send an email to notifications-subscribe@mynewt.incubator.apache.org. \n\n\n\n\n\n\nTo subscribe to a mailing list, you simply send an email to a special subscription address. To subscribe to the dev list, send an email to dev-subscribe@mynewt.incubator.apache.org. For the issues list, the address would be issues-subscribe@mynewt.incubator.apache.org. You should then get an automated email which details how to confirm your subscription.\n\n\nDocumentation Organization\n\n\nThe chapter organization is outlined below. Each chapter will include one or more tutorials for hands-on experience with the material in each chapter. \n\n\n\n\n\n\nChapter 1: Get Started\n introduces some key terms in this initiative and includes a tutorial for a quick project to show how to work with some of the products.\n\n\n\n\n\n\nChapter 2: Get Acclimated\n delves deeper into the concepts crucial to the software development effort. \n\n\n\n\n\n\nChapter 3: Newt Tool Reference\n describes the command structure and details all the available commands to help you with your project. \n\n\n\n\n\n\nChapter 4: Newt OS\n provides an overview of the features available and how to customize for your hardware and software application.\n\n\n\n\n\n\nChapter 5: Modules\n lays out all the available modules such as HAL (Hardware Abstraction Layer), console, file system, networking stacks, and other middleware components.\n\n\n\n\n\n\nChapter 6: Creating packages for distribution\n delineates the process of creating complete packages to load on your embedded device to get it up, connected, and ready for remote management.\n\n\n\n\n\n\nContributing to Documentation\n\n\nAll content on this site is statically generated using \nMkDocs\n from documents written in Markdown and stored in the \ndocs\n directory on the master branch in the \nDocumentation repository\n. As a documentation contributor you will modify the desired markdown file or create new ones in the appropriate chapter subdirectory under \ndocs\n. \n\n\nTo edit content in a Markdown file and be able to see how the changes look you may use desktop apps such as:\n\n\n\n\nMou\n for Mac\n\n\nSomething like Mou\n for Windows\n\n\n\n\nClick on the tutorial \nHow to edit docs\n under \"Get Started\" to learn how to edit a sample file \ntry_markdown.md\n on Mynewt's documentation git repository.\n\n\nThe static html content is generated and maintained in the asf-site branch in the documentation repository. Currently, the static html files are generated manually once a day. This will be automated in the future.\n\n\nIf you wish, you may preview the changes you have made on your desktop by installing MkDocs and starting up its built-in webserver as described in \nMkDocs\n. This step is optional but described in the tutorial.", 
            "title": "Home"
        }, 
        {
            "location": "/#objective-of-mynewt", 
            "text": "Mynewt is an open source initiative to build a stack of modularized control, networking, and monitoring software for embedded devices like wearables, lightbulbs, locks, and doorbells. At the core is a real-time operating system that is designed to work on a variety of microcontrollers. The project includes the Newt tool to help you build and distribute embedded projects using Mynewt OS. The modular implementation allows the user the flexibility to mix and match hardware components and software stack depending on the feature and performance requirements of the particular application he or she has in mind.  The world of Mynewt, therefore, has three primary collaborative goals:   Build a modularized real-time operating system for a rich set of hardware components  Offer a suite of open-source software for efficient and secure two-way communications with an embedded device  Develop method and tools necessary to build an optimized executable image on the desired hardware   Project Information Links    Project Proposal    Issue Tracking    Project Status    Project GIT Repository    Documentation repository  containing the markdown docs that generate the html pages you see here.    Mynewt OS development repository (larva)  containing all code packages for newt operating system and middleware software being worked on.    Newt tool development repository (newt)  containing source code for the newt tool.    Mailing Lists    dev@mynewt.incubator.apache.org   This is for both contributors and users. In order to subscribe to the dev list, send an email to dev-subscribe@mynewt.incubator.apache.org.    commits@mynewt.incubator.apache.org  This is mainly for contributors to code or documentation. In order to subscribe to the commits list, send an email to commits-subscribe@mynewt.incubator.apache.org.    notifications@mynewt.incubator.apache.org  This is for all autogenerated mail except commits e.g. JIRA notifications. In order to subscribe to the notifications list, send an email to notifications-subscribe@mynewt.incubator.apache.org.     To subscribe to a mailing list, you simply send an email to a special subscription address. To subscribe to the dev list, send an email to dev-subscribe@mynewt.incubator.apache.org. For the issues list, the address would be issues-subscribe@mynewt.incubator.apache.org. You should then get an automated email which details how to confirm your subscription.  Documentation Organization  The chapter organization is outlined below. Each chapter will include one or more tutorials for hands-on experience with the material in each chapter.     Chapter 1: Get Started  introduces some key terms in this initiative and includes a tutorial for a quick project to show how to work with some of the products.    Chapter 2: Get Acclimated  delves deeper into the concepts crucial to the software development effort.     Chapter 3: Newt Tool Reference  describes the command structure and details all the available commands to help you with your project.     Chapter 4: Newt OS  provides an overview of the features available and how to customize for your hardware and software application.    Chapter 5: Modules  lays out all the available modules such as HAL (Hardware Abstraction Layer), console, file system, networking stacks, and other middleware components.    Chapter 6: Creating packages for distribution  delineates the process of creating complete packages to load on your embedded device to get it up, connected, and ready for remote management.    Contributing to Documentation  All content on this site is statically generated using  MkDocs  from documents written in Markdown and stored in the  docs  directory on the master branch in the  Documentation repository . As a documentation contributor you will modify the desired markdown file or create new ones in the appropriate chapter subdirectory under  docs .   To edit content in a Markdown file and be able to see how the changes look you may use desktop apps such as:   Mou  for Mac  Something like Mou  for Windows   Click on the tutorial  How to edit docs  under \"Get Started\" to learn how to edit a sample file  try_markdown.md  on Mynewt's documentation git repository.  The static html content is generated and maintained in the asf-site branch in the documentation repository. Currently, the static html files are generated manually once a day. This will be automated in the future.  If you wish, you may preview the changes you have made on your desktop by installing MkDocs and starting up its built-in webserver as described in  MkDocs . This step is optional but described in the tutorial.", 
            "title": "Objective of Mynewt"
        }, 
        {
            "location": "/chapter1/newt_concepts/", 
            "text": "Newt Concepts\n\n\nThis page introduces the basic terms you will need to find your way around the Mynewt ecosystem.\n\n\nBasic components in the ecosystem\n\n\n\n\n\n\nNewtOS is an open-source RTOS (Real Time Operating System) that works on a variety of hardware. The goal is to develop a pre-emptive, multitasking OS that is highly modular, making it possible to mix and match components to enable desired features and capabilities on multiple hardware architectures. Examples of components being worked on are the Core RTOS, a flash file system, utility functions, a variety of board support packages, packages of microcontrollers etc.\n\n\n\n\n\n\nNetwork protocol stacks such as Bluetooth Low Energy, and more\n\n\n\n\n\n\nNewt Tool helps you mix the specific packages for the combination of hardware and low-level embedded architecture features of the user's choice and generate the corresponding run-time image based on the NewtOS. It provides the infrastructure to manage and build for different CPU architectures, memory units, board support packages etc., allowing a user to formulate the contents according to the low-level features needed by his or her project.\n\n\n\n\n\n\nTerminology\n\n\nA Mynewt user starts with a project in mind that defines the application or utility that he or she wants to implement on an embedded device. Making an LED blink on an electronics prototyping board is a common starter project. Enabling a BLE (Bluetooth Low Energy) peripheral mode on a development board is a more complex project. Specifying a project requires naming it, at the very least, and then adding the desired properties or attributes. In order to actualize a project, it needs to be applied to a target which is essentially a combination of some specified hardware and the execution environment. \n\n\nIn the mynewt lifecycle, a project grows in a nest. A nest may house multiple projects. The nest is, therefore, a repository where various component packages for one or more projects reside. Each package is an egg (naturally!). However, in the world of Mynewt an egg may consist of other eggs! For example, the starter project Blinky is an egg consisting of several constituent eggs that enable core features. The egg form is suitable for elemental units of code as it explicitly exposes characteristics such as dependencies, versions, capabilities, requirements etc., thus making assembling appropriate components for a project and building an image for it easy to follow, modular, and robust.\n\n\nA nest can be given any name. For example, you will see a nest named \"tadpole\" in Mynewt (\nhttps://git-wip-us.apache.org/repos/asf?p=incubator-mynewt-tadpole.git\n). It contains all the core libraries of the operating system for the native platform which currently supports compilation on Mac OS X. The core libraries are contained in the form of eggs where an egg is a basic unit of implementation of any aspect of the RTOS. The eggs are distributed in the following directory structure inside the nest:\n\n\n\n\nlibs: contains the two eggs \nos\n and \ntestutil\n\n\nhw: contains three eggs - (i) \nhal\n which has the abstraction layer (HAL) API definitions that all BSP and MCU implementations must support, (ii) \n/mcu/native\n which in an MCU implementation for the native platform (a simulator, in this case), and (iii) \nbsp/native\n which is a BSP implementation for the native platform \n\n\ncompiler: contains the \nsim\n egg which bundles the compiler specifications for the native platform.\n\n\n\n\nLet's explore this sample nest a bit further. The \nlibs/os\n egg contains code for scheduler, process/thread/memory management, semaphores etc. It is the core RTOS which ports to all supported chip platforms.The \nlibs/testutil\n egg contains code for testing packages on hardware or simulated environment. The \nhw/hal\n egg contains header files that provide abstraction for physical hardware components such as GPIO (general purpose input/output), network adapters, timers, and UARTs. This \nhw/hal\n egg is an MCU peripheral abstraction designed to make it easy to port to different MCUs (microcontrollers). The \nhw/mcu/native\n egg contains code for microcontroller operations on the native platform. The \nhw/bsp/native\n egg contains the board support package for the native platform. And finally, the sixth egg \nsim\n contains the compiler specifications such as path and flags. Currently the compilation is supported on Mac OS X.\n\n\nYou can see another nest in the mynewt ecosystem called the \"larva\". It was spawned from the skeletal \"tadpole\" nest using the newt tool. Spawning is easy - \n$ newt create nest \nyour_nest_name\n. \"larva\" is the developer's test repository containing all sorts of eggs being written and incubated, including ones to enhance the core operating system which should eventually make their way into the \"tadpole\" nest. There is a \nhatch_tadpole\n script to update the \"tadpole\" nest when the core OS related eggs in \"larva\" are ready.\n\n\nThere is a third nest named \"newt\" that contains all the eggs needed to support the build and release process of mynewt software. In the future, there will also be pre-built nests for certain common hardware devices to enable a user to quickly get started with a project.\n\n\nA Mynewt contributor\n\n\nA contributor can choose to work on any area(s) of the Mynewt endeavor that appeals to him or her. Hence, you can work on one or more eggs or an entire nest. You can create your own nest (master) or create a branch in an existing nest. For now, Runtime contributors will review any new areas of support that you may wish to introduce e.g. a new board support package (BSP) or a new network protocol. \n\n\nA contributer role necessarily implies he or she is a Mynewt user (see below) of some or all of the products developed.\n\n\nA Mynewt user\n\n\nAn application developer is interested only in using software available in this ecosystem to build a top level build artifact. He or she may either:\n\n\n\n\nUse a pre-built nest, or\n\n\nSpawn a new nest using the newt tool for a target where a target is a custom combination of supported hardware components\n\n\n\n\nIn either case, the user would use the newt tool to create and set the target in the chosen nest. The newt tool would then be used to build out the target profile which would determine which eggs to choose. Finally, the user would use the newt tool to generate a run-time image that can be run on the device.", 
            "title": "Newt Concepts"
        }, 
        {
            "location": "/chapter1/newt_concepts/#newt-concepts", 
            "text": "This page introduces the basic terms you will need to find your way around the Mynewt ecosystem.  Basic components in the ecosystem    NewtOS is an open-source RTOS (Real Time Operating System) that works on a variety of hardware. The goal is to develop a pre-emptive, multitasking OS that is highly modular, making it possible to mix and match components to enable desired features and capabilities on multiple hardware architectures. Examples of components being worked on are the Core RTOS, a flash file system, utility functions, a variety of board support packages, packages of microcontrollers etc.    Network protocol stacks such as Bluetooth Low Energy, and more    Newt Tool helps you mix the specific packages for the combination of hardware and low-level embedded architecture features of the user's choice and generate the corresponding run-time image based on the NewtOS. It provides the infrastructure to manage and build for different CPU architectures, memory units, board support packages etc., allowing a user to formulate the contents according to the low-level features needed by his or her project.    Terminology  A Mynewt user starts with a project in mind that defines the application or utility that he or she wants to implement on an embedded device. Making an LED blink on an electronics prototyping board is a common starter project. Enabling a BLE (Bluetooth Low Energy) peripheral mode on a development board is a more complex project. Specifying a project requires naming it, at the very least, and then adding the desired properties or attributes. In order to actualize a project, it needs to be applied to a target which is essentially a combination of some specified hardware and the execution environment.   In the mynewt lifecycle, a project grows in a nest. A nest may house multiple projects. The nest is, therefore, a repository where various component packages for one or more projects reside. Each package is an egg (naturally!). However, in the world of Mynewt an egg may consist of other eggs! For example, the starter project Blinky is an egg consisting of several constituent eggs that enable core features. The egg form is suitable for elemental units of code as it explicitly exposes characteristics such as dependencies, versions, capabilities, requirements etc., thus making assembling appropriate components for a project and building an image for it easy to follow, modular, and robust.  A nest can be given any name. For example, you will see a nest named \"tadpole\" in Mynewt ( https://git-wip-us.apache.org/repos/asf?p=incubator-mynewt-tadpole.git ). It contains all the core libraries of the operating system for the native platform which currently supports compilation on Mac OS X. The core libraries are contained in the form of eggs where an egg is a basic unit of implementation of any aspect of the RTOS. The eggs are distributed in the following directory structure inside the nest:   libs: contains the two eggs  os  and  testutil  hw: contains three eggs - (i)  hal  which has the abstraction layer (HAL) API definitions that all BSP and MCU implementations must support, (ii)  /mcu/native  which in an MCU implementation for the native platform (a simulator, in this case), and (iii)  bsp/native  which is a BSP implementation for the native platform   compiler: contains the  sim  egg which bundles the compiler specifications for the native platform.   Let's explore this sample nest a bit further. The  libs/os  egg contains code for scheduler, process/thread/memory management, semaphores etc. It is the core RTOS which ports to all supported chip platforms.The  libs/testutil  egg contains code for testing packages on hardware or simulated environment. The  hw/hal  egg contains header files that provide abstraction for physical hardware components such as GPIO (general purpose input/output), network adapters, timers, and UARTs. This  hw/hal  egg is an MCU peripheral abstraction designed to make it easy to port to different MCUs (microcontrollers). The  hw/mcu/native  egg contains code for microcontroller operations on the native platform. The  hw/bsp/native  egg contains the board support package for the native platform. And finally, the sixth egg  sim  contains the compiler specifications such as path and flags. Currently the compilation is supported on Mac OS X.  You can see another nest in the mynewt ecosystem called the \"larva\". It was spawned from the skeletal \"tadpole\" nest using the newt tool. Spawning is easy -  $ newt create nest  your_nest_name . \"larva\" is the developer's test repository containing all sorts of eggs being written and incubated, including ones to enhance the core operating system which should eventually make their way into the \"tadpole\" nest. There is a  hatch_tadpole  script to update the \"tadpole\" nest when the core OS related eggs in \"larva\" are ready.  There is a third nest named \"newt\" that contains all the eggs needed to support the build and release process of mynewt software. In the future, there will also be pre-built nests for certain common hardware devices to enable a user to quickly get started with a project.  A Mynewt contributor  A contributor can choose to work on any area(s) of the Mynewt endeavor that appeals to him or her. Hence, you can work on one or more eggs or an entire nest. You can create your own nest (master) or create a branch in an existing nest. For now, Runtime contributors will review any new areas of support that you may wish to introduce e.g. a new board support package (BSP) or a new network protocol.   A contributer role necessarily implies he or she is a Mynewt user (see below) of some or all of the products developed.  A Mynewt user  An application developer is interested only in using software available in this ecosystem to build a top level build artifact. He or she may either:   Use a pre-built nest, or  Spawn a new nest using the newt tool for a target where a target is a custom combination of supported hardware components   In either case, the user would use the newt tool to create and set the target in the chosen nest. The newt tool would then be used to build out the target profile which would determine which eggs to choose. Finally, the user would use the newt tool to generate a run-time image that can be run on the device.", 
            "title": "Newt Concepts"
        }, 
        {
            "location": "/chapter1/project1/", 
            "text": "Blinky, the First Project\n\n\nObjective\n\n\nWe will show you how you can use eggs from a nest on Mynewt to make an LED on a target board blink. We will call it \n Project Blinky\n. The goals of this tutorial are threefold:\n\n\n\n\nFirst, you will learn how to set up your environment to be ready to use Mynewt OS and newt tool. \n\n\nSecond, we will walk you through a download of eggs for building and testing \non a simulated target\n on a non-Windows machine.\n\n\nThird, you will download eggs and use tools to create a runtime image for a board to make its LED blink. You have two choices here - you can \ndownload an image to SRAM\n or you can \ndownload it to flash\n.\n\n\n\n\n Time Requirement\n: Allow yourself a couple of hours for this project if you are relatively new to embedded systems and playing with development boards. Those jumpers can be pesky!\n\n\nWhat you need\n\n\n\n\nSTM32-E407 development board from Olimex. You can order it from \nhttp://www.mouser.com\n, \nhttp://www.digikey.com\n, and other places.\n\n\nARM-USB-TINY-H connector with JTAG interface for debugging ARM microcontrollers (comes with the ribbon cable to hook up to the board)\n\n\nUSB A-B type cable to connect the debugger to your personal computer\n\n\nPersonal Computer\n\n\n\n\nThe instructions assume the user is using a Bourne-compatible shell (e.g. bash or zsh) on your computer. You may already have some of the required packages on your machine.  In that \ncase, simply skip the corresponding installation step in the instructions under \nGetting your Mac Ready\n or \nGetting your Ubuntu machine Ready\n or \nGetting your Windows machine Ready\n. While the given instructions should work on other versions, they have been tested for the three specific releases of operating systems noted here:\n\n\n\n\nMac: OS X Yosemite Version 10.10.5\n\n\nLinux: Ubuntu 14.10 (Utopic Unicorn)\n\n\nWindows: Windows 10\n\n\n\n\nAccess to the Apache repo\n\n\n\n\n\n\nGet an account on Apache. \n\n\n\n\n\n\nThe latest codebase for the Mynewt OS is on the master branch at  https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git\n\n\n\n\n\n\nThe latest codebase for the Newt tool is on the master branch at  https://git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git\n\n\n\n\n\n\nGetting your Mac Ready\n\n\nInstalling Homebrew to ease installs on OS X\n\n\n\n\n\n\nDo you have Homebrew? If not, open a terminal on your Mac and paste the following at a Terminal prompt. It will ask you for your sudo password.\n\n\n$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n\n\n\nAlternatively, you can just extract (or \ngit clone\n) Homebrew and install it to \n/usr/local\n.\n\n\n\n\n\n\nInstalling Go\n\n\n\n\n\n\nThe directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:\n\n\n\n\n\n\nsrc contains Go source files organized into packages (one package per directory),\n\n\n\n\n\n\npkg contains package objects, and\n\n\n\n\n\n\nbin contains executable commands.\n\n\n\n\n\n\nThe GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory and then proceed to create the directory for cloning the newt tool repository.\n\n\n$ cd $HOME\n$ mkdir -p dev/go  \n$ cd dev/go\n$ export GOPATH=`pwd`\n\n\n\nNote that you need to add export statements to ~/.bash_profile to export variables permanently. Don't forget to source the file for the change to go into effect.\n\n\n$ vi ~/.bash_profile\n$ source ~/.bash_profile\n\n\n\n\n\n\n\nNext you will use brew to install Go. The summary message at the end of the installation should indicate that it is installed in the /usr/local/Cellar/go/ directory. You will use the Go command 'install' to compile and install packages (called eggs in the Mynewt world) and dependencies. \n\n\n$ brew install go\n==\n \n...\n... \n==\n *Summary*\n\ud83c\udf7a  /usr/local/Cellar/go/1.5.1: 5330 files, 273M\n\n\n\nAlternatively, you can download the Go package directly from (https://golang.org/dl/) instead of brewing it. Install it in /usr/local directory.\n\n\n\n\n\n\nYou will now get the godep package. Make sure you are at the Go directory level and get godep. Check for it in the bin subdirectory. Add the Go environment to path. Make sure it is added to your .bash_profile.\n\n\n$ cd $GOPATH\n$ go get github.com/tools/godep\n$ ls src/github.com/tools/\ngodep\n$ export PATH=$PATH:$GOPATH/bin\n\n\n\n\n\n\n\nCreating local repository\n\n\n\n\n\n\nYou are ready to download the newt tool repository. You will use Go to copy the directory (currently the asf incubator directory). Be patient as it may take a minute or two. Check the directories installed.\n\n\n$  go get git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git\n$ $ ls\n bin    pkg    src\n$ ls src\ngit-wip-us.apache.org   github.com      gopkg.in\n\n\n\n\n\n\n\nCheck that newt is installed.\n\n\n$ ls $GOPATH/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git  \nGodeps          README.md       coding_style.txt    newt.go\nLICENSE         cli             design.txt\n\n\n\n\n\n\n\nBuilding the Newt tool\n\n\n\n\nIn preparation for the install, you use the godep command 'restore' to check out listed dependency versions in $GOPATH and link all the necessary files. \n\n\n\n\nYou will use Go to run the newt.go program to build the newt tool. The command used is  \ngo build\n which compiles and writes the resulting executable to an output file named \nnewt\n. The \n-o\n option is used to specify a name and path of your choice for the executable. We suggest using \nnewt\n and installing the executable along with its dependencies in $GOPATH/bin. \n\n\nHowever, it does not install the results along with its dependencies in $GOPATH/bin (for that you will need to use \ngo install\n). \n\n\n    $ ~/dev/go/bin/godep restore\n    $ go build -o \"$GOPATH\"/bin/newt\n    $ ls \"$GOPATH\"/bin/\n    godep       incubator-mynewt-newt.git     newt\n\n\n\n\n\nTry running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.\n\n\n\n\nNote: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to store the command in a variable in your .bash_profile. So type in \nexport newt=\"go run $GOPATH/src/github.com/mynewt/newt/newt.go\"\n in your .bash_profile and execute it by calling \n$newt\n at the prompt instead of \nnewt\n. Don't forget to reload the updated bash profile by typing \nsource ~/.bash_profile\n at the prompt! Here, you use \ngo run\n which runs the compiled binary directly without producing an executable.\n\n\n    $ newt version\n    Newt version:  1.0\n    $ newt -h\n    Newt allows you to create your own embedded project based on the Mynewt\n    operating system. Newt provides both build and package management in a\n    single tool, which allows you to compose an embedded workspace, and set\n    of projects, and then build the necessary artifacts from those projects.\n    For more information on the Mynewt operating system, please visit\n    https://www.github.com/mynewt/documentation.\n\n    Please use the newt help command, and specify the name of the command\n    you want help for, for help on how to use a specific command\n\n    Usage:\n     newt [flags]\n     newt [command]\n\n    Examples:\n     newt\n     newt help [\ncommand-name\n]\n       For help on \ncommand-name\n.  If not specified, print this message.\n\n\n    Available Commands:\n     version     Display the Newt version number.\n     target      Set and view target information\n     egg         Commands to list and inspect eggs on a nest\n     nest        Commands to manage nests \n clutches (remote egg repositories)\n     help        Help about any command\n\n    Flags:\n     -h, --help=false: help for newt\n     -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n     -q, --quiet=false: Be quiet; only display error output.\n     -s, --silent=false: Be silent; don't output anything.\n     -v, --verbose=false: Enable verbose output when executing commands.\n\n\n    Use \"newt help [command]\" for more information about a command.\n\n\n\n\n\nWithout creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool. \n\n\n\n\nGetting the debugger ready\n\n\n\n\n\n\nBefore you start building nests and hatching eggs, you need to do one final step in the environment preparation - install gcc / libc that can produce 32-bit executables. So, first install gcc. You will see the brew steps and a final summary confirming install.\n\n\n$ brew install gcc\n...\n...\n==\n Summary\n\ud83c\udf7a  /usr/local/Cellar/gcc/5.2.0: 1353 files, 248M\n\n\n\n\n\n\n\nARM maintains a pre-built GNU toolchain with a GCC source branch targeted at Embedded ARM Processors namely Cortex-R/Cortex-M processor families. Install the PX4 Toolchain and check the version installed. Make sure that the symbolic link installed by Homebrew points to the correct version of the debugger. If not, you can either change the symbolic link using the \"ln -f -s\" command or just go ahead and try with the version it points to!\n\n\n$ brew tap PX4/homebrew-px4\n$ brew update\n$ brew install gcc-arm-none-eabi-49\n$ arm-none-eabi-gcc --version  \narm-none-eabi-gcc (GNU Tools for ARM Embedded Processors) 4.9.3 20150529 (release) [ARM/embedded-4_9-branch revision 224288]\nCopyright (C) 2014 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n$ ls -al /usr/local/bin/arm-none-eabi-gdb\nlrwxr-xr-x  1 aditihilbert  admin  69 Sep 22 17:16 /usr/local/bin/arm-none-eabi-gdb -\n /usr/local/Cellar/gcc-arm-none-eabi-49/20150609/bin/arm-none-eabi-gdb\n\n\n\nNote: If no version is specified, brew will install the latest version available. MynewtOS will eventually work with multiple versions available including the latest releases. However, at present we have tested only with this version and recommend it for getting started. \n\n\n\n\n\n\nYou have to install OpenOCD (Open On-Chip Debugger) which is an open-source software that will allow you to interface with the JTAG debug connector/adaptor for the Olimex board. It lets you program, debug, and test embedded target devices which, in this case, is the Olimex board. Use brew to install it. Brew adds a simlink /usr/local/bin/openocd to the openocd directory in the Cellar. For more on OpenOCD go to \nhttp://openocd.org\n.\n\n\n$ brew install open-ocd\n$ which openocd\n/usr/local/bin/openocd\n$ ls -l $(which openocd)\nlrwxr-xr-x  1 \nuser\n  admin  36 Sep 17 16:22 /usr/local/bin/openocd -\n ../Cellar/open-ocd/0.9.0/bin/openocd\n\n\n\n\n\n\n\nProceed to the \nBuilding test code on simulator\n section.\n\n\n\n\n\n\nGetting your Ubuntu machine Ready\n\n\nGetting an account on GitHub\n\n\n\n\nGet an account on GitHub. Make sure you have joined the \"Newt Operating System\" organization.\n\n\n\n\nInstalling some prerequisites\n\n\n\n\nInstall git, libcurl, and the Go language if you do not have them already.\n$ sudo apt-get install git \n$ sudo apt-get install libcurl4-gnutls-dev \n$ sudo apt-get install golang\n\n\n\n\n\n\n\nCreating local repository\n\n\n\n\n\n\nThe directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:\n\n\n\n\n\n\nsrc contains Go source files organized into packages (one package per directory),\n\n\n\n\n\n\npkg contains package objects, and\n\n\n\n\n\n\nbin contains executable commands.\n\n\n\n\n\n\nThe GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory and then proceed to create the directory for cloning the newt tool repository.\n\n\n$ cd $HOME\n$ mkdir -p dev/go  \n$ cd dev/go\n$ export GOPATH=$PWD\n\n\n\nNote that you need to add export statements to ~/.bashrc (or equivalent) to export variables permanently.\n\n\n\n\n\n\nNext, install godep. Note that the following command produces no output.\n\n\n$ go get github.com/tools/godep\n\n\n\n\n\n\n\nBuilding the newt tool\n\n\n\n\n\n\nYou will now use Go to run the newt.go program to build the newt tool. You will have to use \ngo build\n command which compiles and writes the resulting executable to an output file named \nnewt\n. The \n-o\n option is used to specify a reasonable name such as \nnewt\n for the the resulting executable and install the executable along with its dependencies in $GOPATH/bin. In preparation for the install, you may use the godep command 'restore' to check out listed dependency versions in $GOPATH and link all the necessary files. \n\n\n$ ~/dev/go/bin/godep restore\n$ go build -o \"$GOPATH\"/bin/newt\n$ ls \"$GOPATH\"/bin/\ngodep       incubator-mynewt-newt.git     newt\n\n\n\n\n\n\n\nTry running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.\n\n\n\n\n\n\nNote: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to store the command in a variable in your .bash_profile. So type in \nexport newt=\"go run $GOPATH/src/github.com/mynewt/newt/newt.go\"\n in your ~/.bashrc (or equivalent) and execute it by calling \n$newt\n at the prompt instead of \nnewt\n. Here, you use \ngo run\n which runs the compiled binary directly without producing an executable.\n\n\n    $ go build %GOPATH%/src/github.com/mynewt/newt/newt.go\n    $ cd ~/dev/go/src/github.com/mynewt/newt\n    $ ls\n    Godeps          README.md       coding_style.txt    newt\n    LICENSE         cli         design.txt      newt.go\n    $ newt version\n    Newt version:  1.0\n    $ newt -h\n    Newt allows you to create your own embedded project based on the Mynewt\n    operating system. Newt provides both build and package management in a\n    single tool, which allows you to compose an embedded workspace, and set\n    of projects, and then build the necessary artifacts from those projects.\n    For more information on the Mynewt operating system, please visit\n    https://www.github.com/mynewt/documentation.\n\n    Please use the newt help command, and specify the name of the command\n    you want help for, for help on how to use a specific command\n\n    Usage:\n     newt [flags]\n     newt [command]\n\n    Examples:\n     newt\n     newt help [\ncommand-name\n]\n       For help on \ncommand-name\n.  If not specified, print this message.\n\n\n    Available Commands:\n     version     Display the Newt version number.\n     target      Set and view target information\n     egg         Commands to list and inspect eggs on a nest\n     nest        Commands to manage nests \n clutches (remote egg repositories)\n     help        Help about any command\n\n    Flags:\n     -h, --help=false: help for newt\n     -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n     -q, --quiet=false: Be quiet; only display error output.\n     -s, --silent=false: Be silent; don't output anything.\n     -v, --verbose=false: Enable verbose output when executing commands.\n\n\n    Use \"newt help [command]\" for more information about a command.\n\n\n\n\n\nWithout creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool. \n\n\n\n\nGetting the debugger ready\n\n\n\n\n\n\nBefore you start building nests and hatching eggs, you need to do one final step in the environment preparation - install gcc / libc that can produce 32-bit executables. You can install these as follows: \n\n\n$ sudo apt-get install gcc-multilib libc6-i386\n\n\n\n\n\n\n\nFor the LED project on the Olimex hardware, you have to install gcc for AM 4.9.3.  This package can be installed with apt-get as documented \nhere\n.\n\n\n$ sudo apt-get remove binutils-arm-none-eabi gcc-arm-none-eabi \n$ sudo add-apt-repository ppa:terry.guo/gcc-arm-embedded \n$ sudo apt-get update \n$ sudo apt-get install gcc-arm-none-eabi\n\n\n\n\n\n\n\nAnd finally, you have to install OpenOCD (Open On-Chip Debugger) which is an open-source software that will allow you to interface with the JTAG debug connector/adaptor for the Olimex board. It lets you program, debug, and test embedded target devices which, in this case, is the Olimex board. You have to acquire OpenOCD 0.8.0. \n\n\nIf you are running Ubuntu 15.x, then you are in luck and you can simply run: \n\n\n$ sudo apt-get install openocd\n\n\n\nOther versions of Ubuntu may not have the correct version of openocd available.  In this case, you should download the openocd 0.8.0 package from \nhttps://launchpad.net/ubuntu/vivid/+source/openocd\n. The direct link to the amd64 build is \nhttp://launchpadlibrarian.net/188260097/openocd_0.8.0-4_amd64.deb\n. \n\n\n\n\n\n\nProceed to the \nBuilding test code on simulator\n section.\n\n\n\n\n\n\nGetting your Windows machine Ready\n\n\nGetting an account on GitHub\n\n\n\n\nGet an account on GitHub. Make sure you have joined the \"Newt Operating System\" organization.\n\n\n\n\nInstalling some prerequisites\n\n\n\n\n\n\nYou have to install the following if you do not have them already.  The steps below indicate specific folders where each of these programs should be installed. You can choose different locations, but the remainder of this\ntutorial for a Windows machine assumes the specified folders.    \n\n\n\n\nwin-builds-i686\n\n\nwin-builds-x86_64\n\n\nMSYS\n\n\ngcc for ARM\n\n\nopenocd\n\n\nzadig\n\n\ngit\n\n\n\n\ngo\n\n\n\n\nwin-builds (mingw64) 1.5 for i686\n\n\n\n\nDownload from \nhttp://win-builds.org/doku.php/download_and_installation_from_windows\n. Install at: \"C:\\win-builds-i686\".\n\n\nBe sure to click the i686 option (not x86_64). The defaults for all other options are OK. The installer will want to download a bunch of additional packages. They are not all necessary, but it is simplest to just accept the defaults.\n\n\n\n\nwin-builds (mingw64) 1.5 for x86_64\n\n\n\n\nDownload from \nhttp://win-builds.org/doku.php/download_and_installation_from_windows\n. Install at \"C:\\win-builds-x86_64\"\n\n\nRun the installer a second time, but this time click the x86_64 option, NOT i686.  The defaults for all other options are OK.\n\n\n\n\nMSYS\n\n\n\n\nStart your download from \nhttp://sourceforge.net/projects/mingw-w64/files/External%20binary%20packages%20%28Win64%20hosted%29/MSYS%20%2832-bit%29/MSYS-20111123.zip\n\n\nUnzip to \"C:\\msys\"\n\n\n\n\ngcc for ARM, 4.9.3\n\n\n\n\nDownload the Windows installer from \nhttps://launchpad.net/gcc-arm-embedded/+download\n and install at \"C:\\Program Files (x86)\\GNU Tools ARM Embedded\\4.9 2015q3\".\n\n\n\n\nOpenOCD 0.8.0\n\n\n\n\nDownload OpenOCD 0.8.0 from \nhttp://www.freddiechopin.info/en/download/category/4-openocd\n. Unzip to \"C:\\openocd\".\n\n\n\n\nZadig 2.1.2\n\n\n\n\nDownload it from \nhttp://zadig.akeo.ie\n and install it at \"C:\\zadig\".\n\n\n\n\nGit\n\n\n\n\nClick on \nhttps://git-scm.com/download/win\n to start the download. Install at \"C:\\Program Files (x86)\\Git\". Specify the \"Use Git from the Windows Command Prompt\" option.  The defaults for all other options are OK.\n\n\n\n\nGo\n\n\n\n\nDownload the release for Microsoft Windows from \nhttps://golang.org/dl/\n and install it \"C:\\Go\".\n\n\n\n\n\n\n\n\n\n\nCreating local repository\n\n\n\n\n\n\nThe directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:\n\n\n\n\n\n\nsrc contains Go source files organized into packages (one package per directory),\n\n\n\n\n\n\npkg contains package objects, and\n\n\n\n\n\n\nbin contains executable commands.\n\n\n\n\n\n\nThe GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory and then proceed to create the directory for cloning the newt tool repository.\n\n\n$ cd c:\\\n$ mkdir dev\\go\n$ cd dev\\go\n\n\n\n\n\n\n\nSet the following user environment variables using the steps outlined here.\n\n\n\n\nGOPATH: C:\\dev\\go\n\n\nPATH: C:\\Program Files (x86)\\GNU Tools ARM Embedded\\4.9 2015q3\\bin;%GOPATH%\\bin;C:\\win-builds-x86_64\\bin;C:\\win-builds-i686\\bin;C:\\msys\\bin\n\n\n\n\nSteps:\n\n\n\n\nRight-click the start button\n\n\nClick \"Control panel\"\n\n\nClick \"System and Security\"\n\n\nClick \"System\"\n\n\nClick \"Advanced system settings\" in the left panel\n\n\nClick the \"Envoronment Variables...\" button\n\n\nThere will be two sets of environment variables: user variables\n  in the upper half of the screen, and system variables in the lower\n  half.  Configuring the user variables is recommended and tested \n  (though system variables will work as well).\n\n\n\n\n\n\n\n\nNext, install godep. Note that the following command produces no output.\n\n\n$ go get github.com/tools/godep\n\n\n\n\n\n\n\nSet up the repository for the package building tool \"newt\" on your local machine. First create the appropriate directory for it and then clone the newt tool repository from the online apache repository (or its github.com mirror) into this newly created directory. Check the contents of the directory.\n\n\n$ mkdir %GOPATH%\\src\\github.com\\mynewt\n$ cd %GOPATH%\\src\\github.com\\mynewt\n$ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git newt\n$ ls\nnewt\n$ cd newt\n$ ls\nGodeps                  README.md               coding_style.txt        newt.go\nLICENSE                 cli                     design.txt\n\n\n\n\n\n\n\nUse the Go command 'install' to compile and install packages and dependencies. Add Go environment to path. Again, to make the export variable permanent, add it to your ~/.bashrc (or equivalent) file.\n\n\n$ %GOPATH%\\bin\\godep restore \n$ go get \n$ go install\n\n\n\n\n\n\n\nBuilding the newt tool\n\n\n\n\n\n\nYou will now use Go to run the newt.go program to build the newt tool. You will have to use \ngo build\n command which compiles and writes the resulting executable to an output file named \nnewt\n. However, it does not install the results along with its dependencies in $GOPATH/bin (for that you will need to use \ngo install\n). Now try running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.\n\n\nNote: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to define the newt environment variable that allows you to execute the command via \n%newt%\n. Use \nset newt=go run %GOPATH%\\src\\github.com\\mynewt\\newt\\newt.go\n or set it from the GUI. Here, you use \ngo run\n which runs the compiled binary directly without producing an executable.\n\n\n$ go build %GOPATH%\\src\\github.com\\mynewt\\newt\\newt.go\n$ cd ~/dev/go/src/github.com/mynewt/newt\n$ dir\nGodeps          README.md       coding_style.txt    newt\nLICENSE         cli         design.txt      newt.go\n$ newt version\nNewt version:  1.0\n$ newt -h\nNewt allows you to create your own embedded project based on the Mynewt\noperating system. Newt provides both build and package management in a\nsingle tool, which allows you to compose an embedded workspace, and set\nof projects, and then build the necessary artifacts from those projects.\nFor more information on the Mynewt operating system, please visit\nhttps://www.github.com/mynewt/documentation.\n\nPlease use the newt help command, and specify the name of the command\nyou want help for, for help on how to use a specific command\n\nUsage:\n newt [flags]\n newt [command]\n\nExamples:\n newt\n newt help [\ncommand-name\n]\n   For help on \ncommand-name\n.  If not specified, print this message.\n\nAvailable Commands:\n version     Display the Newt version number.\n target      Set and view target information\n egg         Commands to list and inspect eggs on a nest\n nest        Commands to manage nests \n clutches (remote egg repositories)\n help        Help about any command\n\nFlags:\n -h, --help=false: help for newt\n -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n -q, --quiet=false: Be quiet; only display error output.\n -s, --silent=false: Be silent; don't output anything.\n -v, --verbose=false: Enable verbose output when executing commands.\n\nUse \"newt help [command]\" for more information about a command.\n\n\n\n\n\n\n\nWithout creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool. \n\n\n\n\n\n\nGetting the debugger ready\n\n\n\n\n\n\nUse Zadig to configure the USB driver for your Olimex debugger.  If your debugger is already set up, you can skip this step.\n\n\n\n\nPlug in your Olimex debugger.\n\n\nStart Zadig.\n\n\nCheck the Options -\n List All Devices checkbox.\n\n\nSelect \"Olimex OpenOCD JTAG ARM-USB-TINY-H\" in the dropdown menu.\n\n\nSelect the \"WinUSB\" driver.\n\n\nClick the \"Install Driver\" button.\n\n\n\n\n\n\n\n\nProceed to the \nBuilding test code on simulator on Windows machine\n section.\n\n\nNote: Currently, the simulator cannot be run in the Windows machine. We are still working on it. So you will go ahead and \nmake an LED blink\n on the Olimex hardware directly. \n\n\nHowever, before you skip to the hardware target, you still need to build your first nest as outlined in step 1 in the \nBuilding test code on simulator\n.\n\n\nBuilding test code on simulator\n\n\nNote: Currently, the simulator cannot be run in the Windows machine. We are working on it. If you are on a Windows machine, do step 1 below and then proceed to the \nMaking an LED blink\n on the Olimex hardware directly.\n\n\n\n\n\n\nFirst, you have to create a repository for the project i.e. build your first nest! Go to ~/dev and clone the larva repository from the apache git repository into a local directory named \nlarva\n.\n\n\nSubstitute DOS commands for Unix commands as necessary in the following steps if your machine is running Windows. The newt tool commands do not change.\n\n\n$ cd ~/dev \n$ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git larva\n$ ls\ngo  larva\n$ cd larva\n$ ls\nLICENSE     clutch.yml  hw      nest.yml      project\nREADME.md   compiler    libs        net       scripts\n\n\n\n\n\n\n\nYou will now create a new target using the newt tool. You can either use the compiled binary \nnewt\n or run the newt.go program using \n$newt\n (assuming you have stored the command in a variable in your .bash_profile or .bashrc). When you do a \nnewt target show\n or \n$newt target show\n it should list all the projects you have created so far. \n\n\n$ newt target create sim_test\nCreating target sim_test\nTarget sim_test sucessfully created!\n$ newt target show\nsim_test\n    name: sim_test\n    arch: sim\n\n\n\n\n\n\n\nNow continue to populate and build out the sim project.\n\n\n$ newt target set sim_test project=test\nTarget sim_test successfully set project to test\n$ newt target set sim_test compiler_def=debug\nTarget sim_test successfully set compiler_def to debug\n$ newt target set sim_test bsp=hw/bsp/native\nTarget sim_test successfully set bsp to hw/bsp/native\n$ newt target set sim_test compiler=sim\nTarget sim_test successfully set compiler to sim\n$ newt target show sim_test\nsim_test\n    arch: sim\n    project: test\n    compiler_def: debug\n    bsp: hw/bsp/native\n    compiler: sim\n    name: sim_test\n\n\n\n\n\n\n\nConfigure newt to use the gnu build tools native to OS X or linux. In order for sim to work properly, it needs to be using 32-bit gcc (gcc-5). Replace \n~/dev/larva/compiler/sim/compiler.yml with the compiler/sim/osx-compiler.yml or linux-compiler.yml file, depending on the system. \n\n\nFor a Mac OS X environment:\n\n\n$ cp compiler/sim/osx-compiler.yml compiler/sim/compiler.yml\n\n\n\nFor a Linux machine:\n\n\n$ cp compiler/sim/linux-compiler.yml compiler/sim/compiler.yml\n\n\n\n\n\n\n\nNext, create (hatch!) the eggs for this project using the newt tool - basically, build the packages for it. You can specify the VERBOSE option if you want to see the gory details. \n\n\n$ $newt target build sim_test\nSuccessfully run!\n\n\n\nYou can specify the VERBOSE option if you want to see the gory details.\n\n\n$newt -l VERBOSE target build sim_test\n2015/09/29 09:46:12 [INFO] Building project test\n2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//bootutil...\n2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//cmsis-core...\n2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//ffs..\n...\nSuccessfully run!\n\n\n\n\n\n\n\nTry running the test suite executable inside this project and enjoy your first successful hatch.\n\n\n$ ./project/test/bin/sim_test/test.elf\n[pass] os_mempool_test_suite/os_mempool_test_case\n[pass] os_mutex_test_suite/os_mutex_test_basic\n[pass] os_mutex_test_suite/os_mutex_test_case_1\n[pass] os_mutex_test_suite/os_mutex_test_case_2\n[pass] os_sem_test_suite/os_sem_test_basic\n[pass] os_sem_test_suite/os_sem_test_case_1\n[pass] os_sem_test_suite/os_sem_test_case_2\n[pass] os_sem_test_suite/os_sem_test_case_3\n[pass] os_sem_test_suite/os_sem_test_case_4\n[pass] os_mbuf_test_suite/os_mbuf_test_case_1\n[pass] os_mbuf_test_suite/os_mbuf_test_case_2\n[pass] os_mbuf_test_suite/os_mbuf_test_case_3\n[pass] gen_1_1/ffs_test_unlink\n[pass] gen_1_1/ffs_test_rename\n[pass] gen_1_1/ffs_test_truncate\n[pass] gen_1_1/ffs_test_append\n[pass] gen_1_1/ffs_test_read\n[pass] gen_1_1/ffs_test_overwrite_one\n[pass] gen_1_1/ffs_test_overwrite_two\n[pass] gen_1_1/ffs_test_overwrite_three\n...\n...\n[pass] boot_test_main/boot_test_vb_ns_11\n\n\n\n\n\n\n\nBuilding test code on simulator on Windows machine\n\n\nComing soon.\n\n\nMaking an LED blink from SRAM\n\n\nYou are here because you want to build an image to be run from internal SRAM on the Olimex board.\n\n\nPreparing the Software\n\n\n\n\n\n\nMake sure the PATH environment variable includes the $HOME/dev/go/bin directory (or C:\\%GOPATH%\\bin on Windows machine). \n\n\nSubstitute DOS commands for Unix commands as necessary in the following steps if your machine is running Windows (e.g. \ncd dev\\go\n instead of \ncd dev/go\n). The newt tool commands do not change.\n\n\n\n\n\n\nYou first have to create a repository for the project. Go to the ~dev/larva directory and build out a second project inside larva. The project name is \"blinky\", in keeping with the objective. Starting with the target name, you have to specify the different aspects of the project to pull the appropriate eggs and build the right package for the board. In this case that means setting the architecture (arch), compiler, board support package (bsp), project, and compiler mode.\n\n\n$ newt target create blinky\nCreating target blinky\nTarget blinky sucessfully created!\n$ newt target set blinky arch=cortex_m4\nTarget blinky successfully set arch to arm\n$ newt target set blinky compiler=arm-none-eabi-m4\nTarget blinky successfully set compiler to arm-none-eabi-m4\n$ newt target set blinky project=blinky\nTarget blinky successfully set project to blinky\n$ newt target set blinky compiler_def=debug\nTarget blinky successfully set compiler_def to debug\n$ newt target set blinky bsp=hw/bsp/olimex_stm32-e407_devboard\nTarget blinky successfully set bsp to hw/bsp/olimex_stm32-e407_devboard\n$ newt target show blinky\nblinky\n    compiler: arm-none-eabi-m4\n    project: blinky\n    compiler_def: debug\n    bsp: hw/bsp/olimex_stm32-e407_devboard\n    name: blinky\n    arch: cortex_m4\n\n\n\n\n\n\n\nNow you have to build the image. The linker script within the \nhw/bsp/olimex_stm32-e407_devboard\n egg builds an image for flash memory by default. Since you want an image for the SRAM, you need to switch that script with \nrun_from_sram.ld\n in order to get the egg to produce an image for SRAM. \n We are working on making it easier to specify where the executable will be run from for a particular project and automatically choose the correct linker scripts and generate the appropriate image. It will be specified as a project identity e.g. bootloader, RAM, flash (default) and the target will build accordingly. \n. \n\n\nOnce the target is built, you can find the executable \"blinky.elf\" in the project directory at ~/dev/larva/project/blinky/bin/blinky. It's a good idea to take a little time to understand the directory structure.\n\n\n$ cd ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n$ diff olimex_stm32-e407_devboard.ld run_from_sram.ld\n$ cp run_from_sram.ld olimex_stm32-e407_devboard.ld\n$ cd ~/dev/larva/project/blinky/bin/blinky\n$ newt target build blinky\nBuilding target blinky (project = blinky)\nCompiling case.c\nCompiling suite.c\n...\nSuccessfully run!\n$ ls\nLICENSE     clutch.yml  hw      nest.yml    project\nREADME.md   compiler    libs        net     scripts\n$ cd project\n$ ls\nbin2img     bletest     blinky      boot        ffs2native  test\n$ cd blinky\n$ ls\nbin     blinky.yml  egg.yml     src\n$ cd bin\n$ ls\nblinky\n$ cd blinky\n$ ls\nblinky.elf  blinky.elf.bin  blinky.elf.cmd  blinky.elf.lst  blinky.elf.map\n\n\n\n\n\n\n\nCheck that you have all the scripts needed to get OpenOCD up and talking with the project's specific hardware. Depending on your system (Ubuntu, Windows) you may already have the scripts in your \n/usr/share/openocd/scripts/\n directory as they may have been part of the openocd download. If yes, you are all set and can proceed to preparing the hardware.\n\n\n\n\n\n\nOtherwise check the \n~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n directory for a file named \nf407.cfg\n. That is the config we will use to talk to this specific hardware using OpenOCD. You are all set if you see it.\n\n\n    $ ls ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n    bin                 olimex_stm32-e407_devboard_debug.sh\n    boot-olimex_stm32-e407_devboard.ld  olimex_stm32-e407_devboard_download.sh\n    egg.yml                 run_from_flash.ld\n    f407.cfg                run_from_loader.ld\n    include                 run_from_sram.ld\n    olimex_stm32-e407_devboard.ld       src\n\n\n\nPreparing the hardware to boot from embedded SRAM\n\n\n\n\n\n\nLocate the boot jumpers on the board.\n\n\n\n\n\n\n\n\n\nB1_1/B1_0 and B0_1/B0_0 are PTH jumpers which can be moved relatively easy. Note that the markings on the board may not always be accurate. Always refer to the manual for the correct positioning of jumpers in case of doubt. The two jumpers must always be moved together \u2013 they are responsible for the boot mode if bootloader is present. The board can search for bootloader on three places \u2013 User Flash Memory, System Memory or the Embedded SRAM. We will configure it to boot from SRAM by jumpering B0_1 and B1_1.\n\n\n\n\n\n\nConnect USB-OTG#2 in the picture above to a USB port on your computer (or a powered USB hub to make sure there is enough power available to the board). \n\n\n\n\n\n\nThe red PWR LED should be lit. \n\n\n\n\n\n\nConnect the JTAG connector to the SWD/JTAG interface on the board. The other end of the cable should be connected to the USB port or hub of your computer.\n\n\n\n\n\n\nLet's Go!\n\n\n\n\n\n\nMake sure you are in the blinky project directory with the blinky.elf executable. Run the debug command in the newt tool. You should see some status messages are shown below. There is an inbuilt \n-c \"reset halt\"\n flag that tells it to halt after opening the session.\n\n\n$ cd dev/larva/project/blinky/bin/blinky\n$ newt target debug blinky\nDebugging with /Users/aditihilbert/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_debug.sh blinky\nDebugging /Users/aditihilbert/dev/larva/project/blinky/bin/blinky/blinky.elf\nGNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later \nhttp://gnu.org/licenses/gpl.html\n\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"--host=x86_64-apple-darwin10 --target=arm-none-eabi\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n\nhttp://www.gnu.org/software/gdb/bugs/\n.\nFind the GDB manual and other documentation resources online at:\n\nhttp://www.gnu.org/software/gdb/documentation/\n.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from /Users/aditihilbert/dev/larva/project/blinky/bin/        blinky/blinky.elf...done.\nOpen On-Chip Debugger 0.8.0 (2015-09-22-18:21)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.sourceforge.net/doc/doxygen/bugs.html\nInfo : only one transport option; autoselect 'jtag'\nadapter speed: 1000 kHz\nadapter_nsrst_delay: 100\njtag_ntrst_delay: 100\nWarn : target name is deprecated use: 'cortex_m'\nDEPRECATED! use 'cortex_m' not 'cortex_m3'\ncortex_m reset_config sysresetreq\nInfo : clock speed 1000 kHz\nInfo : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\nInfo : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\nInfo : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints\nInfo : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\nInfo : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\ntarget state: halted\ntarget halted due to debug-request, current mode: Thread \nxPSR: 0x01000000 pc: 0x20000250 msp: 0x10010000\nInfo : accepting 'gdb' connection from 3333\nInfo : device id = 0x10036413\nInfo : flash size = 1024kbytes\nReset_Handler () at startup_STM32F40x.s:199\n199     ldr    r1, =__etext\n\n\n\nCheck the value of the msp (main service pointer) register. If it is not 0x10010000 as indicated above, you will have to manually set it after you open the gdp tool and load the image on it. \n\n\n(gdb) set $msp=0x10010000\n\n\n\nNow load the image and type \"c\" or \"continue\" from the GNU debugger. \n\n\n(gdb) load ~/dev/larva/project/blinky/bin/blinky/blinky.elf\nLoading section .text, size 0x4294 lma 0x20000000\nLoading section .ARM.extab, size 0x24 lma 0x20004294\nLoading section .ARM.exidx, size 0xd8 lma 0x200042b8\nLoading section .data, size 0x874 lma 0x20004390\nStart address 0x20000250, load size 19460\nTransfer rate: 81 KB/sec, 2432 bytes/write.\n(gdb) c\nContinuing.\n\n\n\n\n\n\n\nVoil\u00e0! The board's LED should be blinking at 1 Hz.\n\n\n\n\n\n\nUsing flash to make LED blink\n\n\nYou are here because you want to build an image to be run from flash memory on the Olimex board.\n\n\n\n\nConfigure the board to boot from flash by moving the two jumpers together to B0_0 and B1_0. \n\n\n\n\nYou will have to reset the board once the image is uploaded to it.\n\n\n\n\n\n\nBy now you know that you have to build a new package that will run from flash. First, the olimex_stm32-e407_devboard.ld linker script which was previously made the same as run_from_sram.ld will now need the contents of run_from_flash.ld. Then the target has to be rebuilt. \n\n\n$ cd ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n$ diff olimex_stm32-e407_devboard.ld run_from_sram.ld\n$ cp run_from_flash.ld olimex_stm32-e407_devboard.ld\n$ cd ~/dev/larva/project/blinky/bin/blinky\n$ newt target build blinky\n\n\n\n\n\n\n\nGo to the project directory and download the image to flash ... in a flash! \n\n\n$ cd ~/dev/larva/project/blinky/bin/blinky\n$ newt target download blinky\nDownloading with ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_download.sh\n\n\n\n\n\n\n\nThe LED should be blinking!\n\n\n\n\n\n\nBut wait...let's double check that it is indeed booting from flash and making the LED blink from the image in flash. Pull the USB cable off the Olimex JTAG adaptor. The debug connection to the JTAG port is now severed. Next power off the Olimex board by pulling out the USB cable from the board. Wait for a couple of seconds and plug the USB cable back to the board. \n\n\nThe LED light will start blinking again. Success!\n\n\nNote #1: If you want to download the image to flash and a gdb session opened up, use \nnewt target debug blinky\n instead of \nnewt target download blinky\n.\n\n\n$ newt target debug blinky\nDebugging with ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_debug.sh blinky\nDebugging ~/dev/larva/project/blinky/bin/blinky/blinky.elf\nGNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later \nhttp://gnu.org/licenses/gpl.html\n\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"--host=x86_64-apple-darwin10 --target=arm-none-eabi\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n\nhttp://www.gnu.org/software/gdb/bugs/\n.\nFind the GDB manual and other documentation resources online at:\n\nhttp://www.gnu.org/software/gdb/documentation/\n.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from /Users/aditihilbert/dev/larva/project/blinky/bin/blinky/blinky.elf...done.\nOpen On-Chip Debugger 0.8.0 (2015-09-22-18:21)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.sourceforge.net/doc/doxygen/bugs.html\nInfo : only one transport option; autoselect 'jtag'\nadapter speed: 1000 kHz\nadapter_nsrst_delay: 100\njtag_ntrst_delay: 100\nWarn : target name is deprecated use: 'cortex_m'\nDEPRECATED! use 'cortex_m' not 'cortex_m3'\ncortex_m reset_config sysresetreq\nInfo : clock speed 1000 kHz\nInfo : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\nInfo : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\nInfo : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints\nInfo : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\nInfo : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\ntarget state: halted\ntarget halted due to debug-request, current mode: Thread \nxPSR: 0x01000000 pc: 0x08000250 msp: 0x10010000\nInfo : accepting 'gdb' connection from 3333\nInfo : device id = 0x10036413\nInfo : flash size = 1024kbytes\nReset_Handler () at startup_STM32F40x.s:199\n199     ldr    r1, =__etext\n(gdb)\n\n\n\nNote #2: If you want to erase the flash and load the image again you may use the following commands from within gdb. \nflash erase_sector 0 0 x\n tells it to erase sectors 0 through x. When you ask it to display (in hex notation) the contents of the sector starting at location 'lma' you should therefore see all f's. The memory location 0x8000000 is the start or origin of the flash memory contents and is specified in the olimex_stm32-e407_devboard.ld linker script. The flash memory locations is specific to the processor.\n\n\n(gdb) monitor flash erase_sector 0 0 4\nerased sectors 0 through 4 on flash bank 0 in 2.296712s\n(gdb) x/32wx 0x8000000 \n0x8000000 \n__isr_vector\n:   0xffffffff  0xffffffff 0xffffffff 0xffffffff \n0x8000010 \n__isr_vector+16\n:    0xffffffff 0xffffffff 0xffffffff 0xffffffff\n...", 
            "title": "Blinky, The First Project"
        }, 
        {
            "location": "/chapter1/project1/#blinky-the-first-project", 
            "text": "Objective  We will show you how you can use eggs from a nest on Mynewt to make an LED on a target board blink. We will call it   Project Blinky . The goals of this tutorial are threefold:   First, you will learn how to set up your environment to be ready to use Mynewt OS and newt tool.   Second, we will walk you through a download of eggs for building and testing  on a simulated target  on a non-Windows machine.  Third, you will download eggs and use tools to create a runtime image for a board to make its LED blink. You have two choices here - you can  download an image to SRAM  or you can  download it to flash .    Time Requirement : Allow yourself a couple of hours for this project if you are relatively new to embedded systems and playing with development boards. Those jumpers can be pesky!  What you need   STM32-E407 development board from Olimex. You can order it from  http://www.mouser.com ,  http://www.digikey.com , and other places.  ARM-USB-TINY-H connector with JTAG interface for debugging ARM microcontrollers (comes with the ribbon cable to hook up to the board)  USB A-B type cable to connect the debugger to your personal computer  Personal Computer   The instructions assume the user is using a Bourne-compatible shell (e.g. bash or zsh) on your computer. You may already have some of the required packages on your machine.  In that \ncase, simply skip the corresponding installation step in the instructions under  Getting your Mac Ready  or  Getting your Ubuntu machine Ready  or  Getting your Windows machine Ready . While the given instructions should work on other versions, they have been tested for the three specific releases of operating systems noted here:   Mac: OS X Yosemite Version 10.10.5  Linux: Ubuntu 14.10 (Utopic Unicorn)  Windows: Windows 10   Access to the Apache repo    Get an account on Apache.     The latest codebase for the Mynewt OS is on the master branch at  https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git    The latest codebase for the Newt tool is on the master branch at  https://git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git    Getting your Mac Ready  Installing Homebrew to ease installs on OS X    Do you have Homebrew? If not, open a terminal on your Mac and paste the following at a Terminal prompt. It will ask you for your sudo password.  $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"  Alternatively, you can just extract (or  git clone ) Homebrew and install it to  /usr/local .    Installing Go    The directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:    src contains Go source files organized into packages (one package per directory),    pkg contains package objects, and    bin contains executable commands.    The GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory and then proceed to create the directory for cloning the newt tool repository.  $ cd $HOME\n$ mkdir -p dev/go  \n$ cd dev/go\n$ export GOPATH=`pwd`  Note that you need to add export statements to ~/.bash_profile to export variables permanently. Don't forget to source the file for the change to go into effect.  $ vi ~/.bash_profile\n$ source ~/.bash_profile    Next you will use brew to install Go. The summary message at the end of the installation should indicate that it is installed in the /usr/local/Cellar/go/ directory. You will use the Go command 'install' to compile and install packages (called eggs in the Mynewt world) and dependencies.   $ brew install go\n==  \n...\n... \n==  *Summary*\n\ud83c\udf7a  /usr/local/Cellar/go/1.5.1: 5330 files, 273M  Alternatively, you can download the Go package directly from (https://golang.org/dl/) instead of brewing it. Install it in /usr/local directory.    You will now get the godep package. Make sure you are at the Go directory level and get godep. Check for it in the bin subdirectory. Add the Go environment to path. Make sure it is added to your .bash_profile.  $ cd $GOPATH\n$ go get github.com/tools/godep\n$ ls src/github.com/tools/\ngodep\n$ export PATH=$PATH:$GOPATH/bin    Creating local repository    You are ready to download the newt tool repository. You will use Go to copy the directory (currently the asf incubator directory). Be patient as it may take a minute or two. Check the directories installed.  $  go get git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git\n$ $ ls\n bin    pkg    src\n$ ls src\ngit-wip-us.apache.org   github.com      gopkg.in    Check that newt is installed.  $ ls $GOPATH/src/git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git  \nGodeps          README.md       coding_style.txt    newt.go\nLICENSE         cli             design.txt    Building the Newt tool   In preparation for the install, you use the godep command 'restore' to check out listed dependency versions in $GOPATH and link all the necessary files.    You will use Go to run the newt.go program to build the newt tool. The command used is   go build  which compiles and writes the resulting executable to an output file named  newt . The  -o  option is used to specify a name and path of your choice for the executable. We suggest using  newt  and installing the executable along with its dependencies in $GOPATH/bin.   However, it does not install the results along with its dependencies in $GOPATH/bin (for that you will need to use  go install ).       $ ~/dev/go/bin/godep restore\n    $ go build -o \"$GOPATH\"/bin/newt\n    $ ls \"$GOPATH\"/bin/\n    godep       incubator-mynewt-newt.git     newt   Try running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.   Note: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to store the command in a variable in your .bash_profile. So type in  export newt=\"go run $GOPATH/src/github.com/mynewt/newt/newt.go\"  in your .bash_profile and execute it by calling  $newt  at the prompt instead of  newt . Don't forget to reload the updated bash profile by typing  source ~/.bash_profile  at the prompt! Here, you use  go run  which runs the compiled binary directly without producing an executable.      $ newt version\n    Newt version:  1.0\n    $ newt -h\n    Newt allows you to create your own embedded project based on the Mynewt\n    operating system. Newt provides both build and package management in a\n    single tool, which allows you to compose an embedded workspace, and set\n    of projects, and then build the necessary artifacts from those projects.\n    For more information on the Mynewt operating system, please visit\n    https://www.github.com/mynewt/documentation.\n\n    Please use the newt help command, and specify the name of the command\n    you want help for, for help on how to use a specific command\n\n    Usage:\n     newt [flags]\n     newt [command]\n\n    Examples:\n     newt\n     newt help [ command-name ]\n       For help on  command-name .  If not specified, print this message.\n\n\n    Available Commands:\n     version     Display the Newt version number.\n     target      Set and view target information\n     egg         Commands to list and inspect eggs on a nest\n     nest        Commands to manage nests   clutches (remote egg repositories)\n     help        Help about any command\n\n    Flags:\n     -h, --help=false: help for newt\n     -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n     -q, --quiet=false: Be quiet; only display error output.\n     -s, --silent=false: Be silent; don't output anything.\n     -v, --verbose=false: Enable verbose output when executing commands.\n\n\n    Use \"newt help [command]\" for more information about a command.   Without creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool.    Getting the debugger ready    Before you start building nests and hatching eggs, you need to do one final step in the environment preparation - install gcc / libc that can produce 32-bit executables. So, first install gcc. You will see the brew steps and a final summary confirming install.  $ brew install gcc\n...\n...\n==  Summary\n\ud83c\udf7a  /usr/local/Cellar/gcc/5.2.0: 1353 files, 248M    ARM maintains a pre-built GNU toolchain with a GCC source branch targeted at Embedded ARM Processors namely Cortex-R/Cortex-M processor families. Install the PX4 Toolchain and check the version installed. Make sure that the symbolic link installed by Homebrew points to the correct version of the debugger. If not, you can either change the symbolic link using the \"ln -f -s\" command or just go ahead and try with the version it points to!  $ brew tap PX4/homebrew-px4\n$ brew update\n$ brew install gcc-arm-none-eabi-49\n$ arm-none-eabi-gcc --version  \narm-none-eabi-gcc (GNU Tools for ARM Embedded Processors) 4.9.3 20150529 (release) [ARM/embedded-4_9-branch revision 224288]\nCopyright (C) 2014 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n$ ls -al /usr/local/bin/arm-none-eabi-gdb\nlrwxr-xr-x  1 aditihilbert  admin  69 Sep 22 17:16 /usr/local/bin/arm-none-eabi-gdb -  /usr/local/Cellar/gcc-arm-none-eabi-49/20150609/bin/arm-none-eabi-gdb  Note: If no version is specified, brew will install the latest version available. MynewtOS will eventually work with multiple versions available including the latest releases. However, at present we have tested only with this version and recommend it for getting started.     You have to install OpenOCD (Open On-Chip Debugger) which is an open-source software that will allow you to interface with the JTAG debug connector/adaptor for the Olimex board. It lets you program, debug, and test embedded target devices which, in this case, is the Olimex board. Use brew to install it. Brew adds a simlink /usr/local/bin/openocd to the openocd directory in the Cellar. For more on OpenOCD go to  http://openocd.org .  $ brew install open-ocd\n$ which openocd\n/usr/local/bin/openocd\n$ ls -l $(which openocd)\nlrwxr-xr-x  1  user   admin  36 Sep 17 16:22 /usr/local/bin/openocd -  ../Cellar/open-ocd/0.9.0/bin/openocd    Proceed to the  Building test code on simulator  section.    Getting your Ubuntu machine Ready  Getting an account on GitHub   Get an account on GitHub. Make sure you have joined the \"Newt Operating System\" organization.   Installing some prerequisites   Install git, libcurl, and the Go language if you do not have them already. $ sudo apt-get install git \n$ sudo apt-get install libcurl4-gnutls-dev \n$ sudo apt-get install golang    Creating local repository    The directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:    src contains Go source files organized into packages (one package per directory),    pkg contains package objects, and    bin contains executable commands.    The GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory and then proceed to create the directory for cloning the newt tool repository.  $ cd $HOME\n$ mkdir -p dev/go  \n$ cd dev/go\n$ export GOPATH=$PWD  Note that you need to add export statements to ~/.bashrc (or equivalent) to export variables permanently.    Next, install godep. Note that the following command produces no output.  $ go get github.com/tools/godep    Building the newt tool    You will now use Go to run the newt.go program to build the newt tool. You will have to use  go build  command which compiles and writes the resulting executable to an output file named  newt . The  -o  option is used to specify a reasonable name such as  newt  for the the resulting executable and install the executable along with its dependencies in $GOPATH/bin. In preparation for the install, you may use the godep command 'restore' to check out listed dependency versions in $GOPATH and link all the necessary files.   $ ~/dev/go/bin/godep restore\n$ go build -o \"$GOPATH\"/bin/newt\n$ ls \"$GOPATH\"/bin/\ngodep       incubator-mynewt-newt.git     newt    Try running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.    Note: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to store the command in a variable in your .bash_profile. So type in  export newt=\"go run $GOPATH/src/github.com/mynewt/newt/newt.go\"  in your ~/.bashrc (or equivalent) and execute it by calling  $newt  at the prompt instead of  newt . Here, you use  go run  which runs the compiled binary directly without producing an executable.      $ go build %GOPATH%/src/github.com/mynewt/newt/newt.go\n    $ cd ~/dev/go/src/github.com/mynewt/newt\n    $ ls\n    Godeps          README.md       coding_style.txt    newt\n    LICENSE         cli         design.txt      newt.go\n    $ newt version\n    Newt version:  1.0\n    $ newt -h\n    Newt allows you to create your own embedded project based on the Mynewt\n    operating system. Newt provides both build and package management in a\n    single tool, which allows you to compose an embedded workspace, and set\n    of projects, and then build the necessary artifacts from those projects.\n    For more information on the Mynewt operating system, please visit\n    https://www.github.com/mynewt/documentation.\n\n    Please use the newt help command, and specify the name of the command\n    you want help for, for help on how to use a specific command\n\n    Usage:\n     newt [flags]\n     newt [command]\n\n    Examples:\n     newt\n     newt help [ command-name ]\n       For help on  command-name .  If not specified, print this message.\n\n\n    Available Commands:\n     version     Display the Newt version number.\n     target      Set and view target information\n     egg         Commands to list and inspect eggs on a nest\n     nest        Commands to manage nests   clutches (remote egg repositories)\n     help        Help about any command\n\n    Flags:\n     -h, --help=false: help for newt\n     -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n     -q, --quiet=false: Be quiet; only display error output.\n     -s, --silent=false: Be silent; don't output anything.\n     -v, --verbose=false: Enable verbose output when executing commands.\n\n\n    Use \"newt help [command]\" for more information about a command.   Without creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool.    Getting the debugger ready    Before you start building nests and hatching eggs, you need to do one final step in the environment preparation - install gcc / libc that can produce 32-bit executables. You can install these as follows:   $ sudo apt-get install gcc-multilib libc6-i386    For the LED project on the Olimex hardware, you have to install gcc for AM 4.9.3.  This package can be installed with apt-get as documented  here .  $ sudo apt-get remove binutils-arm-none-eabi gcc-arm-none-eabi \n$ sudo add-apt-repository ppa:terry.guo/gcc-arm-embedded \n$ sudo apt-get update \n$ sudo apt-get install gcc-arm-none-eabi    And finally, you have to install OpenOCD (Open On-Chip Debugger) which is an open-source software that will allow you to interface with the JTAG debug connector/adaptor for the Olimex board. It lets you program, debug, and test embedded target devices which, in this case, is the Olimex board. You have to acquire OpenOCD 0.8.0.   If you are running Ubuntu 15.x, then you are in luck and you can simply run:   $ sudo apt-get install openocd  Other versions of Ubuntu may not have the correct version of openocd available.  In this case, you should download the openocd 0.8.0 package from  https://launchpad.net/ubuntu/vivid/+source/openocd . The direct link to the amd64 build is  http://launchpadlibrarian.net/188260097/openocd_0.8.0-4_amd64.deb .     Proceed to the  Building test code on simulator  section.    Getting your Windows machine Ready  Getting an account on GitHub   Get an account on GitHub. Make sure you have joined the \"Newt Operating System\" organization.   Installing some prerequisites    You have to install the following if you do not have them already.  The steps below indicate specific folders where each of these programs should be installed. You can choose different locations, but the remainder of this\ntutorial for a Windows machine assumes the specified folders.       win-builds-i686  win-builds-x86_64  MSYS  gcc for ARM  openocd  zadig  git   go   win-builds (mingw64) 1.5 for i686   Download from  http://win-builds.org/doku.php/download_and_installation_from_windows . Install at: \"C:\\win-builds-i686\".  Be sure to click the i686 option (not x86_64). The defaults for all other options are OK. The installer will want to download a bunch of additional packages. They are not all necessary, but it is simplest to just accept the defaults.   win-builds (mingw64) 1.5 for x86_64   Download from  http://win-builds.org/doku.php/download_and_installation_from_windows . Install at \"C:\\win-builds-x86_64\"  Run the installer a second time, but this time click the x86_64 option, NOT i686.  The defaults for all other options are OK.   MSYS   Start your download from  http://sourceforge.net/projects/mingw-w64/files/External%20binary%20packages%20%28Win64%20hosted%29/MSYS%20%2832-bit%29/MSYS-20111123.zip  Unzip to \"C:\\msys\"   gcc for ARM, 4.9.3   Download the Windows installer from  https://launchpad.net/gcc-arm-embedded/+download  and install at \"C:\\Program Files (x86)\\GNU Tools ARM Embedded\\4.9 2015q3\".   OpenOCD 0.8.0   Download OpenOCD 0.8.0 from  http://www.freddiechopin.info/en/download/category/4-openocd . Unzip to \"C:\\openocd\".   Zadig 2.1.2   Download it from  http://zadig.akeo.ie  and install it at \"C:\\zadig\".   Git   Click on  https://git-scm.com/download/win  to start the download. Install at \"C:\\Program Files (x86)\\Git\". Specify the \"Use Git from the Windows Command Prompt\" option.  The defaults for all other options are OK.   Go   Download the release for Microsoft Windows from  https://golang.org/dl/  and install it \"C:\\Go\".      Creating local repository    The directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:    src contains Go source files organized into packages (one package per directory),    pkg contains package objects, and    bin contains executable commands.    The GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory and then proceed to create the directory for cloning the newt tool repository.  $ cd c:\\\n$ mkdir dev\\go\n$ cd dev\\go    Set the following user environment variables using the steps outlined here.   GOPATH: C:\\dev\\go  PATH: C:\\Program Files (x86)\\GNU Tools ARM Embedded\\4.9 2015q3\\bin;%GOPATH%\\bin;C:\\win-builds-x86_64\\bin;C:\\win-builds-i686\\bin;C:\\msys\\bin   Steps:   Right-click the start button  Click \"Control panel\"  Click \"System and Security\"  Click \"System\"  Click \"Advanced system settings\" in the left panel  Click the \"Envoronment Variables...\" button  There will be two sets of environment variables: user variables\n  in the upper half of the screen, and system variables in the lower\n  half.  Configuring the user variables is recommended and tested \n  (though system variables will work as well).     Next, install godep. Note that the following command produces no output.  $ go get github.com/tools/godep    Set up the repository for the package building tool \"newt\" on your local machine. First create the appropriate directory for it and then clone the newt tool repository from the online apache repository (or its github.com mirror) into this newly created directory. Check the contents of the directory.  $ mkdir %GOPATH%\\src\\github.com\\mynewt\n$ cd %GOPATH%\\src\\github.com\\mynewt\n$ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git newt\n$ ls\nnewt\n$ cd newt\n$ ls\nGodeps                  README.md               coding_style.txt        newt.go\nLICENSE                 cli                     design.txt    Use the Go command 'install' to compile and install packages and dependencies. Add Go environment to path. Again, to make the export variable permanent, add it to your ~/.bashrc (or equivalent) file.  $ %GOPATH%\\bin\\godep restore \n$ go get \n$ go install    Building the newt tool    You will now use Go to run the newt.go program to build the newt tool. You will have to use  go build  command which compiles and writes the resulting executable to an output file named  newt . However, it does not install the results along with its dependencies in $GOPATH/bin (for that you will need to use  go install ). Now try running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.  Note: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to define the newt environment variable that allows you to execute the command via  %newt% . Use  set newt=go run %GOPATH%\\src\\github.com\\mynewt\\newt\\newt.go  or set it from the GUI. Here, you use  go run  which runs the compiled binary directly without producing an executable.  $ go build %GOPATH%\\src\\github.com\\mynewt\\newt\\newt.go\n$ cd ~/dev/go/src/github.com/mynewt/newt\n$ dir\nGodeps          README.md       coding_style.txt    newt\nLICENSE         cli         design.txt      newt.go\n$ newt version\nNewt version:  1.0\n$ newt -h\nNewt allows you to create your own embedded project based on the Mynewt\noperating system. Newt provides both build and package management in a\nsingle tool, which allows you to compose an embedded workspace, and set\nof projects, and then build the necessary artifacts from those projects.\nFor more information on the Mynewt operating system, please visit\nhttps://www.github.com/mynewt/documentation.\n\nPlease use the newt help command, and specify the name of the command\nyou want help for, for help on how to use a specific command\n\nUsage:\n newt [flags]\n newt [command]\n\nExamples:\n newt\n newt help [ command-name ]\n   For help on  command-name .  If not specified, print this message.\n\nAvailable Commands:\n version     Display the Newt version number.\n target      Set and view target information\n egg         Commands to list and inspect eggs on a nest\n nest        Commands to manage nests   clutches (remote egg repositories)\n help        Help about any command\n\nFlags:\n -h, --help=false: help for newt\n -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n -q, --quiet=false: Be quiet; only display error output.\n -s, --silent=false: Be silent; don't output anything.\n -v, --verbose=false: Enable verbose output when executing commands.\n\nUse \"newt help [command]\" for more information about a command.    Without creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool.     Getting the debugger ready    Use Zadig to configure the USB driver for your Olimex debugger.  If your debugger is already set up, you can skip this step.   Plug in your Olimex debugger.  Start Zadig.  Check the Options -  List All Devices checkbox.  Select \"Olimex OpenOCD JTAG ARM-USB-TINY-H\" in the dropdown menu.  Select the \"WinUSB\" driver.  Click the \"Install Driver\" button.     Proceed to the  Building test code on simulator on Windows machine  section.  Note: Currently, the simulator cannot be run in the Windows machine. We are still working on it. So you will go ahead and  make an LED blink  on the Olimex hardware directly.   However, before you skip to the hardware target, you still need to build your first nest as outlined in step 1 in the  Building test code on simulator .  Building test code on simulator  Note: Currently, the simulator cannot be run in the Windows machine. We are working on it. If you are on a Windows machine, do step 1 below and then proceed to the  Making an LED blink  on the Olimex hardware directly.    First, you have to create a repository for the project i.e. build your first nest! Go to ~/dev and clone the larva repository from the apache git repository into a local directory named  larva .  Substitute DOS commands for Unix commands as necessary in the following steps if your machine is running Windows. The newt tool commands do not change.  $ cd ~/dev \n$ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git larva\n$ ls\ngo  larva\n$ cd larva\n$ ls\nLICENSE     clutch.yml  hw      nest.yml      project\nREADME.md   compiler    libs        net       scripts    You will now create a new target using the newt tool. You can either use the compiled binary  newt  or run the newt.go program using  $newt  (assuming you have stored the command in a variable in your .bash_profile or .bashrc). When you do a  newt target show  or  $newt target show  it should list all the projects you have created so far.   $ newt target create sim_test\nCreating target sim_test\nTarget sim_test sucessfully created!\n$ newt target show\nsim_test\n    name: sim_test\n    arch: sim    Now continue to populate and build out the sim project.  $ newt target set sim_test project=test\nTarget sim_test successfully set project to test\n$ newt target set sim_test compiler_def=debug\nTarget sim_test successfully set compiler_def to debug\n$ newt target set sim_test bsp=hw/bsp/native\nTarget sim_test successfully set bsp to hw/bsp/native\n$ newt target set sim_test compiler=sim\nTarget sim_test successfully set compiler to sim\n$ newt target show sim_test\nsim_test\n    arch: sim\n    project: test\n    compiler_def: debug\n    bsp: hw/bsp/native\n    compiler: sim\n    name: sim_test    Configure newt to use the gnu build tools native to OS X or linux. In order for sim to work properly, it needs to be using 32-bit gcc (gcc-5). Replace \n~/dev/larva/compiler/sim/compiler.yml with the compiler/sim/osx-compiler.yml or linux-compiler.yml file, depending on the system.   For a Mac OS X environment:  $ cp compiler/sim/osx-compiler.yml compiler/sim/compiler.yml  For a Linux machine:  $ cp compiler/sim/linux-compiler.yml compiler/sim/compiler.yml    Next, create (hatch!) the eggs for this project using the newt tool - basically, build the packages for it. You can specify the VERBOSE option if you want to see the gory details.   $ $newt target build sim_test\nSuccessfully run!  You can specify the VERBOSE option if you want to see the gory details.  $newt -l VERBOSE target build sim_test\n2015/09/29 09:46:12 [INFO] Building project test\n2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//bootutil...\n2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//cmsis-core...\n2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//ffs..\n...\nSuccessfully run!    Try running the test suite executable inside this project and enjoy your first successful hatch.  $ ./project/test/bin/sim_test/test.elf\n[pass] os_mempool_test_suite/os_mempool_test_case\n[pass] os_mutex_test_suite/os_mutex_test_basic\n[pass] os_mutex_test_suite/os_mutex_test_case_1\n[pass] os_mutex_test_suite/os_mutex_test_case_2\n[pass] os_sem_test_suite/os_sem_test_basic\n[pass] os_sem_test_suite/os_sem_test_case_1\n[pass] os_sem_test_suite/os_sem_test_case_2\n[pass] os_sem_test_suite/os_sem_test_case_3\n[pass] os_sem_test_suite/os_sem_test_case_4\n[pass] os_mbuf_test_suite/os_mbuf_test_case_1\n[pass] os_mbuf_test_suite/os_mbuf_test_case_2\n[pass] os_mbuf_test_suite/os_mbuf_test_case_3\n[pass] gen_1_1/ffs_test_unlink\n[pass] gen_1_1/ffs_test_rename\n[pass] gen_1_1/ffs_test_truncate\n[pass] gen_1_1/ffs_test_append\n[pass] gen_1_1/ffs_test_read\n[pass] gen_1_1/ffs_test_overwrite_one\n[pass] gen_1_1/ffs_test_overwrite_two\n[pass] gen_1_1/ffs_test_overwrite_three\n...\n...\n[pass] boot_test_main/boot_test_vb_ns_11    Building test code on simulator on Windows machine  Coming soon.  Making an LED blink from SRAM  You are here because you want to build an image to be run from internal SRAM on the Olimex board.  Preparing the Software    Make sure the PATH environment variable includes the $HOME/dev/go/bin directory (or C:\\%GOPATH%\\bin on Windows machine).   Substitute DOS commands for Unix commands as necessary in the following steps if your machine is running Windows (e.g.  cd dev\\go  instead of  cd dev/go ). The newt tool commands do not change.    You first have to create a repository for the project. Go to the ~dev/larva directory and build out a second project inside larva. The project name is \"blinky\", in keeping with the objective. Starting with the target name, you have to specify the different aspects of the project to pull the appropriate eggs and build the right package for the board. In this case that means setting the architecture (arch), compiler, board support package (bsp), project, and compiler mode.  $ newt target create blinky\nCreating target blinky\nTarget blinky sucessfully created!\n$ newt target set blinky arch=cortex_m4\nTarget blinky successfully set arch to arm\n$ newt target set blinky compiler=arm-none-eabi-m4\nTarget blinky successfully set compiler to arm-none-eabi-m4\n$ newt target set blinky project=blinky\nTarget blinky successfully set project to blinky\n$ newt target set blinky compiler_def=debug\nTarget blinky successfully set compiler_def to debug\n$ newt target set blinky bsp=hw/bsp/olimex_stm32-e407_devboard\nTarget blinky successfully set bsp to hw/bsp/olimex_stm32-e407_devboard\n$ newt target show blinky\nblinky\n    compiler: arm-none-eabi-m4\n    project: blinky\n    compiler_def: debug\n    bsp: hw/bsp/olimex_stm32-e407_devboard\n    name: blinky\n    arch: cortex_m4    Now you have to build the image. The linker script within the  hw/bsp/olimex_stm32-e407_devboard  egg builds an image for flash memory by default. Since you want an image for the SRAM, you need to switch that script with  run_from_sram.ld  in order to get the egg to produce an image for SRAM.   We are working on making it easier to specify where the executable will be run from for a particular project and automatically choose the correct linker scripts and generate the appropriate image. It will be specified as a project identity e.g. bootloader, RAM, flash (default) and the target will build accordingly.  .   Once the target is built, you can find the executable \"blinky.elf\" in the project directory at ~/dev/larva/project/blinky/bin/blinky. It's a good idea to take a little time to understand the directory structure.  $ cd ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n$ diff olimex_stm32-e407_devboard.ld run_from_sram.ld\n$ cp run_from_sram.ld olimex_stm32-e407_devboard.ld\n$ cd ~/dev/larva/project/blinky/bin/blinky\n$ newt target build blinky\nBuilding target blinky (project = blinky)\nCompiling case.c\nCompiling suite.c\n...\nSuccessfully run!\n$ ls\nLICENSE     clutch.yml  hw      nest.yml    project\nREADME.md   compiler    libs        net     scripts\n$ cd project\n$ ls\nbin2img     bletest     blinky      boot        ffs2native  test\n$ cd blinky\n$ ls\nbin     blinky.yml  egg.yml     src\n$ cd bin\n$ ls\nblinky\n$ cd blinky\n$ ls\nblinky.elf  blinky.elf.bin  blinky.elf.cmd  blinky.elf.lst  blinky.elf.map    Check that you have all the scripts needed to get OpenOCD up and talking with the project's specific hardware. Depending on your system (Ubuntu, Windows) you may already have the scripts in your  /usr/share/openocd/scripts/  directory as they may have been part of the openocd download. If yes, you are all set and can proceed to preparing the hardware.    Otherwise check the  ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard  directory for a file named  f407.cfg . That is the config we will use to talk to this specific hardware using OpenOCD. You are all set if you see it.      $ ls ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n    bin                 olimex_stm32-e407_devboard_debug.sh\n    boot-olimex_stm32-e407_devboard.ld  olimex_stm32-e407_devboard_download.sh\n    egg.yml                 run_from_flash.ld\n    f407.cfg                run_from_loader.ld\n    include                 run_from_sram.ld\n    olimex_stm32-e407_devboard.ld       src  Preparing the hardware to boot from embedded SRAM    Locate the boot jumpers on the board.     B1_1/B1_0 and B0_1/B0_0 are PTH jumpers which can be moved relatively easy. Note that the markings on the board may not always be accurate. Always refer to the manual for the correct positioning of jumpers in case of doubt. The two jumpers must always be moved together \u2013 they are responsible for the boot mode if bootloader is present. The board can search for bootloader on three places \u2013 User Flash Memory, System Memory or the Embedded SRAM. We will configure it to boot from SRAM by jumpering B0_1 and B1_1.    Connect USB-OTG#2 in the picture above to a USB port on your computer (or a powered USB hub to make sure there is enough power available to the board).     The red PWR LED should be lit.     Connect the JTAG connector to the SWD/JTAG interface on the board. The other end of the cable should be connected to the USB port or hub of your computer.    Let's Go!    Make sure you are in the blinky project directory with the blinky.elf executable. Run the debug command in the newt tool. You should see some status messages are shown below. There is an inbuilt  -c \"reset halt\"  flag that tells it to halt after opening the session.  $ cd dev/larva/project/blinky/bin/blinky\n$ newt target debug blinky\nDebugging with /Users/aditihilbert/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_debug.sh blinky\nDebugging /Users/aditihilbert/dev/larva/project/blinky/bin/blinky/blinky.elf\nGNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later  http://gnu.org/licenses/gpl.html \nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"--host=x86_64-apple-darwin10 --target=arm-none-eabi\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see: http://www.gnu.org/software/gdb/bugs/ .\nFind the GDB manual and other documentation resources online at: http://www.gnu.org/software/gdb/documentation/ .\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from /Users/aditihilbert/dev/larva/project/blinky/bin/        blinky/blinky.elf...done.\nOpen On-Chip Debugger 0.8.0 (2015-09-22-18:21)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.sourceforge.net/doc/doxygen/bugs.html\nInfo : only one transport option; autoselect 'jtag'\nadapter speed: 1000 kHz\nadapter_nsrst_delay: 100\njtag_ntrst_delay: 100\nWarn : target name is deprecated use: 'cortex_m'\nDEPRECATED! use 'cortex_m' not 'cortex_m3'\ncortex_m reset_config sysresetreq\nInfo : clock speed 1000 kHz\nInfo : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\nInfo : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\nInfo : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints\nInfo : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\nInfo : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\ntarget state: halted\ntarget halted due to debug-request, current mode: Thread \nxPSR: 0x01000000 pc: 0x20000250 msp: 0x10010000\nInfo : accepting 'gdb' connection from 3333\nInfo : device id = 0x10036413\nInfo : flash size = 1024kbytes\nReset_Handler () at startup_STM32F40x.s:199\n199     ldr    r1, =__etext  Check the value of the msp (main service pointer) register. If it is not 0x10010000 as indicated above, you will have to manually set it after you open the gdp tool and load the image on it.   (gdb) set $msp=0x10010000  Now load the image and type \"c\" or \"continue\" from the GNU debugger.   (gdb) load ~/dev/larva/project/blinky/bin/blinky/blinky.elf\nLoading section .text, size 0x4294 lma 0x20000000\nLoading section .ARM.extab, size 0x24 lma 0x20004294\nLoading section .ARM.exidx, size 0xd8 lma 0x200042b8\nLoading section .data, size 0x874 lma 0x20004390\nStart address 0x20000250, load size 19460\nTransfer rate: 81 KB/sec, 2432 bytes/write.\n(gdb) c\nContinuing.    Voil\u00e0! The board's LED should be blinking at 1 Hz.    Using flash to make LED blink  You are here because you want to build an image to be run from flash memory on the Olimex board.   Configure the board to boot from flash by moving the two jumpers together to B0_0 and B1_0.    You will have to reset the board once the image is uploaded to it.    By now you know that you have to build a new package that will run from flash. First, the olimex_stm32-e407_devboard.ld linker script which was previously made the same as run_from_sram.ld will now need the contents of run_from_flash.ld. Then the target has to be rebuilt.   $ cd ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n$ diff olimex_stm32-e407_devboard.ld run_from_sram.ld\n$ cp run_from_flash.ld olimex_stm32-e407_devboard.ld\n$ cd ~/dev/larva/project/blinky/bin/blinky\n$ newt target build blinky    Go to the project directory and download the image to flash ... in a flash!   $ cd ~/dev/larva/project/blinky/bin/blinky\n$ newt target download blinky\nDownloading with ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_download.sh    The LED should be blinking!    But wait...let's double check that it is indeed booting from flash and making the LED blink from the image in flash. Pull the USB cable off the Olimex JTAG adaptor. The debug connection to the JTAG port is now severed. Next power off the Olimex board by pulling out the USB cable from the board. Wait for a couple of seconds and plug the USB cable back to the board.   The LED light will start blinking again. Success!  Note #1: If you want to download the image to flash and a gdb session opened up, use  newt target debug blinky  instead of  newt target download blinky .  $ newt target debug blinky\nDebugging with ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_debug.sh blinky\nDebugging ~/dev/larva/project/blinky/bin/blinky/blinky.elf\nGNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later  http://gnu.org/licenses/gpl.html \nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"--host=x86_64-apple-darwin10 --target=arm-none-eabi\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see: http://www.gnu.org/software/gdb/bugs/ .\nFind the GDB manual and other documentation resources online at: http://www.gnu.org/software/gdb/documentation/ .\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from /Users/aditihilbert/dev/larva/project/blinky/bin/blinky/blinky.elf...done.\nOpen On-Chip Debugger 0.8.0 (2015-09-22-18:21)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.sourceforge.net/doc/doxygen/bugs.html\nInfo : only one transport option; autoselect 'jtag'\nadapter speed: 1000 kHz\nadapter_nsrst_delay: 100\njtag_ntrst_delay: 100\nWarn : target name is deprecated use: 'cortex_m'\nDEPRECATED! use 'cortex_m' not 'cortex_m3'\ncortex_m reset_config sysresetreq\nInfo : clock speed 1000 kHz\nInfo : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\nInfo : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\nInfo : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints\nInfo : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\nInfo : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\ntarget state: halted\ntarget halted due to debug-request, current mode: Thread \nxPSR: 0x01000000 pc: 0x08000250 msp: 0x10010000\nInfo : accepting 'gdb' connection from 3333\nInfo : device id = 0x10036413\nInfo : flash size = 1024kbytes\nReset_Handler () at startup_STM32F40x.s:199\n199     ldr    r1, =__etext\n(gdb)  Note #2: If you want to erase the flash and load the image again you may use the following commands from within gdb.  flash erase_sector 0 0 x  tells it to erase sectors 0 through x. When you ask it to display (in hex notation) the contents of the sector starting at location 'lma' you should therefore see all f's. The memory location 0x8000000 is the start or origin of the flash memory contents and is specified in the olimex_stm32-e407_devboard.ld linker script. The flash memory locations is specific to the processor.  (gdb) monitor flash erase_sector 0 0 4\nerased sectors 0 through 4 on flash bank 0 in 2.296712s\n(gdb) x/32wx 0x8000000 \n0x8000000  __isr_vector :   0xffffffff  0xffffffff 0xffffffff 0xffffffff \n0x8000010  __isr_vector+16 :    0xffffffff 0xffffffff 0xffffffff 0xffffffff\n...", 
            "title": "Blinky, the First Project"
        }, 
        {
            "location": "/chapter1/how_to_edit_docs/", 
            "text": "How to Edit Docs\n\n\nObjective\n\n\nWe will go through the process of downloading existing doccumentation and adding some content to a test document.\n\n\nMarkdown, MkDocs, Mou\n\n\nThe Mynewt documentation you see on the Apache incubator website is a bunch of HTML files generated using MkDocs which is a simple static site generation tool geared towards building project documentation. You can read about it at \nhttp://www.mkdocs.org\n. Documentation source files are written in Markdown, and configured with a single YAML configuration file. Markdown is a lightweight markup language with plain text formatting syntax designed so that it can be converted to HTML and many other formats using a tool (which in our case is MkDocs).\n\n\nYou do not need to install MkDocs unless you want to actually render your documentation in HTML in order to preview it before pushing your content to the remote repository. Typically, using a Markdown editor such as \nMou\n is enough to check how it will look after the document has gone through MkDocs. Go ahead and download \nMou\n. If you are on a Windows machine, download the \neditor of your choice\n.\n\n\nCurrently someone in the project is designated to use MkDocs to generate the HTML pages periodically after changes have been reviewed and accepted into the master branch.\n\n\nAccess to the Apache repo\n\n\nGet an account on Apache. You do not need an account to view the website or clone the repository but you need it to push changes to it.\n\n\nMaking a local copy\n\n\n\n\n\n\nCopy the document source files into a local directory and look at the contents of the copied directory to get an idea of the directory structure. \n\n\n$ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git\nCloning into 'incubator-mynewt-site'...\nremote: Counting objects: 330, done.\nremote: Compressing objects: 100% (263/263), done.\nremote: Total 330 (delta 120), reused 0 (delta 0)\nReceiving objects: 100% (330/330), 4.34 MiB | 830.00 KiB/s, done.\nResolving deltas: 100% (120/120), done.\nChecking connectivity... done.\n$ ls\nincubator-mynewt-site\n$ ls incubator-mynewt-site/\ndocs        images      mkdocs.yml\n\n\n\n\n\n\n\nCreate a new branch to work on your documentation and move to that branch.\n\n\n$ git checkout -b \nyour-branch-name\n\n\n\n\n\n\n\n\nFile to be edited\n\n\nThe file you will edit is \ntry_markdown.md\n.\n\n\nEditing an existing page\n\n\n\n\n\n\nOpen the application Mou.\n\n\n\n\n\n\nOpen the file incubator-mynewt-site/docs/chapter1/try_markdown.md in Mou.\n\n\n\n\n\n\nEdit the last item on the list.\n\n\n\n\n\n\nSave and quit the application.\n\n\n\n\n\n\nYou may want to review the documentation organization back in \nHome\n to remind you how to locate files easily. The corresponding directory tree structure is shown below.\n\n\n  .\n  \u251c\u2500\u2500 docs\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 chapter1\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 how_to_edit_docs.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 newt_concepts.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pics\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 bottomview.png\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 topview.png\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 project1.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 try_markdown.md\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 chapter2\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 project2.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 project3.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ... (more to be added)\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 vocabulary.md\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 chapter3\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 newt_ops.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 newt_tool_reference.md\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 chapter4\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 context_switch.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 event_queue.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 heap.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 mbufs.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 memory_pool.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 mutex.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 mynewt_os.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 port_os.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 sanity.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 semaphore.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 task.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 time.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ... (more to be added)\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 chapter5\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 bootloader.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 console.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 filesystem.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 shell.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 testutil.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ... (more to be added)\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 chapter6\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 dist.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ... (more to be added)\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 extra.css\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 images\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 egg-logo.png\n  \u2502\u00a0\u00a0 \u2514\u2500\u2500 index.md\n  \u251c\u2500\u2500 images\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 asf_logo_wide.gif\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 content-bg.png\n  \u2502\u00a0\u00a0 \u2514\u2500\u2500 egg-logo.png\n  \u251c\u2500\u2500 mkdocs.yml\n\n\n\nAdding a new page\n\n\nIf you create a new file somewhere in the \ndocs\n subdirectory to add a new page, you have to add a line in the \nmkdocs.yml\n file at the correct level. For example, if you add a new module named \"Ethernet\" by creating a new file named \nethernet.md\n in the chapter5 subdirectory, you have to insert the following line under \nModules:\n in the \nmkdocs.yml\n file.\n\n\n    - 'Ethernet': 'chapter5/ethernet.md'\n\n\n\nPushing changes to remote\n\n\n\n\n\n\nCheck whether your remote git repository is set up.\n\n\n$ git remote -v\norigin  https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git (fetch)\norigin  https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git (push)\n\n\n\n\n\n\n\nIf it is not, set it up. Otherwise, proceed to the next step.\n\n\n$ git remote add origin https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git\n\n\n\n\n\n\n\nCommit and push the changes to the remote repository. Instead of \"Green Arrow\" type in your username.\n\n\n$ git add -A \n$ git commit -m \"Green Arrow's first doc change\"\n$ git push -u origin \nyour-branch-name\n\n\n\n\n\n\n\n\nYou can see the changed Markdown file if you traverse the tree on the git repository \n https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git\n.\n\n\n\n\n\n\nA commit notification automatically goes out to the commits@mynewt.incubator.apache.org mailing list. The \"upstream\" manager pulls the notified changes, reviews it, and merges it to the master branch if all is well. Otherwise you get an email for further changes.\n\n\n\n\n\n\nConversion to HTML\n\n\nThe conversion of the Markdown files to HTML for the website happens manually and statically using MkDocs. You cannot see automatic and immediate rendering in HTML upon making a change in the Markdown file. You can choose to stop here and proceed to changing other Markdown files in your branch.\n\n\nLocal preview of HTML files\n\n\nHowever, you have the option to download MkDocs and do a local conversion yourself to preview the pages using the built-in devserver that comes with MkDocs. But first you will have to install MkDocs for that. In order to install MkDocs you'll need Python installed on your system, as well as the Python package manager, pip. You can check if you have them already (usually you will).\n\n\n    $ python --version\n    Python 2.7.2\n    $ pip --version\n    pip 1.5.2\n    $ pip install mkdocs\n\n\n\nYou will then run the built-in webserver from the root of the documentation directory using the command \nmkdocs serve\n. The root directory for documentation is \nincubator-mynewt-site\n or the directory with the \nmkdocs.yml\n file.\n\n\n    $ ls\n    docs        images      mkdocs.yml\n    $ mkdocs serve\n\n\n\nThen go to \nhttp://127.0.0.1:8000\n to preview your pages and see how they will look on the website! Remember that the Myself website itself will not be updated.\n\n\nFor more information on MkDocs go to [http://www.mkdocs.org].", 
            "title": "How to edit docs"
        }, 
        {
            "location": "/chapter1/how_to_edit_docs/#how-to-edit-docs", 
            "text": "Objective  We will go through the process of downloading existing doccumentation and adding some content to a test document.  Markdown, MkDocs, Mou  The Mynewt documentation you see on the Apache incubator website is a bunch of HTML files generated using MkDocs which is a simple static site generation tool geared towards building project documentation. You can read about it at  http://www.mkdocs.org . Documentation source files are written in Markdown, and configured with a single YAML configuration file. Markdown is a lightweight markup language with plain text formatting syntax designed so that it can be converted to HTML and many other formats using a tool (which in our case is MkDocs).  You do not need to install MkDocs unless you want to actually render your documentation in HTML in order to preview it before pushing your content to the remote repository. Typically, using a Markdown editor such as  Mou  is enough to check how it will look after the document has gone through MkDocs. Go ahead and download  Mou . If you are on a Windows machine, download the  editor of your choice .  Currently someone in the project is designated to use MkDocs to generate the HTML pages periodically after changes have been reviewed and accepted into the master branch.  Access to the Apache repo  Get an account on Apache. You do not need an account to view the website or clone the repository but you need it to push changes to it.  Making a local copy    Copy the document source files into a local directory and look at the contents of the copied directory to get an idea of the directory structure.   $ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git\nCloning into 'incubator-mynewt-site'...\nremote: Counting objects: 330, done.\nremote: Compressing objects: 100% (263/263), done.\nremote: Total 330 (delta 120), reused 0 (delta 0)\nReceiving objects: 100% (330/330), 4.34 MiB | 830.00 KiB/s, done.\nResolving deltas: 100% (120/120), done.\nChecking connectivity... done.\n$ ls\nincubator-mynewt-site\n$ ls incubator-mynewt-site/\ndocs        images      mkdocs.yml    Create a new branch to work on your documentation and move to that branch.  $ git checkout -b  your-branch-name     File to be edited  The file you will edit is  try_markdown.md .  Editing an existing page    Open the application Mou.    Open the file incubator-mynewt-site/docs/chapter1/try_markdown.md in Mou.    Edit the last item on the list.    Save and quit the application.    You may want to review the documentation organization back in  Home  to remind you how to locate files easily. The corresponding directory tree structure is shown below.    .\n  \u251c\u2500\u2500 docs\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 chapter1\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 how_to_edit_docs.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 newt_concepts.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pics\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 bottomview.png\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 topview.png\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 project1.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 try_markdown.md\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 chapter2\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 project2.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 project3.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ... (more to be added)\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 vocabulary.md\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 chapter3\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 newt_ops.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 newt_tool_reference.md\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 chapter4\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 context_switch.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 event_queue.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 heap.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 mbufs.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 memory_pool.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 mutex.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 mynewt_os.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 port_os.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 sanity.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 semaphore.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 task.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 time.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ... (more to be added)\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 chapter5\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 bootloader.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 console.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 filesystem.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 shell.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 testutil.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ... (more to be added)\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 chapter6\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 dist.md\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ... (more to be added)\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 extra.css\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 images\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 egg-logo.png\n  \u2502\u00a0\u00a0 \u2514\u2500\u2500 index.md\n  \u251c\u2500\u2500 images\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 asf_logo_wide.gif\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 content-bg.png\n  \u2502\u00a0\u00a0 \u2514\u2500\u2500 egg-logo.png\n  \u251c\u2500\u2500 mkdocs.yml  Adding a new page  If you create a new file somewhere in the  docs  subdirectory to add a new page, you have to add a line in the  mkdocs.yml  file at the correct level. For example, if you add a new module named \"Ethernet\" by creating a new file named  ethernet.md  in the chapter5 subdirectory, you have to insert the following line under  Modules:  in the  mkdocs.yml  file.      - 'Ethernet': 'chapter5/ethernet.md'  Pushing changes to remote    Check whether your remote git repository is set up.  $ git remote -v\norigin  https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git (fetch)\norigin  https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git (push)    If it is not, set it up. Otherwise, proceed to the next step.  $ git remote add origin https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git    Commit and push the changes to the remote repository. Instead of \"Green Arrow\" type in your username.  $ git add -A \n$ git commit -m \"Green Arrow's first doc change\"\n$ git push -u origin  your-branch-name     You can see the changed Markdown file if you traverse the tree on the git repository   https://git-wip-us.apache.org/repos/asf/incubator-mynewt-site.git .    A commit notification automatically goes out to the commits@mynewt.incubator.apache.org mailing list. The \"upstream\" manager pulls the notified changes, reviews it, and merges it to the master branch if all is well. Otherwise you get an email for further changes.    Conversion to HTML  The conversion of the Markdown files to HTML for the website happens manually and statically using MkDocs. You cannot see automatic and immediate rendering in HTML upon making a change in the Markdown file. You can choose to stop here and proceed to changing other Markdown files in your branch.  Local preview of HTML files  However, you have the option to download MkDocs and do a local conversion yourself to preview the pages using the built-in devserver that comes with MkDocs. But first you will have to install MkDocs for that. In order to install MkDocs you'll need Python installed on your system, as well as the Python package manager, pip. You can check if you have them already (usually you will).      $ python --version\n    Python 2.7.2\n    $ pip --version\n    pip 1.5.2\n    $ pip install mkdocs  You will then run the built-in webserver from the root of the documentation directory using the command  mkdocs serve . The root directory for documentation is  incubator-mynewt-site  or the directory with the  mkdocs.yml  file.      $ ls\n    docs        images      mkdocs.yml\n    $ mkdocs serve  Then go to  http://127.0.0.1:8000  to preview your pages and see how they will look on the website! Remember that the Myself website itself will not be updated.  For more information on MkDocs go to [http://www.mkdocs.org].", 
            "title": "How to Edit Docs"
        }, 
        {
            "location": "/chapter1/try_markdown/", 
            "text": "Try Markdown\n\n\nHeading3\n\n\nHeading4\n\n\n\n\nList\n\n\n\n\n\n\nStart with one # for the largest heading (Heading1). The next smaller heading (Heading2) starts with ##. You can go all the way up to Heading 6 (######).\n\n\n\n\n\n\nHeading4 (####) and Heading5 (#####) has been styled to show up underlined. Yes, it can be changed. If you are curious, you can look at the extra.css file in your repo branch.\n\n\n\n\n\n\nIt's \nvery\n easy to do \nbold\n and \nitalics\n.\n\n\n\n\n\n\nSee how this list has been made using *\n\n\n\n\n\n\nClick on \"Help\" in Mou and then on \"Markdown Syntax Reference\".\n\n\n\n\n\n\n Substitute a sentence of your own here \n\n\n\n\n\n\n Guinea Pig!!! \n\n\n\n\n\n\n\n\n\n\n Note! \n\n\n\n\nYou will not be able to see the change immediately by refreshing your browser right after editign the Markdown file. You can only push the change to the Apache repository. So continue with the steps in \nhow_to_edit_docs.md\n.\n\n\nYou can see the change on the website if/when a doc builder on the project team merges your changes to the master branch and generates the pages for the website.\n\n\nYou do have the option to download MkDocs and preview the change by hosting the pages locally using its built-in web server. The steps are described in \nhow_to_edit_docs.md\n.", 
            "title": "Sample doc to edit"
        }, 
        {
            "location": "/chapter1/try_markdown/#try-markdown", 
            "text": "Heading3  Heading4   List    Start with one # for the largest heading (Heading1). The next smaller heading (Heading2) starts with ##. You can go all the way up to Heading 6 (######).    Heading4 (####) and Heading5 (#####) has been styled to show up underlined. Yes, it can be changed. If you are curious, you can look at the extra.css file in your repo branch.    It's  very  easy to do  bold  and  italics .    See how this list has been made using *    Click on \"Help\" in Mou and then on \"Markdown Syntax Reference\".     Substitute a sentence of your own here      Guinea Pig!!!        Note!    You will not be able to see the change immediately by refreshing your browser right after editign the Markdown file. You can only push the change to the Apache repository. So continue with the steps in  how_to_edit_docs.md .  You can see the change on the website if/when a doc builder on the project team merges your changes to the master branch and generates the pages for the website.  You do have the option to download MkDocs and preview the change by hosting the pages locally using its built-in web server. The steps are described in  how_to_edit_docs.md .", 
            "title": "Try Markdown"
        }, 
        {
            "location": "/chapter2/vocabulary/", 
            "text": "Understanding Newt Terms\n\n\nNest\n\n\nThe nest is the base directory of your embedded software. It is meant to be the workspace containing a logical collection of the source code for one or more of your projects. A nest can contain multiple projects, and reflect multiple end products. \n\n\nAs the base repository of your source code, the nest has a master branch and several other branches off it. You may choose any branch to nest on. Each project in your nest will typically consist of several \neggs\n. A project could be an egg itself as well. In addition to eggs, a local nest will contain additional items such as \ntarget\n or build definitions, clutch description files, scripts etc.\n\n\nFor example, a walk through the \"larva\" nest at \nhttps://github.com/mynewt/larva.git\n shows the following structure. The nest.yml file in the larva directory indicates that it is a nest. An egg will have the egg.yml file in it as shown below. By this nomenclature, each board support package for a particular chip is an egg, the API for the hardware abstraction layer is an egg, and so on. \n\n\nlarva\n  |- nest.yml \n  |- compiler\n        |- arm-none-eabi-m4\n        |- sim\n  |- hw (hardware)\n        |- bsp (board support package)\n                |- nrf52pdk (Nordic nRF52 series chip)\n                        |- egg.yml\n                        |- ...\n                |- olimex_stm32-e407_devboard (used in chapter1 project)\n                        |- egg.yml\n                        |- ...\n                |- stm32f3discovery (another board with stm32f3 mcu)\n                        |- egg.yml\n                        |- ...\n                |- yet another board\n                        |- egg.yml\n                        |- ...\n        |- hal (hardware abstraction layer APIs)\n                |- egg.yml\n                |- include\n                        |- hal_cputime.h\n                        |- hal_flash.h\n                        |- hal_gpio.h\n                        |- ... (header files for other peripherals)\n        |- mcu (microcontroller)\n                |- stm (STMicro family)\n                    |- stm32f3xx (STM32f3 series, 32-bit ARM Cortex-M4  core)\n                        |- egg.yml\n                        |- src\n                            |- hal_gpio.c (specific to the STM32f3 mcu)\n                            |- hal_cputime.c\n                            |- ... (code for other peripherals)\n                |- nordic (Nordic Semiconductor family)\n                    |- nrf52xxx (nRF52 Series SoC, Cortex-M4F core)\n                        |- egg.yml\n                        |- src\n                            |- hal_gpio.c (specific to the nRF52 mcu )\n                            |- hal_cputime.c\n                            |- ... (code for other peripherals)\n                |- yet another family of mcu\n                    |- ...\n  |- libs\n        |- bootutil (hw architecture independent boot loader library)\n                |- egg.yml\n                |- src\n                    |- loader.c\n                    |- ... (related source code files)\n        |- nffs (hw architecture independent Newtron Flash File System)\n                |- egg.yml\n                |- src\n                    |- nffs.c\n                    |- ... (related source code files)\n        |- another library \n                |- egg.yml\n                |- src\n                    |- ... (related source code files)\n  |- project\n  |- scripts\n\n\n\n\n\n\nThe newt tool offers the \nnest\n command to create and manage nests. In general, commands represent actions and flags are modifiers for those actions. A command can have children commands and optionally run an action. A full description of the \nnest\n command can be found in the newt tool reference in Chapter 3.\n\n\nnewt nest [flags]\nnewt nest [child-commands]\n\n\n\nA complete list of all the nest commands can be found in the newt tool reference in \nChapter 3\n.\n\n\nProject\n\n\nProjects represent the individual build configurations of your embedded system and essentially defines your application. The project files are what dictate the resulting binary that is generated. \n\n\nLayout-wise, a project is a directory inside a nest and contains eggs required for a certain application. For example, the \nblinky\n egg sits in \nproject/blinky\n directory of the \nlarva\n nest. This egg is used in the blinky project (application) outlined in \nChapter 1\n. \nNote: This Will Change\n\n\nA project has the following concepts or properties associated with it. You can find them in the \nproject-name\n.yml\n file in the project directory. For example, the \nproject/blinky\n directory has the \nblinky.yml\n file indicating some or all of the properties below. Only the name of a project is required for the project to exist, however additional properties may need to be specified for the eggs in it to compile properly and produce an executable. \n\n\n\n\nProject name\n\n\nBase path of the project (nest/project/project-name by default)\n\n\nEggs belonging to the project\n\n\nCapabilities\n that are required for the project or target \n\n\nIdentity\n to classify the type of project or target\n\n\nCompiler flags to call out any specific compiler requirement\n\n\n\n\nA project could itself be an egg if it is a distributable package for a specific application. \n\n\nThe newt tool offers various commands that you can use with a project. For example, if your project is an egg, you can use the following command to install a project from a nest.\n\n\nnewt egg install [flags] \nproject egg name\n\n\n\n\nEgg\n\n\nAn egg is a distributable package of libraries. Just as an egg in nature has various parts each of which serves a certain purpose, the Mynewt egg consists of software parcels or modules that have different functions. However, unlike the egg in nature these software modules can exist by itself and may be distributed; therefore, they too are essentially eggs. Once this concept is grasped it is easy to see how an egg may consist of other eggs.\n\n\nThe two main directories in an egg are \n/include\n and \n/src\n.\n\n\nThe newt tool offers several egg commands to list, inspect, install, and do other operations on eggs. For example, the following command\n\n\nnewt egg list\n\n\n\noutputs all the eggs in the current nest where each egg has details on its version, path, and dependencies. A sample output for an egg is given below.\n\n\nEgg libs/os, version 0.1.0\npath: /Users/aditihilbert/dev/test_project/libs/os\ndeps: libs/testutil@none#stable\n\n\n\nA complete list of all the egg commands can be found in the newt tool reference in \nChapter 3\n.\n\n\nClutch\n\n\nA clutch is a snapshot of all eggs in a remote nest at any point in time. On any given github branch, a nest with a clutch of eggs will contain a \nclutch.yml\n file that specifies the version number, dependencies, and hash value for each constituent egg as well as the name of the entire clutch and the github url for it. [Note: Currently ]\n\n\nYou may download multiple clutches into your local nest as long as the names of the clutches are different. This allows you to mix and match various features and functionality coming from different clutches of eggs. You can see all the clutches in the \n.nest/clutches\n directory in your nest.\n\n\nThe newt tool offers clutch management commands within the \nnewt nest\n command. For example, the following command creates a new clutch using all the eggs in the current directory. It requires that a clutch name be specified and the url for the location of that clutch in the online repository. These two inputs go into the \nclutch.yml\n file in the nest.\n\n\nnewt nest generate-clutch \nname\n \nurl\n\n\n\n\nNote that a clutch merely defines the eggs belonging together and requires the eggs to be installed (hatched) for the source code to be populated in the project. \n\n\nEggshell\n\n\nThe term eggshell is used to refer to the eggs of a clutch in a remote repository. They are not useful on your local machine until you actually install them. So they are mere shells of themselves while sitting on the online repository. When you enter the following command outputs the total number of shells in each remote clutch.\n\n\nnewt nest list-clutches\n\n\n\nSo, if you had two clutches installed, the output could be:\n\n\nRemote clutch larva (eggshells: 19)\nRemote clutch ble_test (eggshells: 15)\n\n\n\nTarget\n\n\nA target is the hardware build or its software equivalent (e.g. test, simulator) set for a project. It tells the newt tool how to build the source code within a given nest. Once a new target is created, its architecture and other details needs to be defined. An example of a defined target named \"blink_f3disc\" is given below.\n\n\nblink_f3disc\n         compiler_def: debug\n         compiler: arm-none-eabi-m4\n         name: blink_f3disc\n         arch: cortex_m4\n         project: blinky\n         bsp: hw/bsp/stm32f3discovery\n\n\n\nThe newt tool offers commands to create, set up and manipulate targets. For example, the create command below creates an empty target named \nmy_target1\n and the set command sets one detail of its definition, namely the architecture.\n\n\nnewt target create my_target1\nnewt target set my_target1 arch=cortex_m4\n\n\n\nCapability\n\n\nCapability is functionality that is exposed by an egg. A capability is tracked by its name and version. An egg may require capabilities exposed by another egg, thus establishing a dependency tracked through the egg.yml files. \n\n\nThe newt tool can ascertain a map of all the egg capabilities and use it to check dependencies and make sure all the necessary eggs are in a project for a particular target.\n\n\nIdentity\n\n\nIdentity is a property of a target or project in the newt world. A target may inherit it from a project or vice versa. It may be used to determine what eggs to include or how an egg code should behave in a build or which linkerscripts to use. For example, the identity of a lock is different from the identity of a wearable monitor. Even if they were to be built on the same hardware target, different features and behavior are required. Their different identities result in differing sets of eggs in the projects and/or the same egg behaving differently depending on the identity.", 
            "title": "Understanding Newt Terms"
        }, 
        {
            "location": "/chapter2/vocabulary/#understanding-newt-terms", 
            "text": "Nest  The nest is the base directory of your embedded software. It is meant to be the workspace containing a logical collection of the source code for one or more of your projects. A nest can contain multiple projects, and reflect multiple end products.   As the base repository of your source code, the nest has a master branch and several other branches off it. You may choose any branch to nest on. Each project in your nest will typically consist of several  eggs . A project could be an egg itself as well. In addition to eggs, a local nest will contain additional items such as  target  or build definitions, clutch description files, scripts etc.  For example, a walk through the \"larva\" nest at  https://github.com/mynewt/larva.git  shows the following structure. The nest.yml file in the larva directory indicates that it is a nest. An egg will have the egg.yml file in it as shown below. By this nomenclature, each board support package for a particular chip is an egg, the API for the hardware abstraction layer is an egg, and so on.   larva\n  |- nest.yml \n  |- compiler\n        |- arm-none-eabi-m4\n        |- sim\n  |- hw (hardware)\n        |- bsp (board support package)\n                |- nrf52pdk (Nordic nRF52 series chip)\n                        |- egg.yml\n                        |- ...\n                |- olimex_stm32-e407_devboard (used in chapter1 project)\n                        |- egg.yml\n                        |- ...\n                |- stm32f3discovery (another board with stm32f3 mcu)\n                        |- egg.yml\n                        |- ...\n                |- yet another board\n                        |- egg.yml\n                        |- ...\n        |- hal (hardware abstraction layer APIs)\n                |- egg.yml\n                |- include\n                        |- hal_cputime.h\n                        |- hal_flash.h\n                        |- hal_gpio.h\n                        |- ... (header files for other peripherals)\n        |- mcu (microcontroller)\n                |- stm (STMicro family)\n                    |- stm32f3xx (STM32f3 series, 32-bit ARM Cortex-M4  core)\n                        |- egg.yml\n                        |- src\n                            |- hal_gpio.c (specific to the STM32f3 mcu)\n                            |- hal_cputime.c\n                            |- ... (code for other peripherals)\n                |- nordic (Nordic Semiconductor family)\n                    |- nrf52xxx (nRF52 Series SoC, Cortex-M4F core)\n                        |- egg.yml\n                        |- src\n                            |- hal_gpio.c (specific to the nRF52 mcu )\n                            |- hal_cputime.c\n                            |- ... (code for other peripherals)\n                |- yet another family of mcu\n                    |- ...\n  |- libs\n        |- bootutil (hw architecture independent boot loader library)\n                |- egg.yml\n                |- src\n                    |- loader.c\n                    |- ... (related source code files)\n        |- nffs (hw architecture independent Newtron Flash File System)\n                |- egg.yml\n                |- src\n                    |- nffs.c\n                    |- ... (related source code files)\n        |- another library \n                |- egg.yml\n                |- src\n                    |- ... (related source code files)\n  |- project\n  |- scripts  The newt tool offers the  nest  command to create and manage nests. In general, commands represent actions and flags are modifiers for those actions. A command can have children commands and optionally run an action. A full description of the  nest  command can be found in the newt tool reference in Chapter 3.  newt nest [flags]\nnewt nest [child-commands]  A complete list of all the nest commands can be found in the newt tool reference in  Chapter 3 .  Project  Projects represent the individual build configurations of your embedded system and essentially defines your application. The project files are what dictate the resulting binary that is generated.   Layout-wise, a project is a directory inside a nest and contains eggs required for a certain application. For example, the  blinky  egg sits in  project/blinky  directory of the  larva  nest. This egg is used in the blinky project (application) outlined in  Chapter 1 .  Note: This Will Change  A project has the following concepts or properties associated with it. You can find them in the  project-name .yml  file in the project directory. For example, the  project/blinky  directory has the  blinky.yml  file indicating some or all of the properties below. Only the name of a project is required for the project to exist, however additional properties may need to be specified for the eggs in it to compile properly and produce an executable.    Project name  Base path of the project (nest/project/project-name by default)  Eggs belonging to the project  Capabilities  that are required for the project or target   Identity  to classify the type of project or target  Compiler flags to call out any specific compiler requirement   A project could itself be an egg if it is a distributable package for a specific application.   The newt tool offers various commands that you can use with a project. For example, if your project is an egg, you can use the following command to install a project from a nest.  newt egg install [flags]  project egg name   Egg  An egg is a distributable package of libraries. Just as an egg in nature has various parts each of which serves a certain purpose, the Mynewt egg consists of software parcels or modules that have different functions. However, unlike the egg in nature these software modules can exist by itself and may be distributed; therefore, they too are essentially eggs. Once this concept is grasped it is easy to see how an egg may consist of other eggs.  The two main directories in an egg are  /include  and  /src .  The newt tool offers several egg commands to list, inspect, install, and do other operations on eggs. For example, the following command  newt egg list  outputs all the eggs in the current nest where each egg has details on its version, path, and dependencies. A sample output for an egg is given below.  Egg libs/os, version 0.1.0\npath: /Users/aditihilbert/dev/test_project/libs/os\ndeps: libs/testutil@none#stable  A complete list of all the egg commands can be found in the newt tool reference in  Chapter 3 .  Clutch  A clutch is a snapshot of all eggs in a remote nest at any point in time. On any given github branch, a nest with a clutch of eggs will contain a  clutch.yml  file that specifies the version number, dependencies, and hash value for each constituent egg as well as the name of the entire clutch and the github url for it. [Note: Currently ]  You may download multiple clutches into your local nest as long as the names of the clutches are different. This allows you to mix and match various features and functionality coming from different clutches of eggs. You can see all the clutches in the  .nest/clutches  directory in your nest.  The newt tool offers clutch management commands within the  newt nest  command. For example, the following command creates a new clutch using all the eggs in the current directory. It requires that a clutch name be specified and the url for the location of that clutch in the online repository. These two inputs go into the  clutch.yml  file in the nest.  newt nest generate-clutch  name   url   Note that a clutch merely defines the eggs belonging together and requires the eggs to be installed (hatched) for the source code to be populated in the project.   Eggshell  The term eggshell is used to refer to the eggs of a clutch in a remote repository. They are not useful on your local machine until you actually install them. So they are mere shells of themselves while sitting on the online repository. When you enter the following command outputs the total number of shells in each remote clutch.  newt nest list-clutches  So, if you had two clutches installed, the output could be:  Remote clutch larva (eggshells: 19)\nRemote clutch ble_test (eggshells: 15)  Target  A target is the hardware build or its software equivalent (e.g. test, simulator) set for a project. It tells the newt tool how to build the source code within a given nest. Once a new target is created, its architecture and other details needs to be defined. An example of a defined target named \"blink_f3disc\" is given below.  blink_f3disc\n         compiler_def: debug\n         compiler: arm-none-eabi-m4\n         name: blink_f3disc\n         arch: cortex_m4\n         project: blinky\n         bsp: hw/bsp/stm32f3discovery  The newt tool offers commands to create, set up and manipulate targets. For example, the create command below creates an empty target named  my_target1  and the set command sets one detail of its definition, namely the architecture.  newt target create my_target1\nnewt target set my_target1 arch=cortex_m4  Capability  Capability is functionality that is exposed by an egg. A capability is tracked by its name and version. An egg may require capabilities exposed by another egg, thus establishing a dependency tracked through the egg.yml files.   The newt tool can ascertain a map of all the egg capabilities and use it to check dependencies and make sure all the necessary eggs are in a project for a particular target.  Identity  Identity is a property of a target or project in the newt world. A target may inherit it from a project or vice versa. It may be used to determine what eggs to include or how an egg code should behave in a build or which linkerscripts to use. For example, the identity of a lock is different from the identity of a wearable monitor. Even if they were to be built on the same hardware target, different features and behavior are required. Their different identities result in differing sets of eggs in the projects and/or the same egg behaving differently depending on the identity.", 
            "title": "Understanding Newt Terms"
        }, 
        {
            "location": "/chapter2/project2/", 
            "text": "Project 2 - Blinky on additional boards\n\n\nObjective\n\n\nThe goal of this tutorial is to download a generic firmware skeleton (\"bootstrap image\") that applies to any hardware and then throw in additional applicable eggs to generate a build for a specific board. \n\n\nThe following target hardware chips are covered:\n\n\n\n\nSTM32F303VC MCU\n from STMicroelectronics\n\n\nnRF52 Series\n from Nordic Semiconductors \n\n\n\n\nSTM32F303VC MCU\n\n\nHardware needed\n\n\n\n\nDiscovery kit with STM32F303VC MCU\n\n\nLaptop running Mac OS\n\n\n\n\nStep by Step Instructions to build image\n\n\n\n\n\n\nThe first step is to download the generic skeleton of the project. The eggs installed are not hardware architecture specific.\n\n\n[user:~/foo]$ newt nest create test_project\nDownloading nest skeleton from https://www.github.com/mynewt/tadpole...   ok!\nNest test_project successfully created in ~/foo/test_project\n\n[user:~/foo]$ cd test_project/\n\n\n\n\n\n\n\nThen, the clutch of eggs named larva is added from the nest (also named larva) on the github. This step simply downloads the clutch description file and does not actually install the eggs that constitute the clutch. The clutch description file (\nclutch.yml\n) will be used to check dependencies during the egg install to ensure completeness. It serves as a reference for all the eggs in the clutch that one can choose from and install.\n\n\n[user:~/foo/test_project]$ newt nest add-clutch larva https://github.com/mynewt/larva\nDownloading clutch.yml from https://github.com/mynewt/larva/master... ok!\nVerifying clutch.yml format... ok!\nClutch larva successfully installed to Nest.\n\n\n\n\n\n\n\nThe next step is to install relevant eggs from the larva nest on github. The instructions assume that you know what application or project you are interested in (the blinky application, in this case), what hardware you are using (STM32F3DISCOVERY board, in this case) and hence, what board support package you need. \n\n\n[user:~/foo/test_projec]$ newt egg install project/blinky          \nDownloading larva from https://github.com/mynewt/larva//master... ok!\nInstalling project/blinky\nInstallation was a success!\n\n[user:~/foo/test_project]$ newt egg install hw/bsp/stm32f3discovery\nDownloading larva from https://github.com/mynewt/larva//master... ok!\nInstalling hw/bsp/stm32f3discovery\nInstalling hw/mcu/stm/stm32f3xx\nInstalling libs/cmsis-core\nInstalling compiler/arm-none-eabi-m4\nInstallation was a success!\n\n\n\n\n\n\n\nIt's time to create a target for the project and define the target attributes. \n\n\n[user:~/foo/test_project]$ newt target create blink_f3disc\nCreating target blink_f3disc\nTarget blink_f3disc successfully created!\n\n[user:~/foo/test_project]$ newt target set blink_f3disc project=blinky\nTarget blink_f3disc successfully set project to blinky\n\n[user:~/foo/test_project]$ newt target set blink_f3disc bsp=hw/bsp/stm32f3discovery\nTarget blink_f3disc successfully set bsp to hw/bsp/stm32f3discovery\n\n[marko@Markos-MacBook-Pro-2:~/foo/test_project]$ newt target set blink_f3disc compiler_def=debug\nTarget blink_f3disc successfully set compiler_def to debug\n\n[user:~/foo/test_project]$ newt target set blink_f3disc compiler=arm-none-eabi-m4\nTarget blink_f3disc successfully set compiler to arm-none-eabi-m4\n\n[user:~/foo/test_project]$ newt target set blink_f3disc arch=cortex_m4\nTarget blink_f3disc successfully set arch to cortex_m4\n\n[user:~/foo/test_project]$ newt target show blink_f3disc\nblink_f3disc\n    arch: cortex_m4\n    project: blinky\n    bsp: hw/bsp/stm32f3discovery\n    compiler_def: debug\n    compiler: arm-none-eabi-m4\n    name: blink_f3disc\n\n\n\n\n\n\n\nFinally, you get to build the target and generate an executable that can now be uploaded to the board via the JTAG port. You can go into the openocd directory and start an OCD session as you did in Project 1.\n\n\n[user:~/foo/test_project]$ newt target build         blink_f3disc\nBuilding target blink_f3disc (project = blinky)\nCompiling case.c\nCompiling suite.c\nCompiling testutil.c\nCompiling testutil_arch_arm.c\nArchiving libtestutil.a\nCompiling os.c\nCompiling os_callout.c\nCompiling os_eventq.c\nCompiling os_heap.c\nCompiling os_mbuf.c\nCompiling os_mempool.c\nCompiling os_mutex.c\nCompiling os_sanity.c\nCompiling os_sched.c\nCompiling os_sem.c\nCompiling os_task.c\nCompiling os_time.c\nCompiling os_arch_arm.c\nAssembling HAL_CM4.s\nAssembling SVC_Table.s\nArchiving libos.a\nCompiling hal_gpio.c\nCompiling stm32f3xx_hal_gpio.c\nArchiving libstm32f3xx.a\nCompiling cmsis_nvic.c\nCompiling libc_stubs.c\nCompiling os_bsp.c\nCompiling sbrk.c\nCompiling system_stm32f3xx.c\nAssembling startup_stm32f303xc.s\nArchiving libstm32f3discovery.a\nCompiling main.c\nBuilding project blinky\nLinking blinky.elf\nSuccessfully run!\n\n\n\n\n\n\n\nnRF52 Series\n\n\nHardware needed\n\n\n\n\nnRF52 Development Kit\n\n\nLaptop running Mac OS\n\n\n\n\nStep by Step Instructions to build image\n\n\n\n\n\n\nThe first step is to download the generic skeleton of the project. The eggs installed are not hardware architecture specific.\n\n\n[]user@~/dev]$ newt nest create nordic_blinky\nDownloading nest skeleton from https://www.github.com/mynewt/tadpole... ok!\nNest nordic_blinky successfully created in ~dev/nordic_blinky\n\nuser@~/dev$ cd nordic_blinky/\n\n\n\n\n\n\n\nThen, the clutch of eggs named larva is added from the nest (also named larva) on the github. This step simply downloads the clutch description file and does not actually install the eggs that constitute the clutch. The clutch description file (\nclutch.yml\n) will be used to check dependencies during the egg install to ensure completeness. It serves as a reference for all the eggs in the clutch that one can choose from and install.\n\n\n[]user@~/dev/nordic_blinky]$ newt nest add-clutch larva https://github.com/mynewt/larva\nDownloading clutch.yml from https://github.com/mynewt/larva/master... ok!\nVerifying clutch.yml format...ok!\nClutch larva successfully installed to Nest.\n\n\n\n\n\n\n\nThe next step is to install relevant eggs from the larva nest on github. The instructions assume that you know what application or project you are interested in (the blinky application, in this case), what hardware you are using (STM32F3DISCOVERY board, in this case) and hence, what board support package you need. \n\n\n[user@~/dev/nordic_blinky]$ newt egg install project/blinky \nDownloading larva from https://github.com/mynewt/larva//master... ok!\nInstalling project/blinky\nInstallation was a success!\n\n[user@~/dev/nordic_blinky]$ newt egg install hw/bsp/nrf52pdk\nDownloading larva from https://github.com/mynewt/larva//master... ok!\nInstalling hw/bsp/nrf52pdk\nInstalling hw/mcu/nordic/nrf52xxx\nInstalling libs/cmsis-core\nInstalling compiler/arm-none-eabi-m4\nInstallation was a success!\n\n\n\n\n\n\n\nIt's time to create a target for the project and define the target attributes. \n\n\n[user@~/dev/nordic_blinky]$ newt target create blink_nordic\nCreating target blink_nordic\nTarget blink_nordic successfully created!\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic project=blinky\nTarget blink_nordic successfully set project to blinky\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic bsp=hw/bsp/nrf52pdk\nTarget blink_nordic successfully set bsp to hw/bsp/nrf52pdk\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic compiler_def=debug\nTarget blink_nordic successfully set compiler_def to debug\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic compiler=arm-none-eabi-m4\nTarget blink_nordic successfully set compiler to arm-none-eabi-m4\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic arch=cortex_m4\nTarget blink_nordic successfully set arch to cortex_m4\n[user@~/dev/nordic_blinky]$ newt target show\nblink_nordic\n    compiler: arm-none-eabi-m4\n    name: blink_nordic\n    arch: cortex_m4\n    project: blinky\n    bsp: hw/bsp/nrf52pdk\n    compiler_def: debug\n\n\n\n\n\n\n\nFinally, you get to build the target and generate an executable that can now be uploaded to the board via the on-board SEGGER J-Link debugger. \n\n\n[user@~/dev/nordic_blinky]$ newt target build blink_nordic\nBuilding target blink_nordic (project = blinky)\nCompiling case.c\nCompiling suite.c\nCompiling testutil.c\nCompiling testutil_arch_arm.c\nArchiving libtestutil.a\nCompiling os.c\nCompiling os_callout.c\nCompiling os_eventq.c\nCompiling os_heap.c\nCompiling os_mbuf.c\nCompiling os_mempool.c\nCompiling os_mutex.c\nCompiling os_sanity.c\nCompiling os_sched.c\nCompiling os_sem.c\nCompiling os_task.c\nCompiling os_time.c\nCompiling os_arch_arm.c\nAssembling HAL_CM4.s\nAssembling SVC_Table.s\nArchiving libos.a\nCompiling hal_cputime.c\nCompiling hal_gpio.c\nCompiling hal_uart.c\nArchiving libnrf52xxx.a\nCompiling cmsis_nvic.c\nCompiling hal_bsp.c\nCompiling libc_stubs.c\nCompiling os_bsp.c\nCompiling sbrk.c\nCompiling system_nrf52.c\nAssembling gcc_startup_nrf52.s\nArchiving libnrf52pdk.a\nCompiling main.c\nBuilding project blinky\nLinking blinky.elf\nSuccessfully run!\n\n\n\n\n\n\n\nIn order to be able to communicate with the SEGGER J-Link debugger on the dev board, you have to download and install the J-Link GDB Server software on to your laptop. You may download the \"Software and documentation pack for Mac OS X\" from \nhttps://www.segger.com/jlink-software.html\n. The command line version of the server is used in the steps below. \n\n\n\n\n\n\nOpen a new terminal and start a J-Link session.\n\n\n[user@~/dev/nordic_blinky/project/blinky/bin]$ which JLinkGDBServer\n/usr/local/bin/JLinkGDBServer\n[user@~/dev/nordic_blinky/project/blinky/bin]$ JLinkGDBServer -if SWD\nSEGGER J-Link GDB Server V5.02f Command Line Version\n\nJLinkARM.dll V5.02f (DLL compiled Oct  2 2015 20:55:03)\n\n-----GDB Server start settings-----\nGDBInit file:                  none\nGDB Server Listening port:     2331\nSWO raw output listening port: 2332\nTerminal I/O port:             2333\nAccept remote connection:      yes\nGenerate logfile:              off\nVerify download:               off\nInit regs on start:            off\nSilent mode:                   off\nSingle run mode:               off\nTarget connection timeout:     0 ms\n------J-Link related settings------\nJ-Link Host interface:         USB\nJ-Link script:                 none\nJ-Link settings file:          none\n------Target related settings------\nTarget device:                 unspecified\nTarget interface:              SWD\nTarget interface speed:        1000kHz\nTarget endian:                 little\n\nConnecting to J-Link...\nJ-Link is connected.\nFirmware: J-Link OB-SAM3U128-V2-NordicSemi compiled Aug 28 2015 19:26:24\nHardware: V1.00\nS/N: 682371959\nChecking target voltage...\nTarget voltage: 3.30 V\nListening on TCP/IP port 2331\nConnecting to target...Connected to target\nWaiting for GDB connection...Connected to 127.0.0.1\n\n\n\n\n\n\n\nYou need a configuration file for the GDB session to be opened correctly and the image (\"blinky.elf\") you built for this target downloaded to flash. A sample config script is given below. Alternatively, you could choose to type each command at the gdb prompt.\n\n\n [user@~/dev/nordic_blinky/project/blinky/bin/blink_nordic]$ cat jlink-gdb.cfg \n echo ***Setting up the environment for debugging gdb.***\\n\n set complaints 1\n set prompt (gdb) \n set endian little\n echo \\n*** Set target charset ASCII\\n\n set target-charset ASCII\n echo \\n*** Connecting over port #2331 ***\\n\n target remote localhost:2331\n echo \\n*** Enable flash write and set device to nrf52 ***\\n\n monitor flash download=1\n monitor flash device=nRF52\n echo \\n*** loading blinky.elf ***\\n\n load ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf \n symbol-file ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf\n echo \\n*** Resetting target ***\\n\n monitor reset\n echo \\n*** Halting target ***\\n\n monitor halt\n\n\n\n\n\n\n\nStart the gdb session and monitor that it loads the image, resets the target, and halts for a command to continue. \n\n\n[user@~/dev/nordic_blinky/project/blinky/bin/blink_nordic]$ arm-none-eabi-gdb -x ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/jlink-gdb.cfg\n\nGNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later \nhttp://gnu.org/licenses/gpl.html\n\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"--host=x86_64-apple-darwin10 --target=arm-none-eabi\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n\nhttp://www.gnu.org/software/gdb/bugs/\n.\nFind the GDB manual and other documentation resources online at:\n\nhttp://www.gnu.org/software/gdb/documentation/\n.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n\n***Setting up the environment for debugging gdb.***\nThe target is assumed to be little endian\n\n*** Set target charset ASCII\n\n*** Connecting over port #2331 ***\n0x00003c34 in ?? ()\n\n*** Enable flash write and set device to nrf52 ***\nFlash download enabled\nSelecting device: nRF52\n\n*** loading blinky.elf ***\nLoading section .text, size 0x5c84 lma 0x0\nLoading section .ARM.extab, size 0x24 lma 0x5c84\nLoading section .ARM.exidx, size 0xd8 lma 0x5ca8\nLoading section .data, size 0x8f8 lma 0x5d80\nStart address 0x48c, load size 26232\nTransfer rate: 12808 KB/sec, 2914 bytes/write.\nDuring symbol reading, unexpected overlap between:\n (A) section `.text' from `~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf' [0x0, 0x5c84)\n (B) section `*COM*' from `~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf' [0x0, 0x0).\nWill ignore section B.\n\n*** Resetting target ***\nResetting target\n\n*** Halting target ***\n\n\n\n\n\n\n\nType 'c' to continue. The LED on the board will start to blink. You will also see some activity in the terminal showing the open J-Link GDB server connection. The LED will continue to blink after you quit out of that connection.\n\n\n(gdb) c\nContinuing.", 
            "title": "Project 2"
        }, 
        {
            "location": "/chapter2/project2/#project-2-blinky-on-additional-boards", 
            "text": "Objective  The goal of this tutorial is to download a generic firmware skeleton (\"bootstrap image\") that applies to any hardware and then throw in additional applicable eggs to generate a build for a specific board.   The following target hardware chips are covered:   STM32F303VC MCU  from STMicroelectronics  nRF52 Series  from Nordic Semiconductors    STM32F303VC MCU  Hardware needed   Discovery kit with STM32F303VC MCU  Laptop running Mac OS   Step by Step Instructions to build image    The first step is to download the generic skeleton of the project. The eggs installed are not hardware architecture specific.  [user:~/foo]$ newt nest create test_project\nDownloading nest skeleton from https://www.github.com/mynewt/tadpole...   ok!\nNest test_project successfully created in ~/foo/test_project\n\n[user:~/foo]$ cd test_project/    Then, the clutch of eggs named larva is added from the nest (also named larva) on the github. This step simply downloads the clutch description file and does not actually install the eggs that constitute the clutch. The clutch description file ( clutch.yml ) will be used to check dependencies during the egg install to ensure completeness. It serves as a reference for all the eggs in the clutch that one can choose from and install.  [user:~/foo/test_project]$ newt nest add-clutch larva https://github.com/mynewt/larva\nDownloading clutch.yml from https://github.com/mynewt/larva/master... ok!\nVerifying clutch.yml format... ok!\nClutch larva successfully installed to Nest.    The next step is to install relevant eggs from the larva nest on github. The instructions assume that you know what application or project you are interested in (the blinky application, in this case), what hardware you are using (STM32F3DISCOVERY board, in this case) and hence, what board support package you need.   [user:~/foo/test_projec]$ newt egg install project/blinky          \nDownloading larva from https://github.com/mynewt/larva//master... ok!\nInstalling project/blinky\nInstallation was a success!\n\n[user:~/foo/test_project]$ newt egg install hw/bsp/stm32f3discovery\nDownloading larva from https://github.com/mynewt/larva//master... ok!\nInstalling hw/bsp/stm32f3discovery\nInstalling hw/mcu/stm/stm32f3xx\nInstalling libs/cmsis-core\nInstalling compiler/arm-none-eabi-m4\nInstallation was a success!    It's time to create a target for the project and define the target attributes.   [user:~/foo/test_project]$ newt target create blink_f3disc\nCreating target blink_f3disc\nTarget blink_f3disc successfully created!\n\n[user:~/foo/test_project]$ newt target set blink_f3disc project=blinky\nTarget blink_f3disc successfully set project to blinky\n\n[user:~/foo/test_project]$ newt target set blink_f3disc bsp=hw/bsp/stm32f3discovery\nTarget blink_f3disc successfully set bsp to hw/bsp/stm32f3discovery\n\n[marko@Markos-MacBook-Pro-2:~/foo/test_project]$ newt target set blink_f3disc compiler_def=debug\nTarget blink_f3disc successfully set compiler_def to debug\n\n[user:~/foo/test_project]$ newt target set blink_f3disc compiler=arm-none-eabi-m4\nTarget blink_f3disc successfully set compiler to arm-none-eabi-m4\n\n[user:~/foo/test_project]$ newt target set blink_f3disc arch=cortex_m4\nTarget blink_f3disc successfully set arch to cortex_m4\n\n[user:~/foo/test_project]$ newt target show blink_f3disc\nblink_f3disc\n    arch: cortex_m4\n    project: blinky\n    bsp: hw/bsp/stm32f3discovery\n    compiler_def: debug\n    compiler: arm-none-eabi-m4\n    name: blink_f3disc    Finally, you get to build the target and generate an executable that can now be uploaded to the board via the JTAG port. You can go into the openocd directory and start an OCD session as you did in Project 1.  [user:~/foo/test_project]$ newt target build         blink_f3disc\nBuilding target blink_f3disc (project = blinky)\nCompiling case.c\nCompiling suite.c\nCompiling testutil.c\nCompiling testutil_arch_arm.c\nArchiving libtestutil.a\nCompiling os.c\nCompiling os_callout.c\nCompiling os_eventq.c\nCompiling os_heap.c\nCompiling os_mbuf.c\nCompiling os_mempool.c\nCompiling os_mutex.c\nCompiling os_sanity.c\nCompiling os_sched.c\nCompiling os_sem.c\nCompiling os_task.c\nCompiling os_time.c\nCompiling os_arch_arm.c\nAssembling HAL_CM4.s\nAssembling SVC_Table.s\nArchiving libos.a\nCompiling hal_gpio.c\nCompiling stm32f3xx_hal_gpio.c\nArchiving libstm32f3xx.a\nCompiling cmsis_nvic.c\nCompiling libc_stubs.c\nCompiling os_bsp.c\nCompiling sbrk.c\nCompiling system_stm32f3xx.c\nAssembling startup_stm32f303xc.s\nArchiving libstm32f3discovery.a\nCompiling main.c\nBuilding project blinky\nLinking blinky.elf\nSuccessfully run!    nRF52 Series  Hardware needed   nRF52 Development Kit  Laptop running Mac OS   Step by Step Instructions to build image    The first step is to download the generic skeleton of the project. The eggs installed are not hardware architecture specific.  []user@~/dev]$ newt nest create nordic_blinky\nDownloading nest skeleton from https://www.github.com/mynewt/tadpole... ok!\nNest nordic_blinky successfully created in ~dev/nordic_blinky\n\nuser@~/dev$ cd nordic_blinky/    Then, the clutch of eggs named larva is added from the nest (also named larva) on the github. This step simply downloads the clutch description file and does not actually install the eggs that constitute the clutch. The clutch description file ( clutch.yml ) will be used to check dependencies during the egg install to ensure completeness. It serves as a reference for all the eggs in the clutch that one can choose from and install.  []user@~/dev/nordic_blinky]$ newt nest add-clutch larva https://github.com/mynewt/larva\nDownloading clutch.yml from https://github.com/mynewt/larva/master... ok!\nVerifying clutch.yml format...ok!\nClutch larva successfully installed to Nest.    The next step is to install relevant eggs from the larva nest on github. The instructions assume that you know what application or project you are interested in (the blinky application, in this case), what hardware you are using (STM32F3DISCOVERY board, in this case) and hence, what board support package you need.   [user@~/dev/nordic_blinky]$ newt egg install project/blinky \nDownloading larva from https://github.com/mynewt/larva//master... ok!\nInstalling project/blinky\nInstallation was a success!\n\n[user@~/dev/nordic_blinky]$ newt egg install hw/bsp/nrf52pdk\nDownloading larva from https://github.com/mynewt/larva//master... ok!\nInstalling hw/bsp/nrf52pdk\nInstalling hw/mcu/nordic/nrf52xxx\nInstalling libs/cmsis-core\nInstalling compiler/arm-none-eabi-m4\nInstallation was a success!    It's time to create a target for the project and define the target attributes.   [user@~/dev/nordic_blinky]$ newt target create blink_nordic\nCreating target blink_nordic\nTarget blink_nordic successfully created!\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic project=blinky\nTarget blink_nordic successfully set project to blinky\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic bsp=hw/bsp/nrf52pdk\nTarget blink_nordic successfully set bsp to hw/bsp/nrf52pdk\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic compiler_def=debug\nTarget blink_nordic successfully set compiler_def to debug\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic compiler=arm-none-eabi-m4\nTarget blink_nordic successfully set compiler to arm-none-eabi-m4\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic arch=cortex_m4\nTarget blink_nordic successfully set arch to cortex_m4\n[user@~/dev/nordic_blinky]$ newt target show\nblink_nordic\n    compiler: arm-none-eabi-m4\n    name: blink_nordic\n    arch: cortex_m4\n    project: blinky\n    bsp: hw/bsp/nrf52pdk\n    compiler_def: debug    Finally, you get to build the target and generate an executable that can now be uploaded to the board via the on-board SEGGER J-Link debugger.   [user@~/dev/nordic_blinky]$ newt target build blink_nordic\nBuilding target blink_nordic (project = blinky)\nCompiling case.c\nCompiling suite.c\nCompiling testutil.c\nCompiling testutil_arch_arm.c\nArchiving libtestutil.a\nCompiling os.c\nCompiling os_callout.c\nCompiling os_eventq.c\nCompiling os_heap.c\nCompiling os_mbuf.c\nCompiling os_mempool.c\nCompiling os_mutex.c\nCompiling os_sanity.c\nCompiling os_sched.c\nCompiling os_sem.c\nCompiling os_task.c\nCompiling os_time.c\nCompiling os_arch_arm.c\nAssembling HAL_CM4.s\nAssembling SVC_Table.s\nArchiving libos.a\nCompiling hal_cputime.c\nCompiling hal_gpio.c\nCompiling hal_uart.c\nArchiving libnrf52xxx.a\nCompiling cmsis_nvic.c\nCompiling hal_bsp.c\nCompiling libc_stubs.c\nCompiling os_bsp.c\nCompiling sbrk.c\nCompiling system_nrf52.c\nAssembling gcc_startup_nrf52.s\nArchiving libnrf52pdk.a\nCompiling main.c\nBuilding project blinky\nLinking blinky.elf\nSuccessfully run!    In order to be able to communicate with the SEGGER J-Link debugger on the dev board, you have to download and install the J-Link GDB Server software on to your laptop. You may download the \"Software and documentation pack for Mac OS X\" from  https://www.segger.com/jlink-software.html . The command line version of the server is used in the steps below.     Open a new terminal and start a J-Link session.  [user@~/dev/nordic_blinky/project/blinky/bin]$ which JLinkGDBServer\n/usr/local/bin/JLinkGDBServer\n[user@~/dev/nordic_blinky/project/blinky/bin]$ JLinkGDBServer -if SWD\nSEGGER J-Link GDB Server V5.02f Command Line Version\n\nJLinkARM.dll V5.02f (DLL compiled Oct  2 2015 20:55:03)\n\n-----GDB Server start settings-----\nGDBInit file:                  none\nGDB Server Listening port:     2331\nSWO raw output listening port: 2332\nTerminal I/O port:             2333\nAccept remote connection:      yes\nGenerate logfile:              off\nVerify download:               off\nInit regs on start:            off\nSilent mode:                   off\nSingle run mode:               off\nTarget connection timeout:     0 ms\n------J-Link related settings------\nJ-Link Host interface:         USB\nJ-Link script:                 none\nJ-Link settings file:          none\n------Target related settings------\nTarget device:                 unspecified\nTarget interface:              SWD\nTarget interface speed:        1000kHz\nTarget endian:                 little\n\nConnecting to J-Link...\nJ-Link is connected.\nFirmware: J-Link OB-SAM3U128-V2-NordicSemi compiled Aug 28 2015 19:26:24\nHardware: V1.00\nS/N: 682371959\nChecking target voltage...\nTarget voltage: 3.30 V\nListening on TCP/IP port 2331\nConnecting to target...Connected to target\nWaiting for GDB connection...Connected to 127.0.0.1    You need a configuration file for the GDB session to be opened correctly and the image (\"blinky.elf\") you built for this target downloaded to flash. A sample config script is given below. Alternatively, you could choose to type each command at the gdb prompt.   [user@~/dev/nordic_blinky/project/blinky/bin/blink_nordic]$ cat jlink-gdb.cfg \n echo ***Setting up the environment for debugging gdb.***\\n\n set complaints 1\n set prompt (gdb) \n set endian little\n echo \\n*** Set target charset ASCII\\n\n set target-charset ASCII\n echo \\n*** Connecting over port #2331 ***\\n\n target remote localhost:2331\n echo \\n*** Enable flash write and set device to nrf52 ***\\n\n monitor flash download=1\n monitor flash device=nRF52\n echo \\n*** loading blinky.elf ***\\n\n load ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf \n symbol-file ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf\n echo \\n*** Resetting target ***\\n\n monitor reset\n echo \\n*** Halting target ***\\n\n monitor halt    Start the gdb session and monitor that it loads the image, resets the target, and halts for a command to continue.   [user@~/dev/nordic_blinky/project/blinky/bin/blink_nordic]$ arm-none-eabi-gdb -x ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/jlink-gdb.cfg\n\nGNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later  http://gnu.org/licenses/gpl.html \nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"--host=x86_64-apple-darwin10 --target=arm-none-eabi\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see: http://www.gnu.org/software/gdb/bugs/ .\nFind the GDB manual and other documentation resources online at: http://www.gnu.org/software/gdb/documentation/ .\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n\n***Setting up the environment for debugging gdb.***\nThe target is assumed to be little endian\n\n*** Set target charset ASCII\n\n*** Connecting over port #2331 ***\n0x00003c34 in ?? ()\n\n*** Enable flash write and set device to nrf52 ***\nFlash download enabled\nSelecting device: nRF52\n\n*** loading blinky.elf ***\nLoading section .text, size 0x5c84 lma 0x0\nLoading section .ARM.extab, size 0x24 lma 0x5c84\nLoading section .ARM.exidx, size 0xd8 lma 0x5ca8\nLoading section .data, size 0x8f8 lma 0x5d80\nStart address 0x48c, load size 26232\nTransfer rate: 12808 KB/sec, 2914 bytes/write.\nDuring symbol reading, unexpected overlap between:\n (A) section `.text' from `~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf' [0x0, 0x5c84)\n (B) section `*COM*' from `~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf' [0x0, 0x0).\nWill ignore section B.\n\n*** Resetting target ***\nResetting target\n\n*** Halting target ***    Type 'c' to continue. The LED on the board will start to blink. You will also see some activity in the terminal showing the open J-Link GDB server connection. The LED will continue to blink after you quit out of that connection.  (gdb) c\nContinuing.", 
            "title": "Project 2 - Blinky on additional boards"
        }, 
        {
            "location": "/chapter2/project3/", 
            "text": "How to Test an Egg", 
            "title": "Project 3"
        }, 
        {
            "location": "/chapter2/project3/#how-to-test-an-egg", 
            "text": "", 
            "title": "How to Test an Egg"
        }, 
        {
            "location": "/chapter3/newt_ops/", 
            "text": "Command Structure\n\n\nIn the newt tool, commands represent actions and flags are modifiers for those actions. A command can have children commands which are also simply referred to as commands. One or more arguments may need to be provided to a command to execute it correctly. \n\n\nIn the example below, the \nnewt\n command has the child command \ntarget set\n. The first argument 'my_target1' is the name of the target whose attributes are being set. The second argument 'arch=cortex_m4' specifies the value to set the attribute (variable) 'arch' to, which in this case is 'cortex_m4'. \n\n\nnewt target set my_target1 arch=cortex_m4\n\n\n\nGlobal flags work on all newt commands in the same way. An example is the flag \n-v, --verbose\n to ask for a verbose output while executing a command. The help flag \n-h\n or  \n--help\n is available on all commands but provides command specific output, of course. These flags may be specified in either a long or a short form. \n\n\nA command may additionally take flags specific to it. For example, the \n-b\n flag may be used with \nnewt egg install\n to tell it which branch to install the egg from. \n\n\nnewt egg install -b \nbranchname\n \neggname\n\n\n\n\nIn addition to the newt tool \nreference\n in this documentation set, command-line help is available for each command (and child command). Simply use the flag \n-h\n or \n--help\n as shown below:\n\n\n$ newt target export --help\nExport build targets from the current nest, and print them to \nstandard output. If the -a (or -export-all) option is specified, \nthen all targets will be exported. Otherwise, \ntarget-name\n \nmust be specified, and only that target will be exported.\n\nUsage: \n  newt target export [flags]\n\nExamples:\n  newt target export [-a -export-all] [\ntarget-name\n]\n  newt target export -a \n my_exports.txt\n  newt target export my_target \n my_target_export.txt\n\nFlags:\n  -a, --export-all=false: If present, export all targets\n  -h, --help=false: help for export\n\nGlobal Flags:\n  -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n  -q, --quiet=false: Be quiet; only display error output.\n  -s, --silent=false: Be silent; don't output anything.\n  -v, --verbose=false: Enable verbose output when executing commands.", 
            "title": "Command structure"
        }, 
        {
            "location": "/chapter3/newt_ops/#command-structure", 
            "text": "In the newt tool, commands represent actions and flags are modifiers for those actions. A command can have children commands which are also simply referred to as commands. One or more arguments may need to be provided to a command to execute it correctly.   In the example below, the  newt  command has the child command  target set . The first argument 'my_target1' is the name of the target whose attributes are being set. The second argument 'arch=cortex_m4' specifies the value to set the attribute (variable) 'arch' to, which in this case is 'cortex_m4'.   newt target set my_target1 arch=cortex_m4  Global flags work on all newt commands in the same way. An example is the flag  -v, --verbose  to ask for a verbose output while executing a command. The help flag  -h  or   --help  is available on all commands but provides command specific output, of course. These flags may be specified in either a long or a short form.   A command may additionally take flags specific to it. For example, the  -b  flag may be used with  newt egg install  to tell it which branch to install the egg from.   newt egg install -b  branchname   eggname   In addition to the newt tool  reference  in this documentation set, command-line help is available for each command (and child command). Simply use the flag  -h  or  --help  as shown below:  $ newt target export --help\nExport build targets from the current nest, and print them to \nstandard output. If the -a (or -export-all) option is specified, \nthen all targets will be exported. Otherwise,  target-name  \nmust be specified, and only that target will be exported.\n\nUsage: \n  newt target export [flags]\n\nExamples:\n  newt target export [-a -export-all] [ target-name ]\n  newt target export -a   my_exports.txt\n  newt target export my_target   my_target_export.txt\n\nFlags:\n  -a, --export-all=false: If present, export all targets\n  -h, --help=false: help for export\n\nGlobal Flags:\n  -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n  -q, --quiet=false: Be quiet; only display error output.\n  -s, --silent=false: Be silent; don't output anything.\n  -v, --verbose=false: Enable verbose output when executing commands.", 
            "title": "Command Structure"
        }, 
        {
            "location": "/chapter3/newt_tool_reference/", 
            "text": "Command List\n\n\nAvailable high-level commands\n\n\nversion     Display the Newt version number\nhelp        Help about any command\nnest        Commands to manage nests \n clutches (remote egg repositories)\negg         Commands to list and inspect eggs on a nest\ntarget      Set and view target information\n\n\n\n\nversion\n\n\nUsage:\n\n\nnewt version [flags]\n\n\n\nFlags:\n\n\n-h, --help=false: help for version\n\n\n\nGlobal Flags:\n\n\n-h, --help=false: help for newt\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nversion\n\n\nnewt version\n\n\nDisplays the version of newt tool installed\n\n\n\n\n\n\n\n\nhelp\n\n\nUsage:\n\n\nnewt help [input1]\n\n\n\nFlags:\n\n\n\n-h, --help=false: help for newt\n-l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nhelp\n\n\nnewt help target\n\n\nDisplays the help text for the newt command 'target'\n\n\n\n\n\n\nhelp\n\n\nnewt help\n\n\nDisplays the help text for newt tool\n\n\n\n\n\n\n\n\nnest\n\n\nUsage:\n\n\nnewt nest [command][flags] input1 input2...\n\n\n\nAvailable commands: \n\n\ncreate          Create a new nest\ngenerate-clutch Generate a clutch file from the eggs in the current directory\nadd-clutch      Add a remote clutch, and put it in the current nest\nlist-clutches   List the clutches installed in the current nest\nshow-clutch     Show an individual clutch in the current nest\n\n\n\nFlags:\n\n\n-h, --help=false: help for nest\n\n\n\nGlobal Flags:\n\n\n-h, --help=false: help for newt\n-l, --loglevel=\"WARN\": Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSub-command\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\ncreate\n\n\nDownloads the skeleton of a nest on your local machine from the optional \ninput2\nnest url, if specified, and creates a new nest directory by the name of \ninput1\n If \ninput2\nis not specified, then a default skeleton from the \ntadpole\nnest on Mynewt is downloaded. The command lays out a generic directory structure for the nest you are going to build under it and includes some default eggs in it.\n\n\n\n\n\n\ngenerate-clutch\n\n\nTakes a snapshot of the eggs in the current local directory and combines them into a clutch by the name of \ninput1\nand with the url of \ninput2\nand generates a standard output of the clutch details that can be redirected to a \n.yml\nclutch file. Typically the clutch file name is chosen to match the clutch name which means the standard output should be directed to a clutch file named \ninput1.yml\n\n\n\n\n\n\nadd-clutch\n\n\nDownloads the clutch of the name \ninput1\nfrom the master branch of the github repository \ninput2\ninto the current nest. A file named \ninput1.yml\nfile is added in the \n.nest/clutches\nsubdirectory inside the current local nest. The \n.nest/\ndirectory structure is created automatically if it does not exist.\n\n\n\n\n\n\nlist-clutches\n\n\nLists all the clutches present in the current nest, including clutches that may have been added from other nests on github. The output shows all the remote clutch names and the total eggshells in each of the clutches.\n\n\n\n\n\n\nshow-clutch\n\n\nShows information about the clutch that has the name given in the \ninput1\nargument. Output includes the clutch name, url, and all the constituent eggs with their version numbers.\n\n\n\n\n\n\n\n\nCommand-specific flags\n\n\n\n\n\n\n\n\nSub-command\n\n\nAvailable flags\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nadd-clutch\n\n\n-b, --branch=\"\n\"\n\n\nFetches the clutch file with name \ninput1\nfrom the specified branch at \ninput1\nurl of the github repository. All subsequent egg installations will be done from that branch.\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\ncreate\n\n\nnewt nest create test_project\n\n\nCreates a new nest named \"test_project \" using the default skeleton0\n\n\n\n\n\n\ncreate\n\n\nnewt nest create mynest \n\n\nCreates a new nest named \"mynest\" using the skeleton at the \n specified\n\n\n\n\n\n\ngenerate-clutch\n\n\nnewt nest generate-clutch myclutch https://www.github.com/mynewt/larva \n myclutch.yml\n\n\nTakes a snapshot of the eggs in the current nest to form a clutch named myclutch with the url https://www.github.com/mynewt/larva. The output is written to a file named \nmyclutch.yml\nand describes the properties and contents of the clutch (name, url, eggs).\n\n\n\n\n\n\nadd-clutch\n\n\nnewt nest add-clutch larva https://www.github.com/mynewt/larva\n\n\nAdds the remote clutch named larva at www.github.com/mynewt/larva to the local nest.\n\n\n\n\n\n\nlist-clutches\n\n\nnewt nest list-clutches\n\n\nShows all the remote clutch description files that been downloaded into the current nest\n\n\n\n\n\n\nshow-clutch\n\n\nnewt nest show-clutch larva\n\n\nOutputs the details of the clutch named larva such as the github url where the remote sits, the constituent eggs and their versions\n\n\n\n\n\n\n\n\negg\n\n\nUsage:\n\n\nnewt egg [command][flag] input1 input2\n\n\n\nAvailable Commands: \n\n\nlist        List eggs in the current nest\ncheckdeps   Check egg dependencies\nhunt        Search for egg from clutches\nshow        Show the contents of an egg.\ninstall     Install an egg\nremove      Remove an egg\n\n\n\nFlags:\n\n\n-h, --help=false: help for egg\n\n\n\nGlobal Flags:\n\n\n-l, --loglevel=\"WARN\": Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSub-command\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nlist\n\n\nList all the eggs in the current nest. The output shows the name, version, path, and any additional attributes of each egg in the nest such as dependencies, capabilities, and linker scripts. The newt command gets the attributes of each egg from the corresponsing egg.yml description file.\n\n\n\n\n\n\ncheckdeps\n\n\nResolve all dependencies in the local nest. This command goes through all eggs currently installed, checks their dependencies, and prints any unresolved dependencies between eggs.\n\n\n\n\n\n\nhunt\n\n\nHunts for an egg, specified by \ninput1\n The local nest, along with all remote nests (clutches) are searched. All matched eggs are shown along with the clutch informaton. Installed eggs are called out as such. The command can be invoked from anywhere in the nest.\n\n\n\n\n\n\nshow\n\n\nShow the contents of the egg named \ninput2\nfound in the clutch named \ninput1\n The clutch name is optional; if only the egg name is given as the argument it is resolved using all the clutches installed in the current nest. If the egg is present in multiple clutches it will list all of them along with the clutch information for each.\n\n\n\n\n\n\ninstall\n\n\nInstall the egg specified by \ninput2\nfrom the clutch named \ninput1\n The command downloads the egg from the github repository using the URL in the clutch description file (typically donwloaded as 'input1@\n.yml' in .nest/clutches). It also downloads all the dependencies (constituent eggs) as decribed in the egg's description file ('egg.yml') and installs all of them. The clutch name is optional. If only the egg name is given as the argument, the command looks for the egg name in all the clutches in the local nest and installs accordingly. An egg is installed by this command only if it has not already been installed.\n\n\n\n\n\n\nremove\n\n\nRemove an egg named \ninput2\nfrom clutch \ninput1\n if clutch is specified. Otherwise only one input required - that of the name of the egg to be removed from the local nest.\n\n\n\n\n\n\n\n\nCommand-specific flags\n\n\n\n\n\n\n\n\nSub-command\n\n\nAvailable flags\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\ninstall\n\n\n-b, --branch=\"\n\"\n\n\nInstalls the eggs from the branch name or tag of the clutch specified\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nlist\n\n\nnewt egg list\n\n\nCList all of the eggs in the current nest and the details of the eggs.\n\n\n\n\n\n\ncheckdeps\n\n\nnewt egg checkdeps\n\n\nChecks all the dependencies between eggs in the nest. Lists any unresolved dependencies.\n\n\n\n\n\n\nhunt\n\n\nnewt egg hunt blinky\n\n\nHunts for the egg named 'blinky'. The command can be invoked from anywhere in the nest. Results show if the egg is installed and which clutch, if any, has the egg.\n\n\n\n\n\n\nshow\n\n\nnewt egg show larva libs/os\n\n\nShow the contents of the egg named 'libs/os' in the clutch named larva. The contents are essentially derived from the egg's 'egg.yml' file.\n\n\n\n\n\n\ninstall\n\n\nnewt egg install hw/bsp/stm32f3discovery\n\n\nDownloads and installs the egg named \"stm32f3discovery\" (specified with its full path name inside the remote nest) along with all its dependencies from the remote nest on github. Since no clutch is specified, the URL for the remote nest in the clutch description file found in the local nest (in .nest/clutches for the project) is used.\n\n\n\n\n\n\nremove\n\n\nnewt egg remove larva blinky\n\n\nRemoves the egg named blinky only from the clutch named larva\n\n\n\n\n\n\nremove\n\n\nnewt egg remove blinky\n\n\nRemoves the egg named blinky from the local nest\n\n\n\n\n\n\n\n\ntarget\n\n\nUsage:\n\n\nUsage: \n\n\nnewt target [command] input1 [flag1] [flag2]\n\n\n\nAvailable Commands: \n\n\nset         Set target configuration variable\nunset       Unset target configuration variable\ndelete      Delete target\ncreate      Create a target\nshow        View target configuration variables\nbuild       Build target\ntest        Test target\nexport      Export target\nimport      Import target\ndownload    Download image to target\ndebug       Download image to target and start an openocd/gdb session\n\n\n\nFlags:\n\n\n-h, --help=false: help for target\n\n\n\nGlobal Flags:\n\n\n-l, --loglevel=\"WARN\": Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSub-command\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nset\n\n\nSet attributes of the target. Currently the list of possible attributes are:\narch, compiler, compiler_def, project, bsp, egg, identities, capabilities, dependencies, cflags, lflags\n Typically only the first 5 need to be set for a hardware target. For a simulated target, e.g. for software testing purposes, \narch=sim\n \ncompiler=sim\n and \negg=\negg name to be tested\n You cannot set both the project and egg for a target.\n\n\n\n\n\n\nunset\n\n\nUnset attributes of the target in its configuration.\n\n\n\n\n\n\ndelete\n\n\nDeletes only the description for the target. Does not delete the target directory with associated binaries. If you want to clean out the binaries, list files, and executables use\nnewt target build \ntarget-name\n clean\nbefore\n deleting the target!\n\n\n\n\n\n\ncreate\n\n\nCreates a target description or build definition by the name \ninput1\n By default it assigns the sim (simulator) architecture to it which allows you to build new projects and software on your native OS and try it out.\n\n\n\n\n\n\nshow\n\n\nDisplay the configuration defined for the target named \ninput1\n If no \ninput1\nis specified then show the details for all the targets in the nest.\n\n\n\n\n\n\nbuild\n\n\nBuild the source code into an image that can be loaded on the hardware associated with the target named \ninput1\nto do the application enabled by the 'project' associated with that target (via the target definition). It creates 'bin/' and 'bin/\n/' subdirectories inside the base directory for the project, compiles and generates binaries and executables, and places them in 'bin/\n/.\n\n\n\n\n\n\ntest\n\n\nTest an egg on the target named \ninput1\n The egg is either supplied as an argument to the command line invocation of \nnewt target test\nor added as part of the target definition. If only the target is specified as \ninput1\n then the egg in the target's definition is automatically chosen to be tested. You currently cannot test an entire project on a hardware target. The test command is envisioned for use if one or two eggs gets updated and each needs to be tested against a target. Alternatively, a script may be written for a series of tests on several eggs.\n\n\n\n\n\n\nexport\n\n\nExports the configurations of the specified target \ninput1\n If -a or -export-all flag is used, then all targets are exported and printed out to standard out. You may redirect the output to a file.\n\n\n\n\n\n\nimport\n\n\nImport one or more target configuration from standard input or a file. Each target starts with \n@target=\ntarget-name\nfollowed by the attributes. The list of targets should end with \n@endtargets\n\n\n\n\n\n\nsize\n\n\nOutputs the RAM and flash consumption by the components of the specified target \ninput1\n\n\n\n\n\n\ndownload\n\n\nDownloads the binary executable \ntarget-name\n.elf.bin\nto the board.\n\n\n\n\n\n\ndebug\n\n\nDownloads the binary executable \ntarget-name\n.elf.bin\nto the board and starts up the openocd/gdb combination session. gdb takes over the terminal.\n\n\n\n\n\n\n\n\nCommand-specific flags\n\n\n\n\n\n\n\n\nSub-command\n\n\nAvailable flags\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nbuild\n\n\nclean\n\n\nAll the binaries and object files for the specified target will be removed. The subdirectory named after the specified target within that project is removed.\n\n\n\n\n\n\nbuild clean\n\n\nall\n\n\nAll the binaries and object files for all targets are removed, and subdirectories of all targets for the project are removed. However, the entire repository is not emptied since any eggs or projects that the specified target doesn't reference are not touched.\n\n\n\n\n\n\nexport\n\n\n-a, -export-all\n\n\nExport all targets. \ninput1\nis not necessary when this flag is used.\n\n\n\n\n\n\nimport\n\n\n-a, -import-all\n\n\nImport all targets typed into standard input or redirected from a file.\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nset\n\n\nnewt target set myblinky compiler=arm-none-eabi-m4\n\n\nSet the compiler for the 'myblinky' target to the gcc compiler for embedded ARM chips.\n\n\n\n\n\n\nunset\n\n\nnewt target unset myblinky compiler\n\n\nRemove the setting for the compiler for the 'myblinky' target.\n\n\n\n\n\n\ndelete\n\n\nnewt target delete myblinky\n\n\nDelete the target description for the target named 'myblinky'. Note that it does not remove any binaries or clean out the directory for this target.\n\n\n\n\n\n\ncreate\n\n\nnewt target create blink_f3disc\n\n\nCreate a new target description by the name 'blink_f3disc'. The architecture is 'sim' by default and can be changed using subcommand 'set' above.\n\n\n\n\n\n\nshow\n\n\nnewt target show myblinky\n\n\nShow the target attributes set for 'myblinky'\n\n\n\n\n\n\nbuild\n\n\nnewt target build blink_f3disc\n\n\nCompile the source code for the target named blink_f3disc and generate binaries that can be loaded into the target hardware.\n\n\n\n\n\n\ntest\n\n\nnewt target test test_target egg=libs/os\n\n\nTests the egg named 'libs/os' against the target named 'test_target'\n\n\n\n\n\n\nexport\n\n\nnewt target export -a \n my_exports.txt\n\n\nExport all build targets from the current nest, and redirect output to a file named 'my_exports.txt'.\n\n\n\n\n\n\nexport\n\n\nnewt target export -export-all\n\n\nExport all build targets from the current nest, and print them to standard output on the screen.\n\n\n\n\n\n\nexport\n\n\nnewt target export my_target\n\n\nExport only target named 'my_target' and print it to standard output on the screen.\n\n\n\n\n\n\nimport\n\n\nnewt target import ex_tgt_1 \n exported_targets.txt\n\n\nImports the target configuration for 'ex_tgt_1' in 'exported_targets.txt'.\n\n\n\n\n\n\nimport\n\n\nnewt target import -a \n in_targets.txt\n\n\nImports all the targets specified in the file named \nin_targets.txt\n A sample file is shown after this table.\n\n\n\n\n\n\nsize\n\n\nnewt target size blink_nordic\n\n\nInspects and lists the RAM and Flash memory use by each component (object files and libraries) of the target.\n\n\n\n\n\n\ndownload\n\n\nnewt target -v -lVERBOSE download blinky\n\n\nDownloads \nblinky.elf.bin\nto the hardware in verbose mode with logging turned on at VERBOSE level.\n\n\n\n\n\n\ndebug\n\n\nnewt target debug blinky\n\n\nDownloads \nblinky.elf.bin\nto the hardware, opens up a gdb session with \nblinky.elf\nin the terminal, and halts for further input in gdb.\n\n\n\n\n\n\n\n\nExample content for \nin_targets.txt\n file used for importing targets \ntest3\n and \ntest4\n.  \n\n\n\n\n@target=test3\n\nproject=blinked\n\narch=sim\n\ncompiler_def=debug\n\ncompiler=arm-none-eabi-m4\n\n@target=test4\n\nproject=super_blinky\n\narch=sim\n\ncompiler_def=debug\n\ncompiler=arm-none-eabi-m4\n\n@endtargets", 
            "title": "Command list"
        }, 
        {
            "location": "/chapter3/newt_tool_reference/#command-list", 
            "text": "Available high-level commands  version     Display the Newt version number\nhelp        Help about any command\nnest        Commands to manage nests   clutches (remote egg repositories)\negg         Commands to list and inspect eggs on a nest\ntarget      Set and view target information  version  Usage:  newt version [flags]  Flags:  -h, --help=false: help for version  Global Flags:  -h, --help=false: help for newt  Examples     Sub-command  Usage  Explanation      version  newt version  Displays the version of newt tool installed     help  Usage:  newt help [input1]  Flags:  \n-h, --help=false: help for newt\n-l, --loglevel= WARN : Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.  Examples     Sub-command  Usage  Explanation      help  newt help target  Displays the help text for the newt command 'target'    help  newt help  Displays the help text for newt tool     nest  Usage:  newt nest [command][flags] input1 input2...  Available commands:   create          Create a new nest\ngenerate-clutch Generate a clutch file from the eggs in the current directory\nadd-clutch      Add a remote clutch, and put it in the current nest\nlist-clutches   List the clutches installed in the current nest\nshow-clutch     Show an individual clutch in the current nest  Flags:  -h, --help=false: help for nest  Global Flags:  -h, --help=false: help for newt\n-l, --loglevel=\"WARN\": Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.  Description     Sub-command  Explanation      create  Downloads the skeleton of a nest on your local machine from the optional  input2 nest url, if specified, and creates a new nest directory by the name of  input1  If  input2 is not specified, then a default skeleton from the  tadpole nest on Mynewt is downloaded. The command lays out a generic directory structure for the nest you are going to build under it and includes some default eggs in it.    generate-clutch  Takes a snapshot of the eggs in the current local directory and combines them into a clutch by the name of  input1 and with the url of  input2 and generates a standard output of the clutch details that can be redirected to a  .yml clutch file. Typically the clutch file name is chosen to match the clutch name which means the standard output should be directed to a clutch file named  input1.yml    add-clutch  Downloads the clutch of the name  input1 from the master branch of the github repository  input2 into the current nest. A file named  input1.yml file is added in the  .nest/clutches subdirectory inside the current local nest. The  .nest/ directory structure is created automatically if it does not exist.    list-clutches  Lists all the clutches present in the current nest, including clutches that may have been added from other nests on github. The output shows all the remote clutch names and the total eggshells in each of the clutches.    show-clutch  Shows information about the clutch that has the name given in the  input1 argument. Output includes the clutch name, url, and all the constituent eggs with their version numbers.     Command-specific flags     Sub-command  Available flags  Explanation      add-clutch  -b, --branch=\" \"  Fetches the clutch file with name  input1 from the specified branch at  input1 url of the github repository. All subsequent egg installations will be done from that branch.     Examples     Sub-command  Usage  Explanation      create  newt nest create test_project  Creates a new nest named \"test_project \" using the default skeleton0    create  newt nest create mynest   Creates a new nest named \"mynest\" using the skeleton at the   specified    generate-clutch  newt nest generate-clutch myclutch https://www.github.com/mynewt/larva   myclutch.yml  Takes a snapshot of the eggs in the current nest to form a clutch named myclutch with the url https://www.github.com/mynewt/larva. The output is written to a file named  myclutch.yml and describes the properties and contents of the clutch (name, url, eggs).    add-clutch  newt nest add-clutch larva https://www.github.com/mynewt/larva  Adds the remote clutch named larva at www.github.com/mynewt/larva to the local nest.    list-clutches  newt nest list-clutches  Shows all the remote clutch description files that been downloaded into the current nest    show-clutch  newt nest show-clutch larva  Outputs the details of the clutch named larva such as the github url where the remote sits, the constituent eggs and their versions     egg  Usage:  newt egg [command][flag] input1 input2  Available Commands:   list        List eggs in the current nest\ncheckdeps   Check egg dependencies\nhunt        Search for egg from clutches\nshow        Show the contents of an egg.\ninstall     Install an egg\nremove      Remove an egg  Flags:  -h, --help=false: help for egg  Global Flags:  -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.  Description     Sub-command  Explanation      list  List all the eggs in the current nest. The output shows the name, version, path, and any additional attributes of each egg in the nest such as dependencies, capabilities, and linker scripts. The newt command gets the attributes of each egg from the corresponsing egg.yml description file.    checkdeps  Resolve all dependencies in the local nest. This command goes through all eggs currently installed, checks their dependencies, and prints any unresolved dependencies between eggs.    hunt  Hunts for an egg, specified by  input1  The local nest, along with all remote nests (clutches) are searched. All matched eggs are shown along with the clutch informaton. Installed eggs are called out as such. The command can be invoked from anywhere in the nest.    show  Show the contents of the egg named  input2 found in the clutch named  input1  The clutch name is optional; if only the egg name is given as the argument it is resolved using all the clutches installed in the current nest. If the egg is present in multiple clutches it will list all of them along with the clutch information for each.    install  Install the egg specified by  input2 from the clutch named  input1  The command downloads the egg from the github repository using the URL in the clutch description file (typically donwloaded as 'input1@ .yml' in .nest/clutches). It also downloads all the dependencies (constituent eggs) as decribed in the egg's description file ('egg.yml') and installs all of them. The clutch name is optional. If only the egg name is given as the argument, the command looks for the egg name in all the clutches in the local nest and installs accordingly. An egg is installed by this command only if it has not already been installed.    remove  Remove an egg named  input2 from clutch  input1  if clutch is specified. Otherwise only one input required - that of the name of the egg to be removed from the local nest.     Command-specific flags     Sub-command  Available flags  Explanation      install  -b, --branch=\" \"  Installs the eggs from the branch name or tag of the clutch specified     Examples     Sub-command  Usage  Explanation      list  newt egg list  CList all of the eggs in the current nest and the details of the eggs.    checkdeps  newt egg checkdeps  Checks all the dependencies between eggs in the nest. Lists any unresolved dependencies.    hunt  newt egg hunt blinky  Hunts for the egg named 'blinky'. The command can be invoked from anywhere in the nest. Results show if the egg is installed and which clutch, if any, has the egg.    show  newt egg show larva libs/os  Show the contents of the egg named 'libs/os' in the clutch named larva. The contents are essentially derived from the egg's 'egg.yml' file.    install  newt egg install hw/bsp/stm32f3discovery  Downloads and installs the egg named \"stm32f3discovery\" (specified with its full path name inside the remote nest) along with all its dependencies from the remote nest on github. Since no clutch is specified, the URL for the remote nest in the clutch description file found in the local nest (in .nest/clutches for the project) is used.    remove  newt egg remove larva blinky  Removes the egg named blinky only from the clutch named larva    remove  newt egg remove blinky  Removes the egg named blinky from the local nest     target  Usage:  Usage:   newt target [command] input1 [flag1] [flag2]  Available Commands:   set         Set target configuration variable\nunset       Unset target configuration variable\ndelete      Delete target\ncreate      Create a target\nshow        View target configuration variables\nbuild       Build target\ntest        Test target\nexport      Export target\nimport      Import target\ndownload    Download image to target\ndebug       Download image to target and start an openocd/gdb session  Flags:  -h, --help=false: help for target  Global Flags:  -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.  Description     Sub-command  Explanation      set  Set attributes of the target. Currently the list of possible attributes are: arch, compiler, compiler_def, project, bsp, egg, identities, capabilities, dependencies, cflags, lflags  Typically only the first 5 need to be set for a hardware target. For a simulated target, e.g. for software testing purposes,  arch=sim   compiler=sim  and  egg= egg name to be tested  You cannot set both the project and egg for a target.    unset  Unset attributes of the target in its configuration.    delete  Deletes only the description for the target. Does not delete the target directory with associated binaries. If you want to clean out the binaries, list files, and executables use newt target build  target-name  clean before  deleting the target!    create  Creates a target description or build definition by the name  input1  By default it assigns the sim (simulator) architecture to it which allows you to build new projects and software on your native OS and try it out.    show  Display the configuration defined for the target named  input1  If no  input1 is specified then show the details for all the targets in the nest.    build  Build the source code into an image that can be loaded on the hardware associated with the target named  input1 to do the application enabled by the 'project' associated with that target (via the target definition). It creates 'bin/' and 'bin/ /' subdirectories inside the base directory for the project, compiles and generates binaries and executables, and places them in 'bin/ /.    test  Test an egg on the target named  input1  The egg is either supplied as an argument to the command line invocation of  newt target test or added as part of the target definition. If only the target is specified as  input1  then the egg in the target's definition is automatically chosen to be tested. You currently cannot test an entire project on a hardware target. The test command is envisioned for use if one or two eggs gets updated and each needs to be tested against a target. Alternatively, a script may be written for a series of tests on several eggs.    export  Exports the configurations of the specified target  input1  If -a or -export-all flag is used, then all targets are exported and printed out to standard out. You may redirect the output to a file.    import  Import one or more target configuration from standard input or a file. Each target starts with  @target= target-name followed by the attributes. The list of targets should end with  @endtargets    size  Outputs the RAM and flash consumption by the components of the specified target  input1    download  Downloads the binary executable  target-name .elf.bin to the board.    debug  Downloads the binary executable  target-name .elf.bin to the board and starts up the openocd/gdb combination session. gdb takes over the terminal.     Command-specific flags     Sub-command  Available flags  Explanation      build  clean  All the binaries and object files for the specified target will be removed. The subdirectory named after the specified target within that project is removed.    build clean  all  All the binaries and object files for all targets are removed, and subdirectories of all targets for the project are removed. However, the entire repository is not emptied since any eggs or projects that the specified target doesn't reference are not touched.    export  -a, -export-all  Export all targets.  input1 is not necessary when this flag is used.    import  -a, -import-all  Import all targets typed into standard input or redirected from a file.     Examples     Sub-command  Usage  Explanation      set  newt target set myblinky compiler=arm-none-eabi-m4  Set the compiler for the 'myblinky' target to the gcc compiler for embedded ARM chips.    unset  newt target unset myblinky compiler  Remove the setting for the compiler for the 'myblinky' target.    delete  newt target delete myblinky  Delete the target description for the target named 'myblinky'. Note that it does not remove any binaries or clean out the directory for this target.    create  newt target create blink_f3disc  Create a new target description by the name 'blink_f3disc'. The architecture is 'sim' by default and can be changed using subcommand 'set' above.    show  newt target show myblinky  Show the target attributes set for 'myblinky'    build  newt target build blink_f3disc  Compile the source code for the target named blink_f3disc and generate binaries that can be loaded into the target hardware.    test  newt target test test_target egg=libs/os  Tests the egg named 'libs/os' against the target named 'test_target'    export  newt target export -a   my_exports.txt  Export all build targets from the current nest, and redirect output to a file named 'my_exports.txt'.    export  newt target export -export-all  Export all build targets from the current nest, and print them to standard output on the screen.    export  newt target export my_target  Export only target named 'my_target' and print it to standard output on the screen.    import  newt target import ex_tgt_1   exported_targets.txt  Imports the target configuration for 'ex_tgt_1' in 'exported_targets.txt'.    import  newt target import -a   in_targets.txt  Imports all the targets specified in the file named  in_targets.txt  A sample file is shown after this table.    size  newt target size blink_nordic  Inspects and lists the RAM and Flash memory use by each component (object files and libraries) of the target.    download  newt target -v -lVERBOSE download blinky  Downloads  blinky.elf.bin to the hardware in verbose mode with logging turned on at VERBOSE level.    debug  newt target debug blinky  Downloads  blinky.elf.bin to the hardware, opens up a gdb session with  blinky.elf in the terminal, and halts for further input in gdb.     Example content for  in_targets.txt  file used for importing targets  test3  and  test4 .     @target=test3 \nproject=blinked \narch=sim \ncompiler_def=debug \ncompiler=arm-none-eabi-m4 \n@target=test4 \nproject=super_blinky \narch=sim \ncompiler_def=debug \ncompiler=arm-none-eabi-m4 \n@endtargets", 
            "title": "Command List"
        }, 
        {
            "location": "/chapter4/mynewt_os/", 
            "text": "Mynewt OS\n\n\nInsert introduction here  \n\n\nReal-Time Kernel \n\n\nDescription\n\n\nReal-Time OS \n\n\nDescription\n\n\nInsert topic of your choice\n\n\nDescription\n\n\nFeatures\n\n\n\n\n\n\nScheduler/context switching\n\n\nTime\n\n\nTasks\n\n\nEvent queues/callouts\n\n\nSemaphores\n\n\nMutexes\n\n\nMemory pools\n\n\nHeap\n\n\nMbufs\n\n\nSanity\n\n\nPorting OS to other platforms\n\n\n\n\nOS Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_idle_task\n\n\nos_started\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\nfunction os_idle_task\n\n\n    void\n    os_idle_task(void *arg)\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function os_started\n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here", 
            "title": "Overview"
        }, 
        {
            "location": "/chapter4/mynewt_os/#mynewt-os", 
            "text": "Insert introduction here", 
            "title": "Mynewt OS"
        }, 
        {
            "location": "/chapter4/mynewt_os/#real-time-kernel", 
            "text": "Description", 
            "title": "Real-Time Kernel "
        }, 
        {
            "location": "/chapter4/mynewt_os/#real-time-os", 
            "text": "Description", 
            "title": "Real-Time OS "
        }, 
        {
            "location": "/chapter4/mynewt_os/#insert-topic-of-your-choice", 
            "text": "Description", 
            "title": "Insert topic of your choice"
        }, 
        {
            "location": "/chapter4/mynewt_os/#features", 
            "text": "Scheduler/context switching  Time  Tasks  Event queues/callouts  Semaphores  Mutexes  Memory pools  Heap  Mbufs  Sanity  Porting OS to other platforms", 
            "title": "Features"
        }, 
        {
            "location": "/chapter4/mynewt_os/#os-functions", 
            "text": "The functions available in this OS feature are:   os_idle_task  os_started  add the rest", 
            "title": "OS Functions"
        }, 
        {
            "location": "/chapter4/mynewt_os/#function-reference", 
            "text": "function os_idle_task      void\n    os_idle_task(void *arg)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function os_started      Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function next_one       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": "Function Reference"
        }, 
        {
            "location": "/chapter4/context_switch/", 
            "text": "Scheduler/Context Switching\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe scheduler here\n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in the scheduler are:\n\n\n\n\nos_sched_insert\n\n\nos_sched_walk\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\nfunction os_sched_insert\n\n\n    os_error_t\n    os_sched_insert(struct os_task *t)\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function os_sched_walk\n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here", 
            "title": "Scheduler/Context Switching"
        }, 
        {
            "location": "/chapter4/context_switch/#schedulercontext-switching", 
            "text": "Insert synopsis here", 
            "title": "Scheduler/Context Switching"
        }, 
        {
            "location": "/chapter4/context_switch/#description", 
            "text": "Describe scheduler here", 
            "title": "Description"
        }, 
        {
            "location": "/chapter4/context_switch/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/chapter4/context_switch/#list-of-functions", 
            "text": "The functions available in the scheduler are:   os_sched_insert  os_sched_walk  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/chapter4/context_switch/#function-reference", 
            "text": "function os_sched_insert      os_error_t\n    os_sched_insert(struct os_task *t)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function os_sched_walk      Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function next_one       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": "Function Reference"
        }, 
        {
            "location": "/chapter4/time/", 
            "text": "Time\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe OS feature here \n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_time_get\n\n\nos_time_tick\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\nfunction os_time_get \n\n\n    os_time_t  \n    os_time_get(void) \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function os_time_tick \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here", 
            "title": "Time"
        }, 
        {
            "location": "/chapter4/time/#time", 
            "text": "Insert synopsis here", 
            "title": "Time"
        }, 
        {
            "location": "/chapter4/time/#description", 
            "text": "Describe OS feature here", 
            "title": "Description"
        }, 
        {
            "location": "/chapter4/time/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/chapter4/time/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_time_get  os_time_tick  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/chapter4/time/#function-reference", 
            "text": "function os_time_get       os_time_t  \n    os_time_get(void)    Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function os_time_tick       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function next_one       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": "Function Reference"
        }, 
        {
            "location": "/chapter4/task/", 
            "text": "Tasks\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe OS feature here \n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\n_clear_stack\n\n\nos_task_next_id\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\nfunction _clear_stack \n\n\n    static void\n    _clear_stack(os_stack_t *stack_bottom, int size) \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function os_task_next_id \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here", 
            "title": "Tasks"
        }, 
        {
            "location": "/chapter4/task/#tasks", 
            "text": "Insert synopsis here", 
            "title": "Tasks"
        }, 
        {
            "location": "/chapter4/task/#description", 
            "text": "Describe OS feature here", 
            "title": "Description"
        }, 
        {
            "location": "/chapter4/task/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/chapter4/task/#list-of-functions", 
            "text": "The functions available in this OS feature are:   _clear_stack  os_task_next_id  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/chapter4/task/#function-reference", 
            "text": "function _clear_stack       static void\n    _clear_stack(os_stack_t *stack_bottom, int size)    Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function os_task_next_id       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function next_one       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": "Function Reference"
        }, 
        {
            "location": "/chapter4/event_queue/", 
            "text": "Event Queues\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe scheduler here\n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_eventq_init\n\n\nos_eventq_put2\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\nfunction os_eventq_init\n\n\n    void\n    os_eventq_init(struct os_eventq *evq)\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function os_eventq_put2\n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here", 
            "title": "Event Queues"
        }, 
        {
            "location": "/chapter4/event_queue/#event-queues", 
            "text": "Insert synopsis here", 
            "title": "Event Queues"
        }, 
        {
            "location": "/chapter4/event_queue/#description", 
            "text": "Describe scheduler here", 
            "title": "Description"
        }, 
        {
            "location": "/chapter4/event_queue/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/chapter4/event_queue/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_eventq_init  os_eventq_put2  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/chapter4/event_queue/#function-reference", 
            "text": "function os_eventq_init      void\n    os_eventq_init(struct os_eventq *evq)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function os_eventq_put2      Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function next_one       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": "Function Reference"
        }, 
        {
            "location": "/chapter4/semaphore/", 
            "text": "Semaphore\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe OS feature here \n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_sem_init\n\n\nos_sem_release\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\nfunction os_sem_init\n\n\n    os_error_t\n    os_sem_init(struct os_sem *sem, uint16_t tokens)    \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function os_sem_release \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here", 
            "title": "Semaphores"
        }, 
        {
            "location": "/chapter4/semaphore/#semaphore", 
            "text": "Insert synopsis here", 
            "title": "Semaphore"
        }, 
        {
            "location": "/chapter4/semaphore/#description", 
            "text": "Describe OS feature here", 
            "title": "Description"
        }, 
        {
            "location": "/chapter4/semaphore/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/chapter4/semaphore/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_sem_init  os_sem_release  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/chapter4/semaphore/#function-reference", 
            "text": "function os_sem_init      os_error_t\n    os_sem_init(struct os_sem *sem, uint16_t tokens)       Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function os_sem_release       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function next_one       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": "Function Reference"
        }, 
        {
            "location": "/chapter4/mutex/", 
            "text": "Mutex\n\n\nMutex is short for \"mutual exclusion\"; a mutex provides mutually exclusive access to a shared resource. A mutex provides \npriority inheritance\n in order to prevent \npriority inversion\n. Priority inversion occurs when a higher priority task is waiting on a resource owned by a lower priority task. Using a mutex, the lower priority task will inherit the highest priority of any task waiting on the mutex. \n\n\nDescription\n\n\nDescribe OS feature here \n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_mutex_init\n\n\nos_mutex_release\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\nfunction os_mutex_init\n\n\n    os_error_t\n    os_mutex_init(struct os_mutex *mu)\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function os_mutex_release\n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here", 
            "title": "Mutexes"
        }, 
        {
            "location": "/chapter4/mutex/#mutex", 
            "text": "Mutex is short for \"mutual exclusion\"; a mutex provides mutually exclusive access to a shared resource. A mutex provides  priority inheritance  in order to prevent  priority inversion . Priority inversion occurs when a higher priority task is waiting on a resource owned by a lower priority task. Using a mutex, the lower priority task will inherit the highest priority of any task waiting on the mutex.", 
            "title": "Mutex"
        }, 
        {
            "location": "/chapter4/mutex/#description", 
            "text": "Describe OS feature here", 
            "title": "Description"
        }, 
        {
            "location": "/chapter4/mutex/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/chapter4/mutex/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_mutex_init  os_mutex_release  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/chapter4/mutex/#function-reference", 
            "text": "function os_mutex_init      os_error_t\n    os_mutex_init(struct os_mutex *mu)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function os_mutex_release      Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function next_one       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": "Function Reference"
        }, 
        {
            "location": "/chapter4/memory_pool/", 
            "text": "Memory Pools\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe OS feature here \n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_mempool_init\n\n\nos_memblock_get\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\nfunction os_mempool_init\n\n\n    os_error_t\n    os_mempool_init(struct os_mempool *mp, int blocks, \n                    int block_size, void *membuf, char *name)\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function os_memblock_get\n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here", 
            "title": "Memory Pools"
        }, 
        {
            "location": "/chapter4/memory_pool/#memory-pools", 
            "text": "Insert synopsis here", 
            "title": "Memory Pools"
        }, 
        {
            "location": "/chapter4/memory_pool/#description", 
            "text": "Describe OS feature here", 
            "title": "Description"
        }, 
        {
            "location": "/chapter4/memory_pool/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/chapter4/memory_pool/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_mempool_init  os_memblock_get  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/chapter4/memory_pool/#function-reference", 
            "text": "function os_mempool_init      os_error_t\n    os_mempool_init(struct os_mempool *mp, int blocks, \n                    int block_size, void *membuf, char *name)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function os_memblock_get      Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function next_one       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": "Function Reference"
        }, 
        {
            "location": "/chapter4/heap/", 
            "text": "Heap\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe OS feature  here \n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_malloc_lock\n\n\nos_malloc_unlock\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\nfunction os_malloc_lock\n\n\n    static void\n    os_malloc_lock(void)\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function os_malloc_unlock\n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here", 
            "title": "Heap"
        }, 
        {
            "location": "/chapter4/heap/#heap", 
            "text": "Insert synopsis here", 
            "title": "Heap"
        }, 
        {
            "location": "/chapter4/heap/#description", 
            "text": "Describe OS feature  here", 
            "title": "Description"
        }, 
        {
            "location": "/chapter4/heap/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/chapter4/heap/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_malloc_lock  os_malloc_unlock  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/chapter4/heap/#function-reference", 
            "text": "function os_malloc_lock      static void\n    os_malloc_lock(void)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function os_malloc_unlock      Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function next_one       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": "Function Reference"
        }, 
        {
            "location": "/chapter4/mbufs/", 
            "text": "Mbufs\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe OS feature here \n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_mbuf_pool_init\n\n\nos_mbuf_get\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\nfunction os_mbuf_pool_init\n\n\n    int \n    os_mbuf_pool_init(struct os_mbuf_pool *omp, struct os_mempool *mp, \n        uint16_t hdr_len, uint16_t buf_len, uint16_t nbufs)\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function os_mbuf_get\n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here", 
            "title": "Mbufs"
        }, 
        {
            "location": "/chapter4/mbufs/#mbufs", 
            "text": "Insert synopsis here", 
            "title": "Mbufs"
        }, 
        {
            "location": "/chapter4/mbufs/#description", 
            "text": "Describe OS feature here", 
            "title": "Description"
        }, 
        {
            "location": "/chapter4/mbufs/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/chapter4/mbufs/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_mbuf_pool_init  os_mbuf_get  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/chapter4/mbufs/#function-reference", 
            "text": "function os_mbuf_pool_init      int \n    os_mbuf_pool_init(struct os_mbuf_pool *omp, struct os_mempool *mp, \n        uint16_t hdr_len, uint16_t buf_len, uint16_t nbufs)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function os_mbuf_get      Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function next_one       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": "Function Reference"
        }, 
        {
            "location": "/chapter4/sanity/", 
            "text": "Sanity\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe OS feature here \n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nos_sanity_check_init\n\n\nos_sanity_check_list_lock\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\nfunction os_sanity_check_init\n\n\n    int \n    os_sanity_check_init(struct os_sanity_check *sc)    \n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function os_sanity_check_list_lock \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here", 
            "title": "Sanity"
        }, 
        {
            "location": "/chapter4/sanity/#sanity", 
            "text": "Insert synopsis here", 
            "title": "Sanity"
        }, 
        {
            "location": "/chapter4/sanity/#description", 
            "text": "Describe OS feature here", 
            "title": "Description"
        }, 
        {
            "location": "/chapter4/sanity/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/chapter4/sanity/#list-of-functions", 
            "text": "The functions available in this OS feature are:   os_sanity_check_init  os_sanity_check_list_lock  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/chapter4/sanity/#function-reference", 
            "text": "function os_sanity_check_init      int \n    os_sanity_check_init(struct os_sanity_check *sc)       Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function os_sanity_check_list_lock       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function next_one       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": "Function Reference"
        }, 
        {
            "location": "/chapter4/port_os/", 
            "text": "Porting Mynewt OS\n\n\nThis chapter describes how to adapt Newt OS to different processors. Adapting \u03bcC/OS-III to a microprocessor or a microcontroller is called porting. \n\n\nDescription\n\n\nInsert sections as you wish", 
            "title": "Porting to other Platforms"
        }, 
        {
            "location": "/chapter4/port_os/#porting-mynewt-os", 
            "text": "This chapter describes how to adapt Newt OS to different processors. Adapting \u03bcC/OS-III to a microprocessor or a microcontroller is called porting.", 
            "title": "Porting Mynewt OS"
        }, 
        {
            "location": "/chapter4/port_os/#description", 
            "text": "", 
            "title": "Description"
        }, 
        {
            "location": "/chapter4/port_os/#insert-sections-as-you-wish", 
            "text": "", 
            "title": "Insert sections as you wish"
        }, 
        {
            "location": "/chapter5/console/", 
            "text": "Console\n\n\nThe console is an operating system window where users interact with system programs of the operating system or a console application by entering text input (typically from a keyboard) and reading text output (typically on the computer terminal). The text written on the console brings some information and is a sequence of characters sent by the OS or programs running on the OS. \n\n\nSupport is currently available for console access via the serial port on the hardware board.\n\n\nDescription\n\n\nIn the Mynewt OS, the console library comes in two versions:\n\n\n\n\nfull - containing the full implementation\n\n\nstub - containing stubs for the API\n\n\n\n\nIf an egg or project requires the full console capability it lists that dependency in its egg.yml file. For example, the shell egg is defined by the following egg.yml file:\n\n\negg.name: libs/shell \negg.vers: 0.1\negg.deps:\n    - libs/console/full\n    - libs/os\negg.identities:\n    - SHELL\n\n\n\nOn the other hand, a project may not have a physical console (e.g. a UART port to connect a terminal to) but may have a dependency on an egg that has console capability. In that case you would use a console stub. Another example would be the bootloader project where we want to keep the size of the image small. It includes the \nlibs/os\n egg that can print out messages on a console (e.g. if there is a hard fault) and the \nlibs/util\n egg that uses full console (but only if SHELL is present to provide a CLI). However, we do not want to use any console I/O capability in this particular bootloader project to keep the size small. We simply use the console stub instead and the egg.yml file for the project boot egg looks like the following:\n\n\nproject.name: boot\nproject.identities: bootloader\nproject.eggs:\n    - libs/os\n    - libs/bootutil\n    - libs/nffs\n    - libs/console/stub\n    - libs/util\n\n\n\nData structures\n\n\nConsole interaction is intrinsically composed of two unidirectional systems. The console implementation uses two ring buffers containing input (receive) and output (transmit) characters, respectively. Read and write operations on the console_ring structure are managed by labeling the read location indicator the \ncr_tail\n and the write location indicator the \ncr_head\n. The console ring length is variable and is specified as the \ncr_size\n member of the data structure. \ncr_buf\n is the pointer to the actual array of data contained.\n\n\nstruct console_ring {\n  32     uint8_t cr_head;\n  33     uint8_t cr_tail;\n  34     uint8_t cr_size;\n  35     uint8_t _pad;\n  36     uint8_t *cr_buf;\n  37 }\n\n\n\n\nstruct console_tty {\n  40     struct console_ring ct_tx;\n  41     uint8_t ct_tx_buf[CONSOLE_TX_BUF_SZ]; /* must be after console_ring */\n  42     struct console_ring ct_rx;\n  43     uint8_t ct_rx_buf[CONSOLE_RX_BUF_SZ]; /* must be after console_ring */\n  44     console_rx_cb ct_rx_cb;     /* callback that input is ready */\n  45     console_write_char ct_write_char;\n  46 } console_tty\n\n\n\n\nList of Functions\n\n\nThe functions available in console are:\n\n\n\n\nconsole_printf\n\n\nconsole_add_char\n\n\nconsole_pull_char\n\n\nconsole_pull_char_head\n\n\nconsole_queue_char\n\n\nconsole_blocking_tx\n\n\nconsole_blocking_mode\n\n\nconsole_write\n\n\nconsole_read\n\n\nconsole_tx_char\n\n\nconsole_rx_char\n\n\nconsole_init\n\n\n\n\nFunction Reference\n\n\n\n\nfunction console_printf\n\n\n    void \n    console_printf(const char *fmt, ...)\n\n\n\n\nWrites a formatted message instead of raw output to the console. It first composes a C string containing text specified as arguments to the function or containing the elements in the variable argument list passed to it using snprintf or vsnprintf, respectively. It then uses function \nconsole_write\n to output the formatted data (messages) on the console.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfmt\n\n\nPointer to C string that contains a format string that follows the same specifications as format in printf. The string is printed to console.\n\n\n\n\n\n\n...\n\n\nDepending on the format string, the function may expect either a sequence of additional arguments to be used to replace a format specifier in the format string or a variable arguments list. va_list is a special type defined in \n in stdarg.h.\n\n\n\n\n\n\n\n\nReturned values\n\n\nNone\n\n\nNotes\n\n\nWhile \nconsole_printf\n, with its well understood formatting options in C, is more convenient and easy on the eyes than the raw output of \nconsole_write\n, the associated code size is considerably larger.\n\n\nExample\n\n\nExample #1:\n\n\nchar adv_data_buf[32];\n\nvoid\ntask()\n{ \n   char adv_data_buf[32];\n\n   console_printf(\n%s\n, adv_data_buf);\n}\n\n\n\n\nExample #2:\n\n\nstruct exception_frame {\n    uint32_t r0;\n    uint32_t r1;\n\nstruct trap_frame {\n    struct exception_frame *ef;\n    uint32_t r2;\n    uint32_t r3;\n};\n\nvoid\ntask(struct trap_frame *tf)\n{\n     console_printf(\n r0:%8.8x  r1:%8.8x\n, tf-\nef-\nr0, tf-\nef-\nr1);\n     console_printf(\n r8:%8.8x  r9:%8.8x\n, tf-\nr2, tf-\nr3);\n}\n\n\n\n\n\n\n function console_add_char\n\n\n   static void\n   console_add_char(struct console_ring *cr, char ch)\n\n\n\n\nAdds a character to the console ring buffer. When you store an item in the buffer you store it at the head location, and the head advances to the next location.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*cr\n\n\nPointer to a console ring data structure whose \ncr_head\nvariable is to be set to the second argument in this function call\n\n\n\n\n\n\nch\n\n\nCharacter to be inserted to the ring\n\n\n\n\n\n\n\n\nReturned values\n\n\nNone\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nAdd a new line character to the output (transmit) buffer.\n\n\nvoid\ntask()\n{\n     struct console_ring *tx = \nct-\nct_tx;\n\n     console_add_char(tx, '\\n');\n}\n\n\n\n\n\n\n function console_pull_char \n\n\n   static uint8_t\n   console_pull_char(struct console_ring *cr)\n\n\n\n\nReads (remove) a byte from the console ring buffer. When you read (pull) an item, you read it at the current tail location, and the tail advances to the next position. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*cr\n\n\nPointer to the console ring buffer from where a character is to be removed\n\n\n\n\n\n\n\n\nReturned values\n\n\nReturns the character pulled from the ring buffer.\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nRead the characters in the ring buffer into a string.\n\n\nvoid\ntask(struct console_ring *cr, char *str, int cnt)\n{    \n     for (i = 0; i \n cnt; i++) {\n          if (cr-\ncr_head == cr-\ncr_tail) {\n              i = -1;\n              break;\n          }\n     ch = console_pull_char(cr);\n     *str++ = ch;\n     }\n}\n\n\n\n\n\n\n function console_pull_char_head \n\n\n   static void\n   console_pull_char_head(struct console_ring *cr)\n\n\n\n\nRemoves the last character inserted into the ring buffer by moving back the head location and shrinking the ring size by 1. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncr\n\n\nPointer to the console ring buffer from which the last inserted character must be deleted\n\n\n\n\n\n\n\n\nReturned values\n\n\nNone\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nIn order to see a character getting deleted when a user hits backspace while typying a command, the following needs to happen in sequence:\n\n\n\n\noutput a backspace (move cursor back one character)\n\n\noutput space (erasing whatever character there was before)\n\n\noutput backspace (move cursor back one character)\n\n\nremove the previous character from incoming RX queue\n\n\n\n\nThe example below shows console_pull_char_head being used for the last step.\n\n\nvoid\ntask(uint8_t data)\n{\n      struct console_tty *ct = (struct console_tty *)arg;\n      struct console_ring *tx = \nct-\nct_tx;\n      struct console_ring *rx = \nct-\nct_rx;\n\n      switch (data) {\n      case '\\b':\n          console_add_char(tx, '\\b');\n          console_add_char(tx, ' ');\n          console_add_char(tx, '\\b');\n          console_pull_char_head(rx);\n          break;\n      }\n}\n\n\n\n\n\n\n\n function console_queue_char \n\n\n   static void\n   console_queue_char(char ch)\n\n\n\n\nManage the buffer queue before inserting a character into it. If the head of the output (transmit) console ring is right up to its tail, the queue needs to be drained first before any data can be added. Then it uses console_add_char function to add the character.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nch\n\n\nCharacter to be inserted to the queue\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nThis function makes sure no interrupts are allowed while the transmit buffer is draining and the character is being added.\n\n\nExample\n\n\nInsert example\n\n\n\n\n\n\n function console_blocking_tx \n\n\n    static void\n    console_blocking_tx(char ch)\n\n\n\n\nCalls the hal function hal_uart_blocking_tx to transmit a byte to the console over UART in a blocking mode until the character has been sent. Hence it must be called with interrupts disabled. It is used when printing diagnostic output from system crash. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\n\n\nxx\n\n\n\n\n\n\nyy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nGive at least one example of usage.\n\n\n\n\n function console_blocking_mode \n\n\n   void\n   console_blocking_mode(void)\n\n\n\n\nCalls the console_blocking_tx function to flush the buffered console output (transmit) queue. The function OS_ENTER_CRITICAL() is called to disable interrupts and OS_EXIT_CRITICAL() is called to enable interrupts back again once the buffer is flushed.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\n\n\nxx\n\n\n\n\n\n\nyy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nGive at least one example of usage.\n\n\nfunction console_write \n\n\n   void\n   console_write(char *str, int cnt)\n\n\n\n\nTransmit characters to console display over serial port. \n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\n\n\nxx\n\n\n\n\n\n\nyy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nGive at least one example of usage.\n\n\n function console_read \n\n\n  int\n  console_read(char *str, int cnt)\n\n\n\n\nCalls hal function hal_uart_start_rx to start receiving input from console terminal over serial port.\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\n\n\nxx\n\n\n\n\n\n\nyy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nGive at least one example of usage.\n\n\n function console_tx_char \n\n\nstatic int\n   console_tx_char(void *arg)\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\n\n\nxx\n\n\n\n\n\n\nyy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nGive at least one example of usage.\n\n\n function console_rx_char \n\n\n   static int\n   console_rx_char(void *arg, uint8_t data)\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\n\n\nxx\n\n\n\n\n\n\nyy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nGive at least one example of usage.\n\n\n function console_init \n\n\n   int\n   console_init(console_rx_cb rx_cb)\n\n\n\n\nInitializes console receive buffer and calls hal funtions hal_uart_init_cbs and hal_uart_config to initialize serial port connection and configure it (e.g. baud rate, flow control etc.)\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\n\n\nxx\n\n\n\n\n\n\nyy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\nGive at least one example of usage.", 
            "title": "Console"
        }, 
        {
            "location": "/chapter5/console/#console", 
            "text": "The console is an operating system window where users interact with system programs of the operating system or a console application by entering text input (typically from a keyboard) and reading text output (typically on the computer terminal). The text written on the console brings some information and is a sequence of characters sent by the OS or programs running on the OS.   Support is currently available for console access via the serial port on the hardware board.", 
            "title": "Console"
        }, 
        {
            "location": "/chapter5/console/#description", 
            "text": "In the Mynewt OS, the console library comes in two versions:   full - containing the full implementation  stub - containing stubs for the API   If an egg or project requires the full console capability it lists that dependency in its egg.yml file. For example, the shell egg is defined by the following egg.yml file:  egg.name: libs/shell \negg.vers: 0.1\negg.deps:\n    - libs/console/full\n    - libs/os\negg.identities:\n    - SHELL  On the other hand, a project may not have a physical console (e.g. a UART port to connect a terminal to) but may have a dependency on an egg that has console capability. In that case you would use a console stub. Another example would be the bootloader project where we want to keep the size of the image small. It includes the  libs/os  egg that can print out messages on a console (e.g. if there is a hard fault) and the  libs/util  egg that uses full console (but only if SHELL is present to provide a CLI). However, we do not want to use any console I/O capability in this particular bootloader project to keep the size small. We simply use the console stub instead and the egg.yml file for the project boot egg looks like the following:  project.name: boot\nproject.identities: bootloader\nproject.eggs:\n    - libs/os\n    - libs/bootutil\n    - libs/nffs\n    - libs/console/stub\n    - libs/util", 
            "title": "Description"
        }, 
        {
            "location": "/chapter5/console/#data-structures", 
            "text": "Console interaction is intrinsically composed of two unidirectional systems. The console implementation uses two ring buffers containing input (receive) and output (transmit) characters, respectively. Read and write operations on the console_ring structure are managed by labeling the read location indicator the  cr_tail  and the write location indicator the  cr_head . The console ring length is variable and is specified as the  cr_size  member of the data structure.  cr_buf  is the pointer to the actual array of data contained.  struct console_ring {\n  32     uint8_t cr_head;\n  33     uint8_t cr_tail;\n  34     uint8_t cr_size;\n  35     uint8_t _pad;\n  36     uint8_t *cr_buf;\n  37 }  struct console_tty {\n  40     struct console_ring ct_tx;\n  41     uint8_t ct_tx_buf[CONSOLE_TX_BUF_SZ]; /* must be after console_ring */\n  42     struct console_ring ct_rx;\n  43     uint8_t ct_rx_buf[CONSOLE_RX_BUF_SZ]; /* must be after console_ring */\n  44     console_rx_cb ct_rx_cb;     /* callback that input is ready */\n  45     console_write_char ct_write_char;\n  46 } console_tty", 
            "title": "Data structures"
        }, 
        {
            "location": "/chapter5/console/#list-of-functions", 
            "text": "The functions available in console are:   console_printf  console_add_char  console_pull_char  console_pull_char_head  console_queue_char  console_blocking_tx  console_blocking_mode  console_write  console_read  console_tx_char  console_rx_char  console_init", 
            "title": "List of Functions"
        }, 
        {
            "location": "/chapter5/console/#function-reference", 
            "text": "function console_printf      void \n    console_printf(const char *fmt, ...)  Writes a formatted message instead of raw output to the console. It first composes a C string containing text specified as arguments to the function or containing the elements in the variable argument list passed to it using snprintf or vsnprintf, respectively. It then uses function  console_write  to output the formatted data (messages) on the console.  Arguments     Arguments  Description      fmt  Pointer to C string that contains a format string that follows the same specifications as format in printf. The string is printed to console.    ...  Depending on the format string, the function may expect either a sequence of additional arguments to be used to replace a format specifier in the format string or a variable arguments list. va_list is a special type defined in   in stdarg.h.     Returned values  None  Notes  While  console_printf , with its well understood formatting options in C, is more convenient and easy on the eyes than the raw output of  console_write , the associated code size is considerably larger.  Example  Example #1:  char adv_data_buf[32];\n\nvoid\ntask()\n{ \n   char adv_data_buf[32];\n\n   console_printf( %s , adv_data_buf);\n}  Example #2:  struct exception_frame {\n    uint32_t r0;\n    uint32_t r1;\n\nstruct trap_frame {\n    struct exception_frame *ef;\n    uint32_t r2;\n    uint32_t r3;\n};\n\nvoid\ntask(struct trap_frame *tf)\n{\n     console_printf(  r0:%8.8x  r1:%8.8x , tf- ef- r0, tf- ef- r1);\n     console_printf(  r8:%8.8x  r9:%8.8x , tf- r2, tf- r3);\n}    function console_add_char     static void\n   console_add_char(struct console_ring *cr, char ch)  Adds a character to the console ring buffer. When you store an item in the buffer you store it at the head location, and the head advances to the next location.  Arguments     Arguments  Description      *cr  Pointer to a console ring data structure whose  cr_head variable is to be set to the second argument in this function call    ch  Character to be inserted to the ring     Returned values  None  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Add a new line character to the output (transmit) buffer.  void\ntask()\n{\n     struct console_ring *tx =  ct- ct_tx;\n\n     console_add_char(tx, '\\n');\n}    function console_pull_char      static uint8_t\n   console_pull_char(struct console_ring *cr)  Reads (remove) a byte from the console ring buffer. When you read (pull) an item, you read it at the current tail location, and the tail advances to the next position.   Arguments     Arguments  Description      *cr  Pointer to the console ring buffer from where a character is to be removed     Returned values  Returns the character pulled from the ring buffer.  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Read the characters in the ring buffer into a string.  void\ntask(struct console_ring *cr, char *str, int cnt)\n{    \n     for (i = 0; i   cnt; i++) {\n          if (cr- cr_head == cr- cr_tail) {\n              i = -1;\n              break;\n          }\n     ch = console_pull_char(cr);\n     *str++ = ch;\n     }\n}    function console_pull_char_head      static void\n   console_pull_char_head(struct console_ring *cr)  Removes the last character inserted into the ring buffer by moving back the head location and shrinking the ring size by 1.   Arguments     Arguments  Description      cr  Pointer to the console ring buffer from which the last inserted character must be deleted     Returned values  None  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  In order to see a character getting deleted when a user hits backspace while typying a command, the following needs to happen in sequence:   output a backspace (move cursor back one character)  output space (erasing whatever character there was before)  output backspace (move cursor back one character)  remove the previous character from incoming RX queue   The example below shows console_pull_char_head being used for the last step.  void\ntask(uint8_t data)\n{\n      struct console_tty *ct = (struct console_tty *)arg;\n      struct console_ring *tx =  ct- ct_tx;\n      struct console_ring *rx =  ct- ct_rx;\n\n      switch (data) {\n      case '\\b':\n          console_add_char(tx, '\\b');\n          console_add_char(tx, ' ');\n          console_add_char(tx, '\\b');\n          console_pull_char_head(rx);\n          break;\n      }\n}    function console_queue_char      static void\n   console_queue_char(char ch)  Manage the buffer queue before inserting a character into it. If the head of the output (transmit) console ring is right up to its tail, the queue needs to be drained first before any data can be added. Then it uses console_add_char function to add the character.  Arguments     Arguments  Description      ch  Character to be inserted to the queue     Returned values  List any values returned.\nError codes?  Notes  This function makes sure no interrupts are allowed while the transmit buffer is draining and the character is being added.  Example  Insert example    function console_blocking_tx       static void\n    console_blocking_tx(char ch)  Calls the hal function hal_uart_blocking_tx to transmit a byte to the console over UART in a blocking mode until the character has been sent. Hence it must be called with interrupts disabled. It is used when printing diagnostic output from system crash.   Arguments     Arguments      xx    yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Give at least one example of usage.    function console_blocking_mode      void\n   console_blocking_mode(void)  Calls the console_blocking_tx function to flush the buffered console output (transmit) queue. The function OS_ENTER_CRITICAL() is called to disable interrupts and OS_EXIT_CRITICAL() is called to enable interrupts back again once the buffer is flushed.  Arguments     Arguments      xx    yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Give at least one example of usage.  function console_write      void\n   console_write(char *str, int cnt)  Transmit characters to console display over serial port.   Arguments     Arguments      xx    yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Give at least one example of usage.   function console_read     int\n  console_read(char *str, int cnt)  Calls hal function hal_uart_start_rx to start receiving input from console terminal over serial port.  Arguments     Arguments      xx    yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Give at least one example of usage.   function console_tx_char   static int\n   console_tx_char(void *arg)  Arguments     Arguments      xx    yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Give at least one example of usage.   function console_rx_char      static int\n   console_rx_char(void *arg, uint8_t data)  Arguments     Arguments      xx    yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Give at least one example of usage.   function console_init      int\n   console_init(console_rx_cb rx_cb)  Initializes console receive buffer and calls hal funtions hal_uart_init_cbs and hal_uart_config to initialize serial port connection and configure it (e.g. baud rate, flow control etc.)  Arguments     Arguments      xx    yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example  Give at least one example of usage.", 
            "title": "Function Reference"
        }, 
        {
            "location": "/chapter5/shell/", 
            "text": "Shell\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe module here, special features, how pieces fit together etc.\n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nshell_cmd_list_lock\n\n\nshell_cmd_list_unlock\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\nfunction shell_cmd_list_lock \n\n\n    static int \n    shell_cmd_list_lock(void)\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function shell_cmd_list_unlock \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here", 
            "title": "Shell"
        }, 
        {
            "location": "/chapter5/shell/#shell", 
            "text": "Insert synopsis here", 
            "title": "Shell"
        }, 
        {
            "location": "/chapter5/shell/#description", 
            "text": "Describe module here, special features, how pieces fit together etc.", 
            "title": "Description"
        }, 
        {
            "location": "/chapter5/shell/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/chapter5/shell/#list-of-functions", 
            "text": "The functions available in this OS feature are:   shell_cmd_list_lock  shell_cmd_list_unlock  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/chapter5/shell/#function-reference", 
            "text": "function shell_cmd_list_lock       static int \n    shell_cmd_list_lock(void)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function shell_cmd_list_unlock       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function next_one       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": "Function Reference"
        }, 
        {
            "location": "/chapter5/bootloader/", 
            "text": "Bootloader\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe module here, special features, how pieces fit together etc.\n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nboot_slot_addr\n\n\nboot_find_image_slot\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\nfunction boot_slot_addr \n\n\n    static void\n    boot_slot_addr(int slot_num, uint8_t *flash_id, uint32_t *address)\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function boot_find_image_slot \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here", 
            "title": "Bootloader"
        }, 
        {
            "location": "/chapter5/bootloader/#bootloader", 
            "text": "Insert synopsis here", 
            "title": "Bootloader"
        }, 
        {
            "location": "/chapter5/bootloader/#description", 
            "text": "Describe module here, special features, how pieces fit together etc.", 
            "title": "Description"
        }, 
        {
            "location": "/chapter5/bootloader/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/chapter5/bootloader/#list-of-functions", 
            "text": "The functions available in this OS feature are:   boot_slot_addr  boot_find_image_slot  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/chapter5/bootloader/#function-reference", 
            "text": "function boot_slot_addr       static void\n    boot_slot_addr(int slot_num, uint8_t *flash_id, uint32_t *address)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function boot_find_image_slot       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function next_one       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": "Function Reference"
        }, 
        {
            "location": "/chapter5/filesystem/", 
            "text": "Filesystem\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe module here, special features, how pieces fit together etc.\n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\nnffs_lock\n\n\nnffs_unlock\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\nfunction nffs_lock \n\n\n    static void\n    nffs_lock(void)\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function nffs_unlock \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here", 
            "title": "File System"
        }, 
        {
            "location": "/chapter5/filesystem/#filesystem", 
            "text": "Insert synopsis here", 
            "title": "Filesystem"
        }, 
        {
            "location": "/chapter5/filesystem/#description", 
            "text": "Describe module here, special features, how pieces fit together etc.", 
            "title": "Description"
        }, 
        {
            "location": "/chapter5/filesystem/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/chapter5/filesystem/#list-of-functions", 
            "text": "The functions available in this OS feature are:   nffs_lock  nffs_unlock  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/chapter5/filesystem/#function-reference", 
            "text": "function nffs_lock       static void\n    nffs_lock(void)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function nffs_unlock       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function next_one       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": "Function Reference"
        }, 
        {
            "location": "/chapter5/testutil/", 
            "text": "testutil\n\n\nInsert synopsis here\n\n\nDescription\n\n\nDescribe module here, special features, how pieces fit together etc.\n\n\nData structures\n\n\nReplace this with the list of data structures used, why, any neat features\n\n\nList of Functions\n\n\n\n\nThe functions available in this OS feature are:\n\n\n\n\ntu_init\n\n\ntu_restart\n\n\nadd the rest\n\n\n\n\nFunction Reference\n\n\n\n\nfunction tu_init \n\n\n    int\n    tu_init(void)\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function tu_restart \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here\n\n\n\n\n\n\n\n\n function next_one \n\n\n   \nInsert function callout here \n\n\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxx\n\n\nexplain argument xx\n\n\n\n\n\n\nyy\n\n\nexplain argument yy\n\n\n\n\n\n\n\n\nReturned values\n\n\nList any values returned.\nError codes?\n\n\nNotes\n\n\nAny special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).\n\n\nExample\n\n\n\n\n\n\nInsert the code snippet here", 
            "title": "Test Utilities"
        }, 
        {
            "location": "/chapter5/testutil/#testutil", 
            "text": "Insert synopsis here", 
            "title": "testutil"
        }, 
        {
            "location": "/chapter5/testutil/#description", 
            "text": "Describe module here, special features, how pieces fit together etc.", 
            "title": "Description"
        }, 
        {
            "location": "/chapter5/testutil/#data-structures", 
            "text": "Replace this with the list of data structures used, why, any neat features", 
            "title": "Data structures"
        }, 
        {
            "location": "/chapter5/testutil/#list-of-functions", 
            "text": "The functions available in this OS feature are:   tu_init  tu_restart  add the rest", 
            "title": "List of Functions"
        }, 
        {
            "location": "/chapter5/testutil/#function-reference", 
            "text": "function tu_init       int\n    tu_init(void)   Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function tu_restart       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here     function next_one       Insert function callout here     Arguments     Arguments  Description      xx  explain argument xx    yy  explain argument yy     Returned values  List any values returned.\nError codes?  Notes  Any special feature/special benefit that we want to tout. \nDoes it need to be used with some other specific functions?\nAny caveats to be careful about (e.g. high memory requirements).  Example    Insert the code snippet here", 
            "title": "Function Reference"
        }, 
        {
            "location": "/chapter6/dist/", 
            "text": "", 
            "title": "Creating Packages"
        }
    ]
}