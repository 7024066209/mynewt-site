{
    "docs": [
        {
            "location": "/", 
            "text": "Objective of Mynewt\n\n\nMynewt is an open source initiative to build a stack of modularized control, networking, and monitoring software for embedded devices. The modular implementation allows the user the flexibility to mix and match hardware components and software stack depending on the feature and performance requirements of the particular application he or she has in mind.\n\n\nThe world of Mynewt, therefore, has three primary collaborative goals:\n\n\n\n\nBuild a modularized real-time operating system for a rich set of hardware components\n\n\nOffer a suite of open-source software for efficient and secure two-way communications with an embedded device\n\n\nDevelop method and tools necessary to build an optimized executable image on the desired hardware\n\n\n\n\nThe chapter organization is outlined below. Each Chapter has one or more tutorials for hands-on experience with the material in each chapter. \n\n\n\n\n\n\nChapter 1: Getting Started\n introduces some key terms in this initiative and includes a tutorial for a quick project to show how to work with some of the products.\n\n\n\n\n\n\nChapter 2: Getting Acclimated\n delves deeper into the concepts crucial to the software development effort. \n\n\n\n\n\n\nChapter 3: Newt Tool Reference\n describes the command structure and details all the available commands to help you with your project.", 
            "title": "Doc Home"
        }, 
        {
            "location": "/#objective-of-mynewt", 
            "text": "Mynewt is an open source initiative to build a stack of modularized control, networking, and monitoring software for embedded devices. The modular implementation allows the user the flexibility to mix and match hardware components and software stack depending on the feature and performance requirements of the particular application he or she has in mind.  The world of Mynewt, therefore, has three primary collaborative goals:   Build a modularized real-time operating system for a rich set of hardware components  Offer a suite of open-source software for efficient and secure two-way communications with an embedded device  Develop method and tools necessary to build an optimized executable image on the desired hardware   The chapter organization is outlined below. Each Chapter has one or more tutorials for hands-on experience with the material in each chapter.     Chapter 1: Getting Started  introduces some key terms in this initiative and includes a tutorial for a quick project to show how to work with some of the products.    Chapter 2: Getting Acclimated  delves deeper into the concepts crucial to the software development effort.     Chapter 3: Newt Tool Reference  describes the command structure and details all the available commands to help you with your project.", 
            "title": "Objective of Mynewt"
        }, 
        {
            "location": "/chapter1/newt_concepts/", 
            "text": "Newt Concepts\n\n\nThis page introduces the basic terms you will need to find your way around the Mynewt ecosystem.\n\n\nBasic components in the ecosystem\n\n\n\n\n\n\nNewtOS is an open-source RTOS (Real Time Operating System) that works on a variety of hardware. The goal is to develop a pre-emptive, multitasking OS that is highly modular, making it possible to mix and match components to enable desired features and capabilities on multiple hardware architectures. Examples of components being worked on are the Core RTOS, a flash file system, utility functions, a variety of board support packages, packages of microcontrollers etc.\n\n\n\n\n\n\nNetwork protocol stacks such as Bluetooth Low Energy, and more\n\n\n\n\n\n\nNewt Tool helps you mix the specific packages for the combination of hardware and low-level embedded architecture features of the user's choice and generate the corresponding run-time image based on the NewtOS. It provides the infrastructure to manage and build for different CPU architectures, memory units, board support packages etc., allowing a user to formulate the contents according to the low-level features needed by his or her project.\n\n\n\n\n\n\nTerminology\n\n\nA Mynewt user starts with a project in mind that defines the application or utility that he or she wants to implement on an embedded device. Making an LED blink on an electronics prototyping board is a common starter project. Enabling a BLE (Bluetooth Low Energy) peripheral mode on a development board is a more complex project. Specifying a project requires naming it, at the very least, and then adding the desired properties or attributes. In order to actualize a project, it needs to be applied to a target which is essentially a combination of some specified hardware and the execution environment. \n\n\nIn the mynewt lifecycle, a project grows in a nest. A nest may house multiple projects. The nest is, therefore, a repository where various component packages for one or more projects reside. Each package is an egg (naturally!). However, in the world of Mynewt an egg may consist of other eggs! For example, the starter project Blinky is an egg consisting of several constituent eggs that enable core features. The egg form is suitable for elemental units of code as it explicitly exposes characteristics such as dependencies, versions, capabilities, requirements etc., thus making assembling appropriate components for a project and building an image for it easy to follow, modular, and robust.\n\n\nA nest can be given any name. For example, you will see a nest named \"tadpole\" in Mynewt (\nhttps://git-wip-us.apache.org/repos/asf?p=incubator-mynewt-tadpole.git\n). It contains all the core libraries of the operating system for the native platform which currently supports compilation on Mac OS X. The core libraries are contained in the form of eggs where an egg is a basic unit of implementation of any aspect of the RTOS. The eggs are distributed in the following directory structure inside the nest:\n\n\n\n\nlibs: contains the two eggs \nos\n and \ntestutil\n\n\nhw: contains three eggs - (i) \nhal\n which has the abstraction layer (HAL) API definitions that all BSP and MCU implementations must support, (ii) \n/mcu/native\n which in an MCU implementation for the native platform (a simulator, in this case), and (iii) \nbsp/native\n which is a BSP implementation for the native platform \n\n\ncompiler: contains the \nsim\n egg which bundles the compiler specifications for the native platform.\n\n\n\n\nLet's explore this sample nest a bit further. The \nlibs/os\n egg contains code for scheduler, process/thread/memory management, semaphores etc. It is the core RTOS which ports to all supported chip platforms.The \nlibs/testutil\n egg contains code for testing packages on hardware or simulated environment. The \nhw/hal\n egg contains header files that provide abstraction for physical hardware components such as GPIO (general purpose input/output), network adapters, timers, and UARTs. This \nhw/hal\n egg is an MCU peripheral abstraction designed to make it easy to port to different MCUs (microcontrollers). The \nhw/mcu/native\n egg contains code for microcontroller operations on the native platform. The \nhw/bsp/native\n egg contains the board support package for the native platform. And finally, the sixth egg \nsim\n contains the compiler specifications such as path and flags. Currently the compilation is supported on Mac OS X.\n\n\nYou can see another nest in the mynewt ecosystem called the \"larva\". It was spawned from the skeletal \"tadpole\" nest using the newt tool. Spawning is easy - \n$ newt create nest \nyour_nest_name\n. \"larva\" is the developer's test repository containing all sorts of eggs being written and incubated, including ones to enhance the core operating system which should eventually make their way into the \"tadpole\" nest. There is a \nhatch_tadpole\n script to update the \"tadpole\" nest when the core OS related eggs in \"larva\" are ready.\n\n\nThere is a third nest named \"newt\" that contains all the eggs needed to support the build and release process of mynewt software. In the future, there will also be pre-built nests for certain common hardware devices to enable a user to quickly get started with a project.\n\n\nA Mynewt contributor\n\n\nA contributor can choose to work on any area(s) of the Mynewt endeavor that appeals to him or her. Hence, you can work on one or more eggs or an entire nest. You can create your own nest (master) or create a branch in an existing nest. For now, Runtime contributors will review any new areas of support that you may wish to introduce e.g. a new board support package (BSP) or a new network protocol. \n\n\nA contributer role necessarily implies he or she is a Mynewt user (see below) of some or all of the products developed.\n\n\nA Mynewt user\n\n\nAn application developer is interested only in using software available in this ecosystem to build a top level build artifact. He or she may either:\n\n\n\n\nUse a pre-built nest, or\n\n\nSpawn a new nest using the newt tool for a target where a target is a custom combination of supported hardware components\n\n\n\n\nIn either case, the user would use the newt tool to create and set the target in the chosen nest. The newt tool would then be used to build out the target profile which would determine which eggs to choose. Finally, the user would use the newt tool to generate a run-time image that can be run on the device.", 
            "title": "Newt Concepts"
        }, 
        {
            "location": "/chapter1/newt_concepts/#newt-concepts", 
            "text": "This page introduces the basic terms you will need to find your way around the Mynewt ecosystem.  Basic components in the ecosystem    NewtOS is an open-source RTOS (Real Time Operating System) that works on a variety of hardware. The goal is to develop a pre-emptive, multitasking OS that is highly modular, making it possible to mix and match components to enable desired features and capabilities on multiple hardware architectures. Examples of components being worked on are the Core RTOS, a flash file system, utility functions, a variety of board support packages, packages of microcontrollers etc.    Network protocol stacks such as Bluetooth Low Energy, and more    Newt Tool helps you mix the specific packages for the combination of hardware and low-level embedded architecture features of the user's choice and generate the corresponding run-time image based on the NewtOS. It provides the infrastructure to manage and build for different CPU architectures, memory units, board support packages etc., allowing a user to formulate the contents according to the low-level features needed by his or her project.    Terminology  A Mynewt user starts with a project in mind that defines the application or utility that he or she wants to implement on an embedded device. Making an LED blink on an electronics prototyping board is a common starter project. Enabling a BLE (Bluetooth Low Energy) peripheral mode on a development board is a more complex project. Specifying a project requires naming it, at the very least, and then adding the desired properties or attributes. In order to actualize a project, it needs to be applied to a target which is essentially a combination of some specified hardware and the execution environment.   In the mynewt lifecycle, a project grows in a nest. A nest may house multiple projects. The nest is, therefore, a repository where various component packages for one or more projects reside. Each package is an egg (naturally!). However, in the world of Mynewt an egg may consist of other eggs! For example, the starter project Blinky is an egg consisting of several constituent eggs that enable core features. The egg form is suitable for elemental units of code as it explicitly exposes characteristics such as dependencies, versions, capabilities, requirements etc., thus making assembling appropriate components for a project and building an image for it easy to follow, modular, and robust.  A nest can be given any name. For example, you will see a nest named \"tadpole\" in Mynewt ( https://git-wip-us.apache.org/repos/asf?p=incubator-mynewt-tadpole.git ). It contains all the core libraries of the operating system for the native platform which currently supports compilation on Mac OS X. The core libraries are contained in the form of eggs where an egg is a basic unit of implementation of any aspect of the RTOS. The eggs are distributed in the following directory structure inside the nest:   libs: contains the two eggs  os  and  testutil  hw: contains three eggs - (i)  hal  which has the abstraction layer (HAL) API definitions that all BSP and MCU implementations must support, (ii)  /mcu/native  which in an MCU implementation for the native platform (a simulator, in this case), and (iii)  bsp/native  which is a BSP implementation for the native platform   compiler: contains the  sim  egg which bundles the compiler specifications for the native platform.   Let's explore this sample nest a bit further. The  libs/os  egg contains code for scheduler, process/thread/memory management, semaphores etc. It is the core RTOS which ports to all supported chip platforms.The  libs/testutil  egg contains code for testing packages on hardware or simulated environment. The  hw/hal  egg contains header files that provide abstraction for physical hardware components such as GPIO (general purpose input/output), network adapters, timers, and UARTs. This  hw/hal  egg is an MCU peripheral abstraction designed to make it easy to port to different MCUs (microcontrollers). The  hw/mcu/native  egg contains code for microcontroller operations on the native platform. The  hw/bsp/native  egg contains the board support package for the native platform. And finally, the sixth egg  sim  contains the compiler specifications such as path and flags. Currently the compilation is supported on Mac OS X.  You can see another nest in the mynewt ecosystem called the \"larva\". It was spawned from the skeletal \"tadpole\" nest using the newt tool. Spawning is easy -  $ newt create nest  your_nest_name . \"larva\" is the developer's test repository containing all sorts of eggs being written and incubated, including ones to enhance the core operating system which should eventually make their way into the \"tadpole\" nest. There is a  hatch_tadpole  script to update the \"tadpole\" nest when the core OS related eggs in \"larva\" are ready.  There is a third nest named \"newt\" that contains all the eggs needed to support the build and release process of mynewt software. In the future, there will also be pre-built nests for certain common hardware devices to enable a user to quickly get started with a project.  A Mynewt contributor  A contributor can choose to work on any area(s) of the Mynewt endeavor that appeals to him or her. Hence, you can work on one or more eggs or an entire nest. You can create your own nest (master) or create a branch in an existing nest. For now, Runtime contributors will review any new areas of support that you may wish to introduce e.g. a new board support package (BSP) or a new network protocol.   A contributer role necessarily implies he or she is a Mynewt user (see below) of some or all of the products developed.  A Mynewt user  An application developer is interested only in using software available in this ecosystem to build a top level build artifact. He or she may either:   Use a pre-built nest, or  Spawn a new nest using the newt tool for a target where a target is a custom combination of supported hardware components   In either case, the user would use the newt tool to create and set the target in the chosen nest. The newt tool would then be used to build out the target profile which would determine which eggs to choose. Finally, the user would use the newt tool to generate a run-time image that can be run on the device.", 
            "title": "Newt Concepts"
        }, 
        {
            "location": "/chapter1/project1/", 
            "text": "Blinky, the First Project\n\n\nObjective\n\n\nWe will show you how you can use eggs from a nest on Mynewt to make an LED on a target board blink. We will call it \n Project Blinky\n. The goals of this tutorial are threefold:\n\n\n\n\nFirst, you will learn how to set up your environment to be ready to use Mynewt OS and newt tool. \n\n\nSecond, we will walk you through a download of eggs for building and testing \non a simulated target\n on a non-Windows machine.\n\n\nThird, you will download eggs and use tools to create a runtime image for a board to \nmake its LED blink\n. \n\n\n\n\nIf you want to explore even further, you can try to upload the image to the board's flash memory and have it \nboot from flash\n!\n\n\nWhat you need\n\n\n\n\nSTM32-E407 development board from Olimex.\n\n\nARM-USB-TINY-H connector with JTAG interface for debugging ARM microcontrollers (comes with the ribbon cable to hook up to the board)\n\n\nUSB A-B type cable to connect the debugger to your personal computer\n\n\nPersonal Computer\n\n\n\n\nThe instructions assume the user is using a Bourne-compatible shell (e.g. bash or zsh) on your computer. You may already have some of the required packages on your machine.  In that \ncase, simply skip the corresponding installation step in the instructions under \nGetting your Mac Ready\n or \nGetting your Ubuntu machine Ready\n or \nGetting your Windows machine Ready\n. While the given instructions should work on other versions, they have been tested for the three specific releases of operating systems noted here:\n\n\n\n\nMac: OS X Yosemite Version 10.10.5\n\n\nLinux: Ubuntu 14.10 (Utopic Unicorn)\n\n\nWindows: Windows 10\n\n\n\n\nGetting your Mac Ready\n\n\nGetting an account on GitHub\n\n\n\n\nGet an account on GitHub. Make sure you have joined the \"Newt Operating System\" organization.\n\n\n\n\nInstalling Homebrew to ease installs on OS X\n\n\n\n\n\n\nDo you have Homebrew? If not, open a terminal on your Mac and paste the following at a Terminal prompt. It will ask you for your sudo password.\n\n\n$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n\n\n\nAlternatively, you can just extract (or \ngit clone\n) Homebrew and install it to \n/usr/local\n.\n\n\n\n\n\n\nCreating local repository\n\n\n\n\n\n\nThe directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:\n\n\n\n\n\n\nsrc contains Go source files organized into packages (one package per directory),\n\n\n\n\n\n\npkg contains package objects, and\n\n\n\n\n\n\nbin contains executable commands.\n\n\n\n\n\n\nThe GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory and then proceed to create the directory for cloning the newt tool repository.\n\n\n$ cd $HOME\n$ mkdir -p dev/go  \n$ cd dev/go\n$ export GOPATH=`pwd`\n\n\n\nNote that you need to add export statements to ~/.bash_profile to export variables permanently.\n    $ vi ~/.bash_profile\n\n\n\n\n\n\nThe next step is to set up the repository for the package building tool \"newt\" on your local machine. First create the appropriate directory for it and then clone the newt tool repository from the online apache repository (or its github.com mirror) into this newly created directory. Check the installation.\n\n\n$ mkdir -p $GOPATH/src/github.com/mynewt  \n$ cd $GOPATH/src/github.com/mynewt\n$ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git newt\n$ ls\nnewt\n$ cd newt\n$ ls\nGodeps                  README.md               coding_style.txt        newt.go\nLICENSE                 cli                     design.txt\n\n\n\n\n\n\n\nInstalling Go and Godep\n\n\n\n\n\n\nNext you will use brew to install go. The summary message at the end of the installation should indicate that it is installed in the /usr/local/Cellar/go/ directory. You will use the go command 'install' to compile and install packages (called eggs in the Mynewt world) and dependencies. \n\n\n$ brew install go\n==\n \n==\n \n==\n *Summary*\n\ud83c\udf7a  /usr/local/Cellar/go/1.5.1: 5330 files, 273M\n$ cd $GOPATH/src/github.com/mynewt/newt\n\n\n\nAlternatively, you can download the go package directly from (https://golang.org/dl/) instead of brewing it. Install it in /usr/local directory.\n\n\n\n\n\n\nNow you will get the godep package. Return to the go directory level and get godep. Check for it in the bin subdirectory. Add the go environment to path. Make sure it is added to your .bash_profile.\n\n\n$ cd $GOPATH\n$ go get github.com/tools/godep\n$ ls\nbin     pkg     src\n$ ls bin\ngodep\n$ export PATH=$PATH:$GOPATH/bin\n\n\n\n\n\n\n\nUse the go command 'install' to compile and install packages and dependencies. In preparation for the install, you may use the godep command 'restore' to check out listed dependency versions in $GOPATH and link all the necessary files. Note that you may have to go to the \n~/dev/go/src/github.com/mynewt/newt\n directory to successfully run the restore command (e.g. on certain distributions of Linux). You may also have to do a \ngo get\n before the restore to make sure all the necessary packages and dependencies are correct.\n\n\n$ cd ~/dev/go/src/github.com/mynewt/newt\n$ go get\n$ ~/dev/go/bin/godep restore\n$ go install\n\n\n\n\n\n\n\nBuilding the Newt tool\n\n\n\n\nYou will now use go to run the newt.go program to build the newt tool. You will have to use \ngo build\n command which compiles and writes the resulting executable to an output file named \nnewt\n. However, it does not install the results along with its dependencies in $GOPATH/bin (for that you will need to use \ngo install\n). Now try running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.\n\n\n\n\nNote: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to store the command in a variable in your .bash_profile. So type in \nexport newt=\"go run $GOPATH/src/github.com/mynewt/newt/newt.go\"\n in your .bash_profile and execute it by calling \n$newt\n at the prompt instead of \nnewt\n. Don't forget to reload the updated bash profile by typing \nsource ~/.bash_profile\n at the prompt! Here, you use \ngo run\n which runs the compiled binary directly without producing an executable.\n\n\n    $ go run %GOPATH%/src/github.com/mynewt/newt/newt.go\n    $ cd ~/dev/go/src/github.com/mynewt/newt\n    $ ls\n    Godeps          README.md       coding_style.txt    newt\n    LICENSE         cli         design.txt      newt.go\n    $ newt version\n    Newt version:  1.0\n    $ newt -h\n    Newt allows you to create your own embedded project based on the Mynewt\n    operating system. Newt provides both build and package management in a\n    single tool, which allows you to compose an embedded workspace, and set\n    of projects, and then build the necessary artifacts from those projects.\n    For more information on the Mynewt operating system, please visit\n    https://www.github.com/mynewt/documentation.\n\n    Please use the newt help command, and specify the name of the command\n    you want help for, for help on how to use a specific command\n\n    Usage:\n     newt [flags]\n     newt [command]\n\n    Examples:\n     newt\n     newt help [\ncommand-name\n]\n       For help on \ncommand-name\n.  If not specified, print this message.\n\n\n    Available Commands:\n     version     Display the Newt version number.\n     target      Set and view target information\n     egg         Commands to list and inspect eggs on a nest\n     nest        Commands to manage nests \n clutches (remote egg repositories)\n     help        Help about any command\n\n    Flags:\n     -h, --help=false: help for newt\n     -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n     -q, --quiet=false: Be quiet; only display error output.\n     -s, --silent=false: Be silent; don't output anything.\n     -v, --verbose=false: Enable verbose output when executing commands.\n\n\n    Use \"newt help [command]\" for more information about a command.\n\n\n\n\n\nWithout creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool. \n\n\n\n\nGetting the debugger ready\n\n\n\n\n\n\nBefore you start building nests and hatching eggs, you need to do one final step in the environment preparation - install gcc / libc that can produce 32-bit executables. So, first install gcc. You will see the brew steps and a final summary confirming install.\n\n\n$ brew install gcc\n...\n...\n==\n Summary\n\ud83c\udf7a  /usr/local/Cellar/gcc/5.2.0: 1353 files, 248M\n\n\n\n\n\n\n\nARM maintains a pre-built GNU toolchain with a GCC source branch targeted at Embedded ARM Processors namely Cortex-R/Cortex-M processor families. Install the PX4 Toolchain and check the version installed. Make sure that the symbolic link installed by Homebrew points to the correct version of the debugger. If not, you can either change the symbolic link using the \"ln -f -s\" command or just go ahead and try with the version it points to!\n\n\n$ brew tap PX4/homebrew-px4\n$ brew update\n$ brew install gcc-arm-none-eabi-49\n$ arm-none-eabi-gcc --version  \narm-none-eabi-gcc (GNU Tools for ARM Embedded Processors) 4.9.3 20150529 (release) [ARM/embedded-4_9-branch revision 224288]\nCopyright (C) 2014 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n$ ls -al /usr/local/bin/arm-none-eabi-gdb\nlrwxr-xr-x  1 aditihilbert  admin  69 Sep 22 17:16 /usr/local/bin/arm-none-eabi-gdb -\n /usr/local/Cellar/gcc-arm-none-eabi-49/20150609/bin/arm-none-eabi-gdb\n\n\n\nNote: If no version is specified, brew will install the latest version available. StackOS will eventually work with multiple versions available including the latest releases. However, at present we have tested only with this version and recommend it for getting started. \n\n\n\n\n\n\nYou have to install OpenOCD (Open On-Chip Debugger) which is an open-source software that will allow you to interface with the JTAG debug connector/adaptor for the Olimex board. It lets you program, debug, and test embedded target devices which, in this case, is the Olimex board. Use brew to install it. Brew adds a simlink /usr/local/bin/openocd to the openocd directory in the Cellar.\n\n\n$ brew install open-ocd\n$ which openocd\n/usr/local/bin/openocd\n$ ls -l $(which openocd)\nlrwxr-xr-x  1 \nuser\n  admin  36 Sep 17 16:22 /usr/local/bin/openocd -\n ../Cellar/open-ocd/0.9.0/bin/openocd\n\n\n\n\n\n\n\nProceed to the \nBuilding test code on simulator\n section.\n\n\n\n\n\n\nGetting your Ubuntu machine Ready\n\n\nGetting an account on GitHub\n\n\n\n\nGet an account on GitHub. Make sure you have joined the \"Newt Operating System\" organization.\n\n\n\n\nInstalling some prerequisites\n\n\n\n\nInstall git, libcurl, and the go language if you do not have them already.\n$ sudo apt-get install git \n$ sudo apt-get install libcurl4-gnutls-dev \n$ sudo apt-get install golang\n\n\n\n\n\n\n\nCreating local repository\n\n\n\n\n\n\nThe directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:\n\n\n\n\n\n\nsrc contains Go source files organized into packages (one package per directory),\n\n\n\n\n\n\npkg contains package objects, and\n\n\n\n\n\n\nbin contains executable commands.\n\n\n\n\n\n\nThe GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory and then proceed to create the directory for cloning the newt tool repository.\n\n\n$ cd $HOME\n$ mkdir -p dev/go  \n$ cd dev/go\n$ export GOPATH=$PWD\n\n\n\nNote that you need to add export statements to ~/.bashrc (or equivalent) to export variables permanently.\n\n\n\n\n\n\nNext, install godep. Note that the following command produces no output.\n\n\n$ go get github.com/tools/godep\n\n\n\n\n\n\n\nSet up the repository for the package building tool \"newt\" on your local machine. First create the appropriate directory for it and then clone the newt tool repository from the online apache repository (or its github.com mirror) into this newly created directory. Check the contents of the directory.\n\n\n$ mkdir -p $GOPATH/src/github.com/mynewt  \n$ cd $GOPATH/src/github.com/mynewt\n$ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git newt\n$ ls\nnewt\n$ cd newt\n$ ls\nGodeps                  README.md               coding_style.txt        newt.go\nLICENSE                 cli                     design.txt\n\n\n\n\n\n\n\nUse the go command 'install' to compile and install packages and dependencies. Add go environment to path. Again, to make the export variable permanent, add it to your ~/.bashrc (or equivalent) file.\n\n\n$ $GOPATH/bin/godep restore \n$ go get \n$ go install \n$ export PATH=$PATH:$GOPATH/bin\n\n\n\n\n\n\n\nBuilding the newt tool\n\n\n\n\nYou will now use go to run the newt.go program to build the newt tool. You will have to use \ngo build\n command which compiles and writes the resulting executable to an output file named \nnewt\n. However, it does not install the results along with its dependencies in $GOPATH/bin (for that you will need to use \ngo install\n). Now try running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.\n\n\n\n\nNote: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to store the command in a variable in your .bash_profile. So type in \nexport newt=\"go run $GOPATH/src/github.com/mynewt/newt/newt.go\"\n in your ~/.bashrc (or equivalent) and execute it by calling \n$newt\n at the prompt instead of \nnewt\n. Here, you use \ngo run\n which runs the compiled binary directly without producing an executable.\n\n\n    $ go build %GOPATH%/src/github.com/mynewt/newt/newt.go\n    $ cd ~/dev/go/src/github.com/mynewt/newt\n    $ ls\n    Godeps          README.md       coding_style.txt    newt\n    LICENSE         cli         design.txt      newt.go\n    $ newt version\n    Newt version:  1.0\n    $ newt -h\n    Newt allows you to create your own embedded project based on the Mynewt\n    operating system. Newt provides both build and package management in a\n    single tool, which allows you to compose an embedded workspace, and set\n    of projects, and then build the necessary artifacts from those projects.\n    For more information on the Mynewt operating system, please visit\n    https://www.github.com/mynewt/documentation.\n\n    Please use the newt help command, and specify the name of the command\n    you want help for, for help on how to use a specific command\n\n    Usage:\n     newt [flags]\n     newt [command]\n\n    Examples:\n     newt\n     newt help [\ncommand-name\n]\n       For help on \ncommand-name\n.  If not specified, print this message.\n\n\n    Available Commands:\n     version     Display the Newt version number.\n     target      Set and view target information\n     egg         Commands to list and inspect eggs on a nest\n     nest        Commands to manage nests \n clutches (remote egg repositories)\n     help        Help about any command\n\n    Flags:\n     -h, --help=false: help for newt\n     -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n     -q, --quiet=false: Be quiet; only display error output.\n     -s, --silent=false: Be silent; don't output anything.\n     -v, --verbose=false: Enable verbose output when executing commands.\n\n\n    Use \"newt help [command]\" for more information about a command.\n\n\n\n\n\nWithout creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool. \n\n\n\n\nGetting the debugger ready\n\n\n\n\n\n\nBefore you start building nests and hatching eggs, you need to do one final step in the environment preparation - install gcc / libc that can produce 32-bit executables. You can install these as follows: \n\n\n$ sudo apt-get install gcc-multilib libc6-i386\n\n\n\n\n\n\n\nFor the LED project on the Olimex hardware, you have to install gcc for AM 4.9.3.  This package can be installed with apt-get as documented \nhere\n.\n\n\n$ sudo apt-get remove binutils-arm-none-eabi gcc-arm-none-eabi \n$ sudo add-apt-repository ppa:terry.guo/gcc-arm-embedded \n$ sudo apt-get update \n$ sudo apt-get install gcc-arm-none-eabi\n\n\n\n\n\n\n\nAnd finally, you have to install OpenOCD (Open On-Chip Debugger) which is an open-source software that will allow you to interface with the JTAG debug connector/adaptor for the Olimex board. It lets you program, debug, and test embedded target devices which, in this case, is the Olimex board. You have to acquire OpenOCD 0.8.0. \n\n\nIf you are running Ubuntu 15.x, then you are in luck and you can simply run: \n\n\n$ sudo apt-get install openocd\n\n\n\nOther versions of Ubuntu may not have the correct version of openocd available.  In this case, you should download the openocd 0.8.0 package from \nhttps://launchpad.net/ubuntu/vivid/+source/openocd\n. The direct link to the amd64 build is \nhttp://launchpadlibrarian.net/188260097/openocd_0.8.0-4_amd64.deb\n. \n\n\n\n\n\n\nProceed to the \nBuilding test code on simulator\n section.\n\n\n\n\n\n\nGetting your Windows machine Ready\n\n\nGetting an account on GitHub\n\n\n\n\nGet an account on GitHub. Make sure you have joined the \"Newt Operating System\" organization.\n\n\n\n\nInstalling some prerequisites\n\n\n\n\n\n\nYou have to install the following if you do not have them already.  The steps below indicate specific folders where each of these programs should be installed. You can choose different locations, but the remainder of this\ntutorial for a Windows machine assumes the specified folders.    \n\n\n\n\nwin-builds-i686\n\n\nwin-builds-x86_64\n\n\nMSYS\n\n\ngcc for ARM\n\n\nopenocd\n\n\nzadig\n\n\ngit\n\n\n\n\ngo\n\n\n\n\nwin-builds (mingw64) 1.5 for i686\n\n\n\n\nDownload from \nhttp://win-builds.org/doku.php/download_and_installation_from_windows\n. Install at: \"C:\\win-builds-i686\".\n\n\nBe sure to click the i686 option (not x86_64). The defaults for all other options are OK. The installer will want to download a bunch of additional packages. They are not all necessary, but it is simplest to just accept the defaults.\n\n\n\n\nwin-builds (mingw64) 1.5 for x86_64\n\n\n\n\nDownload from \nhttp://win-builds.org/doku.php/download_and_installation_from_windows\n. Install at \"C:\\win-builds-x86_64\"\n\n\nRun the installer a second time, but this time click the x86_64 option, NOT i686.  The defaults for all other options are OK.\n\n\n\n\nMSYS\n\n\n\n\nStart your download from \nhttp://sourceforge.net/projects/mingw-w64/files/External%20binary%20packages%20%28Win64%20hosted%29/MSYS%20%2832-bit%29/MSYS-20111123.zip\n\n\nUnzip to \"C:\\msys\"\n\n\n\n\ngcc for ARM, 4.9.3\n\n\n\n\nDownload the Windows installer from \nhttps://launchpad.net/gcc-arm-embedded/+download\n and install at \"C:\\Program Files (x86)\\GNU Tools ARM Embedded\\4.9 2015q3\".\n\n\n\n\nOpenOCD 0.8.0\n\n\n\n\nDownload OpenOCD 0.8.0 from \nhttp://www.freddiechopin.info/en/download/category/4-openocd\n. Unzip to \"C:\\openocd\".\n\n\n\n\nZadig 2.1.2\n\n\n\n\nDownload it from \nhttp://zadig.akeo.ie\n and install it at \"C:\\zadig\".\n\n\n\n\nGit\n\n\n\n\nClick on \nhttps://git-scm.com/download/win\n to start the download. Install at \"C:\\Program Files (x86)\\Git\". Specify the \"Use Git from the Windows Command Prompt\" option.  The defaults for all other options are OK.\n\n\n\n\nGo\n\n\n\n\nDownload the release for Microsoft Windows from \nhttps://golang.org/dl/\n and install it \"C:\\Go\".\n\n\n\n\n\n\n\n\n\n\nCreating local repository\n\n\n\n\n\n\nThe directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:\n\n\n\n\n\n\nsrc contains Go source files organized into packages (one package per directory),\n\n\n\n\n\n\npkg contains package objects, and\n\n\n\n\n\n\nbin contains executable commands.\n\n\n\n\n\n\nThe GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory and then proceed to create the directory for cloning the newt tool repository.\n\n\n$ cd c:\\\n$ mkdir dev\\go\n$ cd dev\\go\n\n\n\n\n\n\n\nSet the following user environment variables using the steps outlined here.\n\n\n\n\nGOPATH: C:\\dev\\go\n\n\nPATH: C:\\Program Files (x86)\\GNU Tools ARM Embedded\\4.9 2015q3\\bin;%GOPATH%\\bin;C:\\win-builds-x86_64\\bin;C:\\win-builds-i686\\bin;C:\\msys\\bin\n\n\n\n\nSteps:\n\n\n\n\nRight-click the start button\n\n\nClick \"Control panel\"\n\n\nClick \"System and Security\"\n\n\nClick \"System\"\n\n\nClick \"Advanced system settings\" in the left panel\n\n\nClick the \"Envoronment Variables...\" button\n\n\nThere will be two sets of environment variables: user variables\n  in the upper half of the screen, and system variables in the lower\n  half.  Configuring the user variables is recommended and tested \n  (though system variables will work as well).\n\n\n\n\n\n\n\n\nNext, install godep. Note that the following command produces no output.\n\n\n$ go get github.com/tools/godep\n\n\n\n\n\n\n\nSet up the repository for the package building tool \"newt\" on your local machine. First create the appropriate directory for it and then clone the newt tool repository from the online apache repository (or its github.com mirror) into this newly created directory. Check the contents of the directory.\n\n\n$ mkdir %GOPATH%\\src\\github.com\\mynewt\n$ cd %GOPATH%\\src\\github.com\\mynewt\n$ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git newt\n$ ls\nnewt\n$ cd newt\n$ ls\nGodeps                  README.md               coding_style.txt        newt.go\nLICENSE                 cli                     design.txt\n\n\n\n\n\n\n\nUse the go command 'install' to compile and install packages and dependencies. Add go environment to path. Again, to make the export variable permanent, add it to your ~/.bashrc (or equivalent) file.\n\n\n$ %GOPATH%\\bin\\godep restore \n$ go get \n$ go install\n\n\n\n\n\n\n\nBuilding the newt tool\n\n\n\n\n\n\nYou will now use go to run the newt.go program to build the newt tool. You will have to use \ngo build\n command which compiles and writes the resulting executable to an output file named \nnewt\n. However, it does not install the results along with its dependencies in $GOPATH/bin (for that you will need to use \ngo install\n). Now try running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.\n\n\nNote: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to define the newt environment variable that allows you to execute the command via \n%newt%\n. Use \nset newt=go run %GOPATH%\\src\\github.com\\mynewt\\newt\\newt.go\n or set it from the GUI. Here, you use \ngo run\n which runs the compiled binary directly without producing an executable.\n\n\n$ go build %GOPATH%\\src\\github.com\\mynewt\\newt\\newt.go\n$ cd ~/dev/go/src/github.com/mynewt/newt\n$ dir\nGodeps          README.md       coding_style.txt    newt\nLICENSE         cli         design.txt      newt.go\n$ newt version\nNewt version:  1.0\n$ newt -h\nNewt allows you to create your own embedded project based on the Mynewt\noperating system. Newt provides both build and package management in a\nsingle tool, which allows you to compose an embedded workspace, and set\nof projects, and then build the necessary artifacts from those projects.\nFor more information on the Mynewt operating system, please visit\nhttps://www.github.com/mynewt/documentation.\n\nPlease use the newt help command, and specify the name of the command\nyou want help for, for help on how to use a specific command\n\nUsage:\n newt [flags]\n newt [command]\n\nExamples:\n newt\n newt help [\ncommand-name\n]\n   For help on \ncommand-name\n.  If not specified, print this message.\n\nAvailable Commands:\n version     Display the Newt version number.\n target      Set and view target information\n egg         Commands to list and inspect eggs on a nest\n nest        Commands to manage nests \n clutches (remote egg repositories)\n help        Help about any command\n\nFlags:\n -h, --help=false: help for newt\n -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n -q, --quiet=false: Be quiet; only display error output.\n -s, --silent=false: Be silent; don't output anything.\n -v, --verbose=false: Enable verbose output when executing commands.\n\nUse \"newt help [command]\" for more information about a command.\n\n\n\n\n\n\n\nWithout creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool. \n\n\n\n\n\n\nGetting the debugger ready\n\n\n\n\n\n\nUse Zadig to configure the USB driver for your Olimex debugger.  If your debugger is already set up, you can skip this step.\n\n\n\n\nPlug in your Olimex debugger.\n\n\nStart Zadig.\n\n\nCheck the Options -\n List All Devices checkbox.\n\n\nSelect \"Olimex OpenOCD JTAG ARM-USB-TINY-H\" in the dropdown menu.\n\n\nSelect the \"WinUSB\" driver.\n\n\nClick the \"Install Driver\" button.\n\n\n\n\n\n\n\n\nProceed to the \nBuilding test code on simulator on Windows machine\n section.\n\n\nNote: Currently, the simulator cannot be run in the Windows machine. We are still working on it. So you will go ahead and \nmake an LED blink\n on the Olimex hardware directly. \n\n\nHowever, before you skip to the hardware target, you still need to build your first nest as outlined in step 1 in the \nBuilding test code on simulator\n.\n\n\nBuilding test code on simulator\n\n\nNote: Currently, the simulator cannot be run in the Windows machine. We are working on it. If you are on a Windows machine, do step 1 below and then proceed to the \nMaking an LED blink\n on the Olimex hardware directly.\n\n\n\n\n\n\nFirst, you have to create a repository for the project i.e. build your first nest! Go to ~/dev and clone the larva repository from the apache git repository into a local directory named \nlarva\n.\n\n\nSubstitute DOS commands for Unix commands as necessary in the following steps if your machine is running Windows. The newt tool commands do not change.\n\n\n$ cd ~/dev \n$ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git larva\n$ ls\ngo  larva\n$ cd larva\n$ ls\nLICENSE     clutch.yml  hw      nest.yml      project\nREADME.md   compiler    libs        net       scripts\n\n\n\n\n\n\n\nYou will now create a new target using the newt tool. You can either use the compiled binary \nnewt\n or run the newt.go program using \n$newt\n (assuming you have stored the command in a variable in your .bash_profile or .bashrc). When you do a \nnewt target show\n or \n$newt target show\n it should list all the projects you have created so far. \n\n\n$ newt target create sim_test\nCreating target sim_test\nTarget sim_test sucessfully created!\n$ newt target show\nsim_test\n    name: sim_test\n    arch: sim\n\n\n\n\n\n\n\nNow continue to populate and build out the sim project.\n\n\n$ newt target set sim_test project=test\nTarget sim_test successfully set project to test\n$ newt target set sim_test compiler_def=debug\nTarget sim_test successfully set compiler_def to debug\n$ newt target set sim_test bsp=hw/bsp/native\nTarget sim_test successfully set bsp to hw/bsp/native\n$ newt target set sim_test compiler=sim\nTarget sim_test successfully set compiler to sim\n$ newt target show sim_test\nsim_test\n    arch: sim\n    project: test\n    compiler_def: debug\n    bsp: hw/bsp/native\n    compiler: sim\n    name: sim_test\n\n\n\n\n\n\n\nConfigure newt to use the gnu build tools native to OS X or linux. In order for sim to work properly, it needs to be using 32-bit gcc (gcc-5). Replace \n~/dev/larva/compiler/sim/compiler.yml with the compiler/sim/osx-compiler.yml or linux-compiler.yml file, depending on the system. \n\n\nFor a Mac OS X environment:\n\n\n$ cp compiler/sim/osx-compiler.yml compiler/sim/compiler.yml\n\n\n\nFor a Linux machine:\n\n\n$ cp compiler/sim/linux-compiler.yml compiler/sim/compiler.yml\n\n\n\n\n\n\n\nNext, create (hatch!) the eggs for this project using the newt tool - basically, build the packages for it. You can specify the VERBOSE option if you want to see the gory details. \n\n\n$ $newt target build sim_test\nSuccessfully run!\n\n\n\nYou can specify the VERBOSE option if you want to see the gory details.\n\n\n$newt -l VERBOSE target build sim_test\n2015/09/29 09:46:12 [INFO] Building project test\n2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//bootutil...\n2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//cmsis-core...\n2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//ffs..\n...\nSuccessfully run!\n\n\n\n\n\n\n\nTry running the test suite executable inside this project and enjoy your first successful hatch.\n\n\n$ ./project/test/bin/sim_test/test.elf\n[pass] os_mempool_test_suite/os_mempool_test_case\n[pass] os_mutex_test_suite/os_mutex_test_basic\n[pass] os_mutex_test_suite/os_mutex_test_case_1\n[pass] os_mutex_test_suite/os_mutex_test_case_2\n[pass] os_sem_test_suite/os_sem_test_basic\n[pass] os_sem_test_suite/os_sem_test_case_1\n[pass] os_sem_test_suite/os_sem_test_case_2\n[pass] os_sem_test_suite/os_sem_test_case_3\n[pass] os_sem_test_suite/os_sem_test_case_4\n[pass] os_mbuf_test_suite/os_mbuf_test_case_1\n[pass] os_mbuf_test_suite/os_mbuf_test_case_2\n[pass] os_mbuf_test_suite/os_mbuf_test_case_3\n[pass] gen_1_1/ffs_test_unlink\n[pass] gen_1_1/ffs_test_rename\n[pass] gen_1_1/ffs_test_truncate\n[pass] gen_1_1/ffs_test_append\n[pass] gen_1_1/ffs_test_read\n[pass] gen_1_1/ffs_test_overwrite_one\n[pass] gen_1_1/ffs_test_overwrite_two\n[pass] gen_1_1/ffs_test_overwrite_three\n...\n...\n[pass] boot_test_main/boot_test_vb_ns_11\n\n\n\n\n\n\n\nBuilding test code on simulator on Windows machine\n\n\nComing soon.\n\n\nMaking an LED blink\n\n\nPreparing the Software\n\n\n\n\n\n\nMake sure the PATH environment variable includes the $HOME/dev/go/bin directory (or C:\\%GOPATH%\\bin on Windows machine). \n\n\nSubstitute DOS commands for Unix commands as necessary in the following steps if your machine is running Windows. The newt tool commands do not change.\n\n\n\n\n\n\nYou first have to create a repository for the project. Go to the ~dev/larva directory and build out a second project inside larva. The project name is \"blinky\", in keeping with the objective. Starting with the target name, you have to specify the different aspects of the project to pull the appropriate eggs and build the right package for the board. In this case that means setting the architecture (arch), compiler, board support package (bsp), project, and compiler mode.\n\n\n$ newt target create blinky\nCreating target blinky\nTarget blinky sucessfully created!\n$ newt target set blinky arch=cortex_m4\nTarget blinky successfully set arch to arm\n$ newt target set blinky compiler=arm-none-eabi-m4\nTarget blinky successfully set compiler to arm-none-eabi-m4\n$ newt target set blinky project=blinky\nTarget blinky successfully set project to blinky\n$ newt target set blinky compiler_def=debug\nTarget blinky successfully set compiler_def to debug\n$ newt target set blinky bsp=hw/bsp/olimex_stm32-e407_devboard\nTarget blinky successfully set bsp to hw/bsp/olimex_stm32-e407_devboard\n$ newt target show blinky\nblinky\n    compiler: arm-none-eabi-m4\n    project: blinky\n    compiler_def: debug\n    bsp: hw/bsp/olimex_stm32-e407_devboard\n    name: blinky\n    arch: cortex_m4\n\n\n\n\n\n\n\nNow you have to build the image. The linker script within the \nhw/bsp/olimex_stm32-e407_devboard\n egg builds an image for flash memory by default. Therefore, you need to switch that script with \nrun_from_sram.ld\n in order to get the egg to produce an image for SRAM. \n We are working on making it easier to specify where the executable will be run from for a particular project and automatically choose the correct linker scripts and generate the appropriate image. It will be specified as a project identity e.g. bootloader, RAM, flash (default) and the target will build accordingly. \n. \n\n\nOnce the target is built, you can find the executable \"blinky.elf\" in the project directory at ~/dev/larva/project/blinky/bin/blinky. It's a good idea to take a little time to understand the directory structure.\n\n\n$ cd ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n$ diff olimex_stm32-e407_devboard.ld run_from_sram.ld\n$ cp run_from_sram.ld olimex_stm32-e407_devboard.ld\n$ cd ~/dev/larva/project/blinky/bin/blinky\n$ newt target build blinky\nBuilding target blinky (project = blinky)\nCompiling case.c\nCompiling suite.c\n...\nSuccessfully run!\n$ ls\nLICENSE     clutch.yml  hw      nest.yml    project\nREADME.md   compiler    libs        net     scripts\n$ cd project\n$ ls\nbin2img     bletest     blinky      boot        ffs2native  test\n$ cd blinky\n$ ls\nbin     blinky.yml  egg.yml     src\n$ cd bin\n$ ls\nblinky\n$ cd blinky\n$ ls\nblinky.elf  blinky.elf.bin  blinky.elf.cmd  blinky.elf.lst  blinky.elf.map\n\n\n\n\n\n\n\nCheck that you have all the scripts needed to get OpenOCD up and talking with the project's specific hardware. Check whether you already have the scripts in your \n/usr/share/openocd/scripts/\n directory as they may have been part of the openocd download. If yes, you are all set and can proceed to preparing the hardware. If not, continue with this step.\n\n\nCurrently, the following 5 files are required. They are likely to be packed into a .tar file and made available under mynewt on github.com. Unpack it in the blinky directory using \ntar xvfz\n command. Go into the openocd directory created and make sure that the gdb-8888.cfg file indicates the correct file ('blinky.elf' in this case) to load and its full path. Specifically, add 'load ~/dev/larva/project/main/bin/blink/main.elf' and 'symbol-file ~/larva/larva/project/main/bin/blink/main.elf' to this file. Alternatively, you could load these files from within the debugger (gdb) as explained later in the project when you connect to the board using openocd.   \n\n\n\n\nocd-8888.cfg\n\n\nolimex-arm-usb-tiny-h-ftdi.cfg\n\n\narm-gdb.cfg\n\n\ngdb-dev_test-8888.cfg\n\n\nstm32f4x.cfg  \n\n\n\n\nCheck the arm-gdb.cfg file and see whether the executable you created in the previous step is specified as the file to be loaded to the board. You have the choice of specifying the target and load from within the gdb debugger (Section \"Let's Go\", Step 2) instead.\n\n\n$ cat gdb-8888.cfg\necho \\n*** Set target charset ASCII\\n\nset target-charset ASCII\n#set arm fallback-mode arm\n#echo \\n*** set arm fallback-mode arm ***\\n\necho \\n*** Connecting to OpenOCD over port #8888 ***\\n\ntarget remote localhost:8888\necho \\n*** loading nic.out.elf ***\\n\nload ~/dev/larva/project/main/bin/blink/main.elf\nsymbol-file ~/dev/larva/project/main/bin/blink/main.elf \n#echo *** Set breakpoint and run to main() to sync with gdb ***\\n\n#b main\n#continue\n#delete 1\n\n#set arm fallback-mode thumb\n#echo \\n*** set arm fallback-mode thumb ***\\n\\n\n\n\n\nNote that an OpenOCD configuration script is available from Olimex for the STM32-E407 development board e.g. at \nhttps://www.olimex.com/Products/ARM/ST/STM32-E407/resources/stm32f4x.cfg\n, however getting it to work with different versions of OpenOCD and gcc could get tricky. [\nThis will be simplified eventually into a consolidated single action step instead of manual tweaks currently required\n]\n\n\n\n\n\n\nPreparing the hardware to boot from embedded SRAM\n\n\n\n\n\n\nLocate the boot jumpers on the board.\n\n\n\n\n\n\n\n\n\nB1_1/B1_0 and B0_1/B0_0 are PTH jumpers which can be moved relatively easy. Note that the markings on the board may not always be accurate. Always refer to the manual for the correct positioning of jumpers in case of doubt. The two jumpers must always be moved together \u2013 they are responsible for the boot mode if bootloader is present. The board can search for bootloader on three places \u2013 User Flash Memory, System Memory or the Embedded SRAM. We will configure it to boot from SRAM by jumpering B0_1 and B1_1.\n\n\n\n\n\n\nConnect USB-OTG#2 in the picture above to a USB port on your computer (or a powered USB hub to make sure there is enough power available to the board). \n\n\n\n\n\n\nConnect the JTAG connector to the SWD/JTAG interface on the board. The other end of the cable should be connected to the USB port or hub of your computer.\n\n\n\n\n\n\nThe red PWR LED should be lit. \n\n\n\n\n\n\nLet's Go!\n\n\n\n\n\n\nGo into the openocd directory and start an OCD session. You should see some status messages are shown below. Check the value of the msp (main service pointer) register. If it is not 0x10010000 as indicated below, you will have to manually set it after you open the gdp tool to load the image on it (next step). Note the \n-c \"reset halt\"\n flag that tells it to halt after opening the session. It will now require a manual \"continue\" command from the GNU debugger in step 3. \n\n\n$ cd ~/dev/larva/project/blinky/bin/blinky/openocd\n$ openocd -f olimex-arm-usb-tiny-h-ftdi.cfg -f ocd-8888.cfg -f stm32f4x.cfg -c \"reset halt\" \nOpen On-Chip Debugger 0.8.0 (2015-09-22-18:21)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.sourceforge.net/doc/doxygen/bugs.html\nInfo : only one transport option; autoselect 'jtag'\nadapter speed: 1000 kHz\nadapter_nsrst_assert_width: 500\nadapter_nsrst_delay: 100\njtag_ntrst_delay: 100\ncortex_m reset_config sysresetreq\nInfo : clock speed 1000 kHz\nInfo : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\nInfo : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\nInfo : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints\nInfo : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\nInfo : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\ntarget state: halted\ntarget halted due to debug-request, current mode: Thread \nxPSR: 0x01000000 pc: 0x2000053c msp: 0x10010000\n\n\n\nIf your scripts are in \n/usr/share/openocd/scripts/\n directory you may need to provide the full path information in the arguments.\n\n\n$ openocd -f /usr/share/openocd/scripts/interface/ftdi/olimex-arm-usb-tiny-h.cfg -f /usr/share/openocd/scripts/target/stm32f4x.cfg -c \"gdb_port 8888; init; reset halt\"\n\n\n\nIf you are on a Windows machine, connect to the board with openocd using the following:\n\n\n$ cd C:\\openocd\n$ bin\\openocd-0.8.0.exe -f scripts\\interface\\ftdi\\olimex-arm-usb-tiny-h.cfg -f scripts\\target\\stm32f4x.cfg -c \"gdb_port 8888; init; reset halt\"\n\n\n\n\n\n\n\nOpen a new terminal window and run the GNU debugger for ARM. Specifying the script gdb-8888.cfg tells it what image to load. You should now have a (gdb) prompt inside the debugger.\n\n\n$ cd ~/dev/larva/project/blinky/bin/blinky/openocd\n$ arm-none-eabi-gdb -x gdb-8888.cfg \nGNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later \nhttp://gnu.org/licenses/gpl.html\n\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"--host=x86_64-apple-darwin10 --target=arm-none-eabi\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n\nhttp://www.gnu.org/software/gdb/bugs/\n.\nFind the GDB manual and other documentation resources online at:\n\nhttp://www.gnu.org/software/gdb/documentation/\n.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n\n*** Set target charset ASCII\n\n*** Connecting to OpenOCD over port #8888 ***\n0x20000580 in ?? ()\n\n*** loading image ***\nLoading section .text, size 0x65d4 lma 0x20000000\nLoading section .ARM.extab, size 0x24 lma 0x200065dc\nLoading section .ARM.exidx, size 0xd8 lma 0x20006600\nLoading section .data, size 0x8f8 lma 0x200066d8\nStart address 0x2000053c, load size 28624\nTransfer rate: 78 KB/sec, 2862 bytes/write.\n(gdb)\n\n\n\nInstead of the script, you could connect to the openocd process and tell the debugger what image to load from within gdb (which is 'blinky.elf' in this case). Below is an example input/output when doing it on a Windows machine. Note the forward slashes.\n\n\nC:\\dev\\larva\narm-none-eabi-gdb -q\n(gdb) target remote localhost:8888\nRemote debugging using localhost:8888\n0xb064f054 in ?? ()\n...\n(gdb) load C:/dev/larva/project/blinky/bin/blinky/blinky.elf\nLoading section .text, size 0x6778 lma 0x20000000\nLoading section .ARM.extab, size 0x18 lma 0x20006778\nLoading section .ARM.exidx, size 0xc8 lma 0x20006790\nLoading section .data, size 0x8f8 lma 0x20006858\nStart address 0x20000528, load size 29008\nTransfer rate: 72 KB/sec, 2900 bytes/write.\n(gdb) symbol-file C:/dev/larva/project/blinky/bin/blinky/blinky.elf\nReading symbols from C:/dev/larva/project/blinky/bin/blinky/blinky.elf...done.\n\n\n\n\n\n\n\nFrom within gdb check the registers. Set the msp register for the main stack pointer to the expected value as shown here. \n\n\nFinally, hit \nc\n to continue... and your green LED should blink!\n\n\n(gdb) info reg all\n r0             0x0 0\n r1             0x0 0\n r2             0x0 0\n r3             0x0 0\n r4             0x0 0\n r5             0x0 0\n r6             0x0 0\n r7             0x0 0\n r8             0x0 0\n r9             0x0 0\n r10            0x0 0\n r11            0x0 0\n r12            0x0 0\n sp             0x10010000  0x10010000\n lr             0xffffffff  -1\n pc             0x20000580  0x20000580 \nReset_Handler\n\n xPSR           0x1000000   16777216\n msp            0x10010000  0x10010000\n psp            0x0 0x0\n primask        0x0 0\n basepri        0x0 0\n faultmask      0x0 0\n control        0x0 0\n (gdb) set $msp=0x10010000\n (gdb) c\n Continuing.\n\n\n\n\n\n\n\nVoil\u00e0! The board's LED should be blinking at 1 Hz.\n\n\n\n\n\n\nUsing flash to make LED blink\n\n\n\n\nConfigure the board to boot from flash by moving the two jumpers together to B0_0 and B1_0. \n\n\n\n\nYou will have to reset the board once the image is uploaded to it.\n\n\n\n\n\n\nBy now you know that you have to build a new package that will run from flash. First, the olimex_stm32-e407_devboard.ld linker script which was previously made the same as run_from_sram.ld will now need the contents of run_from_flash.ld. Then the target has to be rebuilt. \n\n\n$ cd ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n$ diff olimex_stm32-e407_devboard.ld run_from_sram.ld\n$ cp run_from_flash.ld olimex_stm32-e407_devboard.ld\n$ cd ~/dev/larva/project/blinky/bin/blinky\n$ newt target build blinky\n\n\n\n\n\n\n\nGo to the project directory and download the image to flash ... in a flash! \n\n\n$ cd ~/dev/larva/project/blinky/bin/blinky\n$ newt target download blinky\nDownloading with ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_download.sh\n\n\n\n\n\n\n\nThe LED should be blinking!\n\n\n\n\n\n\nBut wait...let's double check that it is indeed booting from flash and making the LED blink from the image in flash. Pull the USB cable off the Olimex JTAG adaptor. The debug connection to the JTAG port is now severed. Next power off the Olimex board by pulling out the USB cable from the board. Wait for a couple of seconds and plug the USB cable back to the board. \n\n\nThe LED light will start blinking again. Success!\n\n\nNote #1: If you want to download the image to flash and a gdb session opened up, use \nnewt target debug blinky\n instead of \nnewt target download blinky\n.\n\n\n$ newt target debug blinky\nDebugging with ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_debug.sh blinky\nDebugging ~/dev/larva/project/blinky/bin/blinky/blinky.elf\nGNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later \nhttp://gnu.org/licenses/gpl.html\n\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"--host=x86_64-apple-darwin10 --target=arm-none-eabi\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n\nhttp://www.gnu.org/software/gdb/bugs/\n.\nFind the GDB manual and other documentation resources online at:\n\nhttp://www.gnu.org/software/gdb/documentation/\n.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from /Users/aditihilbert/dev/larva/project/blinky/bin/blinky/blinky.elf...done.\nOpen On-Chip Debugger 0.8.0 (2015-09-22-18:21)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.sourceforge.net/doc/doxygen/bugs.html\nInfo : only one transport option; autoselect 'jtag'\nadapter speed: 1000 kHz\nadapter_nsrst_delay: 100\njtag_ntrst_delay: 100\nWarn : target name is deprecated use: 'cortex_m'\nDEPRECATED! use 'cortex_m' not 'cortex_m3'\ncortex_m reset_config sysresetreq\nInfo : clock speed 1000 kHz\nInfo : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\nInfo : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\nInfo : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints\nInfo : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\nInfo : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\ntarget state: halted\ntarget halted due to debug-request, current mode: Thread \nxPSR: 0x01000000 pc: 0x08000250 msp: 0x10010000\nInfo : accepting 'gdb' connection from 3333\nInfo : device id = 0x10036413\nInfo : flash size = 1024kbytes\nReset_Handler () at startup_STM32F40x.s:199\n199     ldr    r1, =__etext\n(gdb)\n\n\n\nNote #2: If you want to erase the flash and load the image again you may use the following commands from within gdb. \nflash erase_sector 0 0 x\n tells it to erase sectors 0 through x. When you ask it to display (in hex notation) the contents of the sector starting at location 'lma' you should therefore see all f's. The memory location 0x8000000 is the start or origin of the flash memory contents and is specified in the olimex_stm32-e407_devboard.ld linker script. The flash memory locations is specific to the processor.\n\n\n(gdb) monitor flash erase_sector 0 0 4\nerased sectors 0 through 4 on flash bank 0 in 2.296712s\n(gdb) x/32wx 0x8000000 \n0x8000000 \n__isr_vector\n:   0xffffffff  0xffffffff 0xffffffff 0xffffffff \n0x8000010 \n__isr_vector+16\n:    0xffffffff 0xffffffff 0xffffffff 0xffffffff\n...", 
            "title": "Blinky, The First Project"
        }, 
        {
            "location": "/chapter1/project1/#blinky-the-first-project", 
            "text": "Objective  We will show you how you can use eggs from a nest on Mynewt to make an LED on a target board blink. We will call it   Project Blinky . The goals of this tutorial are threefold:   First, you will learn how to set up your environment to be ready to use Mynewt OS and newt tool.   Second, we will walk you through a download of eggs for building and testing  on a simulated target  on a non-Windows machine.  Third, you will download eggs and use tools to create a runtime image for a board to  make its LED blink .    If you want to explore even further, you can try to upload the image to the board's flash memory and have it  boot from flash !  What you need   STM32-E407 development board from Olimex.  ARM-USB-TINY-H connector with JTAG interface for debugging ARM microcontrollers (comes with the ribbon cable to hook up to the board)  USB A-B type cable to connect the debugger to your personal computer  Personal Computer   The instructions assume the user is using a Bourne-compatible shell (e.g. bash or zsh) on your computer. You may already have some of the required packages on your machine.  In that \ncase, simply skip the corresponding installation step in the instructions under  Getting your Mac Ready  or  Getting your Ubuntu machine Ready  or  Getting your Windows machine Ready . While the given instructions should work on other versions, they have been tested for the three specific releases of operating systems noted here:   Mac: OS X Yosemite Version 10.10.5  Linux: Ubuntu 14.10 (Utopic Unicorn)  Windows: Windows 10   Getting your Mac Ready  Getting an account on GitHub   Get an account on GitHub. Make sure you have joined the \"Newt Operating System\" organization.   Installing Homebrew to ease installs on OS X    Do you have Homebrew? If not, open a terminal on your Mac and paste the following at a Terminal prompt. It will ask you for your sudo password.  $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"  Alternatively, you can just extract (or  git clone ) Homebrew and install it to  /usr/local .    Creating local repository    The directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:    src contains Go source files organized into packages (one package per directory),    pkg contains package objects, and    bin contains executable commands.    The GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory and then proceed to create the directory for cloning the newt tool repository.  $ cd $HOME\n$ mkdir -p dev/go  \n$ cd dev/go\n$ export GOPATH=`pwd`  Note that you need to add export statements to ~/.bash_profile to export variables permanently.\n    $ vi ~/.bash_profile    The next step is to set up the repository for the package building tool \"newt\" on your local machine. First create the appropriate directory for it and then clone the newt tool repository from the online apache repository (or its github.com mirror) into this newly created directory. Check the installation.  $ mkdir -p $GOPATH/src/github.com/mynewt  \n$ cd $GOPATH/src/github.com/mynewt\n$ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git newt\n$ ls\nnewt\n$ cd newt\n$ ls\nGodeps                  README.md               coding_style.txt        newt.go\nLICENSE                 cli                     design.txt    Installing Go and Godep    Next you will use brew to install go. The summary message at the end of the installation should indicate that it is installed in the /usr/local/Cellar/go/ directory. You will use the go command 'install' to compile and install packages (called eggs in the Mynewt world) and dependencies.   $ brew install go\n==  \n==  \n==  *Summary*\n\ud83c\udf7a  /usr/local/Cellar/go/1.5.1: 5330 files, 273M\n$ cd $GOPATH/src/github.com/mynewt/newt  Alternatively, you can download the go package directly from (https://golang.org/dl/) instead of brewing it. Install it in /usr/local directory.    Now you will get the godep package. Return to the go directory level and get godep. Check for it in the bin subdirectory. Add the go environment to path. Make sure it is added to your .bash_profile.  $ cd $GOPATH\n$ go get github.com/tools/godep\n$ ls\nbin     pkg     src\n$ ls bin\ngodep\n$ export PATH=$PATH:$GOPATH/bin    Use the go command 'install' to compile and install packages and dependencies. In preparation for the install, you may use the godep command 'restore' to check out listed dependency versions in $GOPATH and link all the necessary files. Note that you may have to go to the  ~/dev/go/src/github.com/mynewt/newt  directory to successfully run the restore command (e.g. on certain distributions of Linux). You may also have to do a  go get  before the restore to make sure all the necessary packages and dependencies are correct.  $ cd ~/dev/go/src/github.com/mynewt/newt\n$ go get\n$ ~/dev/go/bin/godep restore\n$ go install    Building the Newt tool   You will now use go to run the newt.go program to build the newt tool. You will have to use  go build  command which compiles and writes the resulting executable to an output file named  newt . However, it does not install the results along with its dependencies in $GOPATH/bin (for that you will need to use  go install ). Now try running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.   Note: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to store the command in a variable in your .bash_profile. So type in  export newt=\"go run $GOPATH/src/github.com/mynewt/newt/newt.go\"  in your .bash_profile and execute it by calling  $newt  at the prompt instead of  newt . Don't forget to reload the updated bash profile by typing  source ~/.bash_profile  at the prompt! Here, you use  go run  which runs the compiled binary directly without producing an executable.      $ go run %GOPATH%/src/github.com/mynewt/newt/newt.go\n    $ cd ~/dev/go/src/github.com/mynewt/newt\n    $ ls\n    Godeps          README.md       coding_style.txt    newt\n    LICENSE         cli         design.txt      newt.go\n    $ newt version\n    Newt version:  1.0\n    $ newt -h\n    Newt allows you to create your own embedded project based on the Mynewt\n    operating system. Newt provides both build and package management in a\n    single tool, which allows you to compose an embedded workspace, and set\n    of projects, and then build the necessary artifacts from those projects.\n    For more information on the Mynewt operating system, please visit\n    https://www.github.com/mynewt/documentation.\n\n    Please use the newt help command, and specify the name of the command\n    you want help for, for help on how to use a specific command\n\n    Usage:\n     newt [flags]\n     newt [command]\n\n    Examples:\n     newt\n     newt help [ command-name ]\n       For help on  command-name .  If not specified, print this message.\n\n\n    Available Commands:\n     version     Display the Newt version number.\n     target      Set and view target information\n     egg         Commands to list and inspect eggs on a nest\n     nest        Commands to manage nests   clutches (remote egg repositories)\n     help        Help about any command\n\n    Flags:\n     -h, --help=false: help for newt\n     -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n     -q, --quiet=false: Be quiet; only display error output.\n     -s, --silent=false: Be silent; don't output anything.\n     -v, --verbose=false: Enable verbose output when executing commands.\n\n\n    Use \"newt help [command]\" for more information about a command.   Without creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool.    Getting the debugger ready    Before you start building nests and hatching eggs, you need to do one final step in the environment preparation - install gcc / libc that can produce 32-bit executables. So, first install gcc. You will see the brew steps and a final summary confirming install.  $ brew install gcc\n...\n...\n==  Summary\n\ud83c\udf7a  /usr/local/Cellar/gcc/5.2.0: 1353 files, 248M    ARM maintains a pre-built GNU toolchain with a GCC source branch targeted at Embedded ARM Processors namely Cortex-R/Cortex-M processor families. Install the PX4 Toolchain and check the version installed. Make sure that the symbolic link installed by Homebrew points to the correct version of the debugger. If not, you can either change the symbolic link using the \"ln -f -s\" command or just go ahead and try with the version it points to!  $ brew tap PX4/homebrew-px4\n$ brew update\n$ brew install gcc-arm-none-eabi-49\n$ arm-none-eabi-gcc --version  \narm-none-eabi-gcc (GNU Tools for ARM Embedded Processors) 4.9.3 20150529 (release) [ARM/embedded-4_9-branch revision 224288]\nCopyright (C) 2014 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n$ ls -al /usr/local/bin/arm-none-eabi-gdb\nlrwxr-xr-x  1 aditihilbert  admin  69 Sep 22 17:16 /usr/local/bin/arm-none-eabi-gdb -  /usr/local/Cellar/gcc-arm-none-eabi-49/20150609/bin/arm-none-eabi-gdb  Note: If no version is specified, brew will install the latest version available. StackOS will eventually work with multiple versions available including the latest releases. However, at present we have tested only with this version and recommend it for getting started.     You have to install OpenOCD (Open On-Chip Debugger) which is an open-source software that will allow you to interface with the JTAG debug connector/adaptor for the Olimex board. It lets you program, debug, and test embedded target devices which, in this case, is the Olimex board. Use brew to install it. Brew adds a simlink /usr/local/bin/openocd to the openocd directory in the Cellar.  $ brew install open-ocd\n$ which openocd\n/usr/local/bin/openocd\n$ ls -l $(which openocd)\nlrwxr-xr-x  1  user   admin  36 Sep 17 16:22 /usr/local/bin/openocd -  ../Cellar/open-ocd/0.9.0/bin/openocd    Proceed to the  Building test code on simulator  section.    Getting your Ubuntu machine Ready  Getting an account on GitHub   Get an account on GitHub. Make sure you have joined the \"Newt Operating System\" organization.   Installing some prerequisites   Install git, libcurl, and the go language if you do not have them already. $ sudo apt-get install git \n$ sudo apt-get install libcurl4-gnutls-dev \n$ sudo apt-get install golang    Creating local repository    The directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:    src contains Go source files organized into packages (one package per directory),    pkg contains package objects, and    bin contains executable commands.    The GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory and then proceed to create the directory for cloning the newt tool repository.  $ cd $HOME\n$ mkdir -p dev/go  \n$ cd dev/go\n$ export GOPATH=$PWD  Note that you need to add export statements to ~/.bashrc (or equivalent) to export variables permanently.    Next, install godep. Note that the following command produces no output.  $ go get github.com/tools/godep    Set up the repository for the package building tool \"newt\" on your local machine. First create the appropriate directory for it and then clone the newt tool repository from the online apache repository (or its github.com mirror) into this newly created directory. Check the contents of the directory.  $ mkdir -p $GOPATH/src/github.com/mynewt  \n$ cd $GOPATH/src/github.com/mynewt\n$ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git newt\n$ ls\nnewt\n$ cd newt\n$ ls\nGodeps                  README.md               coding_style.txt        newt.go\nLICENSE                 cli                     design.txt    Use the go command 'install' to compile and install packages and dependencies. Add go environment to path. Again, to make the export variable permanent, add it to your ~/.bashrc (or equivalent) file.  $ $GOPATH/bin/godep restore \n$ go get \n$ go install \n$ export PATH=$PATH:$GOPATH/bin    Building the newt tool   You will now use go to run the newt.go program to build the newt tool. You will have to use  go build  command which compiles and writes the resulting executable to an output file named  newt . However, it does not install the results along with its dependencies in $GOPATH/bin (for that you will need to use  go install ). Now try running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.   Note: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to store the command in a variable in your .bash_profile. So type in  export newt=\"go run $GOPATH/src/github.com/mynewt/newt/newt.go\"  in your ~/.bashrc (or equivalent) and execute it by calling  $newt  at the prompt instead of  newt . Here, you use  go run  which runs the compiled binary directly without producing an executable.      $ go build %GOPATH%/src/github.com/mynewt/newt/newt.go\n    $ cd ~/dev/go/src/github.com/mynewt/newt\n    $ ls\n    Godeps          README.md       coding_style.txt    newt\n    LICENSE         cli         design.txt      newt.go\n    $ newt version\n    Newt version:  1.0\n    $ newt -h\n    Newt allows you to create your own embedded project based on the Mynewt\n    operating system. Newt provides both build and package management in a\n    single tool, which allows you to compose an embedded workspace, and set\n    of projects, and then build the necessary artifacts from those projects.\n    For more information on the Mynewt operating system, please visit\n    https://www.github.com/mynewt/documentation.\n\n    Please use the newt help command, and specify the name of the command\n    you want help for, for help on how to use a specific command\n\n    Usage:\n     newt [flags]\n     newt [command]\n\n    Examples:\n     newt\n     newt help [ command-name ]\n       For help on  command-name .  If not specified, print this message.\n\n\n    Available Commands:\n     version     Display the Newt version number.\n     target      Set and view target information\n     egg         Commands to list and inspect eggs on a nest\n     nest        Commands to manage nests   clutches (remote egg repositories)\n     help        Help about any command\n\n    Flags:\n     -h, --help=false: help for newt\n     -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n     -q, --quiet=false: Be quiet; only display error output.\n     -s, --silent=false: Be silent; don't output anything.\n     -v, --verbose=false: Enable verbose output when executing commands.\n\n\n    Use \"newt help [command]\" for more information about a command.   Without creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool.    Getting the debugger ready    Before you start building nests and hatching eggs, you need to do one final step in the environment preparation - install gcc / libc that can produce 32-bit executables. You can install these as follows:   $ sudo apt-get install gcc-multilib libc6-i386    For the LED project on the Olimex hardware, you have to install gcc for AM 4.9.3.  This package can be installed with apt-get as documented  here .  $ sudo apt-get remove binutils-arm-none-eabi gcc-arm-none-eabi \n$ sudo add-apt-repository ppa:terry.guo/gcc-arm-embedded \n$ sudo apt-get update \n$ sudo apt-get install gcc-arm-none-eabi    And finally, you have to install OpenOCD (Open On-Chip Debugger) which is an open-source software that will allow you to interface with the JTAG debug connector/adaptor for the Olimex board. It lets you program, debug, and test embedded target devices which, in this case, is the Olimex board. You have to acquire OpenOCD 0.8.0.   If you are running Ubuntu 15.x, then you are in luck and you can simply run:   $ sudo apt-get install openocd  Other versions of Ubuntu may not have the correct version of openocd available.  In this case, you should download the openocd 0.8.0 package from  https://launchpad.net/ubuntu/vivid/+source/openocd . The direct link to the amd64 build is  http://launchpadlibrarian.net/188260097/openocd_0.8.0-4_amd64.deb .     Proceed to the  Building test code on simulator  section.    Getting your Windows machine Ready  Getting an account on GitHub   Get an account on GitHub. Make sure you have joined the \"Newt Operating System\" organization.   Installing some prerequisites    You have to install the following if you do not have them already.  The steps below indicate specific folders where each of these programs should be installed. You can choose different locations, but the remainder of this\ntutorial for a Windows machine assumes the specified folders.       win-builds-i686  win-builds-x86_64  MSYS  gcc for ARM  openocd  zadig  git   go   win-builds (mingw64) 1.5 for i686   Download from  http://win-builds.org/doku.php/download_and_installation_from_windows . Install at: \"C:\\win-builds-i686\".  Be sure to click the i686 option (not x86_64). The defaults for all other options are OK. The installer will want to download a bunch of additional packages. They are not all necessary, but it is simplest to just accept the defaults.   win-builds (mingw64) 1.5 for x86_64   Download from  http://win-builds.org/doku.php/download_and_installation_from_windows . Install at \"C:\\win-builds-x86_64\"  Run the installer a second time, but this time click the x86_64 option, NOT i686.  The defaults for all other options are OK.   MSYS   Start your download from  http://sourceforge.net/projects/mingw-w64/files/External%20binary%20packages%20%28Win64%20hosted%29/MSYS%20%2832-bit%29/MSYS-20111123.zip  Unzip to \"C:\\msys\"   gcc for ARM, 4.9.3   Download the Windows installer from  https://launchpad.net/gcc-arm-embedded/+download  and install at \"C:\\Program Files (x86)\\GNU Tools ARM Embedded\\4.9 2015q3\".   OpenOCD 0.8.0   Download OpenOCD 0.8.0 from  http://www.freddiechopin.info/en/download/category/4-openocd . Unzip to \"C:\\openocd\".   Zadig 2.1.2   Download it from  http://zadig.akeo.ie  and install it at \"C:\\zadig\".   Git   Click on  https://git-scm.com/download/win  to start the download. Install at \"C:\\Program Files (x86)\\Git\". Specify the \"Use Git from the Windows Command Prompt\" option.  The defaults for all other options are OK.   Go   Download the release for Microsoft Windows from  https://golang.org/dl/  and install it \"C:\\Go\".      Creating local repository    The directory structure must be first readied for using Go. Go code must be kept inside a workspace. A workspace is a directory hierarchy with three directories at its root:    src contains Go source files organized into packages (one package per directory),    pkg contains package objects, and    bin contains executable commands.    The GOPATH environment variable specifies the location of your workspace. First create a 'dev' directory and then a 'go' directory under it. Set the GOPATH environment variable to this directory and then proceed to create the directory for cloning the newt tool repository.  $ cd c:\\\n$ mkdir dev\\go\n$ cd dev\\go    Set the following user environment variables using the steps outlined here.   GOPATH: C:\\dev\\go  PATH: C:\\Program Files (x86)\\GNU Tools ARM Embedded\\4.9 2015q3\\bin;%GOPATH%\\bin;C:\\win-builds-x86_64\\bin;C:\\win-builds-i686\\bin;C:\\msys\\bin   Steps:   Right-click the start button  Click \"Control panel\"  Click \"System and Security\"  Click \"System\"  Click \"Advanced system settings\" in the left panel  Click the \"Envoronment Variables...\" button  There will be two sets of environment variables: user variables\n  in the upper half of the screen, and system variables in the lower\n  half.  Configuring the user variables is recommended and tested \n  (though system variables will work as well).     Next, install godep. Note that the following command produces no output.  $ go get github.com/tools/godep    Set up the repository for the package building tool \"newt\" on your local machine. First create the appropriate directory for it and then clone the newt tool repository from the online apache repository (or its github.com mirror) into this newly created directory. Check the contents of the directory.  $ mkdir %GOPATH%\\src\\github.com\\mynewt\n$ cd %GOPATH%\\src\\github.com\\mynewt\n$ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-newt.git newt\n$ ls\nnewt\n$ cd newt\n$ ls\nGodeps                  README.md               coding_style.txt        newt.go\nLICENSE                 cli                     design.txt    Use the go command 'install' to compile and install packages and dependencies. Add go environment to path. Again, to make the export variable permanent, add it to your ~/.bashrc (or equivalent) file.  $ %GOPATH%\\bin\\godep restore \n$ go get \n$ go install    Building the newt tool    You will now use go to run the newt.go program to build the newt tool. You will have to use  go build  command which compiles and writes the resulting executable to an output file named  newt . However, it does not install the results along with its dependencies in $GOPATH/bin (for that you will need to use  go install ). Now try running newt using the compiled binary. For example, check for the version number by typing 'newt version'. See all the possible commands available to a user of newt by typing 'newt -h'.  Note: If you are going to be be modifying the newt tool itself often and wish to compile the program every time you call it, you may want to define the newt environment variable that allows you to execute the command via  %newt% . Use  set newt=go run %GOPATH%\\src\\github.com\\mynewt\\newt\\newt.go  or set it from the GUI. Here, you use  go run  which runs the compiled binary directly without producing an executable.  $ go build %GOPATH%\\src\\github.com\\mynewt\\newt\\newt.go\n$ cd ~/dev/go/src/github.com/mynewt/newt\n$ dir\nGodeps          README.md       coding_style.txt    newt\nLICENSE         cli         design.txt      newt.go\n$ newt version\nNewt version:  1.0\n$ newt -h\nNewt allows you to create your own embedded project based on the Mynewt\noperating system. Newt provides both build and package management in a\nsingle tool, which allows you to compose an embedded workspace, and set\nof projects, and then build the necessary artifacts from those projects.\nFor more information on the Mynewt operating system, please visit\nhttps://www.github.com/mynewt/documentation.\n\nPlease use the newt help command, and specify the name of the command\nyou want help for, for help on how to use a specific command\n\nUsage:\n newt [flags]\n newt [command]\n\nExamples:\n newt\n newt help [ command-name ]\n   For help on  command-name .  If not specified, print this message.\n\nAvailable Commands:\n version     Display the Newt version number.\n target      Set and view target information\n egg         Commands to list and inspect eggs on a nest\n nest        Commands to manage nests   clutches (remote egg repositories)\n help        Help about any command\n\nFlags:\n -h, --help=false: help for newt\n -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n -q, --quiet=false: Be quiet; only display error output.\n -s, --silent=false: Be silent; don't output anything.\n -v, --verbose=false: Enable verbose output when executing commands.\n\nUse \"newt help [command]\" for more information about a command.    Without creating a project repository you can't do a whole lot with the Newt tool. So you'll have to wait till you have downloaded a nest to try out the tool.     Getting the debugger ready    Use Zadig to configure the USB driver for your Olimex debugger.  If your debugger is already set up, you can skip this step.   Plug in your Olimex debugger.  Start Zadig.  Check the Options -  List All Devices checkbox.  Select \"Olimex OpenOCD JTAG ARM-USB-TINY-H\" in the dropdown menu.  Select the \"WinUSB\" driver.  Click the \"Install Driver\" button.     Proceed to the  Building test code on simulator on Windows machine  section.  Note: Currently, the simulator cannot be run in the Windows machine. We are still working on it. So you will go ahead and  make an LED blink  on the Olimex hardware directly.   However, before you skip to the hardware target, you still need to build your first nest as outlined in step 1 in the  Building test code on simulator .  Building test code on simulator  Note: Currently, the simulator cannot be run in the Windows machine. We are working on it. If you are on a Windows machine, do step 1 below and then proceed to the  Making an LED blink  on the Olimex hardware directly.    First, you have to create a repository for the project i.e. build your first nest! Go to ~/dev and clone the larva repository from the apache git repository into a local directory named  larva .  Substitute DOS commands for Unix commands as necessary in the following steps if your machine is running Windows. The newt tool commands do not change.  $ cd ~/dev \n$ git clone https://git-wip-us.apache.org/repos/asf/incubator-mynewt-larva.git larva\n$ ls\ngo  larva\n$ cd larva\n$ ls\nLICENSE     clutch.yml  hw      nest.yml      project\nREADME.md   compiler    libs        net       scripts    You will now create a new target using the newt tool. You can either use the compiled binary  newt  or run the newt.go program using  $newt  (assuming you have stored the command in a variable in your .bash_profile or .bashrc). When you do a  newt target show  or  $newt target show  it should list all the projects you have created so far.   $ newt target create sim_test\nCreating target sim_test\nTarget sim_test sucessfully created!\n$ newt target show\nsim_test\n    name: sim_test\n    arch: sim    Now continue to populate and build out the sim project.  $ newt target set sim_test project=test\nTarget sim_test successfully set project to test\n$ newt target set sim_test compiler_def=debug\nTarget sim_test successfully set compiler_def to debug\n$ newt target set sim_test bsp=hw/bsp/native\nTarget sim_test successfully set bsp to hw/bsp/native\n$ newt target set sim_test compiler=sim\nTarget sim_test successfully set compiler to sim\n$ newt target show sim_test\nsim_test\n    arch: sim\n    project: test\n    compiler_def: debug\n    bsp: hw/bsp/native\n    compiler: sim\n    name: sim_test    Configure newt to use the gnu build tools native to OS X or linux. In order for sim to work properly, it needs to be using 32-bit gcc (gcc-5). Replace \n~/dev/larva/compiler/sim/compiler.yml with the compiler/sim/osx-compiler.yml or linux-compiler.yml file, depending on the system.   For a Mac OS X environment:  $ cp compiler/sim/osx-compiler.yml compiler/sim/compiler.yml  For a Linux machine:  $ cp compiler/sim/linux-compiler.yml compiler/sim/compiler.yml    Next, create (hatch!) the eggs for this project using the newt tool - basically, build the packages for it. You can specify the VERBOSE option if you want to see the gory details.   $ $newt target build sim_test\nSuccessfully run!  You can specify the VERBOSE option if you want to see the gory details.  $newt -l VERBOSE target build sim_test\n2015/09/29 09:46:12 [INFO] Building project test\n2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//bootutil...\n2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//cmsis-core...\n2015/09/29 09:46:12 [INFO] Loading Package /Users/aditihilbert/dev/larva/libs//ffs..\n...\nSuccessfully run!    Try running the test suite executable inside this project and enjoy your first successful hatch.  $ ./project/test/bin/sim_test/test.elf\n[pass] os_mempool_test_suite/os_mempool_test_case\n[pass] os_mutex_test_suite/os_mutex_test_basic\n[pass] os_mutex_test_suite/os_mutex_test_case_1\n[pass] os_mutex_test_suite/os_mutex_test_case_2\n[pass] os_sem_test_suite/os_sem_test_basic\n[pass] os_sem_test_suite/os_sem_test_case_1\n[pass] os_sem_test_suite/os_sem_test_case_2\n[pass] os_sem_test_suite/os_sem_test_case_3\n[pass] os_sem_test_suite/os_sem_test_case_4\n[pass] os_mbuf_test_suite/os_mbuf_test_case_1\n[pass] os_mbuf_test_suite/os_mbuf_test_case_2\n[pass] os_mbuf_test_suite/os_mbuf_test_case_3\n[pass] gen_1_1/ffs_test_unlink\n[pass] gen_1_1/ffs_test_rename\n[pass] gen_1_1/ffs_test_truncate\n[pass] gen_1_1/ffs_test_append\n[pass] gen_1_1/ffs_test_read\n[pass] gen_1_1/ffs_test_overwrite_one\n[pass] gen_1_1/ffs_test_overwrite_two\n[pass] gen_1_1/ffs_test_overwrite_three\n...\n...\n[pass] boot_test_main/boot_test_vb_ns_11    Building test code on simulator on Windows machine  Coming soon.  Making an LED blink  Preparing the Software    Make sure the PATH environment variable includes the $HOME/dev/go/bin directory (or C:\\%GOPATH%\\bin on Windows machine).   Substitute DOS commands for Unix commands as necessary in the following steps if your machine is running Windows. The newt tool commands do not change.    You first have to create a repository for the project. Go to the ~dev/larva directory and build out a second project inside larva. The project name is \"blinky\", in keeping with the objective. Starting with the target name, you have to specify the different aspects of the project to pull the appropriate eggs and build the right package for the board. In this case that means setting the architecture (arch), compiler, board support package (bsp), project, and compiler mode.  $ newt target create blinky\nCreating target blinky\nTarget blinky sucessfully created!\n$ newt target set blinky arch=cortex_m4\nTarget blinky successfully set arch to arm\n$ newt target set blinky compiler=arm-none-eabi-m4\nTarget blinky successfully set compiler to arm-none-eabi-m4\n$ newt target set blinky project=blinky\nTarget blinky successfully set project to blinky\n$ newt target set blinky compiler_def=debug\nTarget blinky successfully set compiler_def to debug\n$ newt target set blinky bsp=hw/bsp/olimex_stm32-e407_devboard\nTarget blinky successfully set bsp to hw/bsp/olimex_stm32-e407_devboard\n$ newt target show blinky\nblinky\n    compiler: arm-none-eabi-m4\n    project: blinky\n    compiler_def: debug\n    bsp: hw/bsp/olimex_stm32-e407_devboard\n    name: blinky\n    arch: cortex_m4    Now you have to build the image. The linker script within the  hw/bsp/olimex_stm32-e407_devboard  egg builds an image for flash memory by default. Therefore, you need to switch that script with  run_from_sram.ld  in order to get the egg to produce an image for SRAM.   We are working on making it easier to specify where the executable will be run from for a particular project and automatically choose the correct linker scripts and generate the appropriate image. It will be specified as a project identity e.g. bootloader, RAM, flash (default) and the target will build accordingly.  .   Once the target is built, you can find the executable \"blinky.elf\" in the project directory at ~/dev/larva/project/blinky/bin/blinky. It's a good idea to take a little time to understand the directory structure.  $ cd ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n$ diff olimex_stm32-e407_devboard.ld run_from_sram.ld\n$ cp run_from_sram.ld olimex_stm32-e407_devboard.ld\n$ cd ~/dev/larva/project/blinky/bin/blinky\n$ newt target build blinky\nBuilding target blinky (project = blinky)\nCompiling case.c\nCompiling suite.c\n...\nSuccessfully run!\n$ ls\nLICENSE     clutch.yml  hw      nest.yml    project\nREADME.md   compiler    libs        net     scripts\n$ cd project\n$ ls\nbin2img     bletest     blinky      boot        ffs2native  test\n$ cd blinky\n$ ls\nbin     blinky.yml  egg.yml     src\n$ cd bin\n$ ls\nblinky\n$ cd blinky\n$ ls\nblinky.elf  blinky.elf.bin  blinky.elf.cmd  blinky.elf.lst  blinky.elf.map    Check that you have all the scripts needed to get OpenOCD up and talking with the project's specific hardware. Check whether you already have the scripts in your  /usr/share/openocd/scripts/  directory as they may have been part of the openocd download. If yes, you are all set and can proceed to preparing the hardware. If not, continue with this step.  Currently, the following 5 files are required. They are likely to be packed into a .tar file and made available under mynewt on github.com. Unpack it in the blinky directory using  tar xvfz  command. Go into the openocd directory created and make sure that the gdb-8888.cfg file indicates the correct file ('blinky.elf' in this case) to load and its full path. Specifically, add 'load ~/dev/larva/project/main/bin/blink/main.elf' and 'symbol-file ~/larva/larva/project/main/bin/blink/main.elf' to this file. Alternatively, you could load these files from within the debugger (gdb) as explained later in the project when you connect to the board using openocd.      ocd-8888.cfg  olimex-arm-usb-tiny-h-ftdi.cfg  arm-gdb.cfg  gdb-dev_test-8888.cfg  stm32f4x.cfg     Check the arm-gdb.cfg file and see whether the executable you created in the previous step is specified as the file to be loaded to the board. You have the choice of specifying the target and load from within the gdb debugger (Section \"Let's Go\", Step 2) instead.  $ cat gdb-8888.cfg\necho \\n*** Set target charset ASCII\\n\nset target-charset ASCII\n#set arm fallback-mode arm\n#echo \\n*** set arm fallback-mode arm ***\\n\necho \\n*** Connecting to OpenOCD over port #8888 ***\\n\ntarget remote localhost:8888\necho \\n*** loading nic.out.elf ***\\n\nload ~/dev/larva/project/main/bin/blink/main.elf\nsymbol-file ~/dev/larva/project/main/bin/blink/main.elf \n#echo *** Set breakpoint and run to main() to sync with gdb ***\\n\n#b main\n#continue\n#delete 1\n\n#set arm fallback-mode thumb\n#echo \\n*** set arm fallback-mode thumb ***\\n\\n  Note that an OpenOCD configuration script is available from Olimex for the STM32-E407 development board e.g. at  https://www.olimex.com/Products/ARM/ST/STM32-E407/resources/stm32f4x.cfg , however getting it to work with different versions of OpenOCD and gcc could get tricky. [ This will be simplified eventually into a consolidated single action step instead of manual tweaks currently required ]    Preparing the hardware to boot from embedded SRAM    Locate the boot jumpers on the board.     B1_1/B1_0 and B0_1/B0_0 are PTH jumpers which can be moved relatively easy. Note that the markings on the board may not always be accurate. Always refer to the manual for the correct positioning of jumpers in case of doubt. The two jumpers must always be moved together \u2013 they are responsible for the boot mode if bootloader is present. The board can search for bootloader on three places \u2013 User Flash Memory, System Memory or the Embedded SRAM. We will configure it to boot from SRAM by jumpering B0_1 and B1_1.    Connect USB-OTG#2 in the picture above to a USB port on your computer (or a powered USB hub to make sure there is enough power available to the board).     Connect the JTAG connector to the SWD/JTAG interface on the board. The other end of the cable should be connected to the USB port or hub of your computer.    The red PWR LED should be lit.     Let's Go!    Go into the openocd directory and start an OCD session. You should see some status messages are shown below. Check the value of the msp (main service pointer) register. If it is not 0x10010000 as indicated below, you will have to manually set it after you open the gdp tool to load the image on it (next step). Note the  -c \"reset halt\"  flag that tells it to halt after opening the session. It will now require a manual \"continue\" command from the GNU debugger in step 3.   $ cd ~/dev/larva/project/blinky/bin/blinky/openocd\n$ openocd -f olimex-arm-usb-tiny-h-ftdi.cfg -f ocd-8888.cfg -f stm32f4x.cfg -c \"reset halt\" \nOpen On-Chip Debugger 0.8.0 (2015-09-22-18:21)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.sourceforge.net/doc/doxygen/bugs.html\nInfo : only one transport option; autoselect 'jtag'\nadapter speed: 1000 kHz\nadapter_nsrst_assert_width: 500\nadapter_nsrst_delay: 100\njtag_ntrst_delay: 100\ncortex_m reset_config sysresetreq\nInfo : clock speed 1000 kHz\nInfo : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\nInfo : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\nInfo : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints\nInfo : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\nInfo : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\ntarget state: halted\ntarget halted due to debug-request, current mode: Thread \nxPSR: 0x01000000 pc: 0x2000053c msp: 0x10010000  If your scripts are in  /usr/share/openocd/scripts/  directory you may need to provide the full path information in the arguments.  $ openocd -f /usr/share/openocd/scripts/interface/ftdi/olimex-arm-usb-tiny-h.cfg -f /usr/share/openocd/scripts/target/stm32f4x.cfg -c \"gdb_port 8888; init; reset halt\"  If you are on a Windows machine, connect to the board with openocd using the following:  $ cd C:\\openocd\n$ bin\\openocd-0.8.0.exe -f scripts\\interface\\ftdi\\olimex-arm-usb-tiny-h.cfg -f scripts\\target\\stm32f4x.cfg -c \"gdb_port 8888; init; reset halt\"    Open a new terminal window and run the GNU debugger for ARM. Specifying the script gdb-8888.cfg tells it what image to load. You should now have a (gdb) prompt inside the debugger.  $ cd ~/dev/larva/project/blinky/bin/blinky/openocd\n$ arm-none-eabi-gdb -x gdb-8888.cfg \nGNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later  http://gnu.org/licenses/gpl.html \nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"--host=x86_64-apple-darwin10 --target=arm-none-eabi\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see: http://www.gnu.org/software/gdb/bugs/ .\nFind the GDB manual and other documentation resources online at: http://www.gnu.org/software/gdb/documentation/ .\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n\n*** Set target charset ASCII\n\n*** Connecting to OpenOCD over port #8888 ***\n0x20000580 in ?? ()\n\n*** loading image ***\nLoading section .text, size 0x65d4 lma 0x20000000\nLoading section .ARM.extab, size 0x24 lma 0x200065dc\nLoading section .ARM.exidx, size 0xd8 lma 0x20006600\nLoading section .data, size 0x8f8 lma 0x200066d8\nStart address 0x2000053c, load size 28624\nTransfer rate: 78 KB/sec, 2862 bytes/write.\n(gdb)  Instead of the script, you could connect to the openocd process and tell the debugger what image to load from within gdb (which is 'blinky.elf' in this case). Below is an example input/output when doing it on a Windows machine. Note the forward slashes.  C:\\dev\\larva arm-none-eabi-gdb -q\n(gdb) target remote localhost:8888\nRemote debugging using localhost:8888\n0xb064f054 in ?? ()\n...\n(gdb) load C:/dev/larva/project/blinky/bin/blinky/blinky.elf\nLoading section .text, size 0x6778 lma 0x20000000\nLoading section .ARM.extab, size 0x18 lma 0x20006778\nLoading section .ARM.exidx, size 0xc8 lma 0x20006790\nLoading section .data, size 0x8f8 lma 0x20006858\nStart address 0x20000528, load size 29008\nTransfer rate: 72 KB/sec, 2900 bytes/write.\n(gdb) symbol-file C:/dev/larva/project/blinky/bin/blinky/blinky.elf\nReading symbols from C:/dev/larva/project/blinky/bin/blinky/blinky.elf...done.    From within gdb check the registers. Set the msp register for the main stack pointer to the expected value as shown here.   Finally, hit  c  to continue... and your green LED should blink!  (gdb) info reg all\n r0             0x0 0\n r1             0x0 0\n r2             0x0 0\n r3             0x0 0\n r4             0x0 0\n r5             0x0 0\n r6             0x0 0\n r7             0x0 0\n r8             0x0 0\n r9             0x0 0\n r10            0x0 0\n r11            0x0 0\n r12            0x0 0\n sp             0x10010000  0x10010000\n lr             0xffffffff  -1\n pc             0x20000580  0x20000580  Reset_Handler \n xPSR           0x1000000   16777216\n msp            0x10010000  0x10010000\n psp            0x0 0x0\n primask        0x0 0\n basepri        0x0 0\n faultmask      0x0 0\n control        0x0 0\n (gdb) set $msp=0x10010000\n (gdb) c\n Continuing.    Voil\u00e0! The board's LED should be blinking at 1 Hz.    Using flash to make LED blink   Configure the board to boot from flash by moving the two jumpers together to B0_0 and B1_0.    You will have to reset the board once the image is uploaded to it.    By now you know that you have to build a new package that will run from flash. First, the olimex_stm32-e407_devboard.ld linker script which was previously made the same as run_from_sram.ld will now need the contents of run_from_flash.ld. Then the target has to be rebuilt.   $ cd ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard\n$ diff olimex_stm32-e407_devboard.ld run_from_sram.ld\n$ cp run_from_flash.ld olimex_stm32-e407_devboard.ld\n$ cd ~/dev/larva/project/blinky/bin/blinky\n$ newt target build blinky    Go to the project directory and download the image to flash ... in a flash!   $ cd ~/dev/larva/project/blinky/bin/blinky\n$ newt target download blinky\nDownloading with ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_download.sh    The LED should be blinking!    But wait...let's double check that it is indeed booting from flash and making the LED blink from the image in flash. Pull the USB cable off the Olimex JTAG adaptor. The debug connection to the JTAG port is now severed. Next power off the Olimex board by pulling out the USB cable from the board. Wait for a couple of seconds and plug the USB cable back to the board.   The LED light will start blinking again. Success!  Note #1: If you want to download the image to flash and a gdb session opened up, use  newt target debug blinky  instead of  newt target download blinky .  $ newt target debug blinky\nDebugging with ~/dev/larva/hw/bsp/olimex_stm32-e407_devboard/olimex_stm32-e407_devboard_debug.sh blinky\nDebugging ~/dev/larva/project/blinky/bin/blinky/blinky.elf\nGNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later  http://gnu.org/licenses/gpl.html \nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"--host=x86_64-apple-darwin10 --target=arm-none-eabi\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see: http://www.gnu.org/software/gdb/bugs/ .\nFind the GDB manual and other documentation resources online at: http://www.gnu.org/software/gdb/documentation/ .\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from /Users/aditihilbert/dev/larva/project/blinky/bin/blinky/blinky.elf...done.\nOpen On-Chip Debugger 0.8.0 (2015-09-22-18:21)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.sourceforge.net/doc/doxygen/bugs.html\nInfo : only one transport option; autoselect 'jtag'\nadapter speed: 1000 kHz\nadapter_nsrst_delay: 100\njtag_ntrst_delay: 100\nWarn : target name is deprecated use: 'cortex_m'\nDEPRECATED! use 'cortex_m' not 'cortex_m3'\ncortex_m reset_config sysresetreq\nInfo : clock speed 1000 kHz\nInfo : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\nInfo : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\nInfo : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints\nInfo : JTAG tap: stm32f4x.cpu tap/device found: 0x4ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x4)\nInfo : JTAG tap: stm32f4x.bs tap/device found: 0x06413041 (mfg: 0x020, part: 0x6413, ver: 0x0)\ntarget state: halted\ntarget halted due to debug-request, current mode: Thread \nxPSR: 0x01000000 pc: 0x08000250 msp: 0x10010000\nInfo : accepting 'gdb' connection from 3333\nInfo : device id = 0x10036413\nInfo : flash size = 1024kbytes\nReset_Handler () at startup_STM32F40x.s:199\n199     ldr    r1, =__etext\n(gdb)  Note #2: If you want to erase the flash and load the image again you may use the following commands from within gdb.  flash erase_sector 0 0 x  tells it to erase sectors 0 through x. When you ask it to display (in hex notation) the contents of the sector starting at location 'lma' you should therefore see all f's. The memory location 0x8000000 is the start or origin of the flash memory contents and is specified in the olimex_stm32-e407_devboard.ld linker script. The flash memory locations is specific to the processor.  (gdb) monitor flash erase_sector 0 0 4\nerased sectors 0 through 4 on flash bank 0 in 2.296712s\n(gdb) x/32wx 0x8000000 \n0x8000000  __isr_vector :   0xffffffff  0xffffffff 0xffffffff 0xffffffff \n0x8000010  __isr_vector+16 :    0xffffffff 0xffffffff 0xffffffff 0xffffffff\n...", 
            "title": "Blinky, the First Project"
        }, 
        {
            "location": "/chapter2/vocabulary/", 
            "text": "Understanding Newt Terms\n\n\nNest\n\n\nThe nest is the base directory of your embedded software. It is meant to be the workspace containing a logical collection of the source code for one or more of your projects. A nest can contain multiple projects, and reflect multiple end products. \n\n\nAs the base repository of your source code, the nest has a master branch and several other branches off it. You may choose any branch to nest on. Each project in your nest will typically consist of several \neggs\n. A project could be an egg itself as well. In addition to eggs, a local nest will contain additional items such as \ntarget\n or build definitions, clutch description files, scripts etc.\n\n\nFor example, a walk through the \"larva\" nest at \nhttps://github.com/mynewt/larva.git\n shows the following structure. The nest.yml file in the larva directory indicates that it is a nest. An egg will have the egg.yml file in it as shown below. By this nomenclature, each board support package for a particular chip is an egg, the API for the hardware abstraction layer is an egg, and so on. \n\n\nlarva\n  |- nest.yml \n  |- compiler\n        |- arm-none-eabi-m4\n        |- sim\n  |- hw (hardware)\n        |- bsp (board support package)\n                |- nrf52pdk (Nordic nRF52 series chip)\n                        |- egg.yml\n                        |- ...\n                |- olimex_stm32-e407_devboard (used in chapter1 project)\n                        |- egg.yml\n                        |- ...\n                |- stm32f3discovery (another board with stm32f3 mcu)\n                        |- egg.yml\n                        |- ...\n                |- yet another board\n                        |- egg.yml\n                        |- ...\n        |- hal (hardware abstraction layer APIs)\n                |- egg.yml\n                |- include\n                        |- hal_cputime.h\n                        |- hal_flash.h\n                        |- hal_gpio.h\n                        |- ... (header files for other peripherals)\n        |- mcu (microcontroller)\n                |- stm (STMicro family)\n                    |- stm32f3xx (STM32f3 series, 32-bit ARM Cortex-M4  core)\n                        |- egg.yml\n                        |- src\n                            |- hal_gpio.c (specific to the STM32f3 mcu)\n                            |- hal_cputime.c\n                            |- ... (code for other peripherals)\n                |- nordic (Nordic Semiconductor family)\n                    |- nrf52xxx (nRF52 Series SoC, Cortex-M4F core)\n                        |- egg.yml\n                        |- src\n                            |- hal_gpio.c (specific to the nRF52 mcu )\n                            |- hal_cputime.c\n                            |- ... (code for other peripherals)\n                |- yet another family of mcu\n                    |- ...\n  |- libs\n        |- bootutil (hw architecture independent boot loader library)\n                |- egg.yml\n                |- src\n                    |- loader.c\n                    |- ... (related source code files)\n        |- nffs (hw architecture independent Newtron Flash File System)\n                |- egg.yml\n                |- src\n                    |- nffs.c\n                    |- ... (related source code files)\n        |- another library \n                |- egg.yml\n                |- src\n                    |- ... (related source code files)\n  |- project\n  |- scripts\n\n\n\n\n\n\nThe newt tool offers the \nnest\n command to create and manage nests. In general, commands represent actions and flags are modifiers for those actions. A command can have children commands and optionally run an action. A full description of the \nnest\n command can be found in the newt tool reference in Chapter 3.\n\n\nnewt nest [flags]\nnewt nest [child-commands]\n\n\n\nA complete list of all the nest commands can be found in the newt tool reference in \nChapter 3\n.\n\n\nProject\n\n\nProjects represent the individual build configurations of your embedded system and essentially defines your application. The project files are what dictate the resulting binary that is generated. \n\n\nLayout-wise, a project is a directory inside a nest and contains eggs required for a certain application. For example, the \nblinky\n egg sits in \nproject/blinky\n directory of the \nlarva\n nest. This egg is used in the blinky project (application) outlined in \nChapter 1\n. \nNote: This Will Change\n\n\nA project has the following concepts or properties associated with it. You can find them in the \nproject-name\n.yml\n file in the project directory. For example, the \nproject/blinky\n directory has the \nblinky.yml\n file indicating some or all of the properties below. Only the name of a project is required for the project to exist, however additional properties may need to be specified for the eggs in it to compile properly and produce an executable. \n\n\n\n\nProject name\n\n\nBase path of the project (nest/project/project-name by default)\n\n\nEggs belonging to the project\n\n\nCapabilities\n that are required for the project or target \n\n\nIdentity\n to classify the type of project or target\n\n\nCompiler flags to call out any specific compiler requirement\n\n\n\n\nA project could itself be an egg if it is a distributable package for a specific application. \n\n\nThe newt tool offers various commands that you can use with a project. For example, if your project is an egg, you can use the following command to install a project from a nest.\n\n\nnewt egg install [flags] \nproject egg name\n\n\n\n\nEgg\n\n\nAn egg is a distributable package of libraries. Just as an egg in nature has various parts each of which serves a certain purpose, the Mynewt egg consists of software parcels or modules that have different functions. However, unlike the egg in nature these software modules can exist by itself and may be distributed; therefore, they too are essentially eggs. Once this concept is grasped it is easy to see how an egg may consist of other eggs.\n\n\nThe two main directories in an egg are \n/include\n and \n/src\n.\n\n\nThe newt tool offers several egg commands to list, inspect, install, and do other operations on eggs. For example, the following command\n\n\nnewt egg list\n\n\n\noutputs all the eggs in the current nest where each egg has details on its version, path, and dependencies. A sample output for an egg is given below.\n\n\nEgg libs/os, version 0.1.0\npath: /Users/aditihilbert/dev/test_project/libs/os\ndeps: libs/testutil@none#stable\n\n\n\nA complete list of all the egg commands can be found in the newt tool reference in \nChapter 3\n.\n\n\nClutch\n\n\nA clutch is a snapshot of all eggs in a remote nest at any point in time. On any given github branch, a nest with a clutch of eggs will contain a \nclutch.yml\n file that specifies the version number, dependencies, and hash value for each constituent egg as well as the name of the entire clutch and the github url for it. [Note: Currently ]\n\n\nYou may download multiple clutches into your local nest as long as the names of the clutches are different. This allows you to mix and match various features and functionality coming from different clutches of eggs. You can see all the clutches in the \n.nest/clutches\n directory in your nest.\n\n\nThe newt tool offers clutch management commands within the \nnewt nest\n command. For example, the following command creates a new clutch using all the eggs in the current directory. It requires that a clutch name be specified and the url for the location of that clutch in the online repository. These two inputs go into the \nclutch.yml\n file in the nest.\n\n\nnewt nest generate-clutch \nname\n \nurl\n\n\n\n\nNote that a clutch merely defines the eggs belonging together and requires the eggs to be installed (hatched) for the source code to be populated in the project. \n\n\nEggshell\n\n\nThe term eggshell is used to refer to the eggs of a clutch in a remote repository. They are not useful on your local machine until you actually install them. So they are mere shells of themselves while sitting on the online repository. When you enter the following command outputs the total number of shells in each remote clutch.\n\n\nnewt nest list-clutches\n\n\n\nSo, if you had two clutches installed, the output could be:\n\n\nRemote clutch larva (eggshells: 19)\nRemote clutch ble_test (eggshells: 15)\n\n\n\nTarget\n\n\nA target is the hardware build or its software equivalent (e.g. test, simulator) set for a project. It tells the newt tool how to build the source code within a given nest. Once a new target is created, its architecture and other details needs to be defined. An example of a defined target named \"blink_f3disc\" is given below.\n\n\nblink_f3disc\n         compiler_def: debug\n         compiler: arm-none-eabi-m4\n         name: blink_f3disc\n         arch: cortex_m4\n         project: blinky\n         bsp: hw/bsp/stm32f3discovery\n\n\n\nThe newt tool offers commands to create, set up and manipulate targets. For example, the create command below creates an empty target named \nmy_target1\n and the set command sets one detail of its definition, namely the architecture.\n\n\nnewt target create my_target1\nnewt target set my_target1 arch=cortex_m4\n\n\n\nCapability\n\n\nCapability is functionality that is exposed by an egg. A capability is tracked by its name and version. An egg may require capabilities exposed by another egg, thus establishing a dependency tracked through the egg.yml files. \n\n\nThe newt tool can ascertain a map of all the egg capabilities and use it to check dependencies and make sure all the necessary eggs are in a project for a particular target.\n\n\nIdentity\n\n\nIdentity is a property of a target or project in the newt world. A target may inherit it from a project or vice versa. It may be used to determine what eggs to include or how an egg code should behave in a build or which linkerscripts to use. For example, the identity of a lock is different from the identity of a wearable monitor. Even if they were to be built on the same hardware target, different features and behavior are required. Their different identities result in differing sets of eggs in the projects and/or the same egg behaving differently depending on the identity.", 
            "title": "Understanding Newt Terms"
        }, 
        {
            "location": "/chapter2/vocabulary/#understanding-newt-terms", 
            "text": "Nest  The nest is the base directory of your embedded software. It is meant to be the workspace containing a logical collection of the source code for one or more of your projects. A nest can contain multiple projects, and reflect multiple end products.   As the base repository of your source code, the nest has a master branch and several other branches off it. You may choose any branch to nest on. Each project in your nest will typically consist of several  eggs . A project could be an egg itself as well. In addition to eggs, a local nest will contain additional items such as  target  or build definitions, clutch description files, scripts etc.  For example, a walk through the \"larva\" nest at  https://github.com/mynewt/larva.git  shows the following structure. The nest.yml file in the larva directory indicates that it is a nest. An egg will have the egg.yml file in it as shown below. By this nomenclature, each board support package for a particular chip is an egg, the API for the hardware abstraction layer is an egg, and so on.   larva\n  |- nest.yml \n  |- compiler\n        |- arm-none-eabi-m4\n        |- sim\n  |- hw (hardware)\n        |- bsp (board support package)\n                |- nrf52pdk (Nordic nRF52 series chip)\n                        |- egg.yml\n                        |- ...\n                |- olimex_stm32-e407_devboard (used in chapter1 project)\n                        |- egg.yml\n                        |- ...\n                |- stm32f3discovery (another board with stm32f3 mcu)\n                        |- egg.yml\n                        |- ...\n                |- yet another board\n                        |- egg.yml\n                        |- ...\n        |- hal (hardware abstraction layer APIs)\n                |- egg.yml\n                |- include\n                        |- hal_cputime.h\n                        |- hal_flash.h\n                        |- hal_gpio.h\n                        |- ... (header files for other peripherals)\n        |- mcu (microcontroller)\n                |- stm (STMicro family)\n                    |- stm32f3xx (STM32f3 series, 32-bit ARM Cortex-M4  core)\n                        |- egg.yml\n                        |- src\n                            |- hal_gpio.c (specific to the STM32f3 mcu)\n                            |- hal_cputime.c\n                            |- ... (code for other peripherals)\n                |- nordic (Nordic Semiconductor family)\n                    |- nrf52xxx (nRF52 Series SoC, Cortex-M4F core)\n                        |- egg.yml\n                        |- src\n                            |- hal_gpio.c (specific to the nRF52 mcu )\n                            |- hal_cputime.c\n                            |- ... (code for other peripherals)\n                |- yet another family of mcu\n                    |- ...\n  |- libs\n        |- bootutil (hw architecture independent boot loader library)\n                |- egg.yml\n                |- src\n                    |- loader.c\n                    |- ... (related source code files)\n        |- nffs (hw architecture independent Newtron Flash File System)\n                |- egg.yml\n                |- src\n                    |- nffs.c\n                    |- ... (related source code files)\n        |- another library \n                |- egg.yml\n                |- src\n                    |- ... (related source code files)\n  |- project\n  |- scripts  The newt tool offers the  nest  command to create and manage nests. In general, commands represent actions and flags are modifiers for those actions. A command can have children commands and optionally run an action. A full description of the  nest  command can be found in the newt tool reference in Chapter 3.  newt nest [flags]\nnewt nest [child-commands]  A complete list of all the nest commands can be found in the newt tool reference in  Chapter 3 .  Project  Projects represent the individual build configurations of your embedded system and essentially defines your application. The project files are what dictate the resulting binary that is generated.   Layout-wise, a project is a directory inside a nest and contains eggs required for a certain application. For example, the  blinky  egg sits in  project/blinky  directory of the  larva  nest. This egg is used in the blinky project (application) outlined in  Chapter 1 .  Note: This Will Change  A project has the following concepts or properties associated with it. You can find them in the  project-name .yml  file in the project directory. For example, the  project/blinky  directory has the  blinky.yml  file indicating some or all of the properties below. Only the name of a project is required for the project to exist, however additional properties may need to be specified for the eggs in it to compile properly and produce an executable.    Project name  Base path of the project (nest/project/project-name by default)  Eggs belonging to the project  Capabilities  that are required for the project or target   Identity  to classify the type of project or target  Compiler flags to call out any specific compiler requirement   A project could itself be an egg if it is a distributable package for a specific application.   The newt tool offers various commands that you can use with a project. For example, if your project is an egg, you can use the following command to install a project from a nest.  newt egg install [flags]  project egg name   Egg  An egg is a distributable package of libraries. Just as an egg in nature has various parts each of which serves a certain purpose, the Mynewt egg consists of software parcels or modules that have different functions. However, unlike the egg in nature these software modules can exist by itself and may be distributed; therefore, they too are essentially eggs. Once this concept is grasped it is easy to see how an egg may consist of other eggs.  The two main directories in an egg are  /include  and  /src .  The newt tool offers several egg commands to list, inspect, install, and do other operations on eggs. For example, the following command  newt egg list  outputs all the eggs in the current nest where each egg has details on its version, path, and dependencies. A sample output for an egg is given below.  Egg libs/os, version 0.1.0\npath: /Users/aditihilbert/dev/test_project/libs/os\ndeps: libs/testutil@none#stable  A complete list of all the egg commands can be found in the newt tool reference in  Chapter 3 .  Clutch  A clutch is a snapshot of all eggs in a remote nest at any point in time. On any given github branch, a nest with a clutch of eggs will contain a  clutch.yml  file that specifies the version number, dependencies, and hash value for each constituent egg as well as the name of the entire clutch and the github url for it. [Note: Currently ]  You may download multiple clutches into your local nest as long as the names of the clutches are different. This allows you to mix and match various features and functionality coming from different clutches of eggs. You can see all the clutches in the  .nest/clutches  directory in your nest.  The newt tool offers clutch management commands within the  newt nest  command. For example, the following command creates a new clutch using all the eggs in the current directory. It requires that a clutch name be specified and the url for the location of that clutch in the online repository. These two inputs go into the  clutch.yml  file in the nest.  newt nest generate-clutch  name   url   Note that a clutch merely defines the eggs belonging together and requires the eggs to be installed (hatched) for the source code to be populated in the project.   Eggshell  The term eggshell is used to refer to the eggs of a clutch in a remote repository. They are not useful on your local machine until you actually install them. So they are mere shells of themselves while sitting on the online repository. When you enter the following command outputs the total number of shells in each remote clutch.  newt nest list-clutches  So, if you had two clutches installed, the output could be:  Remote clutch larva (eggshells: 19)\nRemote clutch ble_test (eggshells: 15)  Target  A target is the hardware build or its software equivalent (e.g. test, simulator) set for a project. It tells the newt tool how to build the source code within a given nest. Once a new target is created, its architecture and other details needs to be defined. An example of a defined target named \"blink_f3disc\" is given below.  blink_f3disc\n         compiler_def: debug\n         compiler: arm-none-eabi-m4\n         name: blink_f3disc\n         arch: cortex_m4\n         project: blinky\n         bsp: hw/bsp/stm32f3discovery  The newt tool offers commands to create, set up and manipulate targets. For example, the create command below creates an empty target named  my_target1  and the set command sets one detail of its definition, namely the architecture.  newt target create my_target1\nnewt target set my_target1 arch=cortex_m4  Capability  Capability is functionality that is exposed by an egg. A capability is tracked by its name and version. An egg may require capabilities exposed by another egg, thus establishing a dependency tracked through the egg.yml files.   The newt tool can ascertain a map of all the egg capabilities and use it to check dependencies and make sure all the necessary eggs are in a project for a particular target.  Identity  Identity is a property of a target or project in the newt world. A target may inherit it from a project or vice versa. It may be used to determine what eggs to include or how an egg code should behave in a build or which linkerscripts to use. For example, the identity of a lock is different from the identity of a wearable monitor. Even if they were to be built on the same hardware target, different features and behavior are required. Their different identities result in differing sets of eggs in the projects and/or the same egg behaving differently depending on the identity.", 
            "title": "Understanding Newt Terms"
        }, 
        {
            "location": "/chapter2/project2/", 
            "text": "Project 2 - Blinky on additional boards\n\n\nObjective\n\n\nThe goal of this tutorial is to download a generic firmware skeleton (\"bootstrap image\") that applies to any hardware and then throw in additional applicable eggs to generate a build for a specific board. \n\n\nThe following target hardware chips are covered:\n\n\n\n\nSTM32F303VC MCU\n from STMicroelectronics\n\n\nnRF52 Series\n from Nordic Semiconductors \n\n\n\n\nSTM32F303VC MCU\n\n\nHardware needed\n\n\n\n\nDiscovery kit with STM32F303VC MCU\n\n\nLaptop running Mac OS\n\n\n\n\nStep by Step Instructions to build image\n\n\n\n\n\n\nThe first step is to download the generic skeleton of the project. The eggs installed are not hardware architecture specific.\n\n\n[user:~/foo]$ newt nest create test_project\nDownloading nest skeleton from https://www.github.com/mynewt/tadpole...   ok!\nNest test_project successfully created in ~/foo/test_project\n\n[user:~/foo]$ cd test_project/\n\n\n\n\n\n\n\nThen, the clutch of eggs named larva is added from the nest (also named larva) on the github. This step simply downloads the clutch description file and does not actually install the eggs that constitute the clutch. The clutch description file (\nclutch.yml\n) will be used to check dependencies during the egg install to ensure completeness. It serves as a reference for all the eggs in the clutch that one can choose from and install.\n\n\n[user:~/foo/test_project]$ newt nest add-clutch larva https://github.com/mynewt/larva\nDownloading clutch.yml from https://github.com/mynewt/larva/master... ok!\nVerifying clutch.yml format... ok!\nClutch larva successfully installed to Nest.\n\n\n\n\n\n\n\nThe next step is to install relevant eggs from the larva nest on github. The instructions assume that you know what application or project you are interested in (the blinky application, in this case), what hardware you are using (STM32F3DISCOVERY board, in this case) and hence, what board support package you need. \n\n\n[user:~/foo/test_projec]$ newt egg install project/blinky          \nDownloading larva from https://github.com/mynewt/larva//master... ok!\nInstalling project/blinky\nInstallation was a success!\n\n[user:~/foo/test_project]$ newt egg install hw/bsp/stm32f3discovery\nDownloading larva from https://github.com/mynewt/larva//master... ok!\nInstalling hw/bsp/stm32f3discovery\nInstalling hw/mcu/stm/stm32f3xx\nInstalling libs/cmsis-core\nInstalling compiler/arm-none-eabi-m4\nInstallation was a success!\n\n\n\n\n\n\n\nIt's time to create a target for the project and define the target attributes. \n\n\n[user:~/foo/test_project]$ newt target create blink_f3disc\nCreating target blink_f3disc\nTarget blink_f3disc successfully created!\n\n[user:~/foo/test_project]$ newt target set blink_f3disc project=blinky\nTarget blink_f3disc successfully set project to blinky\n\n[user:~/foo/test_project]$ newt target set blink_f3disc bsp=hw/bsp/stm32f3discovery\nTarget blink_f3disc successfully set bsp to hw/bsp/stm32f3discovery\n\n[marko@Markos-MacBook-Pro-2:~/foo/test_project]$ newt target set blink_f3disc compiler_def=debug\nTarget blink_f3disc successfully set compiler_def to debug\n\n[user:~/foo/test_project]$ newt target set blink_f3disc compiler=arm-none-eabi-m4\nTarget blink_f3disc successfully set compiler to arm-none-eabi-m4\n\n[user:~/foo/test_project]$ newt target set blink_f3disc arch=cortex_m4\nTarget blink_f3disc successfully set arch to cortex_m4\n\n[user:~/foo/test_project]$ newt target show blink_f3disc\nblink_f3disc\n    arch: cortex_m4\n    project: blinky\n    bsp: hw/bsp/stm32f3discovery\n    compiler_def: debug\n    compiler: arm-none-eabi-m4\n    name: blink_f3disc\n\n\n\n\n\n\n\nFinally, you get to build the target and generate an executable that can now be uploaded to the board via the JTAG port. You can go into the openocd directory and start an OCD session as you did in Project 1.\n\n\n[user:~/foo/test_project]$ newt target build         blink_f3disc\nBuilding target blink_f3disc (project = blinky)\nCompiling case.c\nCompiling suite.c\nCompiling testutil.c\nCompiling testutil_arch_arm.c\nArchiving libtestutil.a\nCompiling os.c\nCompiling os_callout.c\nCompiling os_eventq.c\nCompiling os_heap.c\nCompiling os_mbuf.c\nCompiling os_mempool.c\nCompiling os_mutex.c\nCompiling os_sanity.c\nCompiling os_sched.c\nCompiling os_sem.c\nCompiling os_task.c\nCompiling os_time.c\nCompiling os_arch_arm.c\nAssembling HAL_CM4.s\nAssembling SVC_Table.s\nArchiving libos.a\nCompiling hal_gpio.c\nCompiling stm32f3xx_hal_gpio.c\nArchiving libstm32f3xx.a\nCompiling cmsis_nvic.c\nCompiling libc_stubs.c\nCompiling os_bsp.c\nCompiling sbrk.c\nCompiling system_stm32f3xx.c\nAssembling startup_stm32f303xc.s\nArchiving libstm32f3discovery.a\nCompiling main.c\nBuilding project blinky\nLinking blinky.elf\nSuccessfully run!\n\n\n\n\n\n\n\nnRF52 Series\n\n\nHardware needed\n\n\n\n\nnRF52 Development Kit\n\n\nLaptop running Mac OS\n\n\n\n\nStep by Step Instructions to build image\n\n\n\n\n\n\nThe first step is to download the generic skeleton of the project. The eggs installed are not hardware architecture specific.\n\n\n[]user@~/dev]$ newt nest create nordic_blinky\nDownloading nest skeleton from https://www.github.com/mynewt/tadpole... ok!\nNest nordic_blinky successfully created in ~dev/nordic_blinky\n\nuser@~/dev$ cd nordic_blinky/\n\n\n\n\n\n\n\nThen, the clutch of eggs named larva is added from the nest (also named larva) on the github. This step simply downloads the clutch description file and does not actually install the eggs that constitute the clutch. The clutch description file (\nclutch.yml\n) will be used to check dependencies during the egg install to ensure completeness. It serves as a reference for all the eggs in the clutch that one can choose from and install.\n\n\n[]user@~/dev/nordic_blinky]$ newt nest add-clutch larva https://github.com/mynewt/larva\nDownloading clutch.yml from https://github.com/mynewt/larva/master... ok!\nVerifying clutch.yml format...ok!\nClutch larva successfully installed to Nest.\n\n\n\n\n\n\n\nThe next step is to install relevant eggs from the larva nest on github. The instructions assume that you know what application or project you are interested in (the blinky application, in this case), what hardware you are using (STM32F3DISCOVERY board, in this case) and hence, what board support package you need. \n\n\n[user@~/dev/nordic_blinky]$ newt egg install project/blinky \nDownloading larva from https://github.com/mynewt/larva//master... ok!\nInstalling project/blinky\nInstallation was a success!\n\n[user@~/dev/nordic_blinky]$ newt egg install hw/bsp/nrf52pdk\nDownloading larva from https://github.com/mynewt/larva//master... ok!\nInstalling hw/bsp/nrf52pdk\nInstalling hw/mcu/nordic/nrf52xxx\nInstalling libs/cmsis-core\nInstalling compiler/arm-none-eabi-m4\nInstallation was a success!\n\n\n\n\n\n\n\nIt's time to create a target for the project and define the target attributes. \n\n\n[user@~/dev/nordic_blinky]$ newt target create blink_nordic\nCreating target blink_nordic\nTarget blink_nordic successfully created!\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic project=blinky\nTarget blink_nordic successfully set project to blinky\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic bsp=hw/bsp/nrf52pdk\nTarget blink_nordic successfully set bsp to hw/bsp/nrf52pdk\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic compiler_def=debug\nTarget blink_nordic successfully set compiler_def to debug\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic compiler=arm-none-eabi-m4\nTarget blink_nordic successfully set compiler to arm-none-eabi-m4\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic arch=cortex_m4\nTarget blink_nordic successfully set arch to cortex_m4\n[user@~/dev/nordic_blinky]$ newt target show\nblink_nordic\n    compiler: arm-none-eabi-m4\n    name: blink_nordic\n    arch: cortex_m4\n    project: blinky\n    bsp: hw/bsp/nrf52pdk\n    compiler_def: debug\n\n\n\n\n\n\n\nFinally, you get to build the target and generate an executable that can now be uploaded to the board via the on-board SEGGER J-Link debugger. \n\n\n[user@~/dev/nordic_blinky]$ newt target build blink_nordic\nBuilding target blink_nordic (project = blinky)\nCompiling case.c\nCompiling suite.c\nCompiling testutil.c\nCompiling testutil_arch_arm.c\nArchiving libtestutil.a\nCompiling os.c\nCompiling os_callout.c\nCompiling os_eventq.c\nCompiling os_heap.c\nCompiling os_mbuf.c\nCompiling os_mempool.c\nCompiling os_mutex.c\nCompiling os_sanity.c\nCompiling os_sched.c\nCompiling os_sem.c\nCompiling os_task.c\nCompiling os_time.c\nCompiling os_arch_arm.c\nAssembling HAL_CM4.s\nAssembling SVC_Table.s\nArchiving libos.a\nCompiling hal_cputime.c\nCompiling hal_gpio.c\nCompiling hal_uart.c\nArchiving libnrf52xxx.a\nCompiling cmsis_nvic.c\nCompiling hal_bsp.c\nCompiling libc_stubs.c\nCompiling os_bsp.c\nCompiling sbrk.c\nCompiling system_nrf52.c\nAssembling gcc_startup_nrf52.s\nArchiving libnrf52pdk.a\nCompiling main.c\nBuilding project blinky\nLinking blinky.elf\nSuccessfully run!\n\n\n\n\n\n\n\nIn order to be able to communicate with the SEGGER J-Link debugger on the dev board, you have to download and install the J-Link GDB Server software on to your laptop. You may download the \"Software and documentation pack for Mac OS X\" from \nhttps://www.segger.com/jlink-software.html\n. The command line version of the server is used in the steps below. \n\n\n\n\n\n\nOpen a new terminal and start a J-Link session.\n\n\n[user@~/dev/nordic_blinky/project/blinky/bin]$ which JLinkGDBServer\n/usr/local/bin/JLinkGDBServer\n[user@~/dev/nordic_blinky/project/blinky/bin]$ JLinkGDBServer -if SWD\nSEGGER J-Link GDB Server V5.02f Command Line Version\n\nJLinkARM.dll V5.02f (DLL compiled Oct  2 2015 20:55:03)\n\n-----GDB Server start settings-----\nGDBInit file:                  none\nGDB Server Listening port:     2331\nSWO raw output listening port: 2332\nTerminal I/O port:             2333\nAccept remote connection:      yes\nGenerate logfile:              off\nVerify download:               off\nInit regs on start:            off\nSilent mode:                   off\nSingle run mode:               off\nTarget connection timeout:     0 ms\n------J-Link related settings------\nJ-Link Host interface:         USB\nJ-Link script:                 none\nJ-Link settings file:          none\n------Target related settings------\nTarget device:                 unspecified\nTarget interface:              SWD\nTarget interface speed:        1000kHz\nTarget endian:                 little\n\nConnecting to J-Link...\nJ-Link is connected.\nFirmware: J-Link OB-SAM3U128-V2-NordicSemi compiled Aug 28 2015 19:26:24\nHardware: V1.00\nS/N: 682371959\nChecking target voltage...\nTarget voltage: 3.30 V\nListening on TCP/IP port 2331\nConnecting to target...Connected to target\nWaiting for GDB connection...Connected to 127.0.0.1\n\n\n\n\n\n\n\nYou need a configuration file for the GDB session to be opened correctly and the image (\"blinky.elf\") you built for this target downloaded to flash. A sample config script is given below. Alternatively, you could choose to type each command at the gdb prompt.\n\n\n [user@~/dev/nordic_blinky/project/blinky/bin/blink_nordic]$ cat jlink-gdb.cfg \n echo ***Setting up the environment for debugging gdb.***\\n\n set complaints 1\n set prompt (gdb) \n set endian little\n echo \\n*** Set target charset ASCII\\n\n set target-charset ASCII\n echo \\n*** Connecting over port #2331 ***\\n\n target remote localhost:2331\n echo \\n*** Enable flash write and set device to nrf52 ***\\n\n monitor flash download=1\n monitor flash device=nRF52\n echo \\n*** loading blinky.elf ***\\n\n load ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf \n symbol-file ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf\n echo \\n*** Resetting target ***\\n\n monitor reset\n echo \\n*** Halting target ***\\n\n monitor halt\n\n\n\n\n\n\n\nStart the gdb session and monitor that it loads the image, resets the target, and halts for a command to continue. \n\n\n[user@~/dev/nordic_blinky/project/blinky/bin/blink_nordic]$ arm-none-eabi-gdb -x ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/jlink-gdb.cfg\n\nGNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later \nhttp://gnu.org/licenses/gpl.html\n\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"--host=x86_64-apple-darwin10 --target=arm-none-eabi\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n\nhttp://www.gnu.org/software/gdb/bugs/\n.\nFind the GDB manual and other documentation resources online at:\n\nhttp://www.gnu.org/software/gdb/documentation/\n.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n\n***Setting up the environment for debugging gdb.***\nThe target is assumed to be little endian\n\n*** Set target charset ASCII\n\n*** Connecting over port #2331 ***\n0x00003c34 in ?? ()\n\n*** Enable flash write and set device to nrf52 ***\nFlash download enabled\nSelecting device: nRF52\n\n*** loading blinky.elf ***\nLoading section .text, size 0x5c84 lma 0x0\nLoading section .ARM.extab, size 0x24 lma 0x5c84\nLoading section .ARM.exidx, size 0xd8 lma 0x5ca8\nLoading section .data, size 0x8f8 lma 0x5d80\nStart address 0x48c, load size 26232\nTransfer rate: 12808 KB/sec, 2914 bytes/write.\nDuring symbol reading, unexpected overlap between:\n (A) section `.text' from `~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf' [0x0, 0x5c84)\n (B) section `*COM*' from `~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf' [0x0, 0x0).\nWill ignore section B.\n\n*** Resetting target ***\nResetting target\n\n*** Halting target ***\n\n\n\n\n\n\n\nType 'c' to continue. The LED on the board will start to blink. You will also see some activity in the terminal showing the open J-Link GDB server connection. The LED will continue to blink after you quit out of that connection.\n\n\n(gdb) c\nContinuing.", 
            "title": "Project 2"
        }, 
        {
            "location": "/chapter2/project2/#project-2-blinky-on-additional-boards", 
            "text": "Objective  The goal of this tutorial is to download a generic firmware skeleton (\"bootstrap image\") that applies to any hardware and then throw in additional applicable eggs to generate a build for a specific board.   The following target hardware chips are covered:   STM32F303VC MCU  from STMicroelectronics  nRF52 Series  from Nordic Semiconductors    STM32F303VC MCU  Hardware needed   Discovery kit with STM32F303VC MCU  Laptop running Mac OS   Step by Step Instructions to build image    The first step is to download the generic skeleton of the project. The eggs installed are not hardware architecture specific.  [user:~/foo]$ newt nest create test_project\nDownloading nest skeleton from https://www.github.com/mynewt/tadpole...   ok!\nNest test_project successfully created in ~/foo/test_project\n\n[user:~/foo]$ cd test_project/    Then, the clutch of eggs named larva is added from the nest (also named larva) on the github. This step simply downloads the clutch description file and does not actually install the eggs that constitute the clutch. The clutch description file ( clutch.yml ) will be used to check dependencies during the egg install to ensure completeness. It serves as a reference for all the eggs in the clutch that one can choose from and install.  [user:~/foo/test_project]$ newt nest add-clutch larva https://github.com/mynewt/larva\nDownloading clutch.yml from https://github.com/mynewt/larva/master... ok!\nVerifying clutch.yml format... ok!\nClutch larva successfully installed to Nest.    The next step is to install relevant eggs from the larva nest on github. The instructions assume that you know what application or project you are interested in (the blinky application, in this case), what hardware you are using (STM32F3DISCOVERY board, in this case) and hence, what board support package you need.   [user:~/foo/test_projec]$ newt egg install project/blinky          \nDownloading larva from https://github.com/mynewt/larva//master... ok!\nInstalling project/blinky\nInstallation was a success!\n\n[user:~/foo/test_project]$ newt egg install hw/bsp/stm32f3discovery\nDownloading larva from https://github.com/mynewt/larva//master... ok!\nInstalling hw/bsp/stm32f3discovery\nInstalling hw/mcu/stm/stm32f3xx\nInstalling libs/cmsis-core\nInstalling compiler/arm-none-eabi-m4\nInstallation was a success!    It's time to create a target for the project and define the target attributes.   [user:~/foo/test_project]$ newt target create blink_f3disc\nCreating target blink_f3disc\nTarget blink_f3disc successfully created!\n\n[user:~/foo/test_project]$ newt target set blink_f3disc project=blinky\nTarget blink_f3disc successfully set project to blinky\n\n[user:~/foo/test_project]$ newt target set blink_f3disc bsp=hw/bsp/stm32f3discovery\nTarget blink_f3disc successfully set bsp to hw/bsp/stm32f3discovery\n\n[marko@Markos-MacBook-Pro-2:~/foo/test_project]$ newt target set blink_f3disc compiler_def=debug\nTarget blink_f3disc successfully set compiler_def to debug\n\n[user:~/foo/test_project]$ newt target set blink_f3disc compiler=arm-none-eabi-m4\nTarget blink_f3disc successfully set compiler to arm-none-eabi-m4\n\n[user:~/foo/test_project]$ newt target set blink_f3disc arch=cortex_m4\nTarget blink_f3disc successfully set arch to cortex_m4\n\n[user:~/foo/test_project]$ newt target show blink_f3disc\nblink_f3disc\n    arch: cortex_m4\n    project: blinky\n    bsp: hw/bsp/stm32f3discovery\n    compiler_def: debug\n    compiler: arm-none-eabi-m4\n    name: blink_f3disc    Finally, you get to build the target and generate an executable that can now be uploaded to the board via the JTAG port. You can go into the openocd directory and start an OCD session as you did in Project 1.  [user:~/foo/test_project]$ newt target build         blink_f3disc\nBuilding target blink_f3disc (project = blinky)\nCompiling case.c\nCompiling suite.c\nCompiling testutil.c\nCompiling testutil_arch_arm.c\nArchiving libtestutil.a\nCompiling os.c\nCompiling os_callout.c\nCompiling os_eventq.c\nCompiling os_heap.c\nCompiling os_mbuf.c\nCompiling os_mempool.c\nCompiling os_mutex.c\nCompiling os_sanity.c\nCompiling os_sched.c\nCompiling os_sem.c\nCompiling os_task.c\nCompiling os_time.c\nCompiling os_arch_arm.c\nAssembling HAL_CM4.s\nAssembling SVC_Table.s\nArchiving libos.a\nCompiling hal_gpio.c\nCompiling stm32f3xx_hal_gpio.c\nArchiving libstm32f3xx.a\nCompiling cmsis_nvic.c\nCompiling libc_stubs.c\nCompiling os_bsp.c\nCompiling sbrk.c\nCompiling system_stm32f3xx.c\nAssembling startup_stm32f303xc.s\nArchiving libstm32f3discovery.a\nCompiling main.c\nBuilding project blinky\nLinking blinky.elf\nSuccessfully run!    nRF52 Series  Hardware needed   nRF52 Development Kit  Laptop running Mac OS   Step by Step Instructions to build image    The first step is to download the generic skeleton of the project. The eggs installed are not hardware architecture specific.  []user@~/dev]$ newt nest create nordic_blinky\nDownloading nest skeleton from https://www.github.com/mynewt/tadpole... ok!\nNest nordic_blinky successfully created in ~dev/nordic_blinky\n\nuser@~/dev$ cd nordic_blinky/    Then, the clutch of eggs named larva is added from the nest (also named larva) on the github. This step simply downloads the clutch description file and does not actually install the eggs that constitute the clutch. The clutch description file ( clutch.yml ) will be used to check dependencies during the egg install to ensure completeness. It serves as a reference for all the eggs in the clutch that one can choose from and install.  []user@~/dev/nordic_blinky]$ newt nest add-clutch larva https://github.com/mynewt/larva\nDownloading clutch.yml from https://github.com/mynewt/larva/master... ok!\nVerifying clutch.yml format...ok!\nClutch larva successfully installed to Nest.    The next step is to install relevant eggs from the larva nest on github. The instructions assume that you know what application or project you are interested in (the blinky application, in this case), what hardware you are using (STM32F3DISCOVERY board, in this case) and hence, what board support package you need.   [user@~/dev/nordic_blinky]$ newt egg install project/blinky \nDownloading larva from https://github.com/mynewt/larva//master... ok!\nInstalling project/blinky\nInstallation was a success!\n\n[user@~/dev/nordic_blinky]$ newt egg install hw/bsp/nrf52pdk\nDownloading larva from https://github.com/mynewt/larva//master... ok!\nInstalling hw/bsp/nrf52pdk\nInstalling hw/mcu/nordic/nrf52xxx\nInstalling libs/cmsis-core\nInstalling compiler/arm-none-eabi-m4\nInstallation was a success!    It's time to create a target for the project and define the target attributes.   [user@~/dev/nordic_blinky]$ newt target create blink_nordic\nCreating target blink_nordic\nTarget blink_nordic successfully created!\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic project=blinky\nTarget blink_nordic successfully set project to blinky\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic bsp=hw/bsp/nrf52pdk\nTarget blink_nordic successfully set bsp to hw/bsp/nrf52pdk\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic compiler_def=debug\nTarget blink_nordic successfully set compiler_def to debug\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic compiler=arm-none-eabi-m4\nTarget blink_nordic successfully set compiler to arm-none-eabi-m4\n[user@~/dev/nordic_blinky]$ newt target set blink_nordic arch=cortex_m4\nTarget blink_nordic successfully set arch to cortex_m4\n[user@~/dev/nordic_blinky]$ newt target show\nblink_nordic\n    compiler: arm-none-eabi-m4\n    name: blink_nordic\n    arch: cortex_m4\n    project: blinky\n    bsp: hw/bsp/nrf52pdk\n    compiler_def: debug    Finally, you get to build the target and generate an executable that can now be uploaded to the board via the on-board SEGGER J-Link debugger.   [user@~/dev/nordic_blinky]$ newt target build blink_nordic\nBuilding target blink_nordic (project = blinky)\nCompiling case.c\nCompiling suite.c\nCompiling testutil.c\nCompiling testutil_arch_arm.c\nArchiving libtestutil.a\nCompiling os.c\nCompiling os_callout.c\nCompiling os_eventq.c\nCompiling os_heap.c\nCompiling os_mbuf.c\nCompiling os_mempool.c\nCompiling os_mutex.c\nCompiling os_sanity.c\nCompiling os_sched.c\nCompiling os_sem.c\nCompiling os_task.c\nCompiling os_time.c\nCompiling os_arch_arm.c\nAssembling HAL_CM4.s\nAssembling SVC_Table.s\nArchiving libos.a\nCompiling hal_cputime.c\nCompiling hal_gpio.c\nCompiling hal_uart.c\nArchiving libnrf52xxx.a\nCompiling cmsis_nvic.c\nCompiling hal_bsp.c\nCompiling libc_stubs.c\nCompiling os_bsp.c\nCompiling sbrk.c\nCompiling system_nrf52.c\nAssembling gcc_startup_nrf52.s\nArchiving libnrf52pdk.a\nCompiling main.c\nBuilding project blinky\nLinking blinky.elf\nSuccessfully run!    In order to be able to communicate with the SEGGER J-Link debugger on the dev board, you have to download and install the J-Link GDB Server software on to your laptop. You may download the \"Software and documentation pack for Mac OS X\" from  https://www.segger.com/jlink-software.html . The command line version of the server is used in the steps below.     Open a new terminal and start a J-Link session.  [user@~/dev/nordic_blinky/project/blinky/bin]$ which JLinkGDBServer\n/usr/local/bin/JLinkGDBServer\n[user@~/dev/nordic_blinky/project/blinky/bin]$ JLinkGDBServer -if SWD\nSEGGER J-Link GDB Server V5.02f Command Line Version\n\nJLinkARM.dll V5.02f (DLL compiled Oct  2 2015 20:55:03)\n\n-----GDB Server start settings-----\nGDBInit file:                  none\nGDB Server Listening port:     2331\nSWO raw output listening port: 2332\nTerminal I/O port:             2333\nAccept remote connection:      yes\nGenerate logfile:              off\nVerify download:               off\nInit regs on start:            off\nSilent mode:                   off\nSingle run mode:               off\nTarget connection timeout:     0 ms\n------J-Link related settings------\nJ-Link Host interface:         USB\nJ-Link script:                 none\nJ-Link settings file:          none\n------Target related settings------\nTarget device:                 unspecified\nTarget interface:              SWD\nTarget interface speed:        1000kHz\nTarget endian:                 little\n\nConnecting to J-Link...\nJ-Link is connected.\nFirmware: J-Link OB-SAM3U128-V2-NordicSemi compiled Aug 28 2015 19:26:24\nHardware: V1.00\nS/N: 682371959\nChecking target voltage...\nTarget voltage: 3.30 V\nListening on TCP/IP port 2331\nConnecting to target...Connected to target\nWaiting for GDB connection...Connected to 127.0.0.1    You need a configuration file for the GDB session to be opened correctly and the image (\"blinky.elf\") you built for this target downloaded to flash. A sample config script is given below. Alternatively, you could choose to type each command at the gdb prompt.   [user@~/dev/nordic_blinky/project/blinky/bin/blink_nordic]$ cat jlink-gdb.cfg \n echo ***Setting up the environment for debugging gdb.***\\n\n set complaints 1\n set prompt (gdb) \n set endian little\n echo \\n*** Set target charset ASCII\\n\n set target-charset ASCII\n echo \\n*** Connecting over port #2331 ***\\n\n target remote localhost:2331\n echo \\n*** Enable flash write and set device to nrf52 ***\\n\n monitor flash download=1\n monitor flash device=nRF52\n echo \\n*** loading blinky.elf ***\\n\n load ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf \n symbol-file ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf\n echo \\n*** Resetting target ***\\n\n monitor reset\n echo \\n*** Halting target ***\\n\n monitor halt    Start the gdb session and monitor that it loads the image, resets the target, and halts for a command to continue.   [user@~/dev/nordic_blinky/project/blinky/bin/blink_nordic]$ arm-none-eabi-gdb -x ~/dev/nordic_blinky/project/blinky/bin/blink_nordic/jlink-gdb.cfg\n\nGNU gdb (GNU Tools for ARM Embedded Processors) 7.8.0.20150604-cvs\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later  http://gnu.org/licenses/gpl.html \nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"--host=x86_64-apple-darwin10 --target=arm-none-eabi\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see: http://www.gnu.org/software/gdb/bugs/ .\nFind the GDB manual and other documentation resources online at: http://www.gnu.org/software/gdb/documentation/ .\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n\n***Setting up the environment for debugging gdb.***\nThe target is assumed to be little endian\n\n*** Set target charset ASCII\n\n*** Connecting over port #2331 ***\n0x00003c34 in ?? ()\n\n*** Enable flash write and set device to nrf52 ***\nFlash download enabled\nSelecting device: nRF52\n\n*** loading blinky.elf ***\nLoading section .text, size 0x5c84 lma 0x0\nLoading section .ARM.extab, size 0x24 lma 0x5c84\nLoading section .ARM.exidx, size 0xd8 lma 0x5ca8\nLoading section .data, size 0x8f8 lma 0x5d80\nStart address 0x48c, load size 26232\nTransfer rate: 12808 KB/sec, 2914 bytes/write.\nDuring symbol reading, unexpected overlap between:\n (A) section `.text' from `~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf' [0x0, 0x5c84)\n (B) section `*COM*' from `~/dev/nordic_blinky/project/blinky/bin/blink_nordic/blinky.elf' [0x0, 0x0).\nWill ignore section B.\n\n*** Resetting target ***\nResetting target\n\n*** Halting target ***    Type 'c' to continue. The LED on the board will start to blink. You will also see some activity in the terminal showing the open J-Link GDB server connection. The LED will continue to blink after you quit out of that connection.  (gdb) c\nContinuing.", 
            "title": "Project 2 - Blinky on additional boards"
        }, 
        {
            "location": "/chapter2/project3/", 
            "text": "How to Test an Egg", 
            "title": "Project 3"
        }, 
        {
            "location": "/chapter2/project3/#how-to-test-an-egg", 
            "text": "", 
            "title": "How to Test an Egg"
        }, 
        {
            "location": "/chapter3/newt_ops/", 
            "text": "Command Structure\n\n\nIn the newt tool, commands represent actions and flags are modifiers for those actions. A command can have children commands which are also simply referred to as commands. One or more arguments may need to be provided to a command to execute it correctly. \n\n\nIn the example below, the \nnewt\n command has the child command \ntarget set\n. The first argument 'my_target1' is the name of the target whose attributes are being set. The second argument 'arch=cortex_m4' specifies the value to set the attribute (variable) 'arch' to, which in this case is 'cortex_m4'. \n\n\nnewt target set my_target1 arch=cortex_m4\n\n\n\nGlobal flags work on all newt commands in the same way. An example is the flag \n-v, --verbose\n to ask for a verbose output while executing a command. The help flag \n-h\n or  \n--help\n is available on all commands but provides command specific output, of course. These flags may be specified in either a long or a short form. \n\n\nA command may additionally take flags specific to it. For example, the \n-b\n flag may be used with \nnewt egg install\n to tell it which branch to install the egg from. \n\n\nnewt egg install -b \nbranchname\n \neggname\n\n\n\n\nIn addition to the newt tool \nreference\n in this documentation set, command-line help is available for each command (and child command). Simply use the flag \n-h\n or \n--help\n as shown below:\n\n\n$ newt target export --help\nExport build targets from the current nest, and print them to \nstandard output. If the -a (or -export-all) option is specified, \nthen all targets will be exported. Otherwise, \ntarget-name\n \nmust be specified, and only that target will be exported.\n\nUsage: \n  newt target export [flags]\n\nExamples:\n  newt target export [-a -export-all] [\ntarget-name\n]\n  newt target export -a \n my_exports.txt\n  newt target export my_target \n my_target_export.txt\n\nFlags:\n  -a, --export-all=false: If present, export all targets\n  -h, --help=false: help for export\n\nGlobal Flags:\n  -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n  -q, --quiet=false: Be quiet; only display error output.\n  -s, --silent=false: Be silent; don't output anything.\n  -v, --verbose=false: Enable verbose output when executing commands.", 
            "title": "Command structure"
        }, 
        {
            "location": "/chapter3/newt_ops/#command-structure", 
            "text": "In the newt tool, commands represent actions and flags are modifiers for those actions. A command can have children commands which are also simply referred to as commands. One or more arguments may need to be provided to a command to execute it correctly.   In the example below, the  newt  command has the child command  target set . The first argument 'my_target1' is the name of the target whose attributes are being set. The second argument 'arch=cortex_m4' specifies the value to set the attribute (variable) 'arch' to, which in this case is 'cortex_m4'.   newt target set my_target1 arch=cortex_m4  Global flags work on all newt commands in the same way. An example is the flag  -v, --verbose  to ask for a verbose output while executing a command. The help flag  -h  or   --help  is available on all commands but provides command specific output, of course. These flags may be specified in either a long or a short form.   A command may additionally take flags specific to it. For example, the  -b  flag may be used with  newt egg install  to tell it which branch to install the egg from.   newt egg install -b  branchname   eggname   In addition to the newt tool  reference  in this documentation set, command-line help is available for each command (and child command). Simply use the flag  -h  or  --help  as shown below:  $ newt target export --help\nExport build targets from the current nest, and print them to \nstandard output. If the -a (or -export-all) option is specified, \nthen all targets will be exported. Otherwise,  target-name  \nmust be specified, and only that target will be exported.\n\nUsage: \n  newt target export [flags]\n\nExamples:\n  newt target export [-a -export-all] [ target-name ]\n  newt target export -a   my_exports.txt\n  newt target export my_target   my_target_export.txt\n\nFlags:\n  -a, --export-all=false: If present, export all targets\n  -h, --help=false: help for export\n\nGlobal Flags:\n  -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n  -q, --quiet=false: Be quiet; only display error output.\n  -s, --silent=false: Be silent; don't output anything.\n  -v, --verbose=false: Enable verbose output when executing commands.", 
            "title": "Command Structure"
        }, 
        {
            "location": "/chapter3/newt_tool_reference/", 
            "text": "Command List\n\n\nAvailable high-level commands\n\n\nversion     Display the Newt version number\nhelp        Help about any command\nnest        Commands to manage nests \n clutches (remote egg repositories)\negg         Commands to list and inspect eggs on a nest\ntarget      Set and view target information\n\n\n\n\nversion\n\n\nUsage:\n\n\nnewt version [flags]\n\n\n\nFlags:\n\n\n-h, --help=false: help for version\n\n\n\nGlobal Flags:\n\n\n-h, --help=false: help for newt\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nversion\n\n\nnewt version\n\n\nDisplays the version of newt tool installed\n\n\n\n\n\n\n\n\nhelp\n\n\nUsage:\n\n\nnewt help [input1]\n\n\n\nFlags:\n\n\n\n-h, --help=false: help for newt\n-l, --loglevel=\nWARN\n: Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nhelp\n\n\nnewt help target\n\n\nDisplays the help text for the newt command 'target'\n\n\n\n\n\n\nhelp\n\n\nnewt help\n\n\nDisplays the help text for newt tool\n\n\n\n\n\n\n\n\nnest\n\n\nUsage:\n\n\nnewt nest [command][flags] input1 input2...\n\n\n\nAvailable commands: \n\n\ncreate          Create a new nest\ngenerate-clutch Generate a clutch file from the eggs in the current directory\nadd-clutch      Add a remote clutch, and put it in the current nest\nlist-clutches   List the clutches installed in the current nest\nshow-clutch     Show an individual clutch in the current nest\n\n\n\nFlags:\n\n\n-h, --help=false: help for nest\n\n\n\nGlobal Flags:\n\n\n-h, --help=false: help for newt\n-l, --loglevel=\"WARN\": Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSub-command\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\ncreate\n\n\nDownloads the skeleton of a nest on your local machine from the optional \ninput2\nnest url, if specified, and creates a new nest directory by the name of \ninput1\n If \ninput2\nis not specified, then a default skeleton from the \ntadpole\nnest on Mynewt is downloaded. The command lays out a generic directory structure for the nest you are going to build under it and includes some default eggs in it.\n\n\n\n\n\n\ngenerate-clutch\n\n\nTakes a snapshot of the eggs in the current local directory and combines them into a clutch by the name of \ninput1\nand with the url of \ninput2\nand generates a standard output of the clutch details that can be redirected to a \n.yml\nclutch file. Typically the clutch file name is chosen to match the clutch name which means the standard output should be directed to a clutch file named \ninput1.yml\n\n\n\n\n\n\nadd-clutch\n\n\nDownloads the clutch of the name \ninput1\nfrom the master branch of the github repository \ninput2\ninto the current nest. A file named \ninput1.yml\nfile is added in the \n.nest/clutches\nsubdirectory inside the current local nest. The \n.nest/\ndirectory structure is created automatically if it does not exist.\n\n\n\n\n\n\nlist-clutches\n\n\nLists all the clutches present in the current nest, including clutches that may have been added from other nests on github. The output shows all the remote clutch names and the total eggshells in each of the clutches.\n\n\n\n\n\n\nshow-clutch\n\n\nShows information about the clutch that has the name given in the \ninput1\nargument. Output includes the clutch name, url, and all the constituent eggs with their version numbers.\n\n\n\n\n\n\n\n\nCommand-specific flags\n\n\n\n\n\n\n\n\nSub-command\n\n\nAvailable flags\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nadd-clutch\n\n\n-b, --branch=\"\n\"\n\n\nFetches the clutch file with name \ninput1\nfrom the specified branch at \ninput1\nurl of the github repository. All subsequent egg installations will be done from that branch.\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\ncreate\n\n\nnewt nest create test_project\n\n\nCreates a new nest named \"test_project \" using the default skeleton0\n\n\n\n\n\n\ncreate\n\n\nnewt nest create mynest \n\n\nCreates a new nest named \"mynest\" using the skeleton at the \n specified\n\n\n\n\n\n\ngenerate-clutch\n\n\nnewt nest generate-clutch myclutch https://www.github.com/mynewt/larva \n myclutch.yml\n\n\nTakes a snapshot of the eggs in the current nest to form a clutch named myclutch with the url https://www.github.com/mynewt/larva. The output is written to a file named \nmyclutch.yml\nand describes the properties and contents of the clutch (name, url, eggs).\n\n\n\n\n\n\nadd-clutch\n\n\nnewt nest add-clutch larva https://www.github.com/mynewt/larva\n\n\nAdds the remote clutch named larva at www.github.com/mynewt/larva to the local nest.\n\n\n\n\n\n\nlist-clutches\n\n\nnewt nest list-clutches\n\n\nShows all the remote clutch description files that been downloaded into the current nest\n\n\n\n\n\n\nshow-clutch\n\n\nnewt nest show-clutch larva\n\n\nOutputs the details of the clutch named larva such as the github url where the remote sits, the constituent eggs and their versions\n\n\n\n\n\n\n\n\negg\n\n\nUsage:\n\n\nnewt egg [command][flag] input1 input2\n\n\n\nAvailable Commands: \n\n\nlist        List eggs in the current nest\ncheckdeps   Check egg dependencies\nhunt        Search for egg from clutches\nshow        Show the contents of an egg.\ninstall     Install an egg\nremove      Remove an egg\n\n\n\nFlags:\n\n\n-h, --help=false: help for egg\n\n\n\nGlobal Flags:\n\n\n-l, --loglevel=\"WARN\": Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSub-command\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nlist\n\n\nList all the eggs in the current nest. The output shows the name, version, path, and any additional attributes of each egg in the nest such as dependencies, capabilities, and linker scripts. The newt command gets the attributes of each egg from the corresponsing egg.yml description file.\n\n\n\n\n\n\ncheckdeps\n\n\nResolve all dependencies in the local nest. This command goes through all eggs currently installed, checks their dependencies, and prints any unresolved dependencies between eggs.\n\n\n\n\n\n\nhunt\n\n\nHunts for an egg, specified by \ninput1\n The local nest, along with all remote nests (clutches) are searched. All matched eggs are shown along with the clutch informaton. Installed eggs are called out as such. The command can be invoked from anywhere in the nest.\n\n\n\n\n\n\nshow\n\n\nShow the contents of the egg named \ninput2\nfound in the clutch named \ninput1\n The clutch name is optional; if only the egg name is given as the argument it is resolved using all the clutches installed in the current nest. If the egg is present in multiple clutches it will list all of them along with the clutch information for each.\n\n\n\n\n\n\ninstall\n\n\nInstall the egg specified by \ninput2\nfrom the clutch named \ninput1\n The command downloads the egg from the github repository using the URL in the clutch description file (typically donwloaded as 'input1@\n.yml' in .nest/clutches). It also downloads all the dependencies (constituent eggs) as decribed in the egg's description file ('egg.yml') and installs all of them. The clutch name is optional. If only the egg name is given as the argument, the command looks for the egg name in all the clutches in the local nest and installs accordingly. An egg is installed by this command only if it has not already been installed.\n\n\n\n\n\n\nremove\n\n\nRemove an egg named \ninput2\nfrom clutch \ninput1\n if clutch is specified. Otherwise only one input required - that of the name of the egg to be removed from the local nest.\n\n\n\n\n\n\n\n\nCommand-specific flags\n\n\n\n\n\n\n\n\nSub-command\n\n\nAvailable flags\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\ninstall\n\n\n-b, --branch=\"\n\"\n\n\nInstalls the eggs from the branch name or tag of the clutch specified\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nlist\n\n\nnewt egg list\n\n\nCList all of the eggs in the current nest and the details of the eggs.\n\n\n\n\n\n\ncheckdeps\n\n\nnewt egg checkdeps\n\n\nChecks all the dependencies between eggs in the nest. Lists any unresolved dependencies.\n\n\n\n\n\n\nhunt\n\n\nnewt egg hunt blinky\n\n\nHunts for the egg named 'blinky'. The command can be invoked from anywhere in the nest. Results show if the egg is installed and which clutch, if any, has the egg.\n\n\n\n\n\n\nshow\n\n\nnewt egg show larva libs/os\n\n\nShow the contents of the egg named 'libs/os' in the clutch named larva. The contents are essentially derived from the egg's 'egg.yml' file.\n\n\n\n\n\n\ninstall\n\n\nnewt egg install hw/bsp/stm32f3discovery\n\n\nDownloads and installs the egg named \"stm32f3discovery\" (specified with its full path name inside the remote nest) along with all its dependencies from the remote nest on github. Since no clutch is specified, the URL for the remote nest in the clutch description file found in the local nest (in .nest/clutches for the project) is used.\n\n\n\n\n\n\nremove\n\n\nnewt egg remove larva blinky\n\n\nRemoves the egg named blinky only from the clutch named larva\n\n\n\n\n\n\nremove\n\n\nnewt egg remove blinky\n\n\nRemoves the egg named blinky from the local nest\n\n\n\n\n\n\n\n\ntarget\n\n\nUsage:\n\n\nUsage: \n\n\nnewt target [command] input1 [flag1] [flag2]\n\n\n\nAvailable Commands: \n\n\nset         Set target configuration variable\nunset       Unset target configuration variable\ndelete      Delete target\ncreate      Create a target\nshow        View target configuration variables\nbuild       Build target\ntest        Test target\nexport      Export target\nimport      Import target\ndownload    Download image to target\ndebug       Download image to target and start an openocd/gdb session\n\n\n\nFlags:\n\n\n-h, --help=false: help for target\n\n\n\nGlobal Flags:\n\n\n-l, --loglevel=\"WARN\": Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSub-command\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nset\n\n\nSet attributes of the target. Currently the list of possible attributes are:\narch, compiler, compiler_def, project, bsp, egg, identities, capabilities, dependencies, cflags, lflags\n Typically only the first 5 need to be set for a hardware target. For a simulated target, e.g. for software testing purposes, \narch=sim\n \ncompiler=sim\n and \negg=\negg name to be tested\n You cannot set both the project and egg for a target.\n\n\n\n\n\n\nunset\n\n\nUnset attributes of the target in its configuration.\n\n\n\n\n\n\ndelete\n\n\nDeletes only the description for the target. Does not delete the target directory with associated binaries. If you want to clean out the binaries, list files, and executables use\nnewt target build \ntarget-name\n clean\nbefore\n deleting the target!\n\n\n\n\n\n\ncreate\n\n\nCreates a target description or build definition by the name \ninput1\n By default it assigns the sim (simulator) architecture to it which allows you to build new projects and software on your native OS and try it out.\n\n\n\n\n\n\nshow\n\n\nDisplay the configuration defined for the target named \ninput1\n If no \ninput1\nis specified then show the details for all the targets in the nest.\n\n\n\n\n\n\nbuild\n\n\nBuild the source code into an image that can be loaded on the hardware associated with the target named \ninput1\nto do the application enabled by the 'project' associated with that target (via the target definition). It creates 'bin/' and 'bin/\n/' subdirectories inside the base directory for the project, compiles and generates binaries and executables, and places them in 'bin/\n/.\n\n\n\n\n\n\ntest\n\n\nTest an egg on the target named \ninput1\n The egg is either supplied as an argument to the command line invocation of \nnewt target test\nor added as part of the target definition. If only the target is specified as \ninput1\n then the egg in the target's definition is automatically chosen to be tested. You currently cannot test an entire project on a hardware target. The test command is envisioned for use if one or two eggs gets updated and each needs to be tested against a target. Alternatively, a script may be written for a series of tests on several eggs.\n\n\n\n\n\n\nexport\n\n\nExports the configurations of the specified target \ninput1\n If -a or -export-all flag is used, then all targets are exported and printed out to standard out. You may redirect the output to a file.\n\n\n\n\n\n\nimport\n\n\nImport one or more target configuration from standard input or a file. Each target starts with \n@target=\ntarget-name\nfollowed by the attributes. The list of targets should end with \n@endtargets\n\n\n\n\n\n\nsize\n\n\nOutputs the RAM and flash consumption by the components of the specified target \ninput1\n\n\n\n\n\n\ndownload\n\n\nDownloads the binary executable \ntarget-name\n.elf.bin\nto the board.\n\n\n\n\n\n\ndebug\n\n\nDownloads the binary executable \ntarget-name\n.elf.bin\nto the board and starts up the openocd/gdb combination session. gdb takes over the terminal.\n\n\n\n\n\n\n\n\nCommand-specific flags\n\n\n\n\n\n\n\n\nSub-command\n\n\nAvailable flags\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nbuild\n\n\nclean\n\n\nAll the binaries and object files for the specified target will be removed. The subdirectory named after the specified target within that project is removed.\n\n\n\n\n\n\nbuild clean\n\n\nall\n\n\nAll the binaries and object files for all targets are removed, and subdirectories of all targets for the project are removed. However, the entire repository is not emptied since any eggs or projects that the specified target doesn't reference are not touched.\n\n\n\n\n\n\nexport\n\n\n-a, -export-all\n\n\nExport all targets. \ninput1\nis not necessary when this flag is used.\n\n\n\n\n\n\nimport\n\n\n-a, -import-all\n\n\nImport all targets typed into standard input or redirected from a file.\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\n\n\nSub-command\n\n\nUsage\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nset\n\n\nnewt target set myblinky compiler=arm-none-eabi-m4\n\n\nSet the compiler for the 'myblinky' target to the gcc compiler for embedded ARM chips.\n\n\n\n\n\n\nunset\n\n\nnewt target unset myblinky compiler\n\n\nRemove the setting for the compiler for the 'myblinky' target.\n\n\n\n\n\n\ndelete\n\n\nnewt target delete myblinky\n\n\nDelete the target description for the target named 'myblinky'. Note that it does not remove any binaries or clean out the directory for this target.\n\n\n\n\n\n\ncreate\n\n\nnewt target create blink_f3disc\n\n\nCreate a new target description by the name 'blink_f3disc'. The architecture is 'sim' by default and can be changed using subcommand 'set' above.\n\n\n\n\n\n\nshow\n\n\nnewt target show myblinky\n\n\nShow the target attributes set for 'myblinky'\n\n\n\n\n\n\nbuild\n\n\nnewt target build blink_f3disc\n\n\nCompile the source code for the target named blink_f3disc and generate binaries that can be loaded into the target hardware.\n\n\n\n\n\n\ntest\n\n\nnewt target test test_target egg=libs/os\n\n\nTests the egg named 'libs/os' against the target named 'test_target'\n\n\n\n\n\n\nexport\n\n\nnewt target export -a \n my_exports.txt\n\n\nExport all build targets from the current nest, and redirect output to a file named 'my_exports.txt'.\n\n\n\n\n\n\nexport\n\n\nnewt target export -export-all\n\n\nExport all build targets from the current nest, and print them to standard output on the screen.\n\n\n\n\n\n\nexport\n\n\nnewt target export my_target\n\n\nExport only target named 'my_target' and print it to standard output on the screen.\n\n\n\n\n\n\nimport\n\n\nnewt target import ex_tgt_1 \n exported_targets.txt\n\n\nImports the target configuration for 'ex_tgt_1' in 'exported_targets.txt'.\n\n\n\n\n\n\nimport\n\n\nnewt target import -a \n in_targets.txt\n\n\nImports all the targets specified in the file named \nin_targets.txt\n A sample file is shown after this table.\n\n\n\n\n\n\nsize\n\n\nnewt target size blink_nordic\n\n\nInspects and lists the RAM and Flash memory use by each component (object files and libraries) of the target.\n\n\n\n\n\n\ndownload\n\n\nnewt target -v -lVERBOSE download blinky\n\n\nDownloads \nblinky.elf.bin\nto the hardware in verbose mode with logging turned on at VERBOSE level.\n\n\n\n\n\n\ndebug\n\n\nnewt target debug blinky\n\n\nDownloads \nblinky.elf.bin\nto the hardware, opens up a gdb session with \nblinky.elf\nin the terminal, and halts for further input in gdb.\n\n\n\n\n\n\n\n\nExample content for \nin_targets.txt\n file used for importing targets \ntest3\n and \ntest4\n.  \n\n\n\n\n@target=test3\n\nproject=blinked\n\narch=sim\n\ncompiler_def=debug\n\ncompiler=arm-none-eabi-m4\n\n@target=test4\n\nproject=super_blinky\n\narch=sim\n\ncompiler_def=debug\n\ncompiler=arm-none-eabi-m4\n\n@endtargets", 
            "title": "Command list"
        }, 
        {
            "location": "/chapter3/newt_tool_reference/#command-list", 
            "text": "Available high-level commands  version     Display the Newt version number\nhelp        Help about any command\nnest        Commands to manage nests   clutches (remote egg repositories)\negg         Commands to list and inspect eggs on a nest\ntarget      Set and view target information  version  Usage:  newt version [flags]  Flags:  -h, --help=false: help for version  Global Flags:  -h, --help=false: help for newt  Examples     Sub-command  Usage  Explanation      version  newt version  Displays the version of newt tool installed     help  Usage:  newt help [input1]  Flags:  \n-h, --help=false: help for newt\n-l, --loglevel= WARN : Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.  Examples     Sub-command  Usage  Explanation      help  newt help target  Displays the help text for the newt command 'target'    help  newt help  Displays the help text for newt tool     nest  Usage:  newt nest [command][flags] input1 input2...  Available commands:   create          Create a new nest\ngenerate-clutch Generate a clutch file from the eggs in the current directory\nadd-clutch      Add a remote clutch, and put it in the current nest\nlist-clutches   List the clutches installed in the current nest\nshow-clutch     Show an individual clutch in the current nest  Flags:  -h, --help=false: help for nest  Global Flags:  -h, --help=false: help for newt\n-l, --loglevel=\"WARN\": Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.  Description     Sub-command  Explanation      create  Downloads the skeleton of a nest on your local machine from the optional  input2 nest url, if specified, and creates a new nest directory by the name of  input1  If  input2 is not specified, then a default skeleton from the  tadpole nest on Mynewt is downloaded. The command lays out a generic directory structure for the nest you are going to build under it and includes some default eggs in it.    generate-clutch  Takes a snapshot of the eggs in the current local directory and combines them into a clutch by the name of  input1 and with the url of  input2 and generates a standard output of the clutch details that can be redirected to a  .yml clutch file. Typically the clutch file name is chosen to match the clutch name which means the standard output should be directed to a clutch file named  input1.yml    add-clutch  Downloads the clutch of the name  input1 from the master branch of the github repository  input2 into the current nest. A file named  input1.yml file is added in the  .nest/clutches subdirectory inside the current local nest. The  .nest/ directory structure is created automatically if it does not exist.    list-clutches  Lists all the clutches present in the current nest, including clutches that may have been added from other nests on github. The output shows all the remote clutch names and the total eggshells in each of the clutches.    show-clutch  Shows information about the clutch that has the name given in the  input1 argument. Output includes the clutch name, url, and all the constituent eggs with their version numbers.     Command-specific flags     Sub-command  Available flags  Explanation      add-clutch  -b, --branch=\" \"  Fetches the clutch file with name  input1 from the specified branch at  input1 url of the github repository. All subsequent egg installations will be done from that branch.     Examples     Sub-command  Usage  Explanation      create  newt nest create test_project  Creates a new nest named \"test_project \" using the default skeleton0    create  newt nest create mynest   Creates a new nest named \"mynest\" using the skeleton at the   specified    generate-clutch  newt nest generate-clutch myclutch https://www.github.com/mynewt/larva   myclutch.yml  Takes a snapshot of the eggs in the current nest to form a clutch named myclutch with the url https://www.github.com/mynewt/larva. The output is written to a file named  myclutch.yml and describes the properties and contents of the clutch (name, url, eggs).    add-clutch  newt nest add-clutch larva https://www.github.com/mynewt/larva  Adds the remote clutch named larva at www.github.com/mynewt/larva to the local nest.    list-clutches  newt nest list-clutches  Shows all the remote clutch description files that been downloaded into the current nest    show-clutch  newt nest show-clutch larva  Outputs the details of the clutch named larva such as the github url where the remote sits, the constituent eggs and their versions     egg  Usage:  newt egg [command][flag] input1 input2  Available Commands:   list        List eggs in the current nest\ncheckdeps   Check egg dependencies\nhunt        Search for egg from clutches\nshow        Show the contents of an egg.\ninstall     Install an egg\nremove      Remove an egg  Flags:  -h, --help=false: help for egg  Global Flags:  -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.  Description     Sub-command  Explanation      list  List all the eggs in the current nest. The output shows the name, version, path, and any additional attributes of each egg in the nest such as dependencies, capabilities, and linker scripts. The newt command gets the attributes of each egg from the corresponsing egg.yml description file.    checkdeps  Resolve all dependencies in the local nest. This command goes through all eggs currently installed, checks their dependencies, and prints any unresolved dependencies between eggs.    hunt  Hunts for an egg, specified by  input1  The local nest, along with all remote nests (clutches) are searched. All matched eggs are shown along with the clutch informaton. Installed eggs are called out as such. The command can be invoked from anywhere in the nest.    show  Show the contents of the egg named  input2 found in the clutch named  input1  The clutch name is optional; if only the egg name is given as the argument it is resolved using all the clutches installed in the current nest. If the egg is present in multiple clutches it will list all of them along with the clutch information for each.    install  Install the egg specified by  input2 from the clutch named  input1  The command downloads the egg from the github repository using the URL in the clutch description file (typically donwloaded as 'input1@ .yml' in .nest/clutches). It also downloads all the dependencies (constituent eggs) as decribed in the egg's description file ('egg.yml') and installs all of them. The clutch name is optional. If only the egg name is given as the argument, the command looks for the egg name in all the clutches in the local nest and installs accordingly. An egg is installed by this command only if it has not already been installed.    remove  Remove an egg named  input2 from clutch  input1  if clutch is specified. Otherwise only one input required - that of the name of the egg to be removed from the local nest.     Command-specific flags     Sub-command  Available flags  Explanation      install  -b, --branch=\" \"  Installs the eggs from the branch name or tag of the clutch specified     Examples     Sub-command  Usage  Explanation      list  newt egg list  CList all of the eggs in the current nest and the details of the eggs.    checkdeps  newt egg checkdeps  Checks all the dependencies between eggs in the nest. Lists any unresolved dependencies.    hunt  newt egg hunt blinky  Hunts for the egg named 'blinky'. The command can be invoked from anywhere in the nest. Results show if the egg is installed and which clutch, if any, has the egg.    show  newt egg show larva libs/os  Show the contents of the egg named 'libs/os' in the clutch named larva. The contents are essentially derived from the egg's 'egg.yml' file.    install  newt egg install hw/bsp/stm32f3discovery  Downloads and installs the egg named \"stm32f3discovery\" (specified with its full path name inside the remote nest) along with all its dependencies from the remote nest on github. Since no clutch is specified, the URL for the remote nest in the clutch description file found in the local nest (in .nest/clutches for the project) is used.    remove  newt egg remove larva blinky  Removes the egg named blinky only from the clutch named larva    remove  newt egg remove blinky  Removes the egg named blinky from the local nest     target  Usage:  Usage:   newt target [command] input1 [flag1] [flag2]  Available Commands:   set         Set target configuration variable\nunset       Unset target configuration variable\ndelete      Delete target\ncreate      Create a target\nshow        View target configuration variables\nbuild       Build target\ntest        Test target\nexport      Export target\nimport      Import target\ndownload    Download image to target\ndebug       Download image to target and start an openocd/gdb session  Flags:  -h, --help=false: help for target  Global Flags:  -l, --loglevel=\"WARN\": Log level, defaults to WARN.\n-q, --quiet=false: Be quiet; only display error output.\n-s, --silent=false: Be silent; don't output anything.\n-v, --verbose=false: Enable verbose output when executing commands.  Description     Sub-command  Explanation      set  Set attributes of the target. Currently the list of possible attributes are: arch, compiler, compiler_def, project, bsp, egg, identities, capabilities, dependencies, cflags, lflags  Typically only the first 5 need to be set for a hardware target. For a simulated target, e.g. for software testing purposes,  arch=sim   compiler=sim  and  egg= egg name to be tested  You cannot set both the project and egg for a target.    unset  Unset attributes of the target in its configuration.    delete  Deletes only the description for the target. Does not delete the target directory with associated binaries. If you want to clean out the binaries, list files, and executables use newt target build  target-name  clean before  deleting the target!    create  Creates a target description or build definition by the name  input1  By default it assigns the sim (simulator) architecture to it which allows you to build new projects and software on your native OS and try it out.    show  Display the configuration defined for the target named  input1  If no  input1 is specified then show the details for all the targets in the nest.    build  Build the source code into an image that can be loaded on the hardware associated with the target named  input1 to do the application enabled by the 'project' associated with that target (via the target definition). It creates 'bin/' and 'bin/ /' subdirectories inside the base directory for the project, compiles and generates binaries and executables, and places them in 'bin/ /.    test  Test an egg on the target named  input1  The egg is either supplied as an argument to the command line invocation of  newt target test or added as part of the target definition. If only the target is specified as  input1  then the egg in the target's definition is automatically chosen to be tested. You currently cannot test an entire project on a hardware target. The test command is envisioned for use if one or two eggs gets updated and each needs to be tested against a target. Alternatively, a script may be written for a series of tests on several eggs.    export  Exports the configurations of the specified target  input1  If -a or -export-all flag is used, then all targets are exported and printed out to standard out. You may redirect the output to a file.    import  Import one or more target configuration from standard input or a file. Each target starts with  @target= target-name followed by the attributes. The list of targets should end with  @endtargets    size  Outputs the RAM and flash consumption by the components of the specified target  input1    download  Downloads the binary executable  target-name .elf.bin to the board.    debug  Downloads the binary executable  target-name .elf.bin to the board and starts up the openocd/gdb combination session. gdb takes over the terminal.     Command-specific flags     Sub-command  Available flags  Explanation      build  clean  All the binaries and object files for the specified target will be removed. The subdirectory named after the specified target within that project is removed.    build clean  all  All the binaries and object files for all targets are removed, and subdirectories of all targets for the project are removed. However, the entire repository is not emptied since any eggs or projects that the specified target doesn't reference are not touched.    export  -a, -export-all  Export all targets.  input1 is not necessary when this flag is used.    import  -a, -import-all  Import all targets typed into standard input or redirected from a file.     Examples     Sub-command  Usage  Explanation      set  newt target set myblinky compiler=arm-none-eabi-m4  Set the compiler for the 'myblinky' target to the gcc compiler for embedded ARM chips.    unset  newt target unset myblinky compiler  Remove the setting for the compiler for the 'myblinky' target.    delete  newt target delete myblinky  Delete the target description for the target named 'myblinky'. Note that it does not remove any binaries or clean out the directory for this target.    create  newt target create blink_f3disc  Create a new target description by the name 'blink_f3disc'. The architecture is 'sim' by default and can be changed using subcommand 'set' above.    show  newt target show myblinky  Show the target attributes set for 'myblinky'    build  newt target build blink_f3disc  Compile the source code for the target named blink_f3disc and generate binaries that can be loaded into the target hardware.    test  newt target test test_target egg=libs/os  Tests the egg named 'libs/os' against the target named 'test_target'    export  newt target export -a   my_exports.txt  Export all build targets from the current nest, and redirect output to a file named 'my_exports.txt'.    export  newt target export -export-all  Export all build targets from the current nest, and print them to standard output on the screen.    export  newt target export my_target  Export only target named 'my_target' and print it to standard output on the screen.    import  newt target import ex_tgt_1   exported_targets.txt  Imports the target configuration for 'ex_tgt_1' in 'exported_targets.txt'.    import  newt target import -a   in_targets.txt  Imports all the targets specified in the file named  in_targets.txt  A sample file is shown after this table.    size  newt target size blink_nordic  Inspects and lists the RAM and Flash memory use by each component (object files and libraries) of the target.    download  newt target -v -lVERBOSE download blinky  Downloads  blinky.elf.bin to the hardware in verbose mode with logging turned on at VERBOSE level.    debug  newt target debug blinky  Downloads  blinky.elf.bin to the hardware, opens up a gdb session with  blinky.elf in the terminal, and halts for further input in gdb.     Example content for  in_targets.txt  file used for importing targets  test3  and  test4 .     @target=test3 \nproject=blinked \narch=sim \ncompiler_def=debug \ncompiler=arm-none-eabi-m4 \n@target=test4 \nproject=super_blinky \narch=sim \ncompiler_def=debug \ncompiler=arm-none-eabi-m4 \n@endtargets", 
            "title": "Command List"
        }
    ]
}